# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

FAST_METADATA = Metadata(
    id="71882fb7c4050cfbb372686192607f9f7bd8489d.boutiques",
    name="fast",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_FastParamsDictNoTag = typing.TypedDict('_FastParamsDictNoTag', {
    "number_classes": typing.NotRequired[int | None],
    "bias_iters": typing.NotRequired[int | None],
    "bias_lowpass": typing.NotRequired[float | None],
    "img_type": typing.NotRequired[typing.Literal[1, 2, 3] | None],
    "init_seg_smooth": typing.NotRequired[float | None],
    "segments": bool,
    "init_transform": typing.NotRequired[InputPathType | None],
    "other_priors": typing.NotRequired[list[InputPathType] | None],
    "output_biasfield": bool,
    "output_biascorrected": bool,
    "no_bias": bool,
    "channels": typing.NotRequired[int | None],
    "out_basename": typing.NotRequired[str | None],
    "use_priors": bool,
    "no_pve": bool,
    "segment_iters": typing.NotRequired[int | None],
    "mixel_smooth": typing.NotRequired[float | None],
    "hyper": typing.NotRequired[float | None],
    "verbose": bool,
    "manual_seg": typing.NotRequired[InputPathType | None],
    "iters_afterbias": typing.NotRequired[int | None],
    "in_files": list[InputPathType],
})
FastParamsDictTagged = typing.TypedDict('FastParamsDictTagged', {
    "@type": typing.Literal["fsl/fast"],
    "number_classes": typing.NotRequired[int | None],
    "bias_iters": typing.NotRequired[int | None],
    "bias_lowpass": typing.NotRequired[float | None],
    "img_type": typing.NotRequired[typing.Literal[1, 2, 3] | None],
    "init_seg_smooth": typing.NotRequired[float | None],
    "segments": bool,
    "init_transform": typing.NotRequired[InputPathType | None],
    "other_priors": typing.NotRequired[list[InputPathType] | None],
    "output_biasfield": bool,
    "output_biascorrected": bool,
    "no_bias": bool,
    "channels": typing.NotRequired[int | None],
    "out_basename": typing.NotRequired[str | None],
    "use_priors": bool,
    "no_pve": bool,
    "segment_iters": typing.NotRequired[int | None],
    "mixel_smooth": typing.NotRequired[float | None],
    "hyper": typing.NotRequired[float | None],
    "verbose": bool,
    "manual_seg": typing.NotRequired[InputPathType | None],
    "iters_afterbias": typing.NotRequired[int | None],
    "in_files": list[InputPathType],
})
FastParamsDict = _FastParamsDictNoTag | FastParamsDictTagged


class FastOutputs(typing.NamedTuple):
    """
    Output object returned when calling `FastParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    mixeltype: OutputPathType | None
    """Path/name of mixeltype volume file _mixeltype."""
    bias_field: OutputPathType | None
    """No description provided."""
    partial_volume_map: OutputPathType | None
    """Path/name of partial volume file _pveseg."""
    restored_image: OutputPathType | None
    """No description provided."""
    tissue_class_map: OutputPathType | None
    """Path/name of binary segmented volume file one val for each class _seg."""


def fast_params(
    in_files: list[InputPathType],
    number_classes: int | None = None,
    bias_iters: int | None = None,
    bias_lowpass: float | None = None,
    img_type: typing.Literal[1, 2, 3] | None = None,
    init_seg_smooth: float | None = None,
    segments: bool = False,
    init_transform: InputPathType | None = None,
    other_priors: list[InputPathType] | None = None,
    output_biasfield: bool = False,
    output_biascorrected: bool = False,
    no_bias: bool = False,
    channels: int | None = None,
    out_basename: str | None = None,
    use_priors: bool = False,
    no_pve: bool = False,
    segment_iters: int | None = None,
    mixel_smooth: float | None = None,
    hyper: float | None = None,
    verbose: bool = False,
    manual_seg: InputPathType | None = None,
    iters_afterbias: int | None = None,
) -> FastParamsDictTagged:
    """
    Build parameters.
    
    Args:
        in_files: Image, or multi-channel set of images, to be segmented.
        number_classes: number of tissue-type classes; default=3.
        bias_iters: number of main-loop iterations during bias-field removal;\
            default=4.
        bias_lowpass: bias field smoothing extent (FWHM) in mm; default=20.
        img_type: type of image 1=T1, 2=T2, 3=PD; default=T1.
        init_seg_smooth: initial segmentation spatial smoothness (during bias\
            field estimation); default=0.02.
        segments: outputs a separate binary image for each tissue type.
        init_transform: initialise using priors; you must supply a FLIRT\
            transform.
        other_priors: Alternative prior images.
        output_biasfield: Output estimated bias field.
        output_biascorrected: Output restored image (bias-corrected image).
        no_bias: Do not remove bias field.
        channels: number of input images (channels); default 1.
        out_basename: Base name of output files.
        use_priors: Use priors throughout.
        no_pve: Turn off pve (partial volume estimation).
        segment_iters: number of segmentation-initialisation iterations;\
            default=15.
        mixel_smooth: spatial smoothness for mixeltype; default=0.3.
        hyper: 0.0 <= a floating point number <= 1.0. segmentation spatial\
            smoothness; default=0.1.
        verbose: Switch on diagnostic messages.
        manual_seg: Filename containing intensities.
        iters_afterbias: number of main-loop iterations after bias-field\
            removal; default=4.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/fast",
        "segments": segments,
        "output_biasfield": output_biasfield,
        "output_biascorrected": output_biascorrected,
        "no_bias": no_bias,
        "use_priors": use_priors,
        "no_pve": no_pve,
        "verbose": verbose,
        "in_files": in_files,
    }
    if number_classes is not None:
        params["number_classes"] = number_classes
    if bias_iters is not None:
        params["bias_iters"] = bias_iters
    if bias_lowpass is not None:
        params["bias_lowpass"] = bias_lowpass
    if img_type is not None:
        params["img_type"] = img_type
    if init_seg_smooth is not None:
        params["init_seg_smooth"] = init_seg_smooth
    if init_transform is not None:
        params["init_transform"] = init_transform
    if other_priors is not None:
        params["other_priors"] = other_priors
    if channels is not None:
        params["channels"] = channels
    if out_basename is not None:
        params["out_basename"] = out_basename
    if segment_iters is not None:
        params["segment_iters"] = segment_iters
    if mixel_smooth is not None:
        params["mixel_smooth"] = mixel_smooth
    if hyper is not None:
        params["hyper"] = hyper
    if manual_seg is not None:
        params["manual_seg"] = manual_seg
    if iters_afterbias is not None:
        params["iters_afterbias"] = iters_afterbias
    return params


def fast_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid `FastParamsDict`
    object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("number_classes", None) is not None:
        if not isinstance(params["number_classes"], int):
            raise StyxValidationError(f'`number_classes` has the wrong type: Received `{type(params.get("number_classes", None))}` expected `int | None`')
        if params["number_classes"] < 1:
            raise StyxValidationError("Parameter `number_classes` must be at least 1")
    if params.get("bias_iters", None) is not None:
        if not isinstance(params["bias_iters"], int):
            raise StyxValidationError(f'`bias_iters` has the wrong type: Received `{type(params.get("bias_iters", None))}` expected `int | None`')
        if params["bias_iters"] < 1:
            raise StyxValidationError("Parameter `bias_iters` must be at least 1")
    if params.get("bias_lowpass", None) is not None:
        if not isinstance(params["bias_lowpass"], (float, int)):
            raise StyxValidationError(f'`bias_lowpass` has the wrong type: Received `{type(params.get("bias_lowpass", None))}` expected `float | None`')
        if params["bias_lowpass"] < 0:
            raise StyxValidationError("Parameter `bias_lowpass` must be at least 0")
    if params.get("img_type", None) is not None:
        if not isinstance(params["img_type"], int):
            raise StyxValidationError(f'`img_type` has the wrong type: Received `{type(params.get("img_type", None))}` expected `typing.Literal[1, 2, 3] | None`')
        if params["img_type"] not in [1, 2, 3]:
            raise StyxValidationError("Parameter `img_type` must be one of [1, 2, 3]")
    if params.get("init_seg_smooth", None) is not None:
        if not isinstance(params["init_seg_smooth"], (float, int)):
            raise StyxValidationError(f'`init_seg_smooth` has the wrong type: Received `{type(params.get("init_seg_smooth", None))}` expected `float | None`')
    if params.get("segments", False) is None:
        raise StyxValidationError("`segments` must not be None")
    if not isinstance(params["segments"], bool):
        raise StyxValidationError(f'`segments` has the wrong type: Received `{type(params.get("segments", False))}` expected `bool`')
    if params.get("init_transform", None) is not None:
        if not isinstance(params["init_transform"], (pathlib.Path, str)):
            raise StyxValidationError(f'`init_transform` has the wrong type: Received `{type(params.get("init_transform", None))}` expected `InputPathType | None`')
    if params.get("other_priors", None) is not None:
        if not isinstance(params["other_priors"], list):
            raise StyxValidationError(f'`other_priors` has the wrong type: Received `{type(params.get("other_priors", None))}` expected `list[InputPathType] | None`')
        for e in params["other_priors"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`other_priors` has the wrong type: Received `{type(params.get("other_priors", None))}` expected `list[InputPathType] | None`')
    if params.get("output_biasfield", False) is None:
        raise StyxValidationError("`output_biasfield` must not be None")
    if not isinstance(params["output_biasfield"], bool):
        raise StyxValidationError(f'`output_biasfield` has the wrong type: Received `{type(params.get("output_biasfield", False))}` expected `bool`')
    if params.get("output_biascorrected", False) is None:
        raise StyxValidationError("`output_biascorrected` must not be None")
    if not isinstance(params["output_biascorrected"], bool):
        raise StyxValidationError(f'`output_biascorrected` has the wrong type: Received `{type(params.get("output_biascorrected", False))}` expected `bool`')
    if params.get("no_bias", False) is None:
        raise StyxValidationError("`no_bias` must not be None")
    if not isinstance(params["no_bias"], bool):
        raise StyxValidationError(f'`no_bias` has the wrong type: Received `{type(params.get("no_bias", False))}` expected `bool`')
    if params.get("channels", None) is not None:
        if not isinstance(params["channels"], int):
            raise StyxValidationError(f'`channels` has the wrong type: Received `{type(params.get("channels", None))}` expected `int | None`')
    if params.get("out_basename", None) is not None:
        if not isinstance(params["out_basename"], str):
            raise StyxValidationError(f'`out_basename` has the wrong type: Received `{type(params.get("out_basename", None))}` expected `str | None`')
    if params.get("use_priors", False) is None:
        raise StyxValidationError("`use_priors` must not be None")
    if not isinstance(params["use_priors"], bool):
        raise StyxValidationError(f'`use_priors` has the wrong type: Received `{type(params.get("use_priors", False))}` expected `bool`')
    if params.get("no_pve", False) is None:
        raise StyxValidationError("`no_pve` must not be None")
    if not isinstance(params["no_pve"], bool):
        raise StyxValidationError(f'`no_pve` has the wrong type: Received `{type(params.get("no_pve", False))}` expected `bool`')
    if params.get("segment_iters", None) is not None:
        if not isinstance(params["segment_iters"], int):
            raise StyxValidationError(f'`segment_iters` has the wrong type: Received `{type(params.get("segment_iters", None))}` expected `int | None`')
        if params["segment_iters"] < 1:
            raise StyxValidationError("Parameter `segment_iters` must be at least 1")
    if params.get("mixel_smooth", None) is not None:
        if not isinstance(params["mixel_smooth"], (float, int)):
            raise StyxValidationError(f'`mixel_smooth` has the wrong type: Received `{type(params.get("mixel_smooth", None))}` expected `float | None`')
    if params.get("hyper", None) is not None:
        if not isinstance(params["hyper"], (float, int)):
            raise StyxValidationError(f'`hyper` has the wrong type: Received `{type(params.get("hyper", None))}` expected `float | None`')
        if not (0.0 <= params["hyper"] <= 1.0):
            raise StyxValidationError("Parameter `hyper` must be between 0.0 and 1.0 (inclusive)")
    if params.get("verbose", False) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], bool):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", False))}` expected `bool`')
    if params.get("manual_seg", None) is not None:
        if not isinstance(params["manual_seg"], (pathlib.Path, str)):
            raise StyxValidationError(f'`manual_seg` has the wrong type: Received `{type(params.get("manual_seg", None))}` expected `InputPathType | None`')
    if params.get("iters_afterbias", None) is not None:
        if not isinstance(params["iters_afterbias"], int):
            raise StyxValidationError(f'`iters_afterbias` has the wrong type: Received `{type(params.get("iters_afterbias", None))}` expected `int | None`')
        if params["iters_afterbias"] < 1:
            raise StyxValidationError("Parameter `iters_afterbias` must be at least 1")
    if params.get("in_files", None) is None:
        raise StyxValidationError("`in_files` must not be None")
    if not isinstance(params["in_files"], list):
        raise StyxValidationError(f'`in_files` has the wrong type: Received `{type(params.get("in_files", None))}` expected `list[InputPathType]`')
    for e in params["in_files"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`in_files` has the wrong type: Received `{type(params.get("in_files", None))}` expected `list[InputPathType]`')


def fast_cargs(
    params: FastParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("fast")
    if params.get("number_classes", None) is not None:
        cargs.extend([
            "-n",
            str(params.get("number_classes", None))
        ])
    if params.get("bias_iters", None) is not None:
        cargs.extend([
            "-I",
            str(params.get("bias_iters", None))
        ])
    if params.get("bias_lowpass", None) is not None:
        cargs.extend([
            "-l",
            str(params.get("bias_lowpass", None))
        ])
    if params.get("img_type", None) is not None:
        cargs.extend([
            "-t",
            str(params.get("img_type", None))
        ])
    if params.get("init_seg_smooth", None) is not None:
        cargs.extend([
            "-f",
            str(params.get("init_seg_smooth", None))
        ])
    if params.get("segments", False):
        cargs.append("-g")
    if params.get("init_transform", None) is not None:
        cargs.extend([
            "-a",
            execution.input_file(params.get("init_transform", None))
        ])
    if params.get("other_priors", None) is not None:
        cargs.extend([
            "-A",
            *[execution.input_file(f) for f in params.get("other_priors", None)]
        ])
    if params.get("output_biasfield", False):
        cargs.append("-b")
    if params.get("output_biascorrected", False):
        cargs.append("-B")
    if params.get("no_bias", False):
        cargs.append("-N")
    if params.get("channels", None) is not None:
        cargs.extend([
            "-S",
            str(params.get("channels", None))
        ])
    if params.get("out_basename", None) is not None:
        cargs.extend([
            "-o",
            params.get("out_basename", None)
        ])
    if params.get("use_priors", False):
        cargs.append("-P")
    if params.get("no_pve", False):
        cargs.append("--nopve")
    if params.get("segment_iters", None) is not None:
        cargs.extend([
            "-W",
            str(params.get("segment_iters", None))
        ])
    if params.get("mixel_smooth", None) is not None:
        cargs.extend([
            "-R",
            str(params.get("mixel_smooth", None))
        ])
    if params.get("hyper", None) is not None:
        cargs.extend([
            "-H",
            str(params.get("hyper", None))
        ])
    if params.get("verbose", False):
        cargs.append("-v")
    if params.get("manual_seg", None) is not None:
        cargs.extend([
            "-s",
            execution.input_file(params.get("manual_seg", None))
        ])
    if params.get("iters_afterbias", None) is not None:
        cargs.extend([
            "-O",
            str(params.get("iters_afterbias", None))
        ])
    cargs.extend([execution.input_file(f) for f in params.get("in_files", None)])
    return cargs


def fast_outputs(
    params: FastParamsDict,
    execution: Execution,
) -> FastOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = FastOutputs(
        root=execution.output_file("."),
        mixeltype=execution.output_file(params.get("out_basename", None) + "_mixeltype.nii.gz") if (params.get("out_basename") is not None) else None,
        bias_field=execution.output_file(params.get("out_basename", None) + "_bias.nii.gz") if (params.get("out_basename") is not None) else None,
        partial_volume_map=execution.output_file(params.get("out_basename", None) + "_pveseg.nii.gz") if (params.get("out_basename") is not None) else None,
        restored_image=execution.output_file(params.get("out_basename", None) + "_restore.nii.gz") if (params.get("out_basename") is not None) else None,
        tissue_class_map=execution.output_file(params.get("out_basename", None) + "_seg.nii.gz") if (params.get("out_basename") is not None) else None,
    )
    return ret


def fast_execute(
    params: FastParamsDict,
    runner: Runner | None = None,
) -> FastOutputs:
    """
    fast
    
    FAST (FMRIB's Automated Segmentation Tool) segments a 3D image of the brain
    into different tissue types (Grey Matter, White Matter, CSF, etc.), whilst
    also correcting for spatial intensity variations (also known as bias field
    or RF inhomogeneities). The underlying method is based on a hidden Markov
    random field model and an associated Expectation-Maximization algorithm. The
    whole process is fully automated and can also produce a bias field-corrected
    input image and a probabilistic and/or partial volume tissue segmentation.
    It is robust and reliable, compared to most finite mixture model-based
    methods, which are sensitive to noise.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FastOutputs`).
    """
    fast_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(FAST_METADATA)
    params = execution.params(params)
    cargs = fast_cargs(params, execution)
    ret = fast_outputs(params, execution)
    execution.run(cargs)
    return ret


def fast(
    in_files: list[InputPathType],
    number_classes: int | None = None,
    bias_iters: int | None = None,
    bias_lowpass: float | None = None,
    img_type: typing.Literal[1, 2, 3] | None = None,
    init_seg_smooth: float | None = None,
    segments: bool = False,
    init_transform: InputPathType | None = None,
    other_priors: list[InputPathType] | None = None,
    output_biasfield: bool = False,
    output_biascorrected: bool = False,
    no_bias: bool = False,
    channels: int | None = None,
    out_basename: str | None = None,
    use_priors: bool = False,
    no_pve: bool = False,
    segment_iters: int | None = None,
    mixel_smooth: float | None = None,
    hyper: float | None = None,
    verbose: bool = False,
    manual_seg: InputPathType | None = None,
    iters_afterbias: int | None = None,
    runner: Runner | None = None,
) -> FastOutputs:
    """
    fast
    
    FAST (FMRIB's Automated Segmentation Tool) segments a 3D image of the brain
    into different tissue types (Grey Matter, White Matter, CSF, etc.), whilst
    also correcting for spatial intensity variations (also known as bias field
    or RF inhomogeneities). The underlying method is based on a hidden Markov
    random field model and an associated Expectation-Maximization algorithm. The
    whole process is fully automated and can also produce a bias field-corrected
    input image and a probabilistic and/or partial volume tissue segmentation.
    It is robust and reliable, compared to most finite mixture model-based
    methods, which are sensitive to noise.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        in_files: Image, or multi-channel set of images, to be segmented.
        number_classes: number of tissue-type classes; default=3.
        bias_iters: number of main-loop iterations during bias-field removal;\
            default=4.
        bias_lowpass: bias field smoothing extent (FWHM) in mm; default=20.
        img_type: type of image 1=T1, 2=T2, 3=PD; default=T1.
        init_seg_smooth: initial segmentation spatial smoothness (during bias\
            field estimation); default=0.02.
        segments: outputs a separate binary image for each tissue type.
        init_transform: initialise using priors; you must supply a FLIRT\
            transform.
        other_priors: Alternative prior images.
        output_biasfield: Output estimated bias field.
        output_biascorrected: Output restored image (bias-corrected image).
        no_bias: Do not remove bias field.
        channels: number of input images (channels); default 1.
        out_basename: Base name of output files.
        use_priors: Use priors throughout.
        no_pve: Turn off pve (partial volume estimation).
        segment_iters: number of segmentation-initialisation iterations;\
            default=15.
        mixel_smooth: spatial smoothness for mixeltype; default=0.3.
        hyper: 0.0 <= a floating point number <= 1.0. segmentation spatial\
            smoothness; default=0.1.
        verbose: Switch on diagnostic messages.
        manual_seg: Filename containing intensities.
        iters_afterbias: number of main-loop iterations after bias-field\
            removal; default=4.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FastOutputs`).
    """
    params = fast_params(
        number_classes=number_classes,
        bias_iters=bias_iters,
        bias_lowpass=bias_lowpass,
        img_type=img_type,
        init_seg_smooth=init_seg_smooth,
        segments=segments,
        init_transform=init_transform,
        other_priors=other_priors,
        output_biasfield=output_biasfield,
        output_biascorrected=output_biascorrected,
        no_bias=no_bias,
        channels=channels,
        out_basename=out_basename,
        use_priors=use_priors,
        no_pve=no_pve,
        segment_iters=segment_iters,
        mixel_smooth=mixel_smooth,
        hyper=hyper,
        verbose=verbose,
        manual_seg=manual_seg,
        iters_afterbias=iters_afterbias,
        in_files=in_files,
    )
    return fast_execute(params, runner)


__all__ = [
    "FAST_METADATA",
    "FastOutputs",
    "FastParamsDict",
    "FastParamsDictTagged",
    "fast",
    "fast_execute",
    "fast_params",
]
