# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

DTIFIT_METADATA = Metadata(
    id="c042dcd71d648f8a46e45bd13f095c9c5e1a2407.boutiques",
    name="dtifit",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_DtifitParamsDictNoTag = typing.TypedDict('_DtifitParamsDictNoTag', {
    "data_file": InputPathType,
    "output_basename": str,
    "mask_file": InputPathType,
    "bvec_file": InputPathType,
    "bval_file": InputPathType,
    "verbose_flag": bool,
    "sse_flag": bool,
    "wls_flag": bool,
    "kurt_flag": bool,
    "kurtdir_flag": bool,
    "littlebit_flag": bool,
    "save_tensor_flag": bool,
    "zmin": typing.NotRequired[float | None],
    "zmax": typing.NotRequired[float | None],
    "ymin": typing.NotRequired[float | None],
    "ymax": typing.NotRequired[float | None],
    "xmin": typing.NotRequired[float | None],
    "xmax": typing.NotRequired[float | None],
    "gradnonlin_file": typing.NotRequired[InputPathType | None],
    "confound_regressors": typing.NotRequired[InputPathType | None],
})
DtifitParamsDictTagged = typing.TypedDict('DtifitParamsDictTagged', {
    "@type": typing.Literal["fsl/dtifit"],
    "data_file": InputPathType,
    "output_basename": str,
    "mask_file": InputPathType,
    "bvec_file": InputPathType,
    "bval_file": InputPathType,
    "verbose_flag": bool,
    "sse_flag": bool,
    "wls_flag": bool,
    "kurt_flag": bool,
    "kurtdir_flag": bool,
    "littlebit_flag": bool,
    "save_tensor_flag": bool,
    "zmin": typing.NotRequired[float | None],
    "zmax": typing.NotRequired[float | None],
    "ymin": typing.NotRequired[float | None],
    "ymax": typing.NotRequired[float | None],
    "xmin": typing.NotRequired[float | None],
    "xmax": typing.NotRequired[float | None],
    "gradnonlin_file": typing.NotRequired[InputPathType | None],
    "confound_regressors": typing.NotRequired[InputPathType | None],
})
DtifitParamsDict = _DtifitParamsDictNoTag | DtifitParamsDictTagged


class DtifitOutputs(typing.NamedTuple):
    """
    Output object returned when calling `DtifitParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    fa_output: OutputPathType
    """Fractional anisotropy output"""
    md_output: OutputPathType
    """Mean diffusivity output"""
    mo_output: OutputPathType
    """Mode of the anisotropy output"""
    l1_output: OutputPathType
    """1st eigenvalue output"""
    l2_output: OutputPathType
    """2nd eigenvalue output"""
    l3_output: OutputPathType
    """3rd eigenvalue output"""


def dtifit_params(
    data_file: InputPathType,
    output_basename: str,
    mask_file: InputPathType,
    bvec_file: InputPathType,
    bval_file: InputPathType,
    verbose_flag: bool = False,
    sse_flag: bool = False,
    wls_flag: bool = False,
    kurt_flag: bool = False,
    kurtdir_flag: bool = False,
    littlebit_flag: bool = False,
    save_tensor_flag: bool = False,
    zmin: float | None = None,
    zmax: float | None = None,
    ymin: float | None = None,
    ymax: float | None = None,
    xmin: float | None = None,
    xmax: float | None = None,
    gradnonlin_file: InputPathType | None = None,
    confound_regressors: InputPathType | None = None,
) -> DtifitParamsDictTagged:
    """
    Build parameters.
    
    Args:
        data_file: DTI data file.
        output_basename: Output basename.
        mask_file: Bet binary mask file.
        bvec_file: B vectors file.
        bval_file: B values file.
        verbose_flag: Switch on diagnostic messages.
        sse_flag: Output sum of squared errors.
        wls_flag: Fit the tensor with weighted least squares.
        kurt_flag: Output mean kurtosis map (for multi-shell data).
        kurtdir_flag: Output maps of kurtosis along each eigenvector: K1, K2,\
            and K3 (for multi-shell data).
        littlebit_flag: Only process small area of brain.
        save_tensor_flag: Save the elements of the tensor.
        zmin: Minimum z.
        zmax: Maximum z.
        ymin: Minimum y.
        ymax: Maximum y.
        xmin: Minimum x.
        xmax: Maximum x.
        gradnonlin_file: Gradient Nonlinearity Tensor file.
        confound_regressors: Input confound regressors.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/dtifit",
        "data_file": data_file,
        "output_basename": output_basename,
        "mask_file": mask_file,
        "bvec_file": bvec_file,
        "bval_file": bval_file,
        "verbose_flag": verbose_flag,
        "sse_flag": sse_flag,
        "wls_flag": wls_flag,
        "kurt_flag": kurt_flag,
        "kurtdir_flag": kurtdir_flag,
        "littlebit_flag": littlebit_flag,
        "save_tensor_flag": save_tensor_flag,
    }
    if zmin is not None:
        params["zmin"] = zmin
    if zmax is not None:
        params["zmax"] = zmax
    if ymin is not None:
        params["ymin"] = ymin
    if ymax is not None:
        params["ymax"] = ymax
    if xmin is not None:
        params["xmin"] = xmin
    if xmax is not None:
        params["xmax"] = xmax
    if gradnonlin_file is not None:
        params["gradnonlin_file"] = gradnonlin_file
    if confound_regressors is not None:
        params["confound_regressors"] = confound_regressors
    return params


def dtifit_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `DtifitParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("data_file", None) is None:
        raise StyxValidationError("`data_file` must not be None")
    if not isinstance(params["data_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`data_file` has the wrong type: Received `{type(params.get("data_file", None))}` expected `InputPathType`')
    if params.get("output_basename", None) is None:
        raise StyxValidationError("`output_basename` must not be None")
    if not isinstance(params["output_basename"], str):
        raise StyxValidationError(f'`output_basename` has the wrong type: Received `{type(params.get("output_basename", None))}` expected `str`')
    if params.get("mask_file", None) is None:
        raise StyxValidationError("`mask_file` must not be None")
    if not isinstance(params["mask_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`mask_file` has the wrong type: Received `{type(params.get("mask_file", None))}` expected `InputPathType`')
    if params.get("bvec_file", None) is None:
        raise StyxValidationError("`bvec_file` must not be None")
    if not isinstance(params["bvec_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvec_file` has the wrong type: Received `{type(params.get("bvec_file", None))}` expected `InputPathType`')
    if params.get("bval_file", None) is None:
        raise StyxValidationError("`bval_file` must not be None")
    if not isinstance(params["bval_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bval_file` has the wrong type: Received `{type(params.get("bval_file", None))}` expected `InputPathType`')
    if params.get("verbose_flag", False) is None:
        raise StyxValidationError("`verbose_flag` must not be None")
    if not isinstance(params["verbose_flag"], bool):
        raise StyxValidationError(f'`verbose_flag` has the wrong type: Received `{type(params.get("verbose_flag", False))}` expected `bool`')
    if params.get("sse_flag", False) is None:
        raise StyxValidationError("`sse_flag` must not be None")
    if not isinstance(params["sse_flag"], bool):
        raise StyxValidationError(f'`sse_flag` has the wrong type: Received `{type(params.get("sse_flag", False))}` expected `bool`')
    if params.get("wls_flag", False) is None:
        raise StyxValidationError("`wls_flag` must not be None")
    if not isinstance(params["wls_flag"], bool):
        raise StyxValidationError(f'`wls_flag` has the wrong type: Received `{type(params.get("wls_flag", False))}` expected `bool`')
    if params.get("kurt_flag", False) is None:
        raise StyxValidationError("`kurt_flag` must not be None")
    if not isinstance(params["kurt_flag"], bool):
        raise StyxValidationError(f'`kurt_flag` has the wrong type: Received `{type(params.get("kurt_flag", False))}` expected `bool`')
    if params.get("kurtdir_flag", False) is None:
        raise StyxValidationError("`kurtdir_flag` must not be None")
    if not isinstance(params["kurtdir_flag"], bool):
        raise StyxValidationError(f'`kurtdir_flag` has the wrong type: Received `{type(params.get("kurtdir_flag", False))}` expected `bool`')
    if params.get("littlebit_flag", False) is None:
        raise StyxValidationError("`littlebit_flag` must not be None")
    if not isinstance(params["littlebit_flag"], bool):
        raise StyxValidationError(f'`littlebit_flag` has the wrong type: Received `{type(params.get("littlebit_flag", False))}` expected `bool`')
    if params.get("save_tensor_flag", False) is None:
        raise StyxValidationError("`save_tensor_flag` must not be None")
    if not isinstance(params["save_tensor_flag"], bool):
        raise StyxValidationError(f'`save_tensor_flag` has the wrong type: Received `{type(params.get("save_tensor_flag", False))}` expected `bool`')
    if params.get("zmin", None) is not None:
        if not isinstance(params["zmin"], (float, int)):
            raise StyxValidationError(f'`zmin` has the wrong type: Received `{type(params.get("zmin", None))}` expected `float | None`')
    if params.get("zmax", None) is not None:
        if not isinstance(params["zmax"], (float, int)):
            raise StyxValidationError(f'`zmax` has the wrong type: Received `{type(params.get("zmax", None))}` expected `float | None`')
    if params.get("ymin", None) is not None:
        if not isinstance(params["ymin"], (float, int)):
            raise StyxValidationError(f'`ymin` has the wrong type: Received `{type(params.get("ymin", None))}` expected `float | None`')
    if params.get("ymax", None) is not None:
        if not isinstance(params["ymax"], (float, int)):
            raise StyxValidationError(f'`ymax` has the wrong type: Received `{type(params.get("ymax", None))}` expected `float | None`')
    if params.get("xmin", None) is not None:
        if not isinstance(params["xmin"], (float, int)):
            raise StyxValidationError(f'`xmin` has the wrong type: Received `{type(params.get("xmin", None))}` expected `float | None`')
    if params.get("xmax", None) is not None:
        if not isinstance(params["xmax"], (float, int)):
            raise StyxValidationError(f'`xmax` has the wrong type: Received `{type(params.get("xmax", None))}` expected `float | None`')
    if params.get("gradnonlin_file", None) is not None:
        if not isinstance(params["gradnonlin_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`gradnonlin_file` has the wrong type: Received `{type(params.get("gradnonlin_file", None))}` expected `InputPathType | None`')
    if params.get("confound_regressors", None) is not None:
        if not isinstance(params["confound_regressors"], (pathlib.Path, str)):
            raise StyxValidationError(f'`confound_regressors` has the wrong type: Received `{type(params.get("confound_regressors", None))}` expected `InputPathType | None`')


def dtifit_cargs(
    params: DtifitParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("dtifit")
    cargs.extend([
        "-k",
        execution.input_file(params.get("data_file", None))
    ])
    cargs.extend([
        "-o",
        params.get("output_basename", None)
    ])
    cargs.extend([
        "-m",
        execution.input_file(params.get("mask_file", None))
    ])
    cargs.extend([
        "-r",
        execution.input_file(params.get("bvec_file", None))
    ])
    cargs.extend([
        "-b",
        execution.input_file(params.get("bval_file", None))
    ])
    if params.get("verbose_flag", False):
        cargs.append("-V")
    if params.get("sse_flag", False):
        cargs.append("--sse")
    if params.get("wls_flag", False):
        cargs.append("-w")
    if params.get("kurt_flag", False):
        cargs.append("--kurt")
    if params.get("kurtdir_flag", False):
        cargs.append("--kurtdir")
    if params.get("littlebit_flag", False):
        cargs.append("--littlebit")
    if params.get("save_tensor_flag", False):
        cargs.append("--save_tensor")
    if params.get("zmin", None) is not None:
        cargs.extend([
            "-z",
            str(params.get("zmin", None))
        ])
    if params.get("zmax", None) is not None:
        cargs.extend([
            "-Z",
            str(params.get("zmax", None))
        ])
    if params.get("ymin", None) is not None:
        cargs.extend([
            "-y",
            str(params.get("ymin", None))
        ])
    if params.get("ymax", None) is not None:
        cargs.extend([
            "-Y",
            str(params.get("ymax", None))
        ])
    if params.get("xmin", None) is not None:
        cargs.extend([
            "-x",
            str(params.get("xmin", None))
        ])
    if params.get("xmax", None) is not None:
        cargs.extend([
            "-X",
            str(params.get("xmax", None))
        ])
    if params.get("gradnonlin_file", None) is not None:
        cargs.extend([
            "--gradnonlin",
            execution.input_file(params.get("gradnonlin_file", None))
        ])
    if params.get("confound_regressors", None) is not None:
        cargs.extend([
            "--cni",
            execution.input_file(params.get("confound_regressors", None))
        ])
    return cargs


def dtifit_outputs(
    params: DtifitParamsDict,
    execution: Execution,
) -> DtifitOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = DtifitOutputs(
        root=execution.output_file("."),
        fa_output=execution.output_file(params.get("output_basename", None) + "_FA.nii.gz"),
        md_output=execution.output_file(params.get("output_basename", None) + "_MD.nii.gz"),
        mo_output=execution.output_file(params.get("output_basename", None) + "_MO.nii.gz"),
        l1_output=execution.output_file(params.get("output_basename", None) + "_L1.nii.gz"),
        l2_output=execution.output_file(params.get("output_basename", None) + "_L2.nii.gz"),
        l3_output=execution.output_file(params.get("output_basename", None) + "_L3.nii.gz"),
    )
    return ret


def dtifit_execute(
    params: DtifitParamsDict,
    runner: Runner | None = None,
) -> DtifitOutputs:
    """
    dtifit
    
    DTIFIT - Fit a diffusion tensor model at each voxel.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DtifitOutputs`).
    """
    dtifit_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(DTIFIT_METADATA)
    params = execution.params(params)
    cargs = dtifit_cargs(params, execution)
    ret = dtifit_outputs(params, execution)
    execution.run(cargs)
    return ret


def dtifit(
    data_file: InputPathType,
    output_basename: str,
    mask_file: InputPathType,
    bvec_file: InputPathType,
    bval_file: InputPathType,
    verbose_flag: bool = False,
    sse_flag: bool = False,
    wls_flag: bool = False,
    kurt_flag: bool = False,
    kurtdir_flag: bool = False,
    littlebit_flag: bool = False,
    save_tensor_flag: bool = False,
    zmin: float | None = None,
    zmax: float | None = None,
    ymin: float | None = None,
    ymax: float | None = None,
    xmin: float | None = None,
    xmax: float | None = None,
    gradnonlin_file: InputPathType | None = None,
    confound_regressors: InputPathType | None = None,
    runner: Runner | None = None,
) -> DtifitOutputs:
    """
    dtifit
    
    DTIFIT - Fit a diffusion tensor model at each voxel.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        data_file: DTI data file.
        output_basename: Output basename.
        mask_file: Bet binary mask file.
        bvec_file: B vectors file.
        bval_file: B values file.
        verbose_flag: Switch on diagnostic messages.
        sse_flag: Output sum of squared errors.
        wls_flag: Fit the tensor with weighted least squares.
        kurt_flag: Output mean kurtosis map (for multi-shell data).
        kurtdir_flag: Output maps of kurtosis along each eigenvector: K1, K2,\
            and K3 (for multi-shell data).
        littlebit_flag: Only process small area of brain.
        save_tensor_flag: Save the elements of the tensor.
        zmin: Minimum z.
        zmax: Maximum z.
        ymin: Minimum y.
        ymax: Maximum y.
        xmin: Minimum x.
        xmax: Maximum x.
        gradnonlin_file: Gradient Nonlinearity Tensor file.
        confound_regressors: Input confound regressors.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DtifitOutputs`).
    """
    params = dtifit_params(
        data_file=data_file,
        output_basename=output_basename,
        mask_file=mask_file,
        bvec_file=bvec_file,
        bval_file=bval_file,
        verbose_flag=verbose_flag,
        sse_flag=sse_flag,
        wls_flag=wls_flag,
        kurt_flag=kurt_flag,
        kurtdir_flag=kurtdir_flag,
        littlebit_flag=littlebit_flag,
        save_tensor_flag=save_tensor_flag,
        zmin=zmin,
        zmax=zmax,
        ymin=ymin,
        ymax=ymax,
        xmin=xmin,
        xmax=xmax,
        gradnonlin_file=gradnonlin_file,
        confound_regressors=confound_regressors,
    )
    return dtifit_execute(params, runner)


__all__ = [
    "DTIFIT_METADATA",
    "DtifitOutputs",
    "DtifitParamsDict",
    "DtifitParamsDictTagged",
    "dtifit",
    "dtifit_execute",
    "dtifit_params",
]
