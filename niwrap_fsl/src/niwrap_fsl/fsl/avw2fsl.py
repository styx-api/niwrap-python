# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

AVW2FSL_METADATA = Metadata(
    id="3abb23590e6582f19536788936776d60f70fce47.boutiques",
    name="avw2fsl",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_Avw2fslParamsDictNoTag = typing.TypedDict('_Avw2fslParamsDictNoTag', {
    "source": list[str],
    "destination": str,
    "archive": bool,
    "attributes_only": bool,
    "backup": typing.NotRequired[str | None],
    "backup_noarg": bool,
    "copy_contents": bool,
    "no_dereference_preserve_links": bool,
    "force": bool,
    "interactive": bool,
    "follow_symlinks_cmdline": bool,
    "hard_link": bool,
    "dereference": bool,
    "no_clobber": bool,
    "no_dereference": bool,
    "preserve": bool,
    "preserve_attr": typing.NotRequired[str | None],
    "preserve_context": bool,
    "no_preserve": typing.NotRequired[str | None],
    "parents": bool,
    "recursive": bool,
    "reflink": typing.NotRequired[str | None],
    "remove_destination": bool,
    "sparse": typing.NotRequired[str | None],
    "strip_trailing_slashes": bool,
    "symbolic_link": bool,
    "suffix": typing.NotRequired[str | None],
    "target_directory": typing.NotRequired[str | None],
    "no_target_directory": bool,
    "update": bool,
    "verbose": bool,
    "one_file_system": bool,
    "selinux_context": bool,
    "context": typing.NotRequired[str | None],
    "help": bool,
    "version": bool,
})
Avw2fslParamsDictTagged = typing.TypedDict('Avw2fslParamsDictTagged', {
    "@type": typing.Literal["fsl/avw2fsl"],
    "source": list[str],
    "destination": str,
    "archive": bool,
    "attributes_only": bool,
    "backup": typing.NotRequired[str | None],
    "backup_noarg": bool,
    "copy_contents": bool,
    "no_dereference_preserve_links": bool,
    "force": bool,
    "interactive": bool,
    "follow_symlinks_cmdline": bool,
    "hard_link": bool,
    "dereference": bool,
    "no_clobber": bool,
    "no_dereference": bool,
    "preserve": bool,
    "preserve_attr": typing.NotRequired[str | None],
    "preserve_context": bool,
    "no_preserve": typing.NotRequired[str | None],
    "parents": bool,
    "recursive": bool,
    "reflink": typing.NotRequired[str | None],
    "remove_destination": bool,
    "sparse": typing.NotRequired[str | None],
    "strip_trailing_slashes": bool,
    "symbolic_link": bool,
    "suffix": typing.NotRequired[str | None],
    "target_directory": typing.NotRequired[str | None],
    "no_target_directory": bool,
    "update": bool,
    "verbose": bool,
    "one_file_system": bool,
    "selinux_context": bool,
    "context": typing.NotRequired[str | None],
    "help": bool,
    "version": bool,
})
Avw2fslParamsDict = _Avw2fslParamsDictNoTag | Avw2fslParamsDictTagged


class Avw2fslOutputs(typing.NamedTuple):
    """
    Output object returned when calling `Avw2fslParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_dest: OutputPathType
    """Destination file or directory where the source is copied."""


def avw2fsl_params(
    source: list[str],
    destination: str,
    archive: bool = False,
    attributes_only: bool = False,
    backup: str | None = None,
    backup_noarg: bool = False,
    copy_contents: bool = False,
    no_dereference_preserve_links: bool = False,
    force: bool = False,
    interactive: bool = False,
    follow_symlinks_cmdline: bool = False,
    hard_link: bool = False,
    dereference: bool = False,
    no_clobber: bool = False,
    no_dereference: bool = False,
    preserve: bool = False,
    preserve_attr: str | None = None,
    preserve_context: bool = False,
    no_preserve: str | None = None,
    parents: bool = False,
    recursive: bool = False,
    reflink: str | None = None,
    remove_destination: bool = False,
    sparse: str | None = None,
    strip_trailing_slashes: bool = False,
    symbolic_link: bool = False,
    suffix: str | None = None,
    target_directory: str | None = None,
    no_target_directory: bool = False,
    update_: bool = False,
    verbose: bool = False,
    one_file_system: bool = False,
    selinux_context: bool = False,
    context: str | None = None,
    help_: bool = False,
    version: bool = False,
) -> Avw2fslParamsDictTagged:
    """
    Build parameters.
    
    Args:
        source: Source file(s) or directory to copy.
        destination: Destination file or directory where the source is to be\
            copied.
        archive: Archive mode; same as -dR --preserve=all.
        attributes_only: Don't copy the file data, just the attributes.
        backup: Make a backup of each existing destination file.
        backup_noarg: Like --backup but does not accept an argument.
        copy_contents: Copy contents of special files when recursive.
        no_dereference_preserve_links: Same as --no-dereference\
            --preserve=links.
        force: If an existing destination file cannot be opened, remove it and\
            try again.
        interactive: Prompt before overwrite.
        follow_symlinks_cmdline: Follow command-line symbolic links in SOURCE.
        hard_link: Hard link files instead of copying.
        dereference: Always follow symbolic links in SOURCE.
        no_clobber: Do not overwrite an existing file.
        no_dereference: Never follow symbolic links in SOURCE.
        preserve: Preserve mode, ownership, and timestamps.
        preserve_attr: Preserve the specified attributes (default:\
            mode,ownership,timestamps).
        preserve_context: Deprecated, same as --preserve=context.
        no_preserve: Don't preserve the specified attributes.
        parents: Use full source file name under DIRECTORY.
        recursive: Copy directories recursively.
        reflink: Control clone/CoW copies.
        remove_destination: Remove each existing destination file before\
            attempting to open it.
        sparse: Control creation of sparse files.
        strip_trailing_slashes: Remove any trailing slashes from each SOURCE\
            argument.
        symbolic_link: Make symbolic links instead of copying.
        suffix: Override the usual backup suffix.
        target_directory: Specify the target directory.
        no_target_directory: Treat DEST as a normal file.
        update_: Copy only when the SOURCE file is newer than the destination\
            file or when the destination file is missing.
        verbose: Explain what is being done.
        one_file_system: Stay on this file system.
        selinux_context: Set SELinux security context of destination file to\
            default type.
        context: Like -Z, or if CTX is specified set the SELinux or SMACK\
            security context to CTX.
        help_: Display this help and exit.
        version: Output version information and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/avw2fsl",
        "source": source,
        "destination": destination,
        "archive": archive,
        "attributes_only": attributes_only,
        "backup_noarg": backup_noarg,
        "copy_contents": copy_contents,
        "no_dereference_preserve_links": no_dereference_preserve_links,
        "force": force,
        "interactive": interactive,
        "follow_symlinks_cmdline": follow_symlinks_cmdline,
        "hard_link": hard_link,
        "dereference": dereference,
        "no_clobber": no_clobber,
        "no_dereference": no_dereference,
        "preserve": preserve,
        "preserve_context": preserve_context,
        "parents": parents,
        "recursive": recursive,
        "remove_destination": remove_destination,
        "strip_trailing_slashes": strip_trailing_slashes,
        "symbolic_link": symbolic_link,
        "no_target_directory": no_target_directory,
        "update": update_,
        "verbose": verbose,
        "one_file_system": one_file_system,
        "selinux_context": selinux_context,
        "help": help_,
        "version": version,
    }
    if backup is not None:
        params["backup"] = backup
    if preserve_attr is not None:
        params["preserve_attr"] = preserve_attr
    if no_preserve is not None:
        params["no_preserve"] = no_preserve
    if reflink is not None:
        params["reflink"] = reflink
    if sparse is not None:
        params["sparse"] = sparse
    if suffix is not None:
        params["suffix"] = suffix
    if target_directory is not None:
        params["target_directory"] = target_directory
    if context is not None:
        params["context"] = context
    return params


def avw2fsl_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `Avw2fslParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("source", None) is None:
        raise StyxValidationError("`source` must not be None")
    if not isinstance(params["source"], list):
        raise StyxValidationError(f'`source` has the wrong type: Received `{type(params.get("source", None))}` expected `list[str]`')
    for e in params["source"]:
        if not isinstance(e, str):
            raise StyxValidationError(f'`source` has the wrong type: Received `{type(params.get("source", None))}` expected `list[str]`')
    if params.get("destination", None) is None:
        raise StyxValidationError("`destination` must not be None")
    if not isinstance(params["destination"], str):
        raise StyxValidationError(f'`destination` has the wrong type: Received `{type(params.get("destination", None))}` expected `str`')
    if params.get("archive", False) is None:
        raise StyxValidationError("`archive` must not be None")
    if not isinstance(params["archive"], bool):
        raise StyxValidationError(f'`archive` has the wrong type: Received `{type(params.get("archive", False))}` expected `bool`')
    if params.get("attributes_only", False) is None:
        raise StyxValidationError("`attributes_only` must not be None")
    if not isinstance(params["attributes_only"], bool):
        raise StyxValidationError(f'`attributes_only` has the wrong type: Received `{type(params.get("attributes_only", False))}` expected `bool`')
    if params.get("backup", None) is not None:
        if not isinstance(params["backup"], str):
            raise StyxValidationError(f'`backup` has the wrong type: Received `{type(params.get("backup", None))}` expected `str | None`')
    if params.get("backup_noarg", False) is None:
        raise StyxValidationError("`backup_noarg` must not be None")
    if not isinstance(params["backup_noarg"], bool):
        raise StyxValidationError(f'`backup_noarg` has the wrong type: Received `{type(params.get("backup_noarg", False))}` expected `bool`')
    if params.get("copy_contents", False) is None:
        raise StyxValidationError("`copy_contents` must not be None")
    if not isinstance(params["copy_contents"], bool):
        raise StyxValidationError(f'`copy_contents` has the wrong type: Received `{type(params.get("copy_contents", False))}` expected `bool`')
    if params.get("no_dereference_preserve_links", False) is None:
        raise StyxValidationError("`no_dereference_preserve_links` must not be None")
    if not isinstance(params["no_dereference_preserve_links"], bool):
        raise StyxValidationError(f'`no_dereference_preserve_links` has the wrong type: Received `{type(params.get("no_dereference_preserve_links", False))}` expected `bool`')
    if params.get("force", False) is None:
        raise StyxValidationError("`force` must not be None")
    if not isinstance(params["force"], bool):
        raise StyxValidationError(f'`force` has the wrong type: Received `{type(params.get("force", False))}` expected `bool`')
    if params.get("interactive", False) is None:
        raise StyxValidationError("`interactive` must not be None")
    if not isinstance(params["interactive"], bool):
        raise StyxValidationError(f'`interactive` has the wrong type: Received `{type(params.get("interactive", False))}` expected `bool`')
    if params.get("follow_symlinks_cmdline", False) is None:
        raise StyxValidationError("`follow_symlinks_cmdline` must not be None")
    if not isinstance(params["follow_symlinks_cmdline"], bool):
        raise StyxValidationError(f'`follow_symlinks_cmdline` has the wrong type: Received `{type(params.get("follow_symlinks_cmdline", False))}` expected `bool`')
    if params.get("hard_link", False) is None:
        raise StyxValidationError("`hard_link` must not be None")
    if not isinstance(params["hard_link"], bool):
        raise StyxValidationError(f'`hard_link` has the wrong type: Received `{type(params.get("hard_link", False))}` expected `bool`')
    if params.get("dereference", False) is None:
        raise StyxValidationError("`dereference` must not be None")
    if not isinstance(params["dereference"], bool):
        raise StyxValidationError(f'`dereference` has the wrong type: Received `{type(params.get("dereference", False))}` expected `bool`')
    if params.get("no_clobber", False) is None:
        raise StyxValidationError("`no_clobber` must not be None")
    if not isinstance(params["no_clobber"], bool):
        raise StyxValidationError(f'`no_clobber` has the wrong type: Received `{type(params.get("no_clobber", False))}` expected `bool`')
    if params.get("no_dereference", False) is None:
        raise StyxValidationError("`no_dereference` must not be None")
    if not isinstance(params["no_dereference"], bool):
        raise StyxValidationError(f'`no_dereference` has the wrong type: Received `{type(params.get("no_dereference", False))}` expected `bool`')
    if params.get("preserve", False) is None:
        raise StyxValidationError("`preserve` must not be None")
    if not isinstance(params["preserve"], bool):
        raise StyxValidationError(f'`preserve` has the wrong type: Received `{type(params.get("preserve", False))}` expected `bool`')
    if params.get("preserve_attr", None) is not None:
        if not isinstance(params["preserve_attr"], str):
            raise StyxValidationError(f'`preserve_attr` has the wrong type: Received `{type(params.get("preserve_attr", None))}` expected `str | None`')
    if params.get("preserve_context", False) is None:
        raise StyxValidationError("`preserve_context` must not be None")
    if not isinstance(params["preserve_context"], bool):
        raise StyxValidationError(f'`preserve_context` has the wrong type: Received `{type(params.get("preserve_context", False))}` expected `bool`')
    if params.get("no_preserve", None) is not None:
        if not isinstance(params["no_preserve"], str):
            raise StyxValidationError(f'`no_preserve` has the wrong type: Received `{type(params.get("no_preserve", None))}` expected `str | None`')
    if params.get("parents", False) is None:
        raise StyxValidationError("`parents` must not be None")
    if not isinstance(params["parents"], bool):
        raise StyxValidationError(f'`parents` has the wrong type: Received `{type(params.get("parents", False))}` expected `bool`')
    if params.get("recursive", False) is None:
        raise StyxValidationError("`recursive` must not be None")
    if not isinstance(params["recursive"], bool):
        raise StyxValidationError(f'`recursive` has the wrong type: Received `{type(params.get("recursive", False))}` expected `bool`')
    if params.get("reflink", None) is not None:
        if not isinstance(params["reflink"], str):
            raise StyxValidationError(f'`reflink` has the wrong type: Received `{type(params.get("reflink", None))}` expected `str | None`')
    if params.get("remove_destination", False) is None:
        raise StyxValidationError("`remove_destination` must not be None")
    if not isinstance(params["remove_destination"], bool):
        raise StyxValidationError(f'`remove_destination` has the wrong type: Received `{type(params.get("remove_destination", False))}` expected `bool`')
    if params.get("sparse", None) is not None:
        if not isinstance(params["sparse"], str):
            raise StyxValidationError(f'`sparse` has the wrong type: Received `{type(params.get("sparse", None))}` expected `str | None`')
    if params.get("strip_trailing_slashes", False) is None:
        raise StyxValidationError("`strip_trailing_slashes` must not be None")
    if not isinstance(params["strip_trailing_slashes"], bool):
        raise StyxValidationError(f'`strip_trailing_slashes` has the wrong type: Received `{type(params.get("strip_trailing_slashes", False))}` expected `bool`')
    if params.get("symbolic_link", False) is None:
        raise StyxValidationError("`symbolic_link` must not be None")
    if not isinstance(params["symbolic_link"], bool):
        raise StyxValidationError(f'`symbolic_link` has the wrong type: Received `{type(params.get("symbolic_link", False))}` expected `bool`')
    if params.get("suffix", None) is not None:
        if not isinstance(params["suffix"], str):
            raise StyxValidationError(f'`suffix` has the wrong type: Received `{type(params.get("suffix", None))}` expected `str | None`')
    if params.get("target_directory", None) is not None:
        if not isinstance(params["target_directory"], str):
            raise StyxValidationError(f'`target_directory` has the wrong type: Received `{type(params.get("target_directory", None))}` expected `str | None`')
    if params.get("no_target_directory", False) is None:
        raise StyxValidationError("`no_target_directory` must not be None")
    if not isinstance(params["no_target_directory"], bool):
        raise StyxValidationError(f'`no_target_directory` has the wrong type: Received `{type(params.get("no_target_directory", False))}` expected `bool`')
    if params.get("update", False) is None:
        raise StyxValidationError("`update` must not be None")
    if not isinstance(params["update"], bool):
        raise StyxValidationError(f'`update` has the wrong type: Received `{type(params.get("update", False))}` expected `bool`')
    if params.get("verbose", False) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], bool):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", False))}` expected `bool`')
    if params.get("one_file_system", False) is None:
        raise StyxValidationError("`one_file_system` must not be None")
    if not isinstance(params["one_file_system"], bool):
        raise StyxValidationError(f'`one_file_system` has the wrong type: Received `{type(params.get("one_file_system", False))}` expected `bool`')
    if params.get("selinux_context", False) is None:
        raise StyxValidationError("`selinux_context` must not be None")
    if not isinstance(params["selinux_context"], bool):
        raise StyxValidationError(f'`selinux_context` has the wrong type: Received `{type(params.get("selinux_context", False))}` expected `bool`')
    if params.get("context", None) is not None:
        if not isinstance(params["context"], str):
            raise StyxValidationError(f'`context` has the wrong type: Received `{type(params.get("context", None))}` expected `str | None`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')


def avw2fsl_cargs(
    params: Avw2fslParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("avw2fsl")
    cargs.extend(params.get("source", None))
    cargs.append(params.get("destination", None))
    if params.get("archive", False):
        cargs.append("-a")
    if params.get("attributes_only", False):
        cargs.append("--attributes-only")
    if params.get("backup", None) is not None:
        cargs.append("--backup=" + params.get("backup", None))
    if params.get("backup_noarg", False):
        cargs.append("-b")
    if params.get("copy_contents", False):
        cargs.append("--copy-contents")
    if params.get("no_dereference_preserve_links", False):
        cargs.append("-d")
    if params.get("force", False):
        cargs.append("-f")
    if params.get("interactive", False):
        cargs.append("-i")
    if params.get("follow_symlinks_cmdline", False):
        cargs.append("-H")
    if params.get("hard_link", False):
        cargs.append("-l")
    if params.get("dereference", False):
        cargs.append("-L")
    if params.get("no_clobber", False):
        cargs.append("-n")
    if params.get("no_dereference", False):
        cargs.append("-P")
    if params.get("preserve", False):
        cargs.append("-p")
    if params.get("preserve_attr", None) is not None:
        cargs.append("--preserve=" + params.get("preserve_attr", None))
    if params.get("preserve_context", False):
        cargs.append("-c")
    if params.get("no_preserve", None) is not None:
        cargs.append("--no-preserve=" + params.get("no_preserve", None))
    if params.get("parents", False):
        cargs.append("--parents")
    if params.get("recursive", False):
        cargs.append("-R")
    if params.get("reflink", None) is not None:
        cargs.append("--reflink=" + params.get("reflink", None))
    if params.get("remove_destination", False):
        cargs.append("--remove-destination")
    if params.get("sparse", None) is not None:
        cargs.append("--sparse=" + params.get("sparse", None))
    if params.get("strip_trailing_slashes", False):
        cargs.append("--strip-trailing-slashes")
    if params.get("symbolic_link", False):
        cargs.append("-s")
    if params.get("suffix", None) is not None:
        cargs.append("-S=" + params.get("suffix", None))
    if params.get("target_directory", None) is not None:
        cargs.append("-t=" + params.get("target_directory", None))
    if params.get("no_target_directory", False):
        cargs.append("-T")
    if params.get("update", False):
        cargs.append("-u")
    if params.get("verbose", False):
        cargs.append("-v")
    if params.get("one_file_system", False):
        cargs.append("-x")
    if params.get("selinux_context", False):
        cargs.append("-Z")
    if params.get("context", None) is not None:
        cargs.append("--context=" + params.get("context", None))
    if params.get("help", False):
        cargs.append("--help")
    if params.get("version", False):
        cargs.append("--version")
    return cargs


def avw2fsl_outputs(
    params: Avw2fslParamsDict,
    execution: Execution,
) -> Avw2fslOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = Avw2fslOutputs(
        root=execution.output_file("."),
        output_dest=execution.output_file(params.get("destination", None)),
    )
    return ret


def avw2fsl_execute(
    params: Avw2fslParamsDict,
    runner: Runner | None = None,
) -> Avw2fslOutputs:
    """
    avw2fsl
    
    Processing script to copy files and directories.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `Avw2fslOutputs`).
    """
    avw2fsl_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(AVW2FSL_METADATA)
    params = execution.params(params)
    cargs = avw2fsl_cargs(params, execution)
    ret = avw2fsl_outputs(params, execution)
    execution.run(cargs)
    return ret


def avw2fsl(
    source: list[str],
    destination: str,
    archive: bool = False,
    attributes_only: bool = False,
    backup: str | None = None,
    backup_noarg: bool = False,
    copy_contents: bool = False,
    no_dereference_preserve_links: bool = False,
    force: bool = False,
    interactive: bool = False,
    follow_symlinks_cmdline: bool = False,
    hard_link: bool = False,
    dereference: bool = False,
    no_clobber: bool = False,
    no_dereference: bool = False,
    preserve: bool = False,
    preserve_attr: str | None = None,
    preserve_context: bool = False,
    no_preserve: str | None = None,
    parents: bool = False,
    recursive: bool = False,
    reflink: str | None = None,
    remove_destination: bool = False,
    sparse: str | None = None,
    strip_trailing_slashes: bool = False,
    symbolic_link: bool = False,
    suffix: str | None = None,
    target_directory: str | None = None,
    no_target_directory: bool = False,
    update_: bool = False,
    verbose: bool = False,
    one_file_system: bool = False,
    selinux_context: bool = False,
    context: str | None = None,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> Avw2fslOutputs:
    """
    avw2fsl
    
    Processing script to copy files and directories.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        source: Source file(s) or directory to copy.
        destination: Destination file or directory where the source is to be\
            copied.
        archive: Archive mode; same as -dR --preserve=all.
        attributes_only: Don't copy the file data, just the attributes.
        backup: Make a backup of each existing destination file.
        backup_noarg: Like --backup but does not accept an argument.
        copy_contents: Copy contents of special files when recursive.
        no_dereference_preserve_links: Same as --no-dereference\
            --preserve=links.
        force: If an existing destination file cannot be opened, remove it and\
            try again.
        interactive: Prompt before overwrite.
        follow_symlinks_cmdline: Follow command-line symbolic links in SOURCE.
        hard_link: Hard link files instead of copying.
        dereference: Always follow symbolic links in SOURCE.
        no_clobber: Do not overwrite an existing file.
        no_dereference: Never follow symbolic links in SOURCE.
        preserve: Preserve mode, ownership, and timestamps.
        preserve_attr: Preserve the specified attributes (default:\
            mode,ownership,timestamps).
        preserve_context: Deprecated, same as --preserve=context.
        no_preserve: Don't preserve the specified attributes.
        parents: Use full source file name under DIRECTORY.
        recursive: Copy directories recursively.
        reflink: Control clone/CoW copies.
        remove_destination: Remove each existing destination file before\
            attempting to open it.
        sparse: Control creation of sparse files.
        strip_trailing_slashes: Remove any trailing slashes from each SOURCE\
            argument.
        symbolic_link: Make symbolic links instead of copying.
        suffix: Override the usual backup suffix.
        target_directory: Specify the target directory.
        no_target_directory: Treat DEST as a normal file.
        update_: Copy only when the SOURCE file is newer than the destination\
            file or when the destination file is missing.
        verbose: Explain what is being done.
        one_file_system: Stay on this file system.
        selinux_context: Set SELinux security context of destination file to\
            default type.
        context: Like -Z, or if CTX is specified set the SELinux or SMACK\
            security context to CTX.
        help_: Display this help and exit.
        version: Output version information and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `Avw2fslOutputs`).
    """
    params = avw2fsl_params(
        source=source,
        destination=destination,
        archive=archive,
        attributes_only=attributes_only,
        backup=backup,
        backup_noarg=backup_noarg,
        copy_contents=copy_contents,
        no_dereference_preserve_links=no_dereference_preserve_links,
        force=force,
        interactive=interactive,
        follow_symlinks_cmdline=follow_symlinks_cmdline,
        hard_link=hard_link,
        dereference=dereference,
        no_clobber=no_clobber,
        no_dereference=no_dereference,
        preserve=preserve,
        preserve_attr=preserve_attr,
        preserve_context=preserve_context,
        no_preserve=no_preserve,
        parents=parents,
        recursive=recursive,
        reflink=reflink,
        remove_destination=remove_destination,
        sparse=sparse,
        strip_trailing_slashes=strip_trailing_slashes,
        symbolic_link=symbolic_link,
        suffix=suffix,
        target_directory=target_directory,
        no_target_directory=no_target_directory,
        update_=update_,
        verbose=verbose,
        one_file_system=one_file_system,
        selinux_context=selinux_context,
        context=context,
        help_=help_,
        version=version,
    )
    return avw2fsl_execute(params, runner)


__all__ = [
    "AVW2FSL_METADATA",
    "Avw2fslOutputs",
    "Avw2fslParamsDict",
    "Avw2fslParamsDictTagged",
    "avw2fsl",
    "avw2fsl_execute",
    "avw2fsl_params",
]
