# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

QBOOT_METADATA = Metadata(
    id="0cf193296c9ce8e8e9a825681ecddad1366ae2e7.boutiques",
    name="qboot",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_QbootParamsDictNoTag = typing.TypedDict('_QbootParamsDictNoTag', {
    "data_file": InputPathType,
    "mask_file": InputPathType,
    "bvecs_file": InputPathType,
    "bvals_file": InputPathType,
    "log_dir": typing.NotRequired[str | None],
    "forcedir_flag": bool,
    "q_file": typing.NotRequired[InputPathType | None],
    "model_type": typing.NotRequired[int | None],
    "lmax_order": typing.NotRequired[int | None],
    "npeaks": typing.NotRequired[int | None],
    "threshold": typing.NotRequired[float | None],
    "num_samples": typing.NotRequired[int | None],
    "lambda_param": typing.NotRequired[float | None],
    "delta_param": typing.NotRequired[float | None],
    "alpha_param": typing.NotRequired[float | None],
    "seed_param": typing.NotRequired[int | None],
    "gfa_flag": bool,
    "savecoeff_flag": bool,
    "savemeancoeff_flag": bool,
    "verbose_flag": bool,
    "help_flag": bool,
})
QbootParamsDictTagged = typing.TypedDict('QbootParamsDictTagged', {
    "@type": typing.Literal["fsl/qboot"],
    "data_file": InputPathType,
    "mask_file": InputPathType,
    "bvecs_file": InputPathType,
    "bvals_file": InputPathType,
    "log_dir": typing.NotRequired[str | None],
    "forcedir_flag": bool,
    "q_file": typing.NotRequired[InputPathType | None],
    "model_type": typing.NotRequired[int | None],
    "lmax_order": typing.NotRequired[int | None],
    "npeaks": typing.NotRequired[int | None],
    "threshold": typing.NotRequired[float | None],
    "num_samples": typing.NotRequired[int | None],
    "lambda_param": typing.NotRequired[float | None],
    "delta_param": typing.NotRequired[float | None],
    "alpha_param": typing.NotRequired[float | None],
    "seed_param": typing.NotRequired[int | None],
    "gfa_flag": bool,
    "savecoeff_flag": bool,
    "savemeancoeff_flag": bool,
    "verbose_flag": bool,
    "help_flag": bool,
})
QbootParamsDict = _QbootParamsDictNoTag | QbootParamsDictTagged


class QbootOutputs(typing.NamedTuple):
    """
    Output object returned when calling `QbootParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    log_directory: OutputPathType
    """Specified log directory with saved output files."""


def qboot_params(
    data_file: InputPathType,
    mask_file: InputPathType,
    bvecs_file: InputPathType,
    bvals_file: InputPathType,
    log_dir: str | None = None,
    forcedir_flag: bool = False,
    q_file: InputPathType | None = None,
    model_type: int | None = None,
    lmax_order: int | None = None,
    npeaks: int | None = None,
    threshold: float | None = None,
    num_samples: int | None = None,
    lambda_param: float | None = None,
    delta_param: float | None = None,
    alpha_param: float | None = None,
    seed_param: int | None = None,
    gfa_flag: bool = False,
    savecoeff_flag: bool = False,
    savemeancoeff_flag: bool = False,
    verbose_flag: bool = False,
    help_flag: bool = False,
) -> QbootParamsDictTagged:
    """
    Build parameters.
    
    Args:
        data_file: Data file.
        mask_file: Mask file.
        bvecs_file: b vectors file.
        bvals_file: b values file.
        log_dir: Output directory (default is logdir).
        forcedir_flag: Use the actual directory name given - i.e. don't add +\
            to make a new directory.
        q_file: File provided with multi-shell data. Indicates the number of\
            directions for each shell.
        model_type: Which model to use. 1=Tuch's ODFs, 2=CSA ODFs (default),\
            3=multi-shell CSA ODFs.
        lmax_order: Maximum spherical harmonic order employed (must be even,\
            default=4).
        npeaks: Maximum number of ODF peaks to be detected (default 2).
        threshold: Minimum threshold for a local maxima to be considered an ODF\
            peak. Expressed as a fraction of the maximum ODF value (default 0.4).
        num_samples: Number of bootstrap samples (default is 50).
        lambda_param: Laplace-Beltrami regularization parameter (default is 0).
        delta_param: Signal attenuation regularization parameter for models=2,3\
            (default is 0.01).
        alpha_param: Laplacian sharpening parameter for model=1 (default is 0,\
            should be smaller than 1).
        seed_param: Seed for pseudo-random number generator.
        gfa_flag: Compute a generalised FA, using the mean ODF in each voxel.
        savecoeff_flag: Save the ODF coefficients instead of the peaks.\
            WARNING: These can be huge files, please use a few bootstrap samples\
            and a low lmax!.
        savemeancoeff_flag: Save the mean ODF coefficients across all samples.
        verbose_flag: Switch on diagnostic messages.
        help_flag: Display this help message.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/qboot",
        "data_file": data_file,
        "mask_file": mask_file,
        "bvecs_file": bvecs_file,
        "bvals_file": bvals_file,
        "forcedir_flag": forcedir_flag,
        "gfa_flag": gfa_flag,
        "savecoeff_flag": savecoeff_flag,
        "savemeancoeff_flag": savemeancoeff_flag,
        "verbose_flag": verbose_flag,
        "help_flag": help_flag,
    }
    if log_dir is not None:
        params["log_dir"] = log_dir
    if q_file is not None:
        params["q_file"] = q_file
    if model_type is not None:
        params["model_type"] = model_type
    if lmax_order is not None:
        params["lmax_order"] = lmax_order
    if npeaks is not None:
        params["npeaks"] = npeaks
    if threshold is not None:
        params["threshold"] = threshold
    if num_samples is not None:
        params["num_samples"] = num_samples
    if lambda_param is not None:
        params["lambda_param"] = lambda_param
    if delta_param is not None:
        params["delta_param"] = delta_param
    if alpha_param is not None:
        params["alpha_param"] = alpha_param
    if seed_param is not None:
        params["seed_param"] = seed_param
    return params


def qboot_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `QbootParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("data_file", None) is None:
        raise StyxValidationError("`data_file` must not be None")
    if not isinstance(params["data_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`data_file` has the wrong type: Received `{type(params.get("data_file", None))}` expected `InputPathType`')
    if params.get("mask_file", None) is None:
        raise StyxValidationError("`mask_file` must not be None")
    if not isinstance(params["mask_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`mask_file` has the wrong type: Received `{type(params.get("mask_file", None))}` expected `InputPathType`')
    if params.get("bvecs_file", None) is None:
        raise StyxValidationError("`bvecs_file` must not be None")
    if not isinstance(params["bvecs_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvecs_file` has the wrong type: Received `{type(params.get("bvecs_file", None))}` expected `InputPathType`')
    if params.get("bvals_file", None) is None:
        raise StyxValidationError("`bvals_file` must not be None")
    if not isinstance(params["bvals_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvals_file` has the wrong type: Received `{type(params.get("bvals_file", None))}` expected `InputPathType`')
    if params.get("log_dir", None) is not None:
        if not isinstance(params["log_dir"], str):
            raise StyxValidationError(f'`log_dir` has the wrong type: Received `{type(params.get("log_dir", None))}` expected `str | None`')
    if params.get("forcedir_flag", False) is None:
        raise StyxValidationError("`forcedir_flag` must not be None")
    if not isinstance(params["forcedir_flag"], bool):
        raise StyxValidationError(f'`forcedir_flag` has the wrong type: Received `{type(params.get("forcedir_flag", False))}` expected `bool`')
    if params.get("q_file", None) is not None:
        if not isinstance(params["q_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`q_file` has the wrong type: Received `{type(params.get("q_file", None))}` expected `InputPathType | None`')
    if params.get("model_type", None) is not None:
        if not isinstance(params["model_type"], int):
            raise StyxValidationError(f'`model_type` has the wrong type: Received `{type(params.get("model_type", None))}` expected `int | None`')
    if params.get("lmax_order", None) is not None:
        if not isinstance(params["lmax_order"], int):
            raise StyxValidationError(f'`lmax_order` has the wrong type: Received `{type(params.get("lmax_order", None))}` expected `int | None`')
    if params.get("npeaks", None) is not None:
        if not isinstance(params["npeaks"], int):
            raise StyxValidationError(f'`npeaks` has the wrong type: Received `{type(params.get("npeaks", None))}` expected `int | None`')
    if params.get("threshold", None) is not None:
        if not isinstance(params["threshold"], (float, int)):
            raise StyxValidationError(f'`threshold` has the wrong type: Received `{type(params.get("threshold", None))}` expected `float | None`')
    if params.get("num_samples", None) is not None:
        if not isinstance(params["num_samples"], int):
            raise StyxValidationError(f'`num_samples` has the wrong type: Received `{type(params.get("num_samples", None))}` expected `int | None`')
    if params.get("lambda_param", None) is not None:
        if not isinstance(params["lambda_param"], (float, int)):
            raise StyxValidationError(f'`lambda_param` has the wrong type: Received `{type(params.get("lambda_param", None))}` expected `float | None`')
    if params.get("delta_param", None) is not None:
        if not isinstance(params["delta_param"], (float, int)):
            raise StyxValidationError(f'`delta_param` has the wrong type: Received `{type(params.get("delta_param", None))}` expected `float | None`')
    if params.get("alpha_param", None) is not None:
        if not isinstance(params["alpha_param"], (float, int)):
            raise StyxValidationError(f'`alpha_param` has the wrong type: Received `{type(params.get("alpha_param", None))}` expected `float | None`')
    if params.get("seed_param", None) is not None:
        if not isinstance(params["seed_param"], int):
            raise StyxValidationError(f'`seed_param` has the wrong type: Received `{type(params.get("seed_param", None))}` expected `int | None`')
    if params.get("gfa_flag", False) is None:
        raise StyxValidationError("`gfa_flag` must not be None")
    if not isinstance(params["gfa_flag"], bool):
        raise StyxValidationError(f'`gfa_flag` has the wrong type: Received `{type(params.get("gfa_flag", False))}` expected `bool`')
    if params.get("savecoeff_flag", False) is None:
        raise StyxValidationError("`savecoeff_flag` must not be None")
    if not isinstance(params["savecoeff_flag"], bool):
        raise StyxValidationError(f'`savecoeff_flag` has the wrong type: Received `{type(params.get("savecoeff_flag", False))}` expected `bool`')
    if params.get("savemeancoeff_flag", False) is None:
        raise StyxValidationError("`savemeancoeff_flag` must not be None")
    if not isinstance(params["savemeancoeff_flag"], bool):
        raise StyxValidationError(f'`savemeancoeff_flag` has the wrong type: Received `{type(params.get("savemeancoeff_flag", False))}` expected `bool`')
    if params.get("verbose_flag", False) is None:
        raise StyxValidationError("`verbose_flag` must not be None")
    if not isinstance(params["verbose_flag"], bool):
        raise StyxValidationError(f'`verbose_flag` has the wrong type: Received `{type(params.get("verbose_flag", False))}` expected `bool`')
    if params.get("help_flag", False) is None:
        raise StyxValidationError("`help_flag` must not be None")
    if not isinstance(params["help_flag"], bool):
        raise StyxValidationError(f'`help_flag` has the wrong type: Received `{type(params.get("help_flag", False))}` expected `bool`')


def qboot_cargs(
    params: QbootParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("qboot")
    cargs.extend([
        "-k",
        execution.input_file(params.get("data_file", None))
    ])
    cargs.extend([
        "-m",
        execution.input_file(params.get("mask_file", None))
    ])
    cargs.extend([
        "-r",
        execution.input_file(params.get("bvecs_file", None))
    ])
    cargs.extend([
        "-b",
        execution.input_file(params.get("bvals_file", None))
    ])
    if params.get("log_dir", None) is not None:
        cargs.extend([
            "--ld",
            params.get("log_dir", None)
        ])
    if params.get("forcedir_flag", False):
        cargs.append("--forcedir")
    if params.get("q_file", None) is not None:
        cargs.extend([
            "--q",
            execution.input_file(params.get("q_file", None))
        ])
    if params.get("model_type", None) is not None:
        cargs.extend([
            "--model",
            str(params.get("model_type", None))
        ])
    if params.get("lmax_order", None) is not None:
        cargs.extend([
            "--lmax",
            str(params.get("lmax_order", None))
        ])
    if params.get("npeaks", None) is not None:
        cargs.extend([
            "--npeaks",
            str(params.get("npeaks", None))
        ])
    if params.get("threshold", None) is not None:
        cargs.extend([
            "--thr",
            str(params.get("threshold", None))
        ])
    if params.get("num_samples", None) is not None:
        cargs.extend([
            "--ns",
            str(params.get("num_samples", None))
        ])
    if params.get("lambda_param", None) is not None:
        cargs.extend([
            "--lambda",
            str(params.get("lambda_param", None))
        ])
    if params.get("delta_param", None) is not None:
        cargs.extend([
            "--delta",
            str(params.get("delta_param", None))
        ])
    if params.get("alpha_param", None) is not None:
        cargs.extend([
            "--alpha",
            str(params.get("alpha_param", None))
        ])
    if params.get("seed_param", None) is not None:
        cargs.extend([
            "--seed",
            str(params.get("seed_param", None))
        ])
    if params.get("gfa_flag", False):
        cargs.append("--gfa")
    if params.get("savecoeff_flag", False):
        cargs.append("--savecoeff")
    if params.get("savemeancoeff_flag", False):
        cargs.append("--savemeancoeff")
    if params.get("verbose_flag", False):
        cargs.append("-V")
    if params.get("help_flag", False):
        cargs.append("-h")
    return cargs


def qboot_outputs(
    params: QbootParamsDict,
    execution: Execution,
) -> QbootOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = QbootOutputs(
        root=execution.output_file("."),
        log_directory=execution.output_file("logdir"),
    )
    return ret


def qboot_execute(
    params: QbootParamsDict,
    runner: Runner | None = None,
) -> QbootOutputs:
    """
    qboot
    
    Tool for computing q-ball ODFs using bootstrap samples.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `QbootOutputs`).
    """
    qboot_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(QBOOT_METADATA)
    params = execution.params(params)
    cargs = qboot_cargs(params, execution)
    ret = qboot_outputs(params, execution)
    execution.run(cargs)
    return ret


def qboot(
    data_file: InputPathType,
    mask_file: InputPathType,
    bvecs_file: InputPathType,
    bvals_file: InputPathType,
    log_dir: str | None = None,
    forcedir_flag: bool = False,
    q_file: InputPathType | None = None,
    model_type: int | None = None,
    lmax_order: int | None = None,
    npeaks: int | None = None,
    threshold: float | None = None,
    num_samples: int | None = None,
    lambda_param: float | None = None,
    delta_param: float | None = None,
    alpha_param: float | None = None,
    seed_param: int | None = None,
    gfa_flag: bool = False,
    savecoeff_flag: bool = False,
    savemeancoeff_flag: bool = False,
    verbose_flag: bool = False,
    help_flag: bool = False,
    runner: Runner | None = None,
) -> QbootOutputs:
    """
    qboot
    
    Tool for computing q-ball ODFs using bootstrap samples.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        data_file: Data file.
        mask_file: Mask file.
        bvecs_file: b vectors file.
        bvals_file: b values file.
        log_dir: Output directory (default is logdir).
        forcedir_flag: Use the actual directory name given - i.e. don't add +\
            to make a new directory.
        q_file: File provided with multi-shell data. Indicates the number of\
            directions for each shell.
        model_type: Which model to use. 1=Tuch's ODFs, 2=CSA ODFs (default),\
            3=multi-shell CSA ODFs.
        lmax_order: Maximum spherical harmonic order employed (must be even,\
            default=4).
        npeaks: Maximum number of ODF peaks to be detected (default 2).
        threshold: Minimum threshold for a local maxima to be considered an ODF\
            peak. Expressed as a fraction of the maximum ODF value (default 0.4).
        num_samples: Number of bootstrap samples (default is 50).
        lambda_param: Laplace-Beltrami regularization parameter (default is 0).
        delta_param: Signal attenuation regularization parameter for models=2,3\
            (default is 0.01).
        alpha_param: Laplacian sharpening parameter for model=1 (default is 0,\
            should be smaller than 1).
        seed_param: Seed for pseudo-random number generator.
        gfa_flag: Compute a generalised FA, using the mean ODF in each voxel.
        savecoeff_flag: Save the ODF coefficients instead of the peaks.\
            WARNING: These can be huge files, please use a few bootstrap samples\
            and a low lmax!.
        savemeancoeff_flag: Save the mean ODF coefficients across all samples.
        verbose_flag: Switch on diagnostic messages.
        help_flag: Display this help message.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `QbootOutputs`).
    """
    params = qboot_params(
        data_file=data_file,
        mask_file=mask_file,
        bvecs_file=bvecs_file,
        bvals_file=bvals_file,
        log_dir=log_dir,
        forcedir_flag=forcedir_flag,
        q_file=q_file,
        model_type=model_type,
        lmax_order=lmax_order,
        npeaks=npeaks,
        threshold=threshold,
        num_samples=num_samples,
        lambda_param=lambda_param,
        delta_param=delta_param,
        alpha_param=alpha_param,
        seed_param=seed_param,
        gfa_flag=gfa_flag,
        savecoeff_flag=savecoeff_flag,
        savemeancoeff_flag=savemeancoeff_flag,
        verbose_flag=verbose_flag,
        help_flag=help_flag,
    )
    return qboot_execute(params, runner)


__all__ = [
    "QBOOT_METADATA",
    "QbootOutputs",
    "QbootParamsDict",
    "QbootParamsDictTagged",
    "qboot",
    "qboot_execute",
    "qboot_params",
]
