# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

APPLYXFM4_D_METADATA = Metadata(
    id="d2510e511b2a90e3a942ef9b13e47325371c0be9.boutiques",
    name="applyxfm4D",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_Applyxfm4DParamsDictNoTag = typing.TypedDict('_Applyxfm4DParamsDictNoTag', {
    "input_volume": InputPathType,
    "ref_volume": InputPathType,
    "output_volume": str,
    "transformation_matrix": str,
    "interpolation_method": typing.NotRequired[str | None],
    "single_matrix_flag": bool,
    "four_digit_flag": bool,
    "user_prefix": typing.NotRequired[str | None],
})
Applyxfm4DParamsDictTagged = typing.TypedDict('Applyxfm4DParamsDictTagged', {
    "@type": typing.Literal["fsl/applyxfm4D"],
    "input_volume": InputPathType,
    "ref_volume": InputPathType,
    "output_volume": str,
    "transformation_matrix": str,
    "interpolation_method": typing.NotRequired[str | None],
    "single_matrix_flag": bool,
    "four_digit_flag": bool,
    "user_prefix": typing.NotRequired[str | None],
})
Applyxfm4DParamsDict = _Applyxfm4DParamsDictNoTag | Applyxfm4DParamsDictTagged


class Applyxfm4DOutputs(typing.NamedTuple):
    """
    Output object returned when calling `Applyxfm4DParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType
    """Transformed 4D volume output"""


def applyxfm4_d_params(
    input_volume: InputPathType,
    ref_volume: InputPathType,
    output_volume: str,
    transformation_matrix: str,
    interpolation_method: str | None = None,
    single_matrix_flag: bool = False,
    four_digit_flag: bool = False,
    user_prefix: str | None = None,
) -> Applyxfm4DParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_volume: Input 4D volume (e.g. img.nii.gz).
        ref_volume: Reference volume (e.g. ref.nii.gz).
        output_volume: Output volume after applying transformation (e.g.\
            output.nii.gz).
        transformation_matrix: Transformation matrix file or directory.
        interpolation_method: Interpolation method; options are\
            nearestneighbour (or nn), trilinear, spline, sinc; default is sinc.
        single_matrix_flag: Flag to specify a single transformation matrix.
        four_digit_flag: Flag to use four digits in naming files.
        user_prefix: User-defined prefix for output files.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/applyxfm4D",
        "input_volume": input_volume,
        "ref_volume": ref_volume,
        "output_volume": output_volume,
        "transformation_matrix": transformation_matrix,
        "single_matrix_flag": single_matrix_flag,
        "four_digit_flag": four_digit_flag,
    }
    if interpolation_method is not None:
        params["interpolation_method"] = interpolation_method
    if user_prefix is not None:
        params["user_prefix"] = user_prefix
    return params


def applyxfm4_d_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `Applyxfm4DParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input_volume", None) is None:
        raise StyxValidationError("`input_volume` must not be None")
    if not isinstance(params["input_volume"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input_volume` has the wrong type: Received `{type(params.get("input_volume", None))}` expected `InputPathType`')
    if params.get("ref_volume", None) is None:
        raise StyxValidationError("`ref_volume` must not be None")
    if not isinstance(params["ref_volume"], (pathlib.Path, str)):
        raise StyxValidationError(f'`ref_volume` has the wrong type: Received `{type(params.get("ref_volume", None))}` expected `InputPathType`')
    if params.get("output_volume", None) is None:
        raise StyxValidationError("`output_volume` must not be None")
    if not isinstance(params["output_volume"], str):
        raise StyxValidationError(f'`output_volume` has the wrong type: Received `{type(params.get("output_volume", None))}` expected `str`')
    if params.get("transformation_matrix", None) is None:
        raise StyxValidationError("`transformation_matrix` must not be None")
    if not isinstance(params["transformation_matrix"], str):
        raise StyxValidationError(f'`transformation_matrix` has the wrong type: Received `{type(params.get("transformation_matrix", None))}` expected `str`')
    if params.get("interpolation_method", None) is not None:
        if not isinstance(params["interpolation_method"], str):
            raise StyxValidationError(f'`interpolation_method` has the wrong type: Received `{type(params.get("interpolation_method", None))}` expected `str | None`')
    if params.get("single_matrix_flag", False) is None:
        raise StyxValidationError("`single_matrix_flag` must not be None")
    if not isinstance(params["single_matrix_flag"], bool):
        raise StyxValidationError(f'`single_matrix_flag` has the wrong type: Received `{type(params.get("single_matrix_flag", False))}` expected `bool`')
    if params.get("four_digit_flag", False) is None:
        raise StyxValidationError("`four_digit_flag` must not be None")
    if not isinstance(params["four_digit_flag"], bool):
        raise StyxValidationError(f'`four_digit_flag` has the wrong type: Received `{type(params.get("four_digit_flag", False))}` expected `bool`')
    if params.get("user_prefix", None) is not None:
        if not isinstance(params["user_prefix"], str):
            raise StyxValidationError(f'`user_prefix` has the wrong type: Received `{type(params.get("user_prefix", None))}` expected `str | None`')


def applyxfm4_d_cargs(
    params: Applyxfm4DParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("applyxfm4D")
    cargs.append(execution.input_file(params.get("input_volume", None)))
    cargs.append(execution.input_file(params.get("ref_volume", None)))
    cargs.append(params.get("output_volume", None))
    cargs.append(params.get("transformation_matrix", None))
    if params.get("interpolation_method", None) is not None:
        cargs.extend([
            "--interp, -interp",
            params.get("interpolation_method", None)
        ])
    if params.get("single_matrix_flag", False):
        cargs.append("--singlematrix, -singlematrix")
    if params.get("four_digit_flag", False):
        cargs.append("--fourdigit, -fourdigit")
    if params.get("user_prefix", None) is not None:
        cargs.extend([
            "--userprefix, -userprefix",
            params.get("user_prefix", None)
        ])
    return cargs


def applyxfm4_d_outputs(
    params: Applyxfm4DParamsDict,
    execution: Execution,
) -> Applyxfm4DOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = Applyxfm4DOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(params.get("output_volume", None) + ".nii.gz"),
    )
    return ret


def applyxfm4_d_execute(
    params: Applyxfm4DParamsDict,
    runner: Runner | None = None,
) -> Applyxfm4DOutputs:
    """
    applyxfm4D
    
    Applies 4D transformation matrices to 4D volumes.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `Applyxfm4DOutputs`).
    """
    applyxfm4_d_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(APPLYXFM4_D_METADATA)
    params = execution.params(params)
    cargs = applyxfm4_d_cargs(params, execution)
    ret = applyxfm4_d_outputs(params, execution)
    execution.run(cargs)
    return ret


def applyxfm4_d(
    input_volume: InputPathType,
    ref_volume: InputPathType,
    output_volume: str,
    transformation_matrix: str,
    interpolation_method: str | None = None,
    single_matrix_flag: bool = False,
    four_digit_flag: bool = False,
    user_prefix: str | None = None,
    runner: Runner | None = None,
) -> Applyxfm4DOutputs:
    """
    applyxfm4D
    
    Applies 4D transformation matrices to 4D volumes.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        input_volume: Input 4D volume (e.g. img.nii.gz).
        ref_volume: Reference volume (e.g. ref.nii.gz).
        output_volume: Output volume after applying transformation (e.g.\
            output.nii.gz).
        transformation_matrix: Transformation matrix file or directory.
        interpolation_method: Interpolation method; options are\
            nearestneighbour (or nn), trilinear, spline, sinc; default is sinc.
        single_matrix_flag: Flag to specify a single transformation matrix.
        four_digit_flag: Flag to use four digits in naming files.
        user_prefix: User-defined prefix for output files.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `Applyxfm4DOutputs`).
    """
    params = applyxfm4_d_params(
        input_volume=input_volume,
        ref_volume=ref_volume,
        output_volume=output_volume,
        transformation_matrix=transformation_matrix,
        interpolation_method=interpolation_method,
        single_matrix_flag=single_matrix_flag,
        four_digit_flag=four_digit_flag,
        user_prefix=user_prefix,
    )
    return applyxfm4_d_execute(params, runner)


__all__ = [
    "APPLYXFM4_D_METADATA",
    "Applyxfm4DOutputs",
    "Applyxfm4DParamsDict",
    "Applyxfm4DParamsDictTagged",
    "applyxfm4_d",
    "applyxfm4_d_execute",
    "applyxfm4_d_params",
]
