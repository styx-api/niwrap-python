# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

XFIBRES_METADATA = Metadata(
    id="fafbeb72d013b0b0ce07781341982cb881937d4d.boutiques",
    name="xfibres",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_XfibresParamsDictNoTag = typing.TypedDict('_XfibresParamsDictNoTag', {
    "datafile": InputPathType,
    "maskfile": InputPathType,
    "bvecs": InputPathType,
    "bvals": InputPathType,
    "logdir": typing.NotRequired[str | None],
    "forcedir": bool,
    "max_fibres": typing.NotRequired[float | None],
    "model": typing.NotRequired[float | None],
    "fudge": typing.NotRequired[str | None],
    "num_jumps": typing.NotRequired[float | None],
    "num_burnin": typing.NotRequired[float | None],
    "burnin_noard": typing.NotRequired[float | None],
    "sampleevery": typing.NotRequired[float | None],
    "updateproposal": typing.NotRequired[float | None],
    "seed": typing.NotRequired[str | None],
    "noard": bool,
    "allard": bool,
    "nospat": bool,
    "nonlinear": bool,
    "cnonlinear": bool,
    "rician": bool,
    "add_f0": bool,
    "ard_f0": bool,
    "rmean": typing.NotRequired[float | None],
    "rstd": typing.NotRequired[float | None],
    "verbose_flag": bool,
    "help_flag": bool,
})
XfibresParamsDictTagged = typing.TypedDict('XfibresParamsDictTagged', {
    "@type": typing.Literal["fsl/xfibres"],
    "datafile": InputPathType,
    "maskfile": InputPathType,
    "bvecs": InputPathType,
    "bvals": InputPathType,
    "logdir": typing.NotRequired[str | None],
    "forcedir": bool,
    "max_fibres": typing.NotRequired[float | None],
    "model": typing.NotRequired[float | None],
    "fudge": typing.NotRequired[str | None],
    "num_jumps": typing.NotRequired[float | None],
    "num_burnin": typing.NotRequired[float | None],
    "burnin_noard": typing.NotRequired[float | None],
    "sampleevery": typing.NotRequired[float | None],
    "updateproposal": typing.NotRequired[float | None],
    "seed": typing.NotRequired[str | None],
    "noard": bool,
    "allard": bool,
    "nospat": bool,
    "nonlinear": bool,
    "cnonlinear": bool,
    "rician": bool,
    "add_f0": bool,
    "ard_f0": bool,
    "rmean": typing.NotRequired[float | None],
    "rstd": typing.NotRequired[float | None],
    "verbose_flag": bool,
    "help_flag": bool,
})
XfibresParamsDict = _XfibresParamsDictNoTag | XfibresParamsDictTagged


class XfibresOutputs(typing.NamedTuple):
    """
    Output object returned when calling `XfibresParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_logdir: OutputPathType
    """Log directory where output files are saved"""


def xfibres_params(
    datafile: InputPathType,
    maskfile: InputPathType,
    bvecs: InputPathType,
    bvals: InputPathType,
    logdir: str | None = None,
    forcedir: bool = False,
    max_fibres: float | None = None,
    model: float | None = None,
    fudge: str | None = None,
    num_jumps: float | None = None,
    num_burnin: float | None = None,
    burnin_noard: float | None = None,
    sampleevery: float | None = None,
    updateproposal: float | None = None,
    seed: str | None = None,
    noard: bool = False,
    allard: bool = False,
    nospat: bool = False,
    nonlinear: bool = False,
    cnonlinear: bool = False,
    rician: bool = False,
    add_f0: bool = False,
    ard_f0: bool = False,
    rmean: float | None = None,
    rstd: float | None = None,
    verbose_flag: bool = False,
    help_flag: bool = False,
) -> XfibresParamsDictTagged:
    """
    Build parameters.
    
    Args:
        datafile: Data file (e.g., diffusion data).
        maskfile: Mask file defining brain voxels.
        bvecs: B vectors file.
        bvals: B values file.
        logdir: Log directory (default is logdir).
        forcedir: Use the actual directory name given - i.e., don't add + to\
            make a new directory.
        max_fibres: Maximum number of fibres to fit in each voxel (default 1).
        model: Model to use: 1=deconv. with sticks (default), 2=deconv. with\
            sticks and a range of diffusivities, 3=deconv. with zeppelins.
        fudge: ARD fudge factor.
        num_jumps: Number of jumps to be made by MCMC (default 1250).
        num_burnin: Total number of jumps at start of MCMC to be discarded\
            (default 1000).
        burnin_noard: Number of burnin jumps before ARD is imposed (default 0).
        sampleevery: Number of jumps for each sample (MCMC) (default 25).
        updateproposal: Number of jumps for each update to the proposal density\
            std (MCMC) (default 40).
        seed: Seed for pseudo-random number generator.
        noard: Turn ARD off on all fibres.
        allard: Turn ARD on all fibres.
        nospat: Initialize with tensor, not spatially.
        nonlinear: Initialize with nonlinear fitting.
        cnonlinear: Initialize with constrained nonlinear fitting.
        rician: Use Rician noise modelling.
        add_f0: Add to the model an unattenuated signal compartment.
        ard_f0: Use ARD on F0.
        rmean: Set the prior mean for R of model 3 (default: 0.13 - must be\
            <0.5).
        rstd: Set the prior standard deviation for R of model 3 (default: 0.03).
        verbose_flag: Switch on diagnostic messages.
        help_flag: Display help message.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/xfibres",
        "datafile": datafile,
        "maskfile": maskfile,
        "bvecs": bvecs,
        "bvals": bvals,
        "forcedir": forcedir,
        "noard": noard,
        "allard": allard,
        "nospat": nospat,
        "nonlinear": nonlinear,
        "cnonlinear": cnonlinear,
        "rician": rician,
        "add_f0": add_f0,
        "ard_f0": ard_f0,
        "verbose_flag": verbose_flag,
        "help_flag": help_flag,
    }
    if logdir is not None:
        params["logdir"] = logdir
    if max_fibres is not None:
        params["max_fibres"] = max_fibres
    if model is not None:
        params["model"] = model
    if fudge is not None:
        params["fudge"] = fudge
    if num_jumps is not None:
        params["num_jumps"] = num_jumps
    if num_burnin is not None:
        params["num_burnin"] = num_burnin
    if burnin_noard is not None:
        params["burnin_noard"] = burnin_noard
    if sampleevery is not None:
        params["sampleevery"] = sampleevery
    if updateproposal is not None:
        params["updateproposal"] = updateproposal
    if seed is not None:
        params["seed"] = seed
    if rmean is not None:
        params["rmean"] = rmean
    if rstd is not None:
        params["rstd"] = rstd
    return params


def xfibres_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `XfibresParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("datafile", None) is None:
        raise StyxValidationError("`datafile` must not be None")
    if not isinstance(params["datafile"], (pathlib.Path, str)):
        raise StyxValidationError(f'`datafile` has the wrong type: Received `{type(params.get("datafile", None))}` expected `InputPathType`')
    if params.get("maskfile", None) is None:
        raise StyxValidationError("`maskfile` must not be None")
    if not isinstance(params["maskfile"], (pathlib.Path, str)):
        raise StyxValidationError(f'`maskfile` has the wrong type: Received `{type(params.get("maskfile", None))}` expected `InputPathType`')
    if params.get("bvecs", None) is None:
        raise StyxValidationError("`bvecs` must not be None")
    if not isinstance(params["bvecs"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvecs` has the wrong type: Received `{type(params.get("bvecs", None))}` expected `InputPathType`')
    if params.get("bvals", None) is None:
        raise StyxValidationError("`bvals` must not be None")
    if not isinstance(params["bvals"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvals` has the wrong type: Received `{type(params.get("bvals", None))}` expected `InputPathType`')
    if params.get("logdir", None) is not None:
        if not isinstance(params["logdir"], str):
            raise StyxValidationError(f'`logdir` has the wrong type: Received `{type(params.get("logdir", None))}` expected `str | None`')
    if params.get("forcedir", False) is None:
        raise StyxValidationError("`forcedir` must not be None")
    if not isinstance(params["forcedir"], bool):
        raise StyxValidationError(f'`forcedir` has the wrong type: Received `{type(params.get("forcedir", False))}` expected `bool`')
    if params.get("max_fibres", None) is not None:
        if not isinstance(params["max_fibres"], (float, int)):
            raise StyxValidationError(f'`max_fibres` has the wrong type: Received `{type(params.get("max_fibres", None))}` expected `float | None`')
    if params.get("model", None) is not None:
        if not isinstance(params["model"], (float, int)):
            raise StyxValidationError(f'`model` has the wrong type: Received `{type(params.get("model", None))}` expected `float | None`')
    if params.get("fudge", None) is not None:
        if not isinstance(params["fudge"], str):
            raise StyxValidationError(f'`fudge` has the wrong type: Received `{type(params.get("fudge", None))}` expected `str | None`')
    if params.get("num_jumps", None) is not None:
        if not isinstance(params["num_jumps"], (float, int)):
            raise StyxValidationError(f'`num_jumps` has the wrong type: Received `{type(params.get("num_jumps", None))}` expected `float | None`')
    if params.get("num_burnin", None) is not None:
        if not isinstance(params["num_burnin"], (float, int)):
            raise StyxValidationError(f'`num_burnin` has the wrong type: Received `{type(params.get("num_burnin", None))}` expected `float | None`')
    if params.get("burnin_noard", None) is not None:
        if not isinstance(params["burnin_noard"], (float, int)):
            raise StyxValidationError(f'`burnin_noard` has the wrong type: Received `{type(params.get("burnin_noard", None))}` expected `float | None`')
    if params.get("sampleevery", None) is not None:
        if not isinstance(params["sampleevery"], (float, int)):
            raise StyxValidationError(f'`sampleevery` has the wrong type: Received `{type(params.get("sampleevery", None))}` expected `float | None`')
    if params.get("updateproposal", None) is not None:
        if not isinstance(params["updateproposal"], (float, int)):
            raise StyxValidationError(f'`updateproposal` has the wrong type: Received `{type(params.get("updateproposal", None))}` expected `float | None`')
    if params.get("seed", None) is not None:
        if not isinstance(params["seed"], str):
            raise StyxValidationError(f'`seed` has the wrong type: Received `{type(params.get("seed", None))}` expected `str | None`')
    if params.get("noard", False) is None:
        raise StyxValidationError("`noard` must not be None")
    if not isinstance(params["noard"], bool):
        raise StyxValidationError(f'`noard` has the wrong type: Received `{type(params.get("noard", False))}` expected `bool`')
    if params.get("allard", False) is None:
        raise StyxValidationError("`allard` must not be None")
    if not isinstance(params["allard"], bool):
        raise StyxValidationError(f'`allard` has the wrong type: Received `{type(params.get("allard", False))}` expected `bool`')
    if params.get("nospat", False) is None:
        raise StyxValidationError("`nospat` must not be None")
    if not isinstance(params["nospat"], bool):
        raise StyxValidationError(f'`nospat` has the wrong type: Received `{type(params.get("nospat", False))}` expected `bool`')
    if params.get("nonlinear", False) is None:
        raise StyxValidationError("`nonlinear` must not be None")
    if not isinstance(params["nonlinear"], bool):
        raise StyxValidationError(f'`nonlinear` has the wrong type: Received `{type(params.get("nonlinear", False))}` expected `bool`')
    if params.get("cnonlinear", False) is None:
        raise StyxValidationError("`cnonlinear` must not be None")
    if not isinstance(params["cnonlinear"], bool):
        raise StyxValidationError(f'`cnonlinear` has the wrong type: Received `{type(params.get("cnonlinear", False))}` expected `bool`')
    if params.get("rician", False) is None:
        raise StyxValidationError("`rician` must not be None")
    if not isinstance(params["rician"], bool):
        raise StyxValidationError(f'`rician` has the wrong type: Received `{type(params.get("rician", False))}` expected `bool`')
    if params.get("add_f0", False) is None:
        raise StyxValidationError("`add_f0` must not be None")
    if not isinstance(params["add_f0"], bool):
        raise StyxValidationError(f'`add_f0` has the wrong type: Received `{type(params.get("add_f0", False))}` expected `bool`')
    if params.get("ard_f0", False) is None:
        raise StyxValidationError("`ard_f0` must not be None")
    if not isinstance(params["ard_f0"], bool):
        raise StyxValidationError(f'`ard_f0` has the wrong type: Received `{type(params.get("ard_f0", False))}` expected `bool`')
    if params.get("rmean", None) is not None:
        if not isinstance(params["rmean"], (float, int)):
            raise StyxValidationError(f'`rmean` has the wrong type: Received `{type(params.get("rmean", None))}` expected `float | None`')
        if params["rmean"] > 0.5:
            raise StyxValidationError("Parameter `rmean` must be at most 0.5")
    if params.get("rstd", None) is not None:
        if not isinstance(params["rstd"], (float, int)):
            raise StyxValidationError(f'`rstd` has the wrong type: Received `{type(params.get("rstd", None))}` expected `float | None`')
    if params.get("verbose_flag", False) is None:
        raise StyxValidationError("`verbose_flag` must not be None")
    if not isinstance(params["verbose_flag"], bool):
        raise StyxValidationError(f'`verbose_flag` has the wrong type: Received `{type(params.get("verbose_flag", False))}` expected `bool`')
    if params.get("help_flag", False) is None:
        raise StyxValidationError("`help_flag` must not be None")
    if not isinstance(params["help_flag"], bool):
        raise StyxValidationError(f'`help_flag` has the wrong type: Received `{type(params.get("help_flag", False))}` expected `bool`')


def xfibres_cargs(
    params: XfibresParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("xfibres")
    cargs.extend([
        "-k",
        execution.input_file(params.get("datafile", None))
    ])
    cargs.extend([
        "-m",
        execution.input_file(params.get("maskfile", None))
    ])
    cargs.extend([
        "-r",
        execution.input_file(params.get("bvecs", None))
    ])
    cargs.extend([
        "-b",
        execution.input_file(params.get("bvals", None))
    ])
    if params.get("logdir", None) is not None:
        cargs.extend([
            "--ld",
            params.get("logdir", None)
        ])
    if params.get("forcedir", False):
        cargs.append("--forcedir")
    if params.get("max_fibres", None) is not None:
        cargs.extend([
            "--nf",
            str(params.get("max_fibres", None))
        ])
    if params.get("model", None) is not None:
        cargs.extend([
            "--model",
            str(params.get("model", None))
        ])
    if params.get("fudge", None) is not None:
        cargs.extend([
            "--fudge",
            params.get("fudge", None)
        ])
    if params.get("num_jumps", None) is not None:
        cargs.extend([
            "--nj",
            str(params.get("num_jumps", None))
        ])
    if params.get("num_burnin", None) is not None:
        cargs.extend([
            "--bi",
            str(params.get("num_burnin", None))
        ])
    if params.get("burnin_noard", None) is not None:
        cargs.extend([
            "--bn",
            str(params.get("burnin_noard", None))
        ])
    if params.get("sampleevery", None) is not None:
        cargs.extend([
            "--se",
            str(params.get("sampleevery", None))
        ])
    if params.get("updateproposal", None) is not None:
        cargs.extend([
            "--upe",
            str(params.get("updateproposal", None))
        ])
    if params.get("seed", None) is not None:
        cargs.extend([
            "--seed",
            params.get("seed", None)
        ])
    if params.get("noard", False):
        cargs.append("--noard")
    if params.get("allard", False):
        cargs.append("--allard")
    if params.get("nospat", False):
        cargs.append("--nospat")
    if params.get("nonlinear", False):
        cargs.append("--nonlinear")
    if params.get("cnonlinear", False):
        cargs.append("--cnonlinear")
    if params.get("rician", False):
        cargs.append("--rician")
    if params.get("add_f0", False):
        cargs.append("--f0")
    if params.get("ard_f0", False):
        cargs.append("--ardf0")
    if params.get("rmean", None) is not None:
        cargs.extend([
            "--Rmean",
            str(params.get("rmean", None))
        ])
    if params.get("rstd", None) is not None:
        cargs.extend([
            "--Rstd",
            str(params.get("rstd", None))
        ])
    if params.get("verbose_flag", False):
        cargs.append("-V")
    if params.get("help_flag", False):
        cargs.append("-h")
    return cargs


def xfibres_outputs(
    params: XfibresParamsDict,
    execution: Execution,
) -> XfibresOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = XfibresOutputs(
        root=execution.output_file("."),
        output_logdir=execution.output_file("logdir"),
    )
    return ret


def xfibres_execute(
    params: XfibresParamsDict,
    runner: Runner | None = None,
) -> XfibresOutputs:
    """
    xfibres
    
    Part of FSL - estimates diffusion parameters for multiple fibres per voxel.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `XfibresOutputs`).
    """
    xfibres_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(XFIBRES_METADATA)
    params = execution.params(params)
    cargs = xfibres_cargs(params, execution)
    ret = xfibres_outputs(params, execution)
    execution.run(cargs)
    return ret


def xfibres(
    datafile: InputPathType,
    maskfile: InputPathType,
    bvecs: InputPathType,
    bvals: InputPathType,
    logdir: str | None = None,
    forcedir: bool = False,
    max_fibres: float | None = None,
    model: float | None = None,
    fudge: str | None = None,
    num_jumps: float | None = None,
    num_burnin: float | None = None,
    burnin_noard: float | None = None,
    sampleevery: float | None = None,
    updateproposal: float | None = None,
    seed: str | None = None,
    noard: bool = False,
    allard: bool = False,
    nospat: bool = False,
    nonlinear: bool = False,
    cnonlinear: bool = False,
    rician: bool = False,
    add_f0: bool = False,
    ard_f0: bool = False,
    rmean: float | None = None,
    rstd: float | None = None,
    verbose_flag: bool = False,
    help_flag: bool = False,
    runner: Runner | None = None,
) -> XfibresOutputs:
    """
    xfibres
    
    Part of FSL - estimates diffusion parameters for multiple fibres per voxel.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        datafile: Data file (e.g., diffusion data).
        maskfile: Mask file defining brain voxels.
        bvecs: B vectors file.
        bvals: B values file.
        logdir: Log directory (default is logdir).
        forcedir: Use the actual directory name given - i.e., don't add + to\
            make a new directory.
        max_fibres: Maximum number of fibres to fit in each voxel (default 1).
        model: Model to use: 1=deconv. with sticks (default), 2=deconv. with\
            sticks and a range of diffusivities, 3=deconv. with zeppelins.
        fudge: ARD fudge factor.
        num_jumps: Number of jumps to be made by MCMC (default 1250).
        num_burnin: Total number of jumps at start of MCMC to be discarded\
            (default 1000).
        burnin_noard: Number of burnin jumps before ARD is imposed (default 0).
        sampleevery: Number of jumps for each sample (MCMC) (default 25).
        updateproposal: Number of jumps for each update to the proposal density\
            std (MCMC) (default 40).
        seed: Seed for pseudo-random number generator.
        noard: Turn ARD off on all fibres.
        allard: Turn ARD on all fibres.
        nospat: Initialize with tensor, not spatially.
        nonlinear: Initialize with nonlinear fitting.
        cnonlinear: Initialize with constrained nonlinear fitting.
        rician: Use Rician noise modelling.
        add_f0: Add to the model an unattenuated signal compartment.
        ard_f0: Use ARD on F0.
        rmean: Set the prior mean for R of model 3 (default: 0.13 - must be\
            <0.5).
        rstd: Set the prior standard deviation for R of model 3 (default: 0.03).
        verbose_flag: Switch on diagnostic messages.
        help_flag: Display help message.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `XfibresOutputs`).
    """
    params = xfibres_params(
        datafile=datafile,
        maskfile=maskfile,
        bvecs=bvecs,
        bvals=bvals,
        logdir=logdir,
        forcedir=forcedir,
        max_fibres=max_fibres,
        model=model,
        fudge=fudge,
        num_jumps=num_jumps,
        num_burnin=num_burnin,
        burnin_noard=burnin_noard,
        sampleevery=sampleevery,
        updateproposal=updateproposal,
        seed=seed,
        noard=noard,
        allard=allard,
        nospat=nospat,
        nonlinear=nonlinear,
        cnonlinear=cnonlinear,
        rician=rician,
        add_f0=add_f0,
        ard_f0=ard_f0,
        rmean=rmean,
        rstd=rstd,
        verbose_flag=verbose_flag,
        help_flag=help_flag,
    )
    return xfibres_execute(params, runner)


__all__ = [
    "XFIBRES_METADATA",
    "XfibresOutputs",
    "XfibresParamsDict",
    "XfibresParamsDictTagged",
    "xfibres",
    "xfibres_execute",
    "xfibres_params",
]
