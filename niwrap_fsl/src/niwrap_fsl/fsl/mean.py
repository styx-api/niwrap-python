# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MEAN_METADATA = Metadata(
    id="46eff34bd1907238e1062f34a5b76074989dd865.boutiques",
    name="mean",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_MeanParamsDictNoTag = typing.TypedDict('_MeanParamsDictNoTag', {
    "datafile": InputPathType,
    "maskfile": InputPathType,
    "verbose_flag": bool,
    "debug_level": typing.NotRequired[float | None],
    "timing_flag": bool,
    "log_dir": typing.NotRequired[str | None],
    "forcedir_flag": bool,
    "inference_tech": typing.NotRequired[str | None],
    "num_jumps": typing.NotRequired[float | None],
    "num_burnin": typing.NotRequired[float | None],
    "num_sample_every": typing.NotRequired[float | None],
    "num_update_proposalevery": typing.NotRequired[float | None],
    "acceptance_rate": typing.NotRequired[float | None],
    "seed": typing.NotRequired[float | None],
    "error_precision": typing.NotRequired[float | None],
    "noamp_flag": bool,
    "prior_mean": typing.NotRequired[float | None],
    "prior_std": typing.NotRequired[float | None],
    "help_flag": bool,
})
MeanParamsDictTagged = typing.TypedDict('MeanParamsDictTagged', {
    "@type": typing.Literal["fsl/mean"],
    "datafile": InputPathType,
    "maskfile": InputPathType,
    "verbose_flag": bool,
    "debug_level": typing.NotRequired[float | None],
    "timing_flag": bool,
    "log_dir": typing.NotRequired[str | None],
    "forcedir_flag": bool,
    "inference_tech": typing.NotRequired[str | None],
    "num_jumps": typing.NotRequired[float | None],
    "num_burnin": typing.NotRequired[float | None],
    "num_sample_every": typing.NotRequired[float | None],
    "num_update_proposalevery": typing.NotRequired[float | None],
    "acceptance_rate": typing.NotRequired[float | None],
    "seed": typing.NotRequired[float | None],
    "error_precision": typing.NotRequired[float | None],
    "noamp_flag": bool,
    "prior_mean": typing.NotRequired[float | None],
    "prior_std": typing.NotRequired[float | None],
    "help_flag": bool,
})
MeanParamsDict = _MeanParamsDictNoTag | MeanParamsDictTagged


class MeanOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MeanParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_log: OutputPathType
    """Output log of mean computation"""


def mean_params(
    datafile: InputPathType,
    maskfile: InputPathType,
    verbose_flag: bool = False,
    debug_level: float | None = None,
    timing_flag: bool = False,
    log_dir: str | None = None,
    forcedir_flag: bool = False,
    inference_tech: str | None = None,
    num_jumps: float | None = None,
    num_burnin: float | None = None,
    num_sample_every: float | None = None,
    num_update_proposalevery: float | None = None,
    acceptance_rate: float | None = None,
    seed: float | None = None,
    error_precision: float | None = None,
    noamp_flag: bool = False,
    prior_mean: float | None = None,
    prior_std: float | None = None,
    help_flag: bool = False,
) -> MeanParamsDictTagged:
    """
    Build parameters.
    
    Args:
        datafile: Regressor data file.
        maskfile: Mask file.
        verbose_flag: Switch on diagnostic messages.
        debug_level: Set debug level.
        timing_flag: Turn timing on.
        log_dir: Log directory (default is logdir).
        forcedir_flag: Use the actual directory name given - i.e. don't add +\
            to make a new directory.
        inference_tech: Inference technique: mcmc or laplace (default is mcmc).
        num_jumps: Number of jumps to be made by MCMC (default is 5000).
        num_burnin: Number of jumps at start of MCMC to be discarded (default\
            is 500).
        num_sample_every: Number of jumps for each sample (MCMC) (default is 1).
        num_update_proposalevery: Number of jumps for each update to the\
            proposal density std (MCMC) (default is 40).
        acceptance_rate: Acceptance rate to aim for (MCMC) (default is 0.6).
        seed: Seed for pseudo random number generator.
        error_precision: Value to fix error precision to (default is -1, which\
            means error precision is not fixed).
        noamp_flag: Turn off Analytical Marginalisation of error Precision.
        prior_mean: Prior mean.
        prior_std: Prior standard deviation.
        help_flag: Display help message.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/mean",
        "datafile": datafile,
        "maskfile": maskfile,
        "verbose_flag": verbose_flag,
        "timing_flag": timing_flag,
        "forcedir_flag": forcedir_flag,
        "noamp_flag": noamp_flag,
        "help_flag": help_flag,
    }
    if debug_level is not None:
        params["debug_level"] = debug_level
    if log_dir is not None:
        params["log_dir"] = log_dir
    if inference_tech is not None:
        params["inference_tech"] = inference_tech
    if num_jumps is not None:
        params["num_jumps"] = num_jumps
    if num_burnin is not None:
        params["num_burnin"] = num_burnin
    if num_sample_every is not None:
        params["num_sample_every"] = num_sample_every
    if num_update_proposalevery is not None:
        params["num_update_proposalevery"] = num_update_proposalevery
    if acceptance_rate is not None:
        params["acceptance_rate"] = acceptance_rate
    if seed is not None:
        params["seed"] = seed
    if error_precision is not None:
        params["error_precision"] = error_precision
    if prior_mean is not None:
        params["prior_mean"] = prior_mean
    if prior_std is not None:
        params["prior_std"] = prior_std
    return params


def mean_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid `MeanParamsDict`
    object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("datafile", None) is None:
        raise StyxValidationError("`datafile` must not be None")
    if not isinstance(params["datafile"], (pathlib.Path, str)):
        raise StyxValidationError(f'`datafile` has the wrong type: Received `{type(params.get("datafile", None))}` expected `InputPathType`')
    if params.get("maskfile", None) is None:
        raise StyxValidationError("`maskfile` must not be None")
    if not isinstance(params["maskfile"], (pathlib.Path, str)):
        raise StyxValidationError(f'`maskfile` has the wrong type: Received `{type(params.get("maskfile", None))}` expected `InputPathType`')
    if params.get("verbose_flag", False) is None:
        raise StyxValidationError("`verbose_flag` must not be None")
    if not isinstance(params["verbose_flag"], bool):
        raise StyxValidationError(f'`verbose_flag` has the wrong type: Received `{type(params.get("verbose_flag", False))}` expected `bool`')
    if params.get("debug_level", None) is not None:
        if not isinstance(params["debug_level"], (float, int)):
            raise StyxValidationError(f'`debug_level` has the wrong type: Received `{type(params.get("debug_level", None))}` expected `float | None`')
    if params.get("timing_flag", False) is None:
        raise StyxValidationError("`timing_flag` must not be None")
    if not isinstance(params["timing_flag"], bool):
        raise StyxValidationError(f'`timing_flag` has the wrong type: Received `{type(params.get("timing_flag", False))}` expected `bool`')
    if params.get("log_dir", None) is not None:
        if not isinstance(params["log_dir"], str):
            raise StyxValidationError(f'`log_dir` has the wrong type: Received `{type(params.get("log_dir", None))}` expected `str | None`')
    if params.get("forcedir_flag", False) is None:
        raise StyxValidationError("`forcedir_flag` must not be None")
    if not isinstance(params["forcedir_flag"], bool):
        raise StyxValidationError(f'`forcedir_flag` has the wrong type: Received `{type(params.get("forcedir_flag", False))}` expected `bool`')
    if params.get("inference_tech", None) is not None:
        if not isinstance(params["inference_tech"], str):
            raise StyxValidationError(f'`inference_tech` has the wrong type: Received `{type(params.get("inference_tech", None))}` expected `str | None`')
    if params.get("num_jumps", None) is not None:
        if not isinstance(params["num_jumps"], (float, int)):
            raise StyxValidationError(f'`num_jumps` has the wrong type: Received `{type(params.get("num_jumps", None))}` expected `float | None`')
    if params.get("num_burnin", None) is not None:
        if not isinstance(params["num_burnin"], (float, int)):
            raise StyxValidationError(f'`num_burnin` has the wrong type: Received `{type(params.get("num_burnin", None))}` expected `float | None`')
    if params.get("num_sample_every", None) is not None:
        if not isinstance(params["num_sample_every"], (float, int)):
            raise StyxValidationError(f'`num_sample_every` has the wrong type: Received `{type(params.get("num_sample_every", None))}` expected `float | None`')
    if params.get("num_update_proposalevery", None) is not None:
        if not isinstance(params["num_update_proposalevery"], (float, int)):
            raise StyxValidationError(f'`num_update_proposalevery` has the wrong type: Received `{type(params.get("num_update_proposalevery", None))}` expected `float | None`')
    if params.get("acceptance_rate", None) is not None:
        if not isinstance(params["acceptance_rate"], (float, int)):
            raise StyxValidationError(f'`acceptance_rate` has the wrong type: Received `{type(params.get("acceptance_rate", None))}` expected `float | None`')
    if params.get("seed", None) is not None:
        if not isinstance(params["seed"], (float, int)):
            raise StyxValidationError(f'`seed` has the wrong type: Received `{type(params.get("seed", None))}` expected `float | None`')
    if params.get("error_precision", None) is not None:
        if not isinstance(params["error_precision"], (float, int)):
            raise StyxValidationError(f'`error_precision` has the wrong type: Received `{type(params.get("error_precision", None))}` expected `float | None`')
    if params.get("noamp_flag", False) is None:
        raise StyxValidationError("`noamp_flag` must not be None")
    if not isinstance(params["noamp_flag"], bool):
        raise StyxValidationError(f'`noamp_flag` has the wrong type: Received `{type(params.get("noamp_flag", False))}` expected `bool`')
    if params.get("prior_mean", None) is not None:
        if not isinstance(params["prior_mean"], (float, int)):
            raise StyxValidationError(f'`prior_mean` has the wrong type: Received `{type(params.get("prior_mean", None))}` expected `float | None`')
    if params.get("prior_std", None) is not None:
        if not isinstance(params["prior_std"], (float, int)):
            raise StyxValidationError(f'`prior_std` has the wrong type: Received `{type(params.get("prior_std", None))}` expected `float | None`')
    if params.get("help_flag", False) is None:
        raise StyxValidationError("`help_flag` must not be None")
    if not isinstance(params["help_flag"], bool):
        raise StyxValidationError(f'`help_flag` has the wrong type: Received `{type(params.get("help_flag", False))}` expected `bool`')


def mean_cargs(
    params: MeanParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mean")
    cargs.extend([
        "--data",
        execution.input_file(params.get("datafile", None))
    ])
    cargs.extend([
        "--mask",
        execution.input_file(params.get("maskfile", None))
    ])
    if params.get("verbose_flag", False):
        cargs.append("--verbose")
    if params.get("debug_level", None) is not None:
        cargs.extend([
            "--debug",
            str(params.get("debug_level", None))
        ])
    if params.get("timing_flag", False):
        cargs.append("--to")
    if params.get("log_dir", None) is not None:
        cargs.extend([
            "--ld",
            params.get("log_dir", None)
        ])
    if params.get("forcedir_flag", False):
        cargs.append("--forcedir")
    if params.get("inference_tech", None) is not None:
        cargs.extend([
            "--inf",
            params.get("inference_tech", None)
        ])
    if params.get("num_jumps", None) is not None:
        cargs.extend([
            "--nj",
            str(params.get("num_jumps", None))
        ])
    if params.get("num_burnin", None) is not None:
        cargs.extend([
            "--bi",
            str(params.get("num_burnin", None))
        ])
    if params.get("num_sample_every", None) is not None:
        cargs.extend([
            "--se",
            str(params.get("num_sample_every", None))
        ])
    if params.get("num_update_proposalevery", None) is not None:
        cargs.extend([
            "--upe",
            str(params.get("num_update_proposalevery", None))
        ])
    if params.get("acceptance_rate", None) is not None:
        cargs.extend([
            "--arate",
            str(params.get("acceptance_rate", None))
        ])
    if params.get("seed", None) is not None:
        cargs.extend([
            "--seed",
            str(params.get("seed", None))
        ])
    if params.get("error_precision", None) is not None:
        cargs.extend([
            "--prec",
            str(params.get("error_precision", None))
        ])
    if params.get("noamp_flag", False):
        cargs.append("--noamp")
    if params.get("prior_mean", None) is not None:
        cargs.extend([
            "--pm",
            str(params.get("prior_mean", None))
        ])
    if params.get("prior_std", None) is not None:
        cargs.extend([
            "--ps",
            str(params.get("prior_std", None))
        ])
    if params.get("help_flag", False):
        cargs.append("-h")
    return cargs


def mean_outputs(
    params: MeanParamsDict,
    execution: Execution,
) -> MeanOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MeanOutputs(
        root=execution.output_file("."),
        output_log=execution.output_file("logdir/mean_output.txt"),
    )
    return ret


def mean_execute(
    params: MeanParamsDict,
    runner: Runner | None = None,
) -> MeanOutputs:
    """
    mean
    
    Diagnostic tool for analyzing and computing mean values for FSL data.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MeanOutputs`).
    """
    mean_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MEAN_METADATA)
    params = execution.params(params)
    cargs = mean_cargs(params, execution)
    ret = mean_outputs(params, execution)
    execution.run(cargs)
    return ret


def mean(
    datafile: InputPathType,
    maskfile: InputPathType,
    verbose_flag: bool = False,
    debug_level: float | None = None,
    timing_flag: bool = False,
    log_dir: str | None = None,
    forcedir_flag: bool = False,
    inference_tech: str | None = None,
    num_jumps: float | None = None,
    num_burnin: float | None = None,
    num_sample_every: float | None = None,
    num_update_proposalevery: float | None = None,
    acceptance_rate: float | None = None,
    seed: float | None = None,
    error_precision: float | None = None,
    noamp_flag: bool = False,
    prior_mean: float | None = None,
    prior_std: float | None = None,
    help_flag: bool = False,
    runner: Runner | None = None,
) -> MeanOutputs:
    """
    mean
    
    Diagnostic tool for analyzing and computing mean values for FSL data.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        datafile: Regressor data file.
        maskfile: Mask file.
        verbose_flag: Switch on diagnostic messages.
        debug_level: Set debug level.
        timing_flag: Turn timing on.
        log_dir: Log directory (default is logdir).
        forcedir_flag: Use the actual directory name given - i.e. don't add +\
            to make a new directory.
        inference_tech: Inference technique: mcmc or laplace (default is mcmc).
        num_jumps: Number of jumps to be made by MCMC (default is 5000).
        num_burnin: Number of jumps at start of MCMC to be discarded (default\
            is 500).
        num_sample_every: Number of jumps for each sample (MCMC) (default is 1).
        num_update_proposalevery: Number of jumps for each update to the\
            proposal density std (MCMC) (default is 40).
        acceptance_rate: Acceptance rate to aim for (MCMC) (default is 0.6).
        seed: Seed for pseudo random number generator.
        error_precision: Value to fix error precision to (default is -1, which\
            means error precision is not fixed).
        noamp_flag: Turn off Analytical Marginalisation of error Precision.
        prior_mean: Prior mean.
        prior_std: Prior standard deviation.
        help_flag: Display help message.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MeanOutputs`).
    """
    params = mean_params(
        datafile=datafile,
        maskfile=maskfile,
        verbose_flag=verbose_flag,
        debug_level=debug_level,
        timing_flag=timing_flag,
        log_dir=log_dir,
        forcedir_flag=forcedir_flag,
        inference_tech=inference_tech,
        num_jumps=num_jumps,
        num_burnin=num_burnin,
        num_sample_every=num_sample_every,
        num_update_proposalevery=num_update_proposalevery,
        acceptance_rate=acceptance_rate,
        seed=seed,
        error_precision=error_precision,
        noamp_flag=noamp_flag,
        prior_mean=prior_mean,
        prior_std=prior_std,
        help_flag=help_flag,
    )
    return mean_execute(params, runner)


__all__ = [
    "MEAN_METADATA",
    "MeanOutputs",
    "MeanParamsDict",
    "MeanParamsDictTagged",
    "mean",
    "mean_execute",
    "mean_params",
]
