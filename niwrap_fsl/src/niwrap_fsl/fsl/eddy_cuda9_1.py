# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

EDDY_CUDA9_1_METADATA = Metadata(
    id="66f05bab766596d85a8c43aee31f3003245deb1b.boutiques",
    name="eddy_cuda9.1",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_EddyCuda91ParamsDictNoTag = typing.TypedDict('_EddyCuda91ParamsDictNoTag', {
    "imain": InputPathType,
    "mask": InputPathType,
    "index": InputPathType,
    "acqp": InputPathType,
    "bvecs": InputPathType,
    "bvals": InputPathType,
    "out": str,
    "mb": typing.NotRequired[float | None],
    "mb_offs": typing.NotRequired[float | None],
    "slspec": typing.NotRequired[InputPathType | None],
    "json": typing.NotRequired[InputPathType | None],
    "mporder": typing.NotRequired[float | None],
    "s2v_lambda": typing.NotRequired[float | None],
    "topup": typing.NotRequired[InputPathType | None],
    "field": typing.NotRequired[InputPathType | None],
    "field_mat": typing.NotRequired[InputPathType | None],
    "flm": typing.NotRequired[typing.Literal["movement", "linear", "quadratic", "cubic"] | None],
    "slm": typing.NotRequired[typing.Literal["none", "linear", "quadratic"] | None],
    "fwhm": typing.NotRequired[float | None],
    "niter": typing.NotRequired[float | None],
    "s2v_niter": typing.NotRequired[float | None],
    "cnr_maps": bool,
    "residuals": bool,
    "fep": bool,
    "interp": typing.NotRequired[typing.Literal["spline", "trilinear"] | None],
    "s2v_interp": typing.NotRequired[typing.Literal["spline", "trilinear"] | None],
    "resamp": typing.NotRequired[typing.Literal["jac", "lsr"] | None],
    "nvoxhp": typing.NotRequired[float | None],
    "initrand": typing.NotRequired[float | None],
    "ff": typing.NotRequired[float | None],
    "repol": bool,
    "ol_nstd": typing.NotRequired[float | None],
    "ol_nvox": typing.NotRequired[float | None],
    "ol_type": typing.NotRequired[typing.Literal["sw", "gw", "both"] | None],
    "ol_pos": bool,
    "ol_sqr": bool,
    "estimate_move_by_susceptibility": bool,
    "mbs_niter": typing.NotRequired[float | None],
    "mbs_lambda": typing.NotRequired[float | None],
    "mbs_ksp": typing.NotRequired[float | None],
    "dont_sep_offs_move": bool,
    "dont_peas": bool,
    "data_is_shelled": bool,
    "verbose": bool,
})
EddyCuda91ParamsDictTagged = typing.TypedDict('EddyCuda91ParamsDictTagged', {
    "@type": typing.Literal["fsl/eddy_cuda9.1"],
    "imain": InputPathType,
    "mask": InputPathType,
    "index": InputPathType,
    "acqp": InputPathType,
    "bvecs": InputPathType,
    "bvals": InputPathType,
    "out": str,
    "mb": typing.NotRequired[float | None],
    "mb_offs": typing.NotRequired[float | None],
    "slspec": typing.NotRequired[InputPathType | None],
    "json": typing.NotRequired[InputPathType | None],
    "mporder": typing.NotRequired[float | None],
    "s2v_lambda": typing.NotRequired[float | None],
    "topup": typing.NotRequired[InputPathType | None],
    "field": typing.NotRequired[InputPathType | None],
    "field_mat": typing.NotRequired[InputPathType | None],
    "flm": typing.NotRequired[typing.Literal["movement", "linear", "quadratic", "cubic"] | None],
    "slm": typing.NotRequired[typing.Literal["none", "linear", "quadratic"] | None],
    "fwhm": typing.NotRequired[float | None],
    "niter": typing.NotRequired[float | None],
    "s2v_niter": typing.NotRequired[float | None],
    "cnr_maps": bool,
    "residuals": bool,
    "fep": bool,
    "interp": typing.NotRequired[typing.Literal["spline", "trilinear"] | None],
    "s2v_interp": typing.NotRequired[typing.Literal["spline", "trilinear"] | None],
    "resamp": typing.NotRequired[typing.Literal["jac", "lsr"] | None],
    "nvoxhp": typing.NotRequired[float | None],
    "initrand": typing.NotRequired[float | None],
    "ff": typing.NotRequired[float | None],
    "repol": bool,
    "ol_nstd": typing.NotRequired[float | None],
    "ol_nvox": typing.NotRequired[float | None],
    "ol_type": typing.NotRequired[typing.Literal["sw", "gw", "both"] | None],
    "ol_pos": bool,
    "ol_sqr": bool,
    "estimate_move_by_susceptibility": bool,
    "mbs_niter": typing.NotRequired[float | None],
    "mbs_lambda": typing.NotRequired[float | None],
    "mbs_ksp": typing.NotRequired[float | None],
    "dont_sep_offs_move": bool,
    "dont_peas": bool,
    "data_is_shelled": bool,
    "verbose": bool,
})
EddyCuda91ParamsDict = _EddyCuda91ParamsDictNoTag | EddyCuda91ParamsDictTagged


class EddyCuda91Outputs(typing.NamedTuple):
    """
    Output object returned when calling `EddyCuda91ParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out: OutputPathType
    """Output file containing the corrected images"""
    eddy_parameters: OutputPathType
    """Text file containing subject movement and EC-induced field parameters for
    each volume"""
    rotated_bvecs: OutputPathType
    """File containing the reoriented b-vectors for diffusion analysis"""
    rotated_bvecs_slr: OutputPathType
    """File with rotated b-vectors for least-squares reconstruction"""
    command_txt: OutputPathType
    """Text file documenting the command line used to run eddy"""
    input_parameters: OutputPathType
    """List of all parameters used by eddy"""
    movement_rms: OutputPathType
    """Summary of total movement for each volume"""
    restricted_movement_rms: OutputPathType
    """Estimates movement RMS while disregarding translation in the PE
    direction"""
    shell_alignment_parameters: OutputPathType
    """Text file with rigid body movement parameters between different shells"""
    shell_pe_translation_parameters: OutputPathType
    """Translation parameters along the PE direction between different shells"""
    outlier_report: OutputPathType
    """Report of detected outlier slices"""
    outlier_map: OutputPathType
    """Numeric matrix indicating outlier slices"""
    outlier_n_stdev_map: OutputPathType
    """Map of the number of standard deviations for outliers"""
    outlier_n_sqr_stdev_map: OutputPathType
    """Map of the number of squared standard deviations for outliers"""
    outlier_free_data: OutputPathType
    """Original data with outlier slices replaced, only if --repol was set"""
    movement_over_time: OutputPathType
    """Text file with movement parameters over time, only if --mporder > 0"""
    mbs_first_order_fields: OutputPathType
    """4D image file of partial derivative fields, only if
    --estimate_move_by_susceptibility is set"""
    cnr_maps: OutputPathType
    """4D image file with SNR and CNR maps, only if --cnr_maps is set"""
    residuals: OutputPathType
    """4D image file of residuals, only if --residuals is set"""


def eddy_cuda9_1_params(
    imain: InputPathType,
    mask: InputPathType,
    index: InputPathType,
    acqp: InputPathType,
    bvecs: InputPathType,
    bvals: InputPathType,
    out: str = "eddy_corrected",
    mb: float | None = None,
    mb_offs: float | None = None,
    slspec: InputPathType | None = None,
    json_: InputPathType | None = None,
    mporder: float | None = None,
    s2v_lambda: float | None = None,
    topup: InputPathType | None = None,
    field: InputPathType | None = None,
    field_mat: InputPathType | None = None,
    flm: typing.Literal["movement", "linear", "quadratic", "cubic"] | None = None,
    slm: typing.Literal["none", "linear", "quadratic"] | None = None,
    fwhm: float | None = None,
    niter: float | None = None,
    s2v_niter: float | None = None,
    cnr_maps: bool = False,
    residuals: bool = False,
    fep: bool = False,
    interp: typing.Literal["spline", "trilinear"] | None = None,
    s2v_interp: typing.Literal["spline", "trilinear"] | None = None,
    resamp: typing.Literal["jac", "lsr"] | None = None,
    nvoxhp: float | None = None,
    initrand: float | None = None,
    ff: float | None = None,
    repol: bool = False,
    ol_nstd: float | None = None,
    ol_nvox: float | None = None,
    ol_type: typing.Literal["sw", "gw", "both"] | None = None,
    ol_pos: bool = False,
    ol_sqr: bool = False,
    estimate_move_by_susceptibility: bool = False,
    mbs_niter: float | None = None,
    mbs_lambda: float | None = None,
    mbs_ksp: float | None = None,
    dont_sep_offs_move: bool = False,
    dont_peas: bool = False,
    data_is_shelled: bool = False,
    verbose: bool = False,
) -> EddyCuda91ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        imain: File containing all the images to estimate distortions for.
        mask: Mask to indicate brain.
        index: File containing indices for all volumes in --imain into --acqp\
            and --topup.
        acqp: File containing acquisition parameters.
        bvecs: File containing the b-vectors for all volumes in --imain.
        bvals: File containing the b-values for all volumes in --imain.
        out: Basename for output.
        mb: Multi-band factor.
        mb_offs: Multi-band offset (-1 if bottom slice removed, 1 if top slice\
            removed).
        slspec: Name of text file completely specifying slice/group acuistion.\
            N.B. --slspec and --json are mutually exclusive.
        json_: Name of .json text file with information about slice timing.\
            N.B. --json and --slspec are mutually exclusive.
        mporder: Order of slice-to-vol movement model (default 0, i.e.\
            vol-to-vol.
        s2v_lambda: Regularisation weight for slice-to-vol movement. (default\
            1, reasonable range 1--10).
        topup: Base name for output files from topup.
        field: Name of file with susceptibility field (in Hz).
        field_mat: Name of rigid body transform for susceptibility field.
        flm: First level EC model (movement/linear/quadratic/cubic, default\
            quadratic).
        slm: Second level EC model (none/linear/quadratic, default none).
        fwhm: FWHM for conditioning filter when estimating the parameters\
            (default 0).
        niter: Number of iterations (default 5).
        s2v_niter: Number of iterations for slice-to-vol (default 5).
        cnr_maps: Write shell-wise cnr-maps (default false).
        residuals: Write residuals (between GP and observations), (default\
            false).
        fep: Fill empty planes in x- or y-directions (default false).
        interp: Interpolation model for estimation step (spline/trilinear,\
            default spline).
        s2v_interp: Slice-to-vol interpolation model for estimation step\
            (spline/trilinear, default trilinear).
        resamp: Final resampling method (jac/lsr, default jac).
        nvoxhp: # of voxels used to estimate the hyperparameters (default 1000).
        initrand: Seeds rand for when selecting voxels (default 0=no seeding).
        ff: Fudge factor for hyperparameter error variance (default 10.0).
        repol: Detect and replace outlier slices (default false)).
        ol_nstd: Number of std off to qualify as outlier (default 4).
        ol_nvox: Min # of voxels in a slice for inclusion in outlier detection\
            (default 250).
        ol_type: Type of outliers, slicewise (sw), groupwise (gw) or both\
            (both). (default sw).
        ol_pos: Consider both positive and negative outliers if set (default\
            false).
        ol_sqr: Consider outliers among sums-of-squared differences if set\
            (default false).
        estimate_move_by_susceptibility: Estimate how susceptibility field\
            changes with subject movement (default false).
        mbs_niter: Number of iterations for MBS estimation (default 10).
        mbs_lambda: Weighting of regularisation for MBS estimation (default 10).
        mbs_ksp: Knot-spacing for MBS field estimation (default 10mm).
        dont_sep_offs_move: Do NOT attempt to separate field offset from\
            subject movement (default false).
        dont_peas: Do NOT perform a post-eddy alignment of shells (default\
            false).
        data_is_shelled: Assume, don't check, that data is shelled (default\
            false).
        verbose: switch on diagnostic messages.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/eddy_cuda9.1",
        "imain": imain,
        "mask": mask,
        "index": index,
        "acqp": acqp,
        "bvecs": bvecs,
        "bvals": bvals,
        "out": out,
        "cnr_maps": cnr_maps,
        "residuals": residuals,
        "fep": fep,
        "repol": repol,
        "ol_pos": ol_pos,
        "ol_sqr": ol_sqr,
        "estimate_move_by_susceptibility": estimate_move_by_susceptibility,
        "dont_sep_offs_move": dont_sep_offs_move,
        "dont_peas": dont_peas,
        "data_is_shelled": data_is_shelled,
        "verbose": verbose,
    }
    if mb is not None:
        params["mb"] = mb
    if mb_offs is not None:
        params["mb_offs"] = mb_offs
    if slspec is not None:
        params["slspec"] = slspec
    if json_ is not None:
        params["json"] = json_
    if mporder is not None:
        params["mporder"] = mporder
    if s2v_lambda is not None:
        params["s2v_lambda"] = s2v_lambda
    if topup is not None:
        params["topup"] = topup
    if field is not None:
        params["field"] = field
    if field_mat is not None:
        params["field_mat"] = field_mat
    if flm is not None:
        params["flm"] = flm
    if slm is not None:
        params["slm"] = slm
    if fwhm is not None:
        params["fwhm"] = fwhm
    if niter is not None:
        params["niter"] = niter
    if s2v_niter is not None:
        params["s2v_niter"] = s2v_niter
    if interp is not None:
        params["interp"] = interp
    if s2v_interp is not None:
        params["s2v_interp"] = s2v_interp
    if resamp is not None:
        params["resamp"] = resamp
    if nvoxhp is not None:
        params["nvoxhp"] = nvoxhp
    if initrand is not None:
        params["initrand"] = initrand
    if ff is not None:
        params["ff"] = ff
    if ol_nstd is not None:
        params["ol_nstd"] = ol_nstd
    if ol_nvox is not None:
        params["ol_nvox"] = ol_nvox
    if ol_type is not None:
        params["ol_type"] = ol_type
    if mbs_niter is not None:
        params["mbs_niter"] = mbs_niter
    if mbs_lambda is not None:
        params["mbs_lambda"] = mbs_lambda
    if mbs_ksp is not None:
        params["mbs_ksp"] = mbs_ksp
    return params


def eddy_cuda9_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `EddyCuda91ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("imain", None) is None:
        raise StyxValidationError("`imain` must not be None")
    if not isinstance(params["imain"], (pathlib.Path, str)):
        raise StyxValidationError(f'`imain` has the wrong type: Received `{type(params.get("imain", None))}` expected `InputPathType`')
    if params.get("mask", None) is None:
        raise StyxValidationError("`mask` must not be None")
    if not isinstance(params["mask"], (pathlib.Path, str)):
        raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType`')
    if params.get("index", None) is None:
        raise StyxValidationError("`index` must not be None")
    if not isinstance(params["index"], (pathlib.Path, str)):
        raise StyxValidationError(f'`index` has the wrong type: Received `{type(params.get("index", None))}` expected `InputPathType`')
    if params.get("acqp", None) is None:
        raise StyxValidationError("`acqp` must not be None")
    if not isinstance(params["acqp"], (pathlib.Path, str)):
        raise StyxValidationError(f'`acqp` has the wrong type: Received `{type(params.get("acqp", None))}` expected `InputPathType`')
    if params.get("bvecs", None) is None:
        raise StyxValidationError("`bvecs` must not be None")
    if not isinstance(params["bvecs"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvecs` has the wrong type: Received `{type(params.get("bvecs", None))}` expected `InputPathType`')
    if params.get("bvals", None) is None:
        raise StyxValidationError("`bvals` must not be None")
    if not isinstance(params["bvals"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvals` has the wrong type: Received `{type(params.get("bvals", None))}` expected `InputPathType`')
    if params.get("out", "eddy_corrected") is None:
        raise StyxValidationError("`out` must not be None")
    if not isinstance(params["out"], str):
        raise StyxValidationError(f'`out` has the wrong type: Received `{type(params.get("out", "eddy_corrected"))}` expected `str`')
    if params.get("mb", None) is not None:
        if not isinstance(params["mb"], (float, int)):
            raise StyxValidationError(f'`mb` has the wrong type: Received `{type(params.get("mb", None))}` expected `float | None`')
    if params.get("mb_offs", None) is not None:
        if not isinstance(params["mb_offs"], (float, int)):
            raise StyxValidationError(f'`mb_offs` has the wrong type: Received `{type(params.get("mb_offs", None))}` expected `float | None`')
    if params.get("slspec", None) is not None:
        if not isinstance(params["slspec"], (pathlib.Path, str)):
            raise StyxValidationError(f'`slspec` has the wrong type: Received `{type(params.get("slspec", None))}` expected `InputPathType | None`')
    if params.get("json", None) is not None:
        if not isinstance(params["json"], (pathlib.Path, str)):
            raise StyxValidationError(f'`json` has the wrong type: Received `{type(params.get("json", None))}` expected `InputPathType | None`')
    if params.get("mporder", None) is not None:
        if not isinstance(params["mporder"], (float, int)):
            raise StyxValidationError(f'`mporder` has the wrong type: Received `{type(params.get("mporder", None))}` expected `float | None`')
    if params.get("s2v_lambda", None) is not None:
        if not isinstance(params["s2v_lambda"], (float, int)):
            raise StyxValidationError(f'`s2v_lambda` has the wrong type: Received `{type(params.get("s2v_lambda", None))}` expected `float | None`')
    if params.get("topup", None) is not None:
        if not isinstance(params["topup"], (pathlib.Path, str)):
            raise StyxValidationError(f'`topup` has the wrong type: Received `{type(params.get("topup", None))}` expected `InputPathType | None`')
    if params.get("field", None) is not None:
        if not isinstance(params["field"], (pathlib.Path, str)):
            raise StyxValidationError(f'`field` has the wrong type: Received `{type(params.get("field", None))}` expected `InputPathType | None`')
    if params.get("field_mat", None) is not None:
        if not isinstance(params["field_mat"], (pathlib.Path, str)):
            raise StyxValidationError(f'`field_mat` has the wrong type: Received `{type(params.get("field_mat", None))}` expected `InputPathType | None`')
    if params.get("flm", None) is not None:
        if not isinstance(params["flm"], str):
            raise StyxValidationError(f'`flm` has the wrong type: Received `{type(params.get("flm", None))}` expected `typing.Literal["movement", "linear", "quadratic", "cubic"] | None`')
        if params["flm"] not in ["movement", "linear", "quadratic", "cubic"]:
            raise StyxValidationError("Parameter `flm` must be one of [\"movement\", \"linear\", \"quadratic\", \"cubic\"]")
    if params.get("slm", None) is not None:
        if not isinstance(params["slm"], str):
            raise StyxValidationError(f'`slm` has the wrong type: Received `{type(params.get("slm", None))}` expected `typing.Literal["none", "linear", "quadratic"] | None`')
        if params["slm"] not in ["none", "linear", "quadratic"]:
            raise StyxValidationError("Parameter `slm` must be one of [\"none\", \"linear\", \"quadratic\"]")
    if params.get("fwhm", None) is not None:
        if not isinstance(params["fwhm"], (float, int)):
            raise StyxValidationError(f'`fwhm` has the wrong type: Received `{type(params.get("fwhm", None))}` expected `float | None`')
    if params.get("niter", None) is not None:
        if not isinstance(params["niter"], (float, int)):
            raise StyxValidationError(f'`niter` has the wrong type: Received `{type(params.get("niter", None))}` expected `float | None`')
    if params.get("s2v_niter", None) is not None:
        if not isinstance(params["s2v_niter"], (float, int)):
            raise StyxValidationError(f'`s2v_niter` has the wrong type: Received `{type(params.get("s2v_niter", None))}` expected `float | None`')
    if params.get("cnr_maps", False) is None:
        raise StyxValidationError("`cnr_maps` must not be None")
    if not isinstance(params["cnr_maps"], bool):
        raise StyxValidationError(f'`cnr_maps` has the wrong type: Received `{type(params.get("cnr_maps", False))}` expected `bool`')
    if params.get("residuals", False) is None:
        raise StyxValidationError("`residuals` must not be None")
    if not isinstance(params["residuals"], bool):
        raise StyxValidationError(f'`residuals` has the wrong type: Received `{type(params.get("residuals", False))}` expected `bool`')
    if params.get("fep", False) is None:
        raise StyxValidationError("`fep` must not be None")
    if not isinstance(params["fep"], bool):
        raise StyxValidationError(f'`fep` has the wrong type: Received `{type(params.get("fep", False))}` expected `bool`')
    if params.get("interp", None) is not None:
        if not isinstance(params["interp"], str):
            raise StyxValidationError(f'`interp` has the wrong type: Received `{type(params.get("interp", None))}` expected `typing.Literal["spline", "trilinear"] | None`')
        if params["interp"] not in ["spline", "trilinear"]:
            raise StyxValidationError("Parameter `interp` must be one of [\"spline\", \"trilinear\"]")
    if params.get("s2v_interp", None) is not None:
        if not isinstance(params["s2v_interp"], str):
            raise StyxValidationError(f'`s2v_interp` has the wrong type: Received `{type(params.get("s2v_interp", None))}` expected `typing.Literal["spline", "trilinear"] | None`')
        if params["s2v_interp"] not in ["spline", "trilinear"]:
            raise StyxValidationError("Parameter `s2v_interp` must be one of [\"spline\", \"trilinear\"]")
    if params.get("resamp", None) is not None:
        if not isinstance(params["resamp"], str):
            raise StyxValidationError(f'`resamp` has the wrong type: Received `{type(params.get("resamp", None))}` expected `typing.Literal["jac", "lsr"] | None`')
        if params["resamp"] not in ["jac", "lsr"]:
            raise StyxValidationError("Parameter `resamp` must be one of [\"jac\", \"lsr\"]")
    if params.get("nvoxhp", None) is not None:
        if not isinstance(params["nvoxhp"], (float, int)):
            raise StyxValidationError(f'`nvoxhp` has the wrong type: Received `{type(params.get("nvoxhp", None))}` expected `float | None`')
    if params.get("initrand", None) is not None:
        if not isinstance(params["initrand"], (float, int)):
            raise StyxValidationError(f'`initrand` has the wrong type: Received `{type(params.get("initrand", None))}` expected `float | None`')
    if params.get("ff", None) is not None:
        if not isinstance(params["ff"], (float, int)):
            raise StyxValidationError(f'`ff` has the wrong type: Received `{type(params.get("ff", None))}` expected `float | None`')
    if params.get("repol", False) is None:
        raise StyxValidationError("`repol` must not be None")
    if not isinstance(params["repol"], bool):
        raise StyxValidationError(f'`repol` has the wrong type: Received `{type(params.get("repol", False))}` expected `bool`')
    if params.get("ol_nstd", None) is not None:
        if not isinstance(params["ol_nstd"], (float, int)):
            raise StyxValidationError(f'`ol_nstd` has the wrong type: Received `{type(params.get("ol_nstd", None))}` expected `float | None`')
    if params.get("ol_nvox", None) is not None:
        if not isinstance(params["ol_nvox"], (float, int)):
            raise StyxValidationError(f'`ol_nvox` has the wrong type: Received `{type(params.get("ol_nvox", None))}` expected `float | None`')
    if params.get("ol_type", None) is not None:
        if not isinstance(params["ol_type"], str):
            raise StyxValidationError(f'`ol_type` has the wrong type: Received `{type(params.get("ol_type", None))}` expected `typing.Literal["sw", "gw", "both"] | None`')
        if params["ol_type"] not in ["sw", "gw", "both"]:
            raise StyxValidationError("Parameter `ol_type` must be one of [\"sw\", \"gw\", \"both\"]")
    if params.get("ol_pos", False) is None:
        raise StyxValidationError("`ol_pos` must not be None")
    if not isinstance(params["ol_pos"], bool):
        raise StyxValidationError(f'`ol_pos` has the wrong type: Received `{type(params.get("ol_pos", False))}` expected `bool`')
    if params.get("ol_sqr", False) is None:
        raise StyxValidationError("`ol_sqr` must not be None")
    if not isinstance(params["ol_sqr"], bool):
        raise StyxValidationError(f'`ol_sqr` has the wrong type: Received `{type(params.get("ol_sqr", False))}` expected `bool`')
    if params.get("estimate_move_by_susceptibility", False) is None:
        raise StyxValidationError("`estimate_move_by_susceptibility` must not be None")
    if not isinstance(params["estimate_move_by_susceptibility"], bool):
        raise StyxValidationError(f'`estimate_move_by_susceptibility` has the wrong type: Received `{type(params.get("estimate_move_by_susceptibility", False))}` expected `bool`')
    if params.get("mbs_niter", None) is not None:
        if not isinstance(params["mbs_niter"], (float, int)):
            raise StyxValidationError(f'`mbs_niter` has the wrong type: Received `{type(params.get("mbs_niter", None))}` expected `float | None`')
    if params.get("mbs_lambda", None) is not None:
        if not isinstance(params["mbs_lambda"], (float, int)):
            raise StyxValidationError(f'`mbs_lambda` has the wrong type: Received `{type(params.get("mbs_lambda", None))}` expected `float | None`')
    if params.get("mbs_ksp", None) is not None:
        if not isinstance(params["mbs_ksp"], (float, int)):
            raise StyxValidationError(f'`mbs_ksp` has the wrong type: Received `{type(params.get("mbs_ksp", None))}` expected `float | None`')
    if params.get("dont_sep_offs_move", False) is None:
        raise StyxValidationError("`dont_sep_offs_move` must not be None")
    if not isinstance(params["dont_sep_offs_move"], bool):
        raise StyxValidationError(f'`dont_sep_offs_move` has the wrong type: Received `{type(params.get("dont_sep_offs_move", False))}` expected `bool`')
    if params.get("dont_peas", False) is None:
        raise StyxValidationError("`dont_peas` must not be None")
    if not isinstance(params["dont_peas"], bool):
        raise StyxValidationError(f'`dont_peas` has the wrong type: Received `{type(params.get("dont_peas", False))}` expected `bool`')
    if params.get("data_is_shelled", False) is None:
        raise StyxValidationError("`data_is_shelled` must not be None")
    if not isinstance(params["data_is_shelled"], bool):
        raise StyxValidationError(f'`data_is_shelled` has the wrong type: Received `{type(params.get("data_is_shelled", False))}` expected `bool`')
    if params.get("verbose", False) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], bool):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", False))}` expected `bool`')


def eddy_cuda9_1_cargs(
    params: EddyCuda91ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("eddy_cuda9.1")
    cargs.append("--imain=" + execution.input_file(params.get("imain", None)))
    cargs.append("--mask=" + execution.input_file(params.get("mask", None)))
    cargs.append("--index=" + execution.input_file(params.get("index", None)))
    cargs.append("--acqp=" + execution.input_file(params.get("acqp", None)))
    cargs.append("--bvecs=" + execution.input_file(params.get("bvecs", None)))
    cargs.append("--bvals=" + execution.input_file(params.get("bvals", None)))
    cargs.append("--out=" + params.get("out", "eddy_corrected"))
    if params.get("mb", None) is not None:
        cargs.append("--mb=" + str(params.get("mb", None)))
    if params.get("mb_offs", None) is not None:
        cargs.append("--mb_offs=" + str(params.get("mb_offs", None)))
    if params.get("slspec", None) is not None:
        cargs.append("--slspec=" + execution.input_file(params.get("slspec", None)))
    if params.get("json", None) is not None:
        cargs.append("--json=" + execution.input_file(params.get("json", None)))
    if params.get("mporder", None) is not None:
        cargs.append("--mporder=" + str(params.get("mporder", None)))
    if params.get("s2v_lambda", None) is not None:
        cargs.append("--s2v_lambda=" + str(params.get("s2v_lambda", None)))
    if params.get("topup", None) is not None:
        cargs.append("--topup=" + execution.input_file(params.get("topup", None), resolve_parent=True))
    if params.get("field", None) is not None:
        cargs.append("--field=" + execution.input_file(params.get("field", None)))
    if params.get("field_mat", None) is not None:
        cargs.append("--field_mat=" + execution.input_file(params.get("field_mat", None)))
    if params.get("flm", None) is not None:
        cargs.append("--flm=" + params.get("flm", None))
    if params.get("slm", None) is not None:
        cargs.append("--slm=" + params.get("slm", None))
    if params.get("fwhm", None) is not None:
        cargs.append("--fwhm=" + str(params.get("fwhm", None)))
    if params.get("niter", None) is not None:
        cargs.append("--niter=" + str(params.get("niter", None)))
    if params.get("s2v_niter", None) is not None:
        cargs.append("--s2v_niter=" + str(params.get("s2v_niter", None)))
    if params.get("cnr_maps", False):
        cargs.append("--cnr_maps")
    if params.get("residuals", False):
        cargs.append("--residuals")
    if params.get("fep", False):
        cargs.append("--fep")
    if params.get("interp", None) is not None:
        cargs.append("--interp=" + params.get("interp", None))
    if params.get("s2v_interp", None) is not None:
        cargs.append("--s2v_interp=" + params.get("s2v_interp", None))
    if params.get("resamp", None) is not None:
        cargs.append("--resamp=" + params.get("resamp", None))
    if params.get("nvoxhp", None) is not None:
        cargs.append("--nvoxhp=" + str(params.get("nvoxhp", None)))
    if params.get("initrand", None) is not None:
        cargs.append("--initrand=" + str(params.get("initrand", None)))
    if params.get("ff", None) is not None:
        cargs.append("--ff=" + str(params.get("ff", None)))
    if params.get("repol", False):
        cargs.append("--repol")
    if params.get("ol_nstd", None) is not None:
        cargs.append("--ol_nstd=" + str(params.get("ol_nstd", None)))
    if params.get("ol_nvox", None) is not None:
        cargs.append("--ol_nvox=" + str(params.get("ol_nvox", None)))
    if params.get("ol_type", None) is not None:
        cargs.append("--ol_type=" + params.get("ol_type", None))
    if params.get("ol_pos", False):
        cargs.append("--ol_pos")
    if params.get("ol_sqr", False):
        cargs.append("--ol_sqr")
    if params.get("estimate_move_by_susceptibility", False):
        cargs.append("--estimate_move_by_susceptibility")
    if params.get("mbs_niter", None) is not None:
        cargs.append("--mbs_niter=" + str(params.get("mbs_niter", None)))
    if params.get("mbs_lambda", None) is not None:
        cargs.append("--mbs_lambda=" + str(params.get("mbs_lambda", None)))
    if params.get("mbs_ksp", None) is not None:
        cargs.append("--mbs_ksp=" + str(params.get("mbs_ksp", None)))
    if params.get("dont_sep_offs_move", False):
        cargs.append("--dont_sep_offs_move")
    if params.get("dont_peas", False):
        cargs.append("--dont_peas")
    if params.get("data_is_shelled", False):
        cargs.append("--data_is_shelled")
    if params.get("verbose", False):
        cargs.append("--verbose")
    return cargs


def eddy_cuda9_1_outputs(
    params: EddyCuda91ParamsDict,
    execution: Execution,
) -> EddyCuda91Outputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = EddyCuda91Outputs(
        root=execution.output_file("."),
        out=execution.output_file(params.get("out", "eddy_corrected") + ".nii.gz"),
        eddy_parameters=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_parameters"),
        rotated_bvecs=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_rotated_bvecs"),
        rotated_bvecs_slr=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_rotated_bvecs_for_SLR"),
        command_txt=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_command_txt"),
        input_parameters=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_values_of_all_input_parameters"),
        movement_rms=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_movement_rms"),
        restricted_movement_rms=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_restricted_movement_rms"),
        shell_alignment_parameters=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_post_eddy_shell_alignment_parameters"),
        shell_pe_translation_parameters=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_post_eddy_shell_PE_translation_parameters"),
        outlier_report=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_outlier_report"),
        outlier_map=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_outlier_map"),
        outlier_n_stdev_map=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_outlier_n_stdev_map"),
        outlier_n_sqr_stdev_map=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_outlier_n_sqr_stdev_map"),
        outlier_free_data=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_outlier_free_data.nii.gz"),
        movement_over_time=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_movement_over_time"),
        mbs_first_order_fields=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_mbs_first_order_fields.nii.gz"),
        cnr_maps=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_cnr_maps"),
        residuals=execution.output_file(params.get("out", "eddy_corrected") + ".eddy_residuals"),
    )
    return ret


def eddy_cuda9_1_execute(
    params: EddyCuda91ParamsDict,
    runner: Runner | None = None,
) -> EddyCuda91Outputs:
    """
    eddy_cuda9.1
    
    A tool for correcting eddy currents and movements in diffusion data.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `EddyCuda91Outputs`).
    """
    eddy_cuda9_1_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(EDDY_CUDA9_1_METADATA)
    params = execution.params(params)
    cargs = eddy_cuda9_1_cargs(params, execution)
    ret = eddy_cuda9_1_outputs(params, execution)
    execution.run(cargs)
    return ret


def eddy_cuda9_1(
    imain: InputPathType,
    mask: InputPathType,
    index: InputPathType,
    acqp: InputPathType,
    bvecs: InputPathType,
    bvals: InputPathType,
    out: str = "eddy_corrected",
    mb: float | None = None,
    mb_offs: float | None = None,
    slspec: InputPathType | None = None,
    json_: InputPathType | None = None,
    mporder: float | None = None,
    s2v_lambda: float | None = None,
    topup: InputPathType | None = None,
    field: InputPathType | None = None,
    field_mat: InputPathType | None = None,
    flm: typing.Literal["movement", "linear", "quadratic", "cubic"] | None = None,
    slm: typing.Literal["none", "linear", "quadratic"] | None = None,
    fwhm: float | None = None,
    niter: float | None = None,
    s2v_niter: float | None = None,
    cnr_maps: bool = False,
    residuals: bool = False,
    fep: bool = False,
    interp: typing.Literal["spline", "trilinear"] | None = None,
    s2v_interp: typing.Literal["spline", "trilinear"] | None = None,
    resamp: typing.Literal["jac", "lsr"] | None = None,
    nvoxhp: float | None = None,
    initrand: float | None = None,
    ff: float | None = None,
    repol: bool = False,
    ol_nstd: float | None = None,
    ol_nvox: float | None = None,
    ol_type: typing.Literal["sw", "gw", "both"] | None = None,
    ol_pos: bool = False,
    ol_sqr: bool = False,
    estimate_move_by_susceptibility: bool = False,
    mbs_niter: float | None = None,
    mbs_lambda: float | None = None,
    mbs_ksp: float | None = None,
    dont_sep_offs_move: bool = False,
    dont_peas: bool = False,
    data_is_shelled: bool = False,
    verbose: bool = False,
    runner: Runner | None = None,
) -> EddyCuda91Outputs:
    """
    eddy_cuda9.1
    
    A tool for correcting eddy currents and movements in diffusion data.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        imain: File containing all the images to estimate distortions for.
        mask: Mask to indicate brain.
        index: File containing indices for all volumes in --imain into --acqp\
            and --topup.
        acqp: File containing acquisition parameters.
        bvecs: File containing the b-vectors for all volumes in --imain.
        bvals: File containing the b-values for all volumes in --imain.
        out: Basename for output.
        mb: Multi-band factor.
        mb_offs: Multi-band offset (-1 if bottom slice removed, 1 if top slice\
            removed).
        slspec: Name of text file completely specifying slice/group acuistion.\
            N.B. --slspec and --json are mutually exclusive.
        json_: Name of .json text file with information about slice timing.\
            N.B. --json and --slspec are mutually exclusive.
        mporder: Order of slice-to-vol movement model (default 0, i.e.\
            vol-to-vol.
        s2v_lambda: Regularisation weight for slice-to-vol movement. (default\
            1, reasonable range 1--10).
        topup: Base name for output files from topup.
        field: Name of file with susceptibility field (in Hz).
        field_mat: Name of rigid body transform for susceptibility field.
        flm: First level EC model (movement/linear/quadratic/cubic, default\
            quadratic).
        slm: Second level EC model (none/linear/quadratic, default none).
        fwhm: FWHM for conditioning filter when estimating the parameters\
            (default 0).
        niter: Number of iterations (default 5).
        s2v_niter: Number of iterations for slice-to-vol (default 5).
        cnr_maps: Write shell-wise cnr-maps (default false).
        residuals: Write residuals (between GP and observations), (default\
            false).
        fep: Fill empty planes in x- or y-directions (default false).
        interp: Interpolation model for estimation step (spline/trilinear,\
            default spline).
        s2v_interp: Slice-to-vol interpolation model for estimation step\
            (spline/trilinear, default trilinear).
        resamp: Final resampling method (jac/lsr, default jac).
        nvoxhp: # of voxels used to estimate the hyperparameters (default 1000).
        initrand: Seeds rand for when selecting voxels (default 0=no seeding).
        ff: Fudge factor for hyperparameter error variance (default 10.0).
        repol: Detect and replace outlier slices (default false)).
        ol_nstd: Number of std off to qualify as outlier (default 4).
        ol_nvox: Min # of voxels in a slice for inclusion in outlier detection\
            (default 250).
        ol_type: Type of outliers, slicewise (sw), groupwise (gw) or both\
            (both). (default sw).
        ol_pos: Consider both positive and negative outliers if set (default\
            false).
        ol_sqr: Consider outliers among sums-of-squared differences if set\
            (default false).
        estimate_move_by_susceptibility: Estimate how susceptibility field\
            changes with subject movement (default false).
        mbs_niter: Number of iterations for MBS estimation (default 10).
        mbs_lambda: Weighting of regularisation for MBS estimation (default 10).
        mbs_ksp: Knot-spacing for MBS field estimation (default 10mm).
        dont_sep_offs_move: Do NOT attempt to separate field offset from\
            subject movement (default false).
        dont_peas: Do NOT perform a post-eddy alignment of shells (default\
            false).
        data_is_shelled: Assume, don't check, that data is shelled (default\
            false).
        verbose: switch on diagnostic messages.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `EddyCuda91Outputs`).
    """
    params = eddy_cuda9_1_params(
        imain=imain,
        mask=mask,
        index=index,
        acqp=acqp,
        bvecs=bvecs,
        bvals=bvals,
        out=out,
        mb=mb,
        mb_offs=mb_offs,
        slspec=slspec,
        json_=json_,
        mporder=mporder,
        s2v_lambda=s2v_lambda,
        topup=topup,
        field=field,
        field_mat=field_mat,
        flm=flm,
        slm=slm,
        fwhm=fwhm,
        niter=niter,
        s2v_niter=s2v_niter,
        cnr_maps=cnr_maps,
        residuals=residuals,
        fep=fep,
        interp=interp,
        s2v_interp=s2v_interp,
        resamp=resamp,
        nvoxhp=nvoxhp,
        initrand=initrand,
        ff=ff,
        repol=repol,
        ol_nstd=ol_nstd,
        ol_nvox=ol_nvox,
        ol_type=ol_type,
        ol_pos=ol_pos,
        ol_sqr=ol_sqr,
        estimate_move_by_susceptibility=estimate_move_by_susceptibility,
        mbs_niter=mbs_niter,
        mbs_lambda=mbs_lambda,
        mbs_ksp=mbs_ksp,
        dont_sep_offs_move=dont_sep_offs_move,
        dont_peas=dont_peas,
        data_is_shelled=data_is_shelled,
        verbose=verbose,
    )
    return eddy_cuda9_1_execute(params, runner)


__all__ = [
    "EDDY_CUDA9_1_METADATA",
    "EddyCuda91Outputs",
    "EddyCuda91ParamsDict",
    "EddyCuda91ParamsDictTagged",
    "eddy_cuda9_1",
    "eddy_cuda9_1_execute",
    "eddy_cuda9_1_params",
]
