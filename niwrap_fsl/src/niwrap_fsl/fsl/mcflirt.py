# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MCFLIRT_METADATA = Metadata(
    id="f0d8ed32c0ba67770178acd0feb7a0cef0121bf4.boutiques",
    name="mcflirt",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_McflirtParamsDictNoTag = typing.TypedDict('_McflirtParamsDictNoTag', {
    "in_file": InputPathType,
    "bins": typing.NotRequired[int | None],
    "cost": typing.NotRequired[typing.Literal["mutualinfo", "woods", "corratio", "normcorr", "normmi", "leastsquares"] | None],
    "dof": typing.NotRequired[int | None],
    "init": typing.NotRequired[InputPathType | None],
    "interpolation": typing.NotRequired[typing.Literal["spline_final", "nn_final", "sinc_final"] | None],
    "mean_vol": bool,
    "out_file": typing.NotRequired[str | None],
    "ref_file": typing.NotRequired[InputPathType | None],
    "ref_vol": typing.NotRequired[int | None],
    "rotation": typing.NotRequired[int | None],
    "save_mats": bool,
    "save_plots": bool,
    "save_rmsabs": bool,
    "save_rmsrel": bool,
    "scaling": typing.NotRequired[float | None],
    "smooth": typing.NotRequired[float | None],
    "stages": typing.NotRequired[int | None],
    "stats_imgs": bool,
    "use_contour": bool,
    "use_gradient": bool,
})
McflirtParamsDictTagged = typing.TypedDict('McflirtParamsDictTagged', {
    "@type": typing.Literal["fsl/mcflirt"],
    "in_file": InputPathType,
    "bins": typing.NotRequired[int | None],
    "cost": typing.NotRequired[typing.Literal["mutualinfo", "woods", "corratio", "normcorr", "normmi", "leastsquares"] | None],
    "dof": typing.NotRequired[int | None],
    "init": typing.NotRequired[InputPathType | None],
    "interpolation": typing.NotRequired[typing.Literal["spline_final", "nn_final", "sinc_final"] | None],
    "mean_vol": bool,
    "out_file": typing.NotRequired[str | None],
    "ref_file": typing.NotRequired[InputPathType | None],
    "ref_vol": typing.NotRequired[int | None],
    "rotation": typing.NotRequired[int | None],
    "save_mats": bool,
    "save_plots": bool,
    "save_rmsabs": bool,
    "save_rmsrel": bool,
    "scaling": typing.NotRequired[float | None],
    "smooth": typing.NotRequired[float | None],
    "stages": typing.NotRequired[int | None],
    "stats_imgs": bool,
    "use_contour": bool,
    "use_gradient": bool,
})
McflirtParamsDict = _McflirtParamsDictNoTag | McflirtParamsDictTagged


class McflirtOutputs(typing.NamedTuple):
    """
    Output object returned when calling `McflirtParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    mean_img: OutputPathType | None
    """Mean timeseries image (if mean_vol=true)."""
    out_file: OutputPathType | None
    """Motion-corrected timeseries."""
    par_file: OutputPathType | None
    """Text-file with motion parameters."""
    rmsabs_files: OutputPathType | None
    """A list of items which are an existing file name. Absolute displacement
    parameters."""
    rmsrel_files: OutputPathType | None
    """A list of items which are an existing file name. Relative displacement
    parameters."""
    std_img: OutputPathType | None
    """Standard deviation image."""
    variance_img: OutputPathType | None
    """Variance image."""


def mcflirt_params(
    in_file: InputPathType,
    bins: int | None = None,
    cost: typing.Literal["mutualinfo", "woods", "corratio", "normcorr", "normmi", "leastsquares"] | None = None,
    dof: int | None = None,
    init: InputPathType | None = None,
    interpolation: typing.Literal["spline_final", "nn_final", "sinc_final"] | None = None,
    mean_vol: bool = False,
    out_file: str | None = None,
    ref_file: InputPathType | None = None,
    ref_vol: int | None = None,
    rotation: int | None = None,
    save_mats: bool = False,
    save_plots: bool = False,
    save_rmsabs: bool = False,
    save_rmsrel: bool = False,
    scaling: float | None = None,
    smooth: float | None = None,
    stages: int | None = None,
    stats_imgs: bool = False,
    use_contour: bool = False,
    use_gradient: bool = False,
) -> McflirtParamsDictTagged:
    """
    Build parameters.
    
    Args:
        in_file: Timeseries to motion-correct.
        bins: Number of histogram bins.
        cost: 'mutualinfo' or 'woods' or 'corratio' or 'normcorr' or 'normmi'\
            or 'leastsquares'. Cost function to optimize.
        dof: Degrees of freedom for the transformation.
        init: Initial transformation matrix.
        interpolation: 'spline' or 'nn' or 'sinc'. Interpolation method for\
            transformation.
        mean_vol: Register to mean volume.
        out_file: File to write.
        ref_file: Target image for motion correction.
        ref_vol: Volume to align frames to.
        rotation: Scaling factor for rotation tolerances.
        save_mats: Save transformation matrices.
        save_plots: Save transformation parameters.
        save_rmsabs: Save rms displacement parameters.
        save_rmsrel: Save relative rms displacement parameters.
        scaling: Scaling factor to use.
        smooth: Smoothing factor for the cost function.
        stages: Stages (if 4, perform final search with sinc interpolation.
        stats_imgs: Produce variance and std. dev. images.
        use_contour: Run search on contour images.
        use_gradient: Run search on gradient images.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/mcflirt",
        "in_file": in_file,
        "mean_vol": mean_vol,
        "save_mats": save_mats,
        "save_plots": save_plots,
        "save_rmsabs": save_rmsabs,
        "save_rmsrel": save_rmsrel,
        "stats_imgs": stats_imgs,
        "use_contour": use_contour,
        "use_gradient": use_gradient,
    }
    if bins is not None:
        params["bins"] = bins
    if cost is not None:
        params["cost"] = cost
    if dof is not None:
        params["dof"] = dof
    if init is not None:
        params["init"] = init
    if interpolation is not None:
        params["interpolation"] = interpolation
    if out_file is not None:
        params["out_file"] = out_file
    if ref_file is not None:
        params["ref_file"] = ref_file
    if ref_vol is not None:
        params["ref_vol"] = ref_vol
    if rotation is not None:
        params["rotation"] = rotation
    if scaling is not None:
        params["scaling"] = scaling
    if smooth is not None:
        params["smooth"] = smooth
    if stages is not None:
        params["stages"] = stages
    return params


def mcflirt_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `McflirtParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("in_file", None) is None:
        raise StyxValidationError("`in_file` must not be None")
    if not isinstance(params["in_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`in_file` has the wrong type: Received `{type(params.get("in_file", None))}` expected `InputPathType`')
    if params.get("bins", None) is not None:
        if not isinstance(params["bins"], int):
            raise StyxValidationError(f'`bins` has the wrong type: Received `{type(params.get("bins", None))}` expected `int | None`')
    if params.get("cost", None) is not None:
        if not isinstance(params["cost"], str):
            raise StyxValidationError(f'`cost` has the wrong type: Received `{type(params.get("cost", None))}` expected `typing.Literal["mutualinfo", "woods", "corratio", "normcorr", "normmi", "leastsquares"] | None`')
        if params["cost"] not in ["mutualinfo", "woods", "corratio", "normcorr", "normmi", "leastsquares"]:
            raise StyxValidationError("Parameter `cost` must be one of [\"mutualinfo\", \"woods\", \"corratio\", \"normcorr\", \"normmi\", \"leastsquares\"]")
    if params.get("dof", None) is not None:
        if not isinstance(params["dof"], int):
            raise StyxValidationError(f'`dof` has the wrong type: Received `{type(params.get("dof", None))}` expected `int | None`')
    if params.get("init", None) is not None:
        if not isinstance(params["init"], (pathlib.Path, str)):
            raise StyxValidationError(f'`init` has the wrong type: Received `{type(params.get("init", None))}` expected `InputPathType | None`')
    if params.get("interpolation", None) is not None:
        if not isinstance(params["interpolation"], str):
            raise StyxValidationError(f'`interpolation` has the wrong type: Received `{type(params.get("interpolation", None))}` expected `typing.Literal["spline_final", "nn_final", "sinc_final"] | None`')
        if params["interpolation"] not in ["spline_final", "nn_final", "sinc_final"]:
            raise StyxValidationError("Parameter `interpolation` must be one of [\"spline_final\", \"nn_final\", \"sinc_final\"]")
    if params.get("mean_vol", False) is None:
        raise StyxValidationError("`mean_vol` must not be None")
    if not isinstance(params["mean_vol"], bool):
        raise StyxValidationError(f'`mean_vol` has the wrong type: Received `{type(params.get("mean_vol", False))}` expected `bool`')
    if params.get("out_file", None) is not None:
        if not isinstance(params["out_file"], str):
            raise StyxValidationError(f'`out_file` has the wrong type: Received `{type(params.get("out_file", None))}` expected `str | None`')
    if params.get("ref_file", None) is not None:
        if not isinstance(params["ref_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`ref_file` has the wrong type: Received `{type(params.get("ref_file", None))}` expected `InputPathType | None`')
    if params.get("ref_vol", None) is not None:
        if not isinstance(params["ref_vol"], int):
            raise StyxValidationError(f'`ref_vol` has the wrong type: Received `{type(params.get("ref_vol", None))}` expected `int | None`')
    if params.get("rotation", None) is not None:
        if not isinstance(params["rotation"], int):
            raise StyxValidationError(f'`rotation` has the wrong type: Received `{type(params.get("rotation", None))}` expected `int | None`')
    if params.get("save_mats", False) is None:
        raise StyxValidationError("`save_mats` must not be None")
    if not isinstance(params["save_mats"], bool):
        raise StyxValidationError(f'`save_mats` has the wrong type: Received `{type(params.get("save_mats", False))}` expected `bool`')
    if params.get("save_plots", False) is None:
        raise StyxValidationError("`save_plots` must not be None")
    if not isinstance(params["save_plots"], bool):
        raise StyxValidationError(f'`save_plots` has the wrong type: Received `{type(params.get("save_plots", False))}` expected `bool`')
    if params.get("save_rmsabs", False) is None:
        raise StyxValidationError("`save_rmsabs` must not be None")
    if not isinstance(params["save_rmsabs"], bool):
        raise StyxValidationError(f'`save_rmsabs` has the wrong type: Received `{type(params.get("save_rmsabs", False))}` expected `bool`')
    if params.get("save_rmsrel", False) is None:
        raise StyxValidationError("`save_rmsrel` must not be None")
    if not isinstance(params["save_rmsrel"], bool):
        raise StyxValidationError(f'`save_rmsrel` has the wrong type: Received `{type(params.get("save_rmsrel", False))}` expected `bool`')
    if params.get("scaling", None) is not None:
        if not isinstance(params["scaling"], (float, int)):
            raise StyxValidationError(f'`scaling` has the wrong type: Received `{type(params.get("scaling", None))}` expected `float | None`')
    if params.get("smooth", None) is not None:
        if not isinstance(params["smooth"], (float, int)):
            raise StyxValidationError(f'`smooth` has the wrong type: Received `{type(params.get("smooth", None))}` expected `float | None`')
    if params.get("stages", None) is not None:
        if not isinstance(params["stages"], int):
            raise StyxValidationError(f'`stages` has the wrong type: Received `{type(params.get("stages", None))}` expected `int | None`')
    if params.get("stats_imgs", False) is None:
        raise StyxValidationError("`stats_imgs` must not be None")
    if not isinstance(params["stats_imgs"], bool):
        raise StyxValidationError(f'`stats_imgs` has the wrong type: Received `{type(params.get("stats_imgs", False))}` expected `bool`')
    if params.get("use_contour", False) is None:
        raise StyxValidationError("`use_contour` must not be None")
    if not isinstance(params["use_contour"], bool):
        raise StyxValidationError(f'`use_contour` has the wrong type: Received `{type(params.get("use_contour", False))}` expected `bool`')
    if params.get("use_gradient", False) is None:
        raise StyxValidationError("`use_gradient` must not be None")
    if not isinstance(params["use_gradient"], bool):
        raise StyxValidationError(f'`use_gradient` has the wrong type: Received `{type(params.get("use_gradient", False))}` expected `bool`')


def mcflirt_cargs(
    params: McflirtParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mcflirt")
    cargs.extend([
        "-in",
        execution.input_file(params.get("in_file", None))
    ])
    if params.get("bins", None) is not None:
        cargs.extend([
            "-bins",
            str(params.get("bins", None))
        ])
    if params.get("cost", None) is not None:
        cargs.extend([
            "-cost",
            params.get("cost", None)
        ])
    if params.get("dof", None) is not None:
        cargs.extend([
            "-dof",
            str(params.get("dof", None))
        ])
    if params.get("init", None) is not None:
        cargs.extend([
            "-init",
            execution.input_file(params.get("init", None))
        ])
    if params.get("interpolation", None) is not None:
        cargs.append("-" + params.get("interpolation", None))
    if params.get("mean_vol", False):
        cargs.append("-meanvol")
    if params.get("out_file", None) is not None:
        cargs.extend([
            "-out",
            params.get("out_file", None)
        ])
    if params.get("ref_file", None) is not None:
        cargs.extend([
            "-reffile",
            execution.input_file(params.get("ref_file", None))
        ])
    if params.get("ref_vol", None) is not None:
        cargs.extend([
            "-refvol",
            str(params.get("ref_vol", None))
        ])
    if params.get("rotation", None) is not None:
        cargs.extend([
            "-rotation",
            str(params.get("rotation", None))
        ])
    if params.get("save_mats", False):
        cargs.append("-mats")
    if params.get("save_plots", False):
        cargs.append("-plots")
    if params.get("save_rmsabs", False):
        cargs.append("-rmsabs")
    if params.get("save_rmsrel", False):
        cargs.append("-rmsrel")
    if params.get("scaling", None) is not None:
        cargs.extend([
            "-scaling",
            str(params.get("scaling", None))
        ])
    if params.get("smooth", None) is not None:
        cargs.extend([
            "-smooth",
            str(params.get("smooth", None))
        ])
    if params.get("stages", None) is not None:
        cargs.extend([
            "-stages",
            str(params.get("stages", None))
        ])
    if params.get("stats_imgs", False):
        cargs.append("-stats")
    if params.get("use_contour", False):
        cargs.append("-edge")
    if params.get("use_gradient", False):
        cargs.append("-gdt")
    return cargs


def mcflirt_outputs(
    params: McflirtParamsDict,
    execution: Execution,
) -> McflirtOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = McflirtOutputs(
        root=execution.output_file("."),
        mean_img=execution.output_file(params.get("out_file", None) + "_mean_reg.ext") if (params.get("out_file") is not None) else None,
        out_file=execution.output_file(params.get("out_file", None)) if (params.get("out_file") is not None) else None,
        par_file=execution.output_file(params.get("out_file", None) + ".par") if (params.get("out_file") is not None) else None,
        rmsabs_files=execution.output_file(params.get("out_file", None) + "_abs.rms") if (params.get("out_file") is not None) else None,
        rmsrel_files=execution.output_file(params.get("out_file", None) + "_rel.rms") if (params.get("out_file") is not None) else None,
        std_img=execution.output_file(params.get("out_file", None) + "_sigma.ext") if (params.get("out_file") is not None) else None,
        variance_img=execution.output_file(params.get("out_file", None) + "_variance.ext") if (params.get("out_file") is not None) else None,
    )
    return ret


def mcflirt_execute(
    params: McflirtParamsDict,
    runner: Runner | None = None,
) -> McflirtOutputs:
    """
    mcflirt
    
    MCFLIRT is an intra-modal motion correction tool designed for use on fMRI
    time series and based on optimization and registration techniques used in
    FLIRT, a fully automated robust and accurate tool for linear (affine) inter-
    and inter-modal brain image registration.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `McflirtOutputs`).
    """
    mcflirt_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MCFLIRT_METADATA)
    params = execution.params(params)
    cargs = mcflirt_cargs(params, execution)
    ret = mcflirt_outputs(params, execution)
    execution.run(cargs)
    return ret


def mcflirt(
    in_file: InputPathType,
    bins: int | None = None,
    cost: typing.Literal["mutualinfo", "woods", "corratio", "normcorr", "normmi", "leastsquares"] | None = None,
    dof: int | None = None,
    init: InputPathType | None = None,
    interpolation: typing.Literal["spline_final", "nn_final", "sinc_final"] | None = None,
    mean_vol: bool = False,
    out_file: str | None = None,
    ref_file: InputPathType | None = None,
    ref_vol: int | None = None,
    rotation: int | None = None,
    save_mats: bool = False,
    save_plots: bool = False,
    save_rmsabs: bool = False,
    save_rmsrel: bool = False,
    scaling: float | None = None,
    smooth: float | None = None,
    stages: int | None = None,
    stats_imgs: bool = False,
    use_contour: bool = False,
    use_gradient: bool = False,
    runner: Runner | None = None,
) -> McflirtOutputs:
    """
    mcflirt
    
    MCFLIRT is an intra-modal motion correction tool designed for use on fMRI
    time series and based on optimization and registration techniques used in
    FLIRT, a fully automated robust and accurate tool for linear (affine) inter-
    and inter-modal brain image registration.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        in_file: Timeseries to motion-correct.
        bins: Number of histogram bins.
        cost: 'mutualinfo' or 'woods' or 'corratio' or 'normcorr' or 'normmi'\
            or 'leastsquares'. Cost function to optimize.
        dof: Degrees of freedom for the transformation.
        init: Initial transformation matrix.
        interpolation: 'spline' or 'nn' or 'sinc'. Interpolation method for\
            transformation.
        mean_vol: Register to mean volume.
        out_file: File to write.
        ref_file: Target image for motion correction.
        ref_vol: Volume to align frames to.
        rotation: Scaling factor for rotation tolerances.
        save_mats: Save transformation matrices.
        save_plots: Save transformation parameters.
        save_rmsabs: Save rms displacement parameters.
        save_rmsrel: Save relative rms displacement parameters.
        scaling: Scaling factor to use.
        smooth: Smoothing factor for the cost function.
        stages: Stages (if 4, perform final search with sinc interpolation.
        stats_imgs: Produce variance and std. dev. images.
        use_contour: Run search on contour images.
        use_gradient: Run search on gradient images.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `McflirtOutputs`).
    """
    params = mcflirt_params(
        in_file=in_file,
        bins=bins,
        cost=cost,
        dof=dof,
        init=init,
        interpolation=interpolation,
        mean_vol=mean_vol,
        out_file=out_file,
        ref_file=ref_file,
        ref_vol=ref_vol,
        rotation=rotation,
        save_mats=save_mats,
        save_plots=save_plots,
        save_rmsabs=save_rmsabs,
        save_rmsrel=save_rmsrel,
        scaling=scaling,
        smooth=smooth,
        stages=stages,
        stats_imgs=stats_imgs,
        use_contour=use_contour,
        use_gradient=use_gradient,
    )
    return mcflirt_execute(params, runner)


__all__ = [
    "MCFLIRT_METADATA",
    "McflirtOutputs",
    "McflirtParamsDict",
    "McflirtParamsDictTagged",
    "mcflirt",
    "mcflirt_execute",
    "mcflirt_params",
]
