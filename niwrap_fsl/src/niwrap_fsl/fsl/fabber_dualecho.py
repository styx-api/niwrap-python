# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

FABBER_DUALECHO_METADATA = Metadata(
    id="f68dc4d7b7155637ea93ff5746a8c1d85242e7c9.boutiques",
    name="fabber_dualecho",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_FabberDualechoParamsDictNoTag = typing.TypedDict('_FabberDualechoParamsDictNoTag', {
    "output_directory": str,
    "method": str,
    "model": str,
    "data": InputPathType,
    "data_order": typing.NotRequired[str | None],
    "mask_file": typing.NotRequired[InputPathType | None],
    "mt_list": typing.NotRequired[float | None],
    "supp_data": typing.NotRequired[InputPathType | None],
    "options_file": typing.NotRequired[InputPathType | None],
    "help_flag": bool,
    "list_methods_flag": bool,
    "list_models_flag": bool,
    "list_params_flag": bool,
    "desc_params_flag": bool,
    "list_outputs_flag": bool,
    "evaluate": typing.NotRequired[str | None],
    "evaluate_params": typing.NotRequired[str | None],
    "evaluate_nt": typing.NotRequired[float | None],
    "simple_output_flag": bool,
    "overwrite_flag": bool,
    "link_to_latest_flag": bool,
    "load_models": typing.NotRequired[InputPathType | None],
    "dump_param_names_flag": bool,
    "save_model_fit_flag": bool,
    "save_residuals_flag": bool,
    "save_model_extras_flag": bool,
    "save_mvn_flag": bool,
    "save_mean_flag": bool,
    "save_std_flag": bool,
    "save_var_flag": bool,
    "save_zstat_flag": bool,
    "save_noise_mean_flag": bool,
    "save_noise_std_flag": bool,
    "save_free_energy_flag": bool,
    "debug_flag": bool,
})
FabberDualechoParamsDictTagged = typing.TypedDict('FabberDualechoParamsDictTagged', {
    "@type": typing.Literal["fsl/fabber_dualecho"],
    "output_directory": str,
    "method": str,
    "model": str,
    "data": InputPathType,
    "data_order": typing.NotRequired[str | None],
    "mask_file": typing.NotRequired[InputPathType | None],
    "mt_list": typing.NotRequired[float | None],
    "supp_data": typing.NotRequired[InputPathType | None],
    "options_file": typing.NotRequired[InputPathType | None],
    "help_flag": bool,
    "list_methods_flag": bool,
    "list_models_flag": bool,
    "list_params_flag": bool,
    "desc_params_flag": bool,
    "list_outputs_flag": bool,
    "evaluate": typing.NotRequired[str | None],
    "evaluate_params": typing.NotRequired[str | None],
    "evaluate_nt": typing.NotRequired[float | None],
    "simple_output_flag": bool,
    "overwrite_flag": bool,
    "link_to_latest_flag": bool,
    "load_models": typing.NotRequired[InputPathType | None],
    "dump_param_names_flag": bool,
    "save_model_fit_flag": bool,
    "save_residuals_flag": bool,
    "save_model_extras_flag": bool,
    "save_mvn_flag": bool,
    "save_mean_flag": bool,
    "save_std_flag": bool,
    "save_var_flag": bool,
    "save_zstat_flag": bool,
    "save_noise_mean_flag": bool,
    "save_noise_std_flag": bool,
    "save_free_energy_flag": bool,
    "debug_flag": bool,
})
FabberDualechoParamsDict = _FabberDualechoParamsDictNoTag | FabberDualechoParamsDictTagged


class FabberDualechoOutputs(typing.NamedTuple):
    """
    Output object returned when calling `FabberDualechoParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_directory: OutputPathType
    """Output directory specified by the user to store output files."""


def fabber_dualecho_params(
    output_directory: str,
    method: str,
    model: str,
    data: InputPathType,
    data_order: str | None = None,
    mask_file: InputPathType | None = None,
    mt_list: float | None = None,
    supp_data: InputPathType | None = None,
    options_file: InputPathType | None = None,
    help_flag: bool = False,
    list_methods_flag: bool = False,
    list_models_flag: bool = False,
    list_params_flag: bool = False,
    desc_params_flag: bool = False,
    list_outputs_flag: bool = False,
    evaluate: str | None = None,
    evaluate_params: str | None = None,
    evaluate_nt: float | None = None,
    simple_output_flag: bool = False,
    overwrite_flag: bool = False,
    link_to_latest_flag: bool = False,
    load_models: InputPathType | None = None,
    dump_param_names_flag: bool = False,
    save_model_fit_flag: bool = False,
    save_residuals_flag: bool = False,
    save_model_extras_flag: bool = False,
    save_mvn_flag: bool = False,
    save_mean_flag: bool = False,
    save_std_flag: bool = False,
    save_var_flag: bool = False,
    save_zstat_flag: bool = False,
    save_noise_mean_flag: bool = False,
    save_noise_std_flag: bool = False,
    save_free_energy_flag: bool = False,
    debug_flag: bool = False,
) -> FabberDualechoParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output_directory: Directory for output files (including logfile).
        method: Use this inference method.
        model: Use this forward model.
        data: Specify a single input data file.
        data_order: If multiple data files are specified, how they will be\
            handled: concatenate = one after the other, interleave = first record\
            from each file, then second, etc.
        mask_file: Mask file. Inference will only be performed where mask value\
            > 0.
        mt_list: List of masked time points, indexed from 1. These will be\
            ignored in the parameter updates.
        supp_data: 'Supplemental' timeseries data, required for some models.
        options_file: File containing additional options, one per line, in the\
            same form as specified on the command line.
        help_flag: Print this usage method. If given with --method or --model,\
            display relevant method/model usage information.
        list_methods_flag: List all known inference methods.
        list_models_flag: List all known forward models.
        list_params_flag: List model parameters (requires model configuration\
            options to be given).
        desc_params_flag: Descript model parameters (name, description, units)\
            - requires model configuration options to be given. Note that not all\
            models provide parameter descriptions.
        list_outputs_flag: List additional model outputs (requires model\
            configuration options to be given).
        evaluate: Evaluate model. Set to name of output required or blank for\
            default output. Requires model configuration options, --evaluate-params\
            and --evaluate-nt.
        evaluate_params: List of parameter values for evaluation.
        evaluate_nt: Number of time points for evaluation - must be consistent\
            with model options where appropriate.
        simple_output_flag: Instead of usual standard output, simply output\
            series of lines each giving progress as percentage.
        overwrite_flag: If set will overwrite existing output. If not set, new\
            output directories will be created by appending '+' to the directory\
            name.
        link_to_latest_flag: Try to create a link to the most recent output\
            directory with the prefix _latest.
        load_models: Load models dynamically from the specified filename, which\
            should be a DLL/shared library.
        dump_param_names_flag: Write the file paramnames.txt containing the\
            names of the model parameters.
        save_model_fit_flag: Output the model prediction as a 4d volume.
        save_residuals_flag: Output the residuals (difference between the data\
            and the model prediction).
        save_model_extras_flag: Output any additional model-specific timeseries\
            data.
        save_mvn_flag: Output the final MVN distributions.
        save_mean_flag: Output the parameter means.
        save_std_flag: Output the parameter standard deviations.
        save_var_flag: Output the parameter variances.
        save_zstat_flag: Output the parameter Zstats.
        save_noise_mean_flag: Output the noise means. The noise distribution\
            inferred is the precision of a Gaussian noise source.
        save_noise_std_flag: Output the noise standard deviations.
        save_free_energy_flag: Output the free energy, if calculated.
        debug_flag: Output large amounts of debug information. ONLY USE WITH\
            VERY SMALL NUMBERS OF VOXELS.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/fabber_dualecho",
        "output_directory": output_directory,
        "method": method,
        "model": model,
        "data": data,
        "help_flag": help_flag,
        "list_methods_flag": list_methods_flag,
        "list_models_flag": list_models_flag,
        "list_params_flag": list_params_flag,
        "desc_params_flag": desc_params_flag,
        "list_outputs_flag": list_outputs_flag,
        "simple_output_flag": simple_output_flag,
        "overwrite_flag": overwrite_flag,
        "link_to_latest_flag": link_to_latest_flag,
        "dump_param_names_flag": dump_param_names_flag,
        "save_model_fit_flag": save_model_fit_flag,
        "save_residuals_flag": save_residuals_flag,
        "save_model_extras_flag": save_model_extras_flag,
        "save_mvn_flag": save_mvn_flag,
        "save_mean_flag": save_mean_flag,
        "save_std_flag": save_std_flag,
        "save_var_flag": save_var_flag,
        "save_zstat_flag": save_zstat_flag,
        "save_noise_mean_flag": save_noise_mean_flag,
        "save_noise_std_flag": save_noise_std_flag,
        "save_free_energy_flag": save_free_energy_flag,
        "debug_flag": debug_flag,
    }
    if data_order is not None:
        params["data_order"] = data_order
    if mask_file is not None:
        params["mask_file"] = mask_file
    if mt_list is not None:
        params["mt_list"] = mt_list
    if supp_data is not None:
        params["supp_data"] = supp_data
    if options_file is not None:
        params["options_file"] = options_file
    if evaluate is not None:
        params["evaluate"] = evaluate
    if evaluate_params is not None:
        params["evaluate_params"] = evaluate_params
    if evaluate_nt is not None:
        params["evaluate_nt"] = evaluate_nt
    if load_models is not None:
        params["load_models"] = load_models
    return params


def fabber_dualecho_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `FabberDualechoParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output_directory", None) is None:
        raise StyxValidationError("`output_directory` must not be None")
    if not isinstance(params["output_directory"], str):
        raise StyxValidationError(f'`output_directory` has the wrong type: Received `{type(params.get("output_directory", None))}` expected `str`')
    if params.get("method", None) is None:
        raise StyxValidationError("`method` must not be None")
    if not isinstance(params["method"], str):
        raise StyxValidationError(f'`method` has the wrong type: Received `{type(params.get("method", None))}` expected `str`')
    if params.get("model", None) is None:
        raise StyxValidationError("`model` must not be None")
    if not isinstance(params["model"], str):
        raise StyxValidationError(f'`model` has the wrong type: Received `{type(params.get("model", None))}` expected `str`')
    if params.get("data", None) is None:
        raise StyxValidationError("`data` must not be None")
    if not isinstance(params["data"], (pathlib.Path, str)):
        raise StyxValidationError(f'`data` has the wrong type: Received `{type(params.get("data", None))}` expected `InputPathType`')
    if params.get("data_order", None) is not None:
        if not isinstance(params["data_order"], str):
            raise StyxValidationError(f'`data_order` has the wrong type: Received `{type(params.get("data_order", None))}` expected `str | None`')
    if params.get("mask_file", None) is not None:
        if not isinstance(params["mask_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask_file` has the wrong type: Received `{type(params.get("mask_file", None))}` expected `InputPathType | None`')
    if params.get("mt_list", None) is not None:
        if not isinstance(params["mt_list"], (float, int)):
            raise StyxValidationError(f'`mt_list` has the wrong type: Received `{type(params.get("mt_list", None))}` expected `float | None`')
    if params.get("supp_data", None) is not None:
        if not isinstance(params["supp_data"], (pathlib.Path, str)):
            raise StyxValidationError(f'`supp_data` has the wrong type: Received `{type(params.get("supp_data", None))}` expected `InputPathType | None`')
    if params.get("options_file", None) is not None:
        if not isinstance(params["options_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`options_file` has the wrong type: Received `{type(params.get("options_file", None))}` expected `InputPathType | None`')
    if params.get("help_flag", False) is None:
        raise StyxValidationError("`help_flag` must not be None")
    if not isinstance(params["help_flag"], bool):
        raise StyxValidationError(f'`help_flag` has the wrong type: Received `{type(params.get("help_flag", False))}` expected `bool`')
    if params.get("list_methods_flag", False) is None:
        raise StyxValidationError("`list_methods_flag` must not be None")
    if not isinstance(params["list_methods_flag"], bool):
        raise StyxValidationError(f'`list_methods_flag` has the wrong type: Received `{type(params.get("list_methods_flag", False))}` expected `bool`')
    if params.get("list_models_flag", False) is None:
        raise StyxValidationError("`list_models_flag` must not be None")
    if not isinstance(params["list_models_flag"], bool):
        raise StyxValidationError(f'`list_models_flag` has the wrong type: Received `{type(params.get("list_models_flag", False))}` expected `bool`')
    if params.get("list_params_flag", False) is None:
        raise StyxValidationError("`list_params_flag` must not be None")
    if not isinstance(params["list_params_flag"], bool):
        raise StyxValidationError(f'`list_params_flag` has the wrong type: Received `{type(params.get("list_params_flag", False))}` expected `bool`')
    if params.get("desc_params_flag", False) is None:
        raise StyxValidationError("`desc_params_flag` must not be None")
    if not isinstance(params["desc_params_flag"], bool):
        raise StyxValidationError(f'`desc_params_flag` has the wrong type: Received `{type(params.get("desc_params_flag", False))}` expected `bool`')
    if params.get("list_outputs_flag", False) is None:
        raise StyxValidationError("`list_outputs_flag` must not be None")
    if not isinstance(params["list_outputs_flag"], bool):
        raise StyxValidationError(f'`list_outputs_flag` has the wrong type: Received `{type(params.get("list_outputs_flag", False))}` expected `bool`')
    if params.get("evaluate", None) is not None:
        if not isinstance(params["evaluate"], str):
            raise StyxValidationError(f'`evaluate` has the wrong type: Received `{type(params.get("evaluate", None))}` expected `str | None`')
    if params.get("evaluate_params", None) is not None:
        if not isinstance(params["evaluate_params"], str):
            raise StyxValidationError(f'`evaluate_params` has the wrong type: Received `{type(params.get("evaluate_params", None))}` expected `str | None`')
    if params.get("evaluate_nt", None) is not None:
        if not isinstance(params["evaluate_nt"], (float, int)):
            raise StyxValidationError(f'`evaluate_nt` has the wrong type: Received `{type(params.get("evaluate_nt", None))}` expected `float | None`')
    if params.get("simple_output_flag", False) is None:
        raise StyxValidationError("`simple_output_flag` must not be None")
    if not isinstance(params["simple_output_flag"], bool):
        raise StyxValidationError(f'`simple_output_flag` has the wrong type: Received `{type(params.get("simple_output_flag", False))}` expected `bool`')
    if params.get("overwrite_flag", False) is None:
        raise StyxValidationError("`overwrite_flag` must not be None")
    if not isinstance(params["overwrite_flag"], bool):
        raise StyxValidationError(f'`overwrite_flag` has the wrong type: Received `{type(params.get("overwrite_flag", False))}` expected `bool`')
    if params.get("link_to_latest_flag", False) is None:
        raise StyxValidationError("`link_to_latest_flag` must not be None")
    if not isinstance(params["link_to_latest_flag"], bool):
        raise StyxValidationError(f'`link_to_latest_flag` has the wrong type: Received `{type(params.get("link_to_latest_flag", False))}` expected `bool`')
    if params.get("load_models", None) is not None:
        if not isinstance(params["load_models"], (pathlib.Path, str)):
            raise StyxValidationError(f'`load_models` has the wrong type: Received `{type(params.get("load_models", None))}` expected `InputPathType | None`')
    if params.get("dump_param_names_flag", False) is None:
        raise StyxValidationError("`dump_param_names_flag` must not be None")
    if not isinstance(params["dump_param_names_flag"], bool):
        raise StyxValidationError(f'`dump_param_names_flag` has the wrong type: Received `{type(params.get("dump_param_names_flag", False))}` expected `bool`')
    if params.get("save_model_fit_flag", False) is None:
        raise StyxValidationError("`save_model_fit_flag` must not be None")
    if not isinstance(params["save_model_fit_flag"], bool):
        raise StyxValidationError(f'`save_model_fit_flag` has the wrong type: Received `{type(params.get("save_model_fit_flag", False))}` expected `bool`')
    if params.get("save_residuals_flag", False) is None:
        raise StyxValidationError("`save_residuals_flag` must not be None")
    if not isinstance(params["save_residuals_flag"], bool):
        raise StyxValidationError(f'`save_residuals_flag` has the wrong type: Received `{type(params.get("save_residuals_flag", False))}` expected `bool`')
    if params.get("save_model_extras_flag", False) is None:
        raise StyxValidationError("`save_model_extras_flag` must not be None")
    if not isinstance(params["save_model_extras_flag"], bool):
        raise StyxValidationError(f'`save_model_extras_flag` has the wrong type: Received `{type(params.get("save_model_extras_flag", False))}` expected `bool`')
    if params.get("save_mvn_flag", False) is None:
        raise StyxValidationError("`save_mvn_flag` must not be None")
    if not isinstance(params["save_mvn_flag"], bool):
        raise StyxValidationError(f'`save_mvn_flag` has the wrong type: Received `{type(params.get("save_mvn_flag", False))}` expected `bool`')
    if params.get("save_mean_flag", False) is None:
        raise StyxValidationError("`save_mean_flag` must not be None")
    if not isinstance(params["save_mean_flag"], bool):
        raise StyxValidationError(f'`save_mean_flag` has the wrong type: Received `{type(params.get("save_mean_flag", False))}` expected `bool`')
    if params.get("save_std_flag", False) is None:
        raise StyxValidationError("`save_std_flag` must not be None")
    if not isinstance(params["save_std_flag"], bool):
        raise StyxValidationError(f'`save_std_flag` has the wrong type: Received `{type(params.get("save_std_flag", False))}` expected `bool`')
    if params.get("save_var_flag", False) is None:
        raise StyxValidationError("`save_var_flag` must not be None")
    if not isinstance(params["save_var_flag"], bool):
        raise StyxValidationError(f'`save_var_flag` has the wrong type: Received `{type(params.get("save_var_flag", False))}` expected `bool`')
    if params.get("save_zstat_flag", False) is None:
        raise StyxValidationError("`save_zstat_flag` must not be None")
    if not isinstance(params["save_zstat_flag"], bool):
        raise StyxValidationError(f'`save_zstat_flag` has the wrong type: Received `{type(params.get("save_zstat_flag", False))}` expected `bool`')
    if params.get("save_noise_mean_flag", False) is None:
        raise StyxValidationError("`save_noise_mean_flag` must not be None")
    if not isinstance(params["save_noise_mean_flag"], bool):
        raise StyxValidationError(f'`save_noise_mean_flag` has the wrong type: Received `{type(params.get("save_noise_mean_flag", False))}` expected `bool`')
    if params.get("save_noise_std_flag", False) is None:
        raise StyxValidationError("`save_noise_std_flag` must not be None")
    if not isinstance(params["save_noise_std_flag"], bool):
        raise StyxValidationError(f'`save_noise_std_flag` has the wrong type: Received `{type(params.get("save_noise_std_flag", False))}` expected `bool`')
    if params.get("save_free_energy_flag", False) is None:
        raise StyxValidationError("`save_free_energy_flag` must not be None")
    if not isinstance(params["save_free_energy_flag"], bool):
        raise StyxValidationError(f'`save_free_energy_flag` has the wrong type: Received `{type(params.get("save_free_energy_flag", False))}` expected `bool`')
    if params.get("debug_flag", False) is None:
        raise StyxValidationError("`debug_flag` must not be None")
    if not isinstance(params["debug_flag"], bool):
        raise StyxValidationError(f'`debug_flag` has the wrong type: Received `{type(params.get("debug_flag", False))}` expected `bool`')


def fabber_dualecho_cargs(
    params: FabberDualechoParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("fabber_dualecho")
    cargs.append(params.get("output_directory", None))
    cargs.extend([
        "--method",
        params.get("method", None)
    ])
    cargs.extend([
        "--model",
        params.get("model", None)
    ])
    cargs.extend([
        "--data",
        execution.input_file(params.get("data", None))
    ])
    if params.get("data_order", None) is not None:
        cargs.extend([
            "--data-order",
            params.get("data_order", None)
        ])
    if params.get("mask_file", None) is not None:
        cargs.extend([
            "--mask",
            execution.input_file(params.get("mask_file", None))
        ])
    if params.get("mt_list", None) is not None:
        cargs.extend([
            "--mt<n>",
            str(params.get("mt_list", None))
        ])
    if params.get("supp_data", None) is not None:
        cargs.extend([
            "--suppdata",
            execution.input_file(params.get("supp_data", None))
        ])
    if params.get("options_file", None) is not None:
        cargs.extend([
            "--optfile",
            execution.input_file(params.get("options_file", None))
        ])
    if params.get("help_flag", False):
        cargs.append("--help")
    if params.get("list_methods_flag", False):
        cargs.append("--listmethods")
    if params.get("list_models_flag", False):
        cargs.append("--listmodels")
    if params.get("list_params_flag", False):
        cargs.append("--listparams")
    if params.get("desc_params_flag", False):
        cargs.append("--descparams")
    if params.get("list_outputs_flag", False):
        cargs.append("--listoutputs")
    if params.get("evaluate", None) is not None:
        cargs.extend([
            "--evaluate",
            params.get("evaluate", None)
        ])
    if params.get("evaluate_params", None) is not None:
        cargs.extend([
            "--evaluate-params",
            params.get("evaluate_params", None)
        ])
    if params.get("evaluate_nt", None) is not None:
        cargs.extend([
            "--evaluate-nt",
            str(params.get("evaluate_nt", None))
        ])
    if params.get("simple_output_flag", False):
        cargs.append("--simple-output")
    if params.get("overwrite_flag", False):
        cargs.append("--overwrite")
    if params.get("link_to_latest_flag", False):
        cargs.append("--link-to-latest")
    if params.get("load_models", None) is not None:
        cargs.extend([
            "--loadmodels",
            execution.input_file(params.get("load_models", None))
        ])
    if params.get("dump_param_names_flag", False):
        cargs.append("--dump-param-names")
    if params.get("save_model_fit_flag", False):
        cargs.append("--save-model-fit")
    if params.get("save_residuals_flag", False):
        cargs.append("--save-residuals")
    if params.get("save_model_extras_flag", False):
        cargs.append("--save-model-extras")
    if params.get("save_mvn_flag", False):
        cargs.append("--save-mvn")
    if params.get("save_mean_flag", False):
        cargs.append("--save-mean")
    if params.get("save_std_flag", False):
        cargs.append("--save-std")
    if params.get("save_var_flag", False):
        cargs.append("--save-var")
    if params.get("save_zstat_flag", False):
        cargs.append("--save-zstat")
    if params.get("save_noise_mean_flag", False):
        cargs.append("--save-noise-mean")
    if params.get("save_noise_std_flag", False):
        cargs.append("--save-noise-std")
    if params.get("save_free_energy_flag", False):
        cargs.append("--save-free-energy")
    if params.get("debug_flag", False):
        cargs.append("--debug")
    return cargs


def fabber_dualecho_outputs(
    params: FabberDualechoParamsDict,
    execution: Execution,
) -> FabberDualechoOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = FabberDualechoOutputs(
        root=execution.output_file("."),
        output_directory=execution.output_file(params.get("output_directory", None)),
    )
    return ret


def fabber_dualecho_execute(
    params: FabberDualechoParamsDict,
    runner: Runner | None = None,
) -> FabberDualechoOutputs:
    """
    fabber_dualecho
    
    FMRIB's Advanced Bayesian Estimation and Inference tool for FMRI analysis.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FabberDualechoOutputs`).
    """
    fabber_dualecho_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(FABBER_DUALECHO_METADATA)
    params = execution.params(params)
    cargs = fabber_dualecho_cargs(params, execution)
    ret = fabber_dualecho_outputs(params, execution)
    execution.run(cargs)
    return ret


def fabber_dualecho(
    output_directory: str,
    method: str,
    model: str,
    data: InputPathType,
    data_order: str | None = None,
    mask_file: InputPathType | None = None,
    mt_list: float | None = None,
    supp_data: InputPathType | None = None,
    options_file: InputPathType | None = None,
    help_flag: bool = False,
    list_methods_flag: bool = False,
    list_models_flag: bool = False,
    list_params_flag: bool = False,
    desc_params_flag: bool = False,
    list_outputs_flag: bool = False,
    evaluate: str | None = None,
    evaluate_params: str | None = None,
    evaluate_nt: float | None = None,
    simple_output_flag: bool = False,
    overwrite_flag: bool = False,
    link_to_latest_flag: bool = False,
    load_models: InputPathType | None = None,
    dump_param_names_flag: bool = False,
    save_model_fit_flag: bool = False,
    save_residuals_flag: bool = False,
    save_model_extras_flag: bool = False,
    save_mvn_flag: bool = False,
    save_mean_flag: bool = False,
    save_std_flag: bool = False,
    save_var_flag: bool = False,
    save_zstat_flag: bool = False,
    save_noise_mean_flag: bool = False,
    save_noise_std_flag: bool = False,
    save_free_energy_flag: bool = False,
    debug_flag: bool = False,
    runner: Runner | None = None,
) -> FabberDualechoOutputs:
    """
    fabber_dualecho
    
    FMRIB's Advanced Bayesian Estimation and Inference tool for FMRI analysis.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        output_directory: Directory for output files (including logfile).
        method: Use this inference method.
        model: Use this forward model.
        data: Specify a single input data file.
        data_order: If multiple data files are specified, how they will be\
            handled: concatenate = one after the other, interleave = first record\
            from each file, then second, etc.
        mask_file: Mask file. Inference will only be performed where mask value\
            > 0.
        mt_list: List of masked time points, indexed from 1. These will be\
            ignored in the parameter updates.
        supp_data: 'Supplemental' timeseries data, required for some models.
        options_file: File containing additional options, one per line, in the\
            same form as specified on the command line.
        help_flag: Print this usage method. If given with --method or --model,\
            display relevant method/model usage information.
        list_methods_flag: List all known inference methods.
        list_models_flag: List all known forward models.
        list_params_flag: List model parameters (requires model configuration\
            options to be given).
        desc_params_flag: Descript model parameters (name, description, units)\
            - requires model configuration options to be given. Note that not all\
            models provide parameter descriptions.
        list_outputs_flag: List additional model outputs (requires model\
            configuration options to be given).
        evaluate: Evaluate model. Set to name of output required or blank for\
            default output. Requires model configuration options, --evaluate-params\
            and --evaluate-nt.
        evaluate_params: List of parameter values for evaluation.
        evaluate_nt: Number of time points for evaluation - must be consistent\
            with model options where appropriate.
        simple_output_flag: Instead of usual standard output, simply output\
            series of lines each giving progress as percentage.
        overwrite_flag: If set will overwrite existing output. If not set, new\
            output directories will be created by appending '+' to the directory\
            name.
        link_to_latest_flag: Try to create a link to the most recent output\
            directory with the prefix _latest.
        load_models: Load models dynamically from the specified filename, which\
            should be a DLL/shared library.
        dump_param_names_flag: Write the file paramnames.txt containing the\
            names of the model parameters.
        save_model_fit_flag: Output the model prediction as a 4d volume.
        save_residuals_flag: Output the residuals (difference between the data\
            and the model prediction).
        save_model_extras_flag: Output any additional model-specific timeseries\
            data.
        save_mvn_flag: Output the final MVN distributions.
        save_mean_flag: Output the parameter means.
        save_std_flag: Output the parameter standard deviations.
        save_var_flag: Output the parameter variances.
        save_zstat_flag: Output the parameter Zstats.
        save_noise_mean_flag: Output the noise means. The noise distribution\
            inferred is the precision of a Gaussian noise source.
        save_noise_std_flag: Output the noise standard deviations.
        save_free_energy_flag: Output the free energy, if calculated.
        debug_flag: Output large amounts of debug information. ONLY USE WITH\
            VERY SMALL NUMBERS OF VOXELS.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FabberDualechoOutputs`).
    """
    params = fabber_dualecho_params(
        output_directory=output_directory,
        method=method,
        model=model,
        data=data,
        data_order=data_order,
        mask_file=mask_file,
        mt_list=mt_list,
        supp_data=supp_data,
        options_file=options_file,
        help_flag=help_flag,
        list_methods_flag=list_methods_flag,
        list_models_flag=list_models_flag,
        list_params_flag=list_params_flag,
        desc_params_flag=desc_params_flag,
        list_outputs_flag=list_outputs_flag,
        evaluate=evaluate,
        evaluate_params=evaluate_params,
        evaluate_nt=evaluate_nt,
        simple_output_flag=simple_output_flag,
        overwrite_flag=overwrite_flag,
        link_to_latest_flag=link_to_latest_flag,
        load_models=load_models,
        dump_param_names_flag=dump_param_names_flag,
        save_model_fit_flag=save_model_fit_flag,
        save_residuals_flag=save_residuals_flag,
        save_model_extras_flag=save_model_extras_flag,
        save_mvn_flag=save_mvn_flag,
        save_mean_flag=save_mean_flag,
        save_std_flag=save_std_flag,
        save_var_flag=save_var_flag,
        save_zstat_flag=save_zstat_flag,
        save_noise_mean_flag=save_noise_mean_flag,
        save_noise_std_flag=save_noise_std_flag,
        save_free_energy_flag=save_free_energy_flag,
        debug_flag=debug_flag,
    )
    return fabber_dualecho_execute(params, runner)


__all__ = [
    "FABBER_DUALECHO_METADATA",
    "FabberDualechoOutputs",
    "FabberDualechoParamsDict",
    "FabberDualechoParamsDictTagged",
    "fabber_dualecho",
    "fabber_dualecho_execute",
    "fabber_dualecho_params",
]
