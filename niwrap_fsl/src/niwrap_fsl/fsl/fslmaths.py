# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

FSLMATHS_METADATA = Metadata(
    id="c312ba1b97ad7f4433f8466f287cefb9d488d3d4.boutiques",
    name="fslmaths",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_FslmathsOperationParamsDictNoTag = typing.TypedDict('_FslmathsOperationParamsDictNoTag', {
    "add": typing.NotRequired[float | None],
    "sub": typing.NotRequired[float | None],
    "mul": typing.NotRequired[float | None],
    "div": typing.NotRequired[float | None],
    "rem": typing.NotRequired[float | None],
    "mas": typing.NotRequired[InputPathType | None],
    "thr": typing.NotRequired[float | None],
    "thrp": typing.NotRequired[float | None],
    "thrP": typing.NotRequired[float | None],
    "uthr": typing.NotRequired[float | None],
    "uthrp": typing.NotRequired[float | None],
    "uthrP": typing.NotRequired[float | None],
    "max": typing.NotRequired[float | None],
    "min": typing.NotRequired[float | None],
    "seed": typing.NotRequired[float | None],
    "restart": typing.NotRequired[InputPathType | None],
    "save": bool,
    "exp": bool,
    "log": bool,
    "sin": bool,
    "cos": bool,
    "tan": bool,
    "asin": bool,
    "acos": bool,
    "atan": bool,
    "sqr": bool,
    "sqrt": bool,
    "recip": bool,
    "abs": bool,
    "bin": bool,
    "binv": bool,
    "fillh": bool,
    "fillh26": bool,
    "index": bool,
    "grid": typing.NotRequired[list[float] | None],
    "edge": bool,
    "tfce": typing.NotRequired[list[float] | None],
    "tfceS": typing.NotRequired[list[float] | None],
    "nan": bool,
    "nanm": bool,
    "rand": bool,
    "randn": bool,
    "inm": typing.NotRequired[float | None],
    "ing": typing.NotRequired[float | None],
    "range": bool,
    "tensor_decomp": bool,
    "kernel_3D": bool,
    "kernel_2D": bool,
    "kernel_box": typing.NotRequired[float | None],
    "kernel_boxv": typing.NotRequired[float | None],
    "kernel_boxv3": typing.NotRequired[list[float] | None],
    "kernel_gauss": typing.NotRequired[float | None],
    "kernel_sphere": typing.NotRequired[float | None],
    "kernel_file": typing.NotRequired[InputPathType | None],
    "dilM": bool,
    "dilD": bool,
    "dilF": bool,
    "dilall": bool,
    "ero": bool,
    "eroF": bool,
    "fmedian": bool,
    "fmean": bool,
    "fmeanu": bool,
    "s": typing.NotRequired[float | None],
    "subsamp2": bool,
    "subsamp2offc": bool,
    "Tmean": bool,
    "Xmean": bool,
    "Ymean": bool,
    "Zmean": bool,
    "Tstd": bool,
    "Xstd": bool,
    "Ystd": bool,
    "Zstd": bool,
    "Tmax": bool,
    "Xmax": bool,
    "Ymax": bool,
    "Zmax": bool,
    "Tmaxn": bool,
    "Xmaxn": bool,
    "Ymaxn": bool,
    "Zmaxn": bool,
    "Tmin": bool,
    "Xmin": bool,
    "Ymin": bool,
    "Zmin": bool,
    "Tmedian": bool,
    "Xmedian": bool,
    "Ymedian": bool,
    "Zmedian": bool,
    "Tperc": typing.NotRequired[float | None],
    "Xperc": typing.NotRequired[float | None],
    "Yperc": typing.NotRequired[float | None],
    "Zperc": typing.NotRequired[float | None],
    "Tar1": bool,
    "roi": typing.NotRequired[list[float] | None],
    "bptf": typing.NotRequired[list[float] | None],
    "roc": typing.NotRequired[list[float] | None],
})
FslmathsOperationParamsDictTagged = typing.TypedDict('FslmathsOperationParamsDictTagged', {
    "@type": typing.Literal["operation"],
    "add": typing.NotRequired[float | None],
    "sub": typing.NotRequired[float | None],
    "mul": typing.NotRequired[float | None],
    "div": typing.NotRequired[float | None],
    "rem": typing.NotRequired[float | None],
    "mas": typing.NotRequired[InputPathType | None],
    "thr": typing.NotRequired[float | None],
    "thrp": typing.NotRequired[float | None],
    "thrP": typing.NotRequired[float | None],
    "uthr": typing.NotRequired[float | None],
    "uthrp": typing.NotRequired[float | None],
    "uthrP": typing.NotRequired[float | None],
    "max": typing.NotRequired[float | None],
    "min": typing.NotRequired[float | None],
    "seed": typing.NotRequired[float | None],
    "restart": typing.NotRequired[InputPathType | None],
    "save": bool,
    "exp": bool,
    "log": bool,
    "sin": bool,
    "cos": bool,
    "tan": bool,
    "asin": bool,
    "acos": bool,
    "atan": bool,
    "sqr": bool,
    "sqrt": bool,
    "recip": bool,
    "abs": bool,
    "bin": bool,
    "binv": bool,
    "fillh": bool,
    "fillh26": bool,
    "index": bool,
    "grid": typing.NotRequired[list[float] | None],
    "edge": bool,
    "tfce": typing.NotRequired[list[float] | None],
    "tfceS": typing.NotRequired[list[float] | None],
    "nan": bool,
    "nanm": bool,
    "rand": bool,
    "randn": bool,
    "inm": typing.NotRequired[float | None],
    "ing": typing.NotRequired[float | None],
    "range": bool,
    "tensor_decomp": bool,
    "kernel_3D": bool,
    "kernel_2D": bool,
    "kernel_box": typing.NotRequired[float | None],
    "kernel_boxv": typing.NotRequired[float | None],
    "kernel_boxv3": typing.NotRequired[list[float] | None],
    "kernel_gauss": typing.NotRequired[float | None],
    "kernel_sphere": typing.NotRequired[float | None],
    "kernel_file": typing.NotRequired[InputPathType | None],
    "dilM": bool,
    "dilD": bool,
    "dilF": bool,
    "dilall": bool,
    "ero": bool,
    "eroF": bool,
    "fmedian": bool,
    "fmean": bool,
    "fmeanu": bool,
    "s": typing.NotRequired[float | None],
    "subsamp2": bool,
    "subsamp2offc": bool,
    "Tmean": bool,
    "Xmean": bool,
    "Ymean": bool,
    "Zmean": bool,
    "Tstd": bool,
    "Xstd": bool,
    "Ystd": bool,
    "Zstd": bool,
    "Tmax": bool,
    "Xmax": bool,
    "Ymax": bool,
    "Zmax": bool,
    "Tmaxn": bool,
    "Xmaxn": bool,
    "Ymaxn": bool,
    "Zmaxn": bool,
    "Tmin": bool,
    "Xmin": bool,
    "Ymin": bool,
    "Zmin": bool,
    "Tmedian": bool,
    "Xmedian": bool,
    "Ymedian": bool,
    "Zmedian": bool,
    "Tperc": typing.NotRequired[float | None],
    "Xperc": typing.NotRequired[float | None],
    "Yperc": typing.NotRequired[float | None],
    "Zperc": typing.NotRequired[float | None],
    "Tar1": bool,
    "roi": typing.NotRequired[list[float] | None],
    "bptf": typing.NotRequired[list[float] | None],
    "roc": typing.NotRequired[list[float] | None],
})
FslmathsOperationParamsDict = _FslmathsOperationParamsDictNoTag | FslmathsOperationParamsDictTagged


_FslmathsParamsDictNoTag = typing.TypedDict('_FslmathsParamsDictNoTag', {
    "datatype_internal": typing.NotRequired[typing.Literal["char", "short", "int", "float", "double", "input"] | None],
    "input_files": list[InputPathType],
    "operations": list[FslmathsOperationParamsDict],
    "output": str,
    "output_datatype": typing.NotRequired[typing.Literal["char", "short", "int", "float", "double", "input"] | None],
})
FslmathsParamsDictTagged = typing.TypedDict('FslmathsParamsDictTagged', {
    "@type": typing.Literal["fsl/fslmaths"],
    "datatype_internal": typing.NotRequired[typing.Literal["char", "short", "int", "float", "double", "input"] | None],
    "input_files": list[InputPathType],
    "operations": list[FslmathsOperationParamsDict],
    "output": str,
    "output_datatype": typing.NotRequired[typing.Literal["char", "short", "int", "float", "double", "input"] | None],
})
FslmathsParamsDict = _FslmathsParamsDictNoTag | FslmathsParamsDictTagged


def fslmaths_operation(
    add: float | None = None,
    sub: float | None = None,
    mul: float | None = None,
    div: float | None = None,
    rem: float | None = None,
    mas: InputPathType | None = None,
    thr: float | None = None,
    thrp: float | None = None,
    thr_p: float | None = None,
    uthr: float | None = None,
    uthrp: float | None = None,
    uthr_p: float | None = None,
    max_: float | None = None,
    min_: float | None = None,
    seed: float | None = None,
    restart: InputPathType | None = None,
    save: bool = False,
    exp: bool = False,
    log: bool = False,
    sin: bool = False,
    cos: bool = False,
    tan: bool = False,
    asin: bool = False,
    acos: bool = False,
    atan: bool = False,
    sqr: bool = False,
    sqrt: bool = False,
    recip: bool = False,
    abs_: bool = False,
    bin_: bool = False,
    binv: bool = False,
    fillh: bool = False,
    fillh26: bool = False,
    index: bool = False,
    grid: list[float] | None = None,
    edge: bool = False,
    tfce: list[float] | None = None,
    tfce_s: list[float] | None = None,
    nan: bool = False,
    nanm: bool = False,
    rand: bool = False,
    randn: bool = False,
    inm: float | None = None,
    ing: float | None = None,
    range_: bool = False,
    tensor_decomp: bool = False,
    kernel_3_d: bool = False,
    kernel_2_d: bool = False,
    kernel_box: float | None = None,
    kernel_boxv: float | None = None,
    kernel_boxv3: list[float] | None = None,
    kernel_gauss: float | None = None,
    kernel_sphere: float | None = None,
    kernel_file: InputPathType | None = None,
    dil_m: bool = False,
    dil_d: bool = False,
    dil_f: bool = False,
    dilall: bool = False,
    ero: bool = False,
    ero_f: bool = False,
    fmedian: bool = False,
    fmean: bool = False,
    fmeanu: bool = False,
    s: float | None = None,
    subsamp2: bool = False,
    subsamp2offc: bool = False,
    tmean: bool = False,
    xmean: bool = False,
    ymean: bool = False,
    zmean: bool = False,
    tstd: bool = False,
    xstd: bool = False,
    ystd: bool = False,
    zstd: bool = False,
    tmax: bool = False,
    xmax: bool = False,
    ymax: bool = False,
    zmax: bool = False,
    tmaxn: bool = False,
    xmaxn: bool = False,
    ymaxn: bool = False,
    zmaxn: bool = False,
    tmin: bool = False,
    xmin: bool = False,
    ymin: bool = False,
    zmin: bool = False,
    tmedian: bool = False,
    xmedian: bool = False,
    ymedian: bool = False,
    zmedian: bool = False,
    tperc: float | None = None,
    xperc: float | None = None,
    yperc: float | None = None,
    zperc: float | None = None,
    tar1: bool = False,
    roi: list[float] | None = None,
    bptf: list[float] | None = None,
    roc: list[float] | None = None,
) -> FslmathsOperationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        add: Add following input to current image.
        sub: Subtract following input from current image.
        mul: Multiply current image by following input.
        div: Divide current image by following input.
        rem: Modulus remainder - divide current image by following input and\
            take remainder.
        mas: Use (following image>0) to mask current image.
        thr: Use following number to threshold current image (zero anything\
            below the number).
        thrp: Use following percentage (0-100) of ROBUST RANGE to threshold\
            current image (zero anything below the number).
        thr_p: Use following percentage (0-100) of ROBUST RANGE of non-zero\
            voxels and threshold below.
        uthr: Use following number to upper-threshold current image (zero\
            anything above the number).
        uthrp: Use following percentage (0-100) of ROBUST RANGE to\
            upper-threshold current image (zero anything above the number).
        uthr_p: Use following percentage (0-100) of ROBUST RANGE of non-zero\
            voxels and threshold above.
        max_: Take maximum of following input and current image.
        min_: Take minimum of following input and current image.
        seed: Seed random number generator with following number.
        restart: Replace the current image with input for future processing\
            operations.
        save: Save the current working image to the input filename.
        exp: Exponential.
        log: Natural logarithm.
        sin: Sine function.
        cos: Cosine function.
        tan: Tangent function.
        asin: Arc sine function.
        acos: Arc cosine function.
        atan: Arc tangent function.
        sqr: Square.
        sqrt: Square root.
        recip: Reciprocal (1/current image).
        abs_: Absolute value.
        bin_: Use (current image>0) to binarise.
        binv: Binarise and invert (binarisation and logical inversion).
        fillh: Fill holes in a binary mask (holes are internal - i.e. do not\
            touch the edge of the FOV).
        fillh26: Fill holes using 26 connectivity.
        index: Replace each nonzero voxel with a unique (subject to wrapping)\
            index number.
        grid: Add a 3D grid of intensity <value> with grid spacing <spacing>.
        edge: Edge strength.
        tfce: Enhance with TFCE, e.g. -tfce 2 0.5 6 (maybe change 6 to 26 for\
            skeletons).
        tfce_s: Show support area for voxel (X,Y,Z).
        nan: Replace NaNs (improper numbers) with 0.
        nanm: Make NaN (improper number) mask with 1 for NaN voxels, 0\
            otherwise.
        rand: Add uniform noise (range 0:1).
        randn: Add Gaussian noise (mean=0 sigma=1).
        inm: Intensity normalisation (per 3D volume mean).
        ing: Intensity normalisation, global 4D mean.
        range_: Set the output calmin/max to full data range.
        tensor_decomp: Convert a 4D (6-timepoint) tensor image into\
            L1,2,3,FA,MD,MO,V1,2,3 (remaining image in pipeline is FA).
        kernel_3_d: 3x3x3 box centered on target voxel (set as default kernel).
        kernel_2_d: 3x3x1 box centered on target voxel.
        kernel_box: All voxels in a cube of width <size> mm centered on target\
            voxel.
        kernel_boxv: All voxels in a cube of width <size> voxels centered on\
            target voxel.
        kernel_boxv3: All voxels in a cuboid of dimensions X x Y x Z centered\
            on target voxel.
        kernel_gauss: Gaussian kernel (sigma in mm, not voxels).
        kernel_sphere: All voxels in a sphere of radius <size> mm centered on\
            target voxel.
        kernel_file: Use external file as kernel.
        dil_m: Mean Dilation of non-zero voxels.
        dil_d: Modal Dilation of non-zero voxels.
        dil_f: Maximum filtering of all voxels.
        dilall: Apply -dilM repeatedly until the entire FOV is covered.
        ero: Erode by zeroing non-zero voxels when zero voxels found in kernel.
        ero_f: Minimum filtering of all voxels.
        fmedian: Median Filtering.
        fmean: Mean filtering, kernel weighted (conventionally used with gauss\
            kernel).
        fmeanu: Mean filtering, kernel weighted, un-normalised (gives edge\
            effects).
        s: Create a gauss kernel of sigma mm and perform mean filtering.
        subsamp2: Downsamples image by a factor of 2 (keeping new voxels\
            centred on old).
        subsamp2offc: Downsamples image by a factor of 2 (non-centred).
        tmean: Mean across time.
        xmean: Mean across X axis.
        ymean: Mean across Y axis.
        zmean: Mean across Z axis.
        tstd: Standard deviation across time.
        xstd: Standard deviation across X axis.
        ystd: Standard deviation across Y axis.
        zstd: Standard deviation across Z axis.
        tmax: Max across time.
        xmax: Max across X axis.
        ymax: Max across Y axis.
        zmax: Max across Z axis.
        tmaxn: Time index of max across time.
        xmaxn: X index of max across X axis.
        ymaxn: Y index of max across Y axis.
        zmaxn: Z index of max across Z axis.
        tmin: Min across time.
        xmin: Min across X axis.
        ymin: Min across Y axis.
        zmin: Min across Z axis.
        tmedian: Median across time.
        xmedian: Median across X axis.
        ymedian: Median across Y axis.
        zmedian: Median across Z axis.
        tperc: Nth percentile (0-100) of FULL RANGE across time.
        xperc: Nth percentile (0-100) of FULL RANGE across X axis.
        yperc: Nth percentile (0-100) of FULL RANGE across Y axis.
        zperc: Nth percentile (0-100) of FULL RANGE across Z axis.
        tar1: Temporal AR(1) coefficient (use -odt float and probably demean\
            first).
        roi: <xmin> <xsize> <ymin> <ysize> <zmin> <zsize> <tmin> <tsize>. Zero\
            outside roi (using voxel coordinates). Inputting -1 for a size will set\
            it to the full image extent for that dimension.
        bptf: <lowpass> <highpass>. Bandpass temporal filtering (use -odt float\
            and probably demean first).
        roc: <threshold> <output>. ROC analysis.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "operation",
        "save": save,
        "exp": exp,
        "log": log,
        "sin": sin,
        "cos": cos,
        "tan": tan,
        "asin": asin,
        "acos": acos,
        "atan": atan,
        "sqr": sqr,
        "sqrt": sqrt,
        "recip": recip,
        "abs": abs_,
        "bin": bin_,
        "binv": binv,
        "fillh": fillh,
        "fillh26": fillh26,
        "index": index,
        "edge": edge,
        "nan": nan,
        "nanm": nanm,
        "rand": rand,
        "randn": randn,
        "range": range_,
        "tensor_decomp": tensor_decomp,
        "kernel_3D": kernel_3_d,
        "kernel_2D": kernel_2_d,
        "dilM": dil_m,
        "dilD": dil_d,
        "dilF": dil_f,
        "dilall": dilall,
        "ero": ero,
        "eroF": ero_f,
        "fmedian": fmedian,
        "fmean": fmean,
        "fmeanu": fmeanu,
        "subsamp2": subsamp2,
        "subsamp2offc": subsamp2offc,
        "Tmean": tmean,
        "Xmean": xmean,
        "Ymean": ymean,
        "Zmean": zmean,
        "Tstd": tstd,
        "Xstd": xstd,
        "Ystd": ystd,
        "Zstd": zstd,
        "Tmax": tmax,
        "Xmax": xmax,
        "Ymax": ymax,
        "Zmax": zmax,
        "Tmaxn": tmaxn,
        "Xmaxn": xmaxn,
        "Ymaxn": ymaxn,
        "Zmaxn": zmaxn,
        "Tmin": tmin,
        "Xmin": xmin,
        "Ymin": ymin,
        "Zmin": zmin,
        "Tmedian": tmedian,
        "Xmedian": xmedian,
        "Ymedian": ymedian,
        "Zmedian": zmedian,
        "Tar1": tar1,
    }
    if add is not None:
        params["add"] = add
    if sub is not None:
        params["sub"] = sub
    if mul is not None:
        params["mul"] = mul
    if div is not None:
        params["div"] = div
    if rem is not None:
        params["rem"] = rem
    if mas is not None:
        params["mas"] = mas
    if thr is not None:
        params["thr"] = thr
    if thrp is not None:
        params["thrp"] = thrp
    if thr_p is not None:
        params["thrP"] = thr_p
    if uthr is not None:
        params["uthr"] = uthr
    if uthrp is not None:
        params["uthrp"] = uthrp
    if uthr_p is not None:
        params["uthrP"] = uthr_p
    if max_ is not None:
        params["max"] = max_
    if min_ is not None:
        params["min"] = min_
    if seed is not None:
        params["seed"] = seed
    if restart is not None:
        params["restart"] = restart
    if grid is not None:
        params["grid"] = grid
    if tfce is not None:
        params["tfce"] = tfce
    if tfce_s is not None:
        params["tfceS"] = tfce_s
    if inm is not None:
        params["inm"] = inm
    if ing is not None:
        params["ing"] = ing
    if kernel_box is not None:
        params["kernel_box"] = kernel_box
    if kernel_boxv is not None:
        params["kernel_boxv"] = kernel_boxv
    if kernel_boxv3 is not None:
        params["kernel_boxv3"] = kernel_boxv3
    if kernel_gauss is not None:
        params["kernel_gauss"] = kernel_gauss
    if kernel_sphere is not None:
        params["kernel_sphere"] = kernel_sphere
    if kernel_file is not None:
        params["kernel_file"] = kernel_file
    if s is not None:
        params["s"] = s
    if tperc is not None:
        params["Tperc"] = tperc
    if xperc is not None:
        params["Xperc"] = xperc
    if yperc is not None:
        params["Yperc"] = yperc
    if zperc is not None:
        params["Zperc"] = zperc
    if roi is not None:
        params["roi"] = roi
    if bptf is not None:
        params["bptf"] = bptf
    if roc is not None:
        params["roc"] = roc
    return params


def fslmaths_operation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `FslmathsOperationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("add", None) is not None:
        if not isinstance(params["add"], (float, int)):
            raise StyxValidationError(f'`add` has the wrong type: Received `{type(params.get("add", None))}` expected `float | None`')
    if params.get("sub", None) is not None:
        if not isinstance(params["sub"], (float, int)):
            raise StyxValidationError(f'`sub` has the wrong type: Received `{type(params.get("sub", None))}` expected `float | None`')
    if params.get("mul", None) is not None:
        if not isinstance(params["mul"], (float, int)):
            raise StyxValidationError(f'`mul` has the wrong type: Received `{type(params.get("mul", None))}` expected `float | None`')
    if params.get("div", None) is not None:
        if not isinstance(params["div"], (float, int)):
            raise StyxValidationError(f'`div` has the wrong type: Received `{type(params.get("div", None))}` expected `float | None`')
    if params.get("rem", None) is not None:
        if not isinstance(params["rem"], (float, int)):
            raise StyxValidationError(f'`rem` has the wrong type: Received `{type(params.get("rem", None))}` expected `float | None`')
    if params.get("mas", None) is not None:
        if not isinstance(params["mas"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mas` has the wrong type: Received `{type(params.get("mas", None))}` expected `InputPathType | None`')
    if params.get("thr", None) is not None:
        if not isinstance(params["thr"], (float, int)):
            raise StyxValidationError(f'`thr` has the wrong type: Received `{type(params.get("thr", None))}` expected `float | None`')
    if params.get("thrp", None) is not None:
        if not isinstance(params["thrp"], (float, int)):
            raise StyxValidationError(f'`thrp` has the wrong type: Received `{type(params.get("thrp", None))}` expected `float | None`')
        if not (0 <= params["thrp"] <= 100):
            raise StyxValidationError("Parameter `thrp` must be between 0 and 100 (inclusive)")
    if params.get("thrP", None) is not None:
        if not isinstance(params["thrP"], (float, int)):
            raise StyxValidationError(f'`thrP` has the wrong type: Received `{type(params.get("thrP", None))}` expected `float | None`')
        if not (0 <= params["thrP"] <= 100):
            raise StyxValidationError("Parameter `thrP` must be between 0 and 100 (inclusive)")
    if params.get("uthr", None) is not None:
        if not isinstance(params["uthr"], (float, int)):
            raise StyxValidationError(f'`uthr` has the wrong type: Received `{type(params.get("uthr", None))}` expected `float | None`')
    if params.get("uthrp", None) is not None:
        if not isinstance(params["uthrp"], (float, int)):
            raise StyxValidationError(f'`uthrp` has the wrong type: Received `{type(params.get("uthrp", None))}` expected `float | None`')
        if not (0 <= params["uthrp"] <= 100):
            raise StyxValidationError("Parameter `uthrp` must be between 0 and 100 (inclusive)")
    if params.get("uthrP", None) is not None:
        if not isinstance(params["uthrP"], (float, int)):
            raise StyxValidationError(f'`uthrP` has the wrong type: Received `{type(params.get("uthrP", None))}` expected `float | None`')
        if not (0 <= params["uthrP"] <= 100):
            raise StyxValidationError("Parameter `uthrP` must be between 0 and 100 (inclusive)")
    if params.get("max", None) is not None:
        if not isinstance(params["max"], (float, int)):
            raise StyxValidationError(f'`max` has the wrong type: Received `{type(params.get("max", None))}` expected `float | None`')
    if params.get("min", None) is not None:
        if not isinstance(params["min"], (float, int)):
            raise StyxValidationError(f'`min` has the wrong type: Received `{type(params.get("min", None))}` expected `float | None`')
    if params.get("seed", None) is not None:
        if not isinstance(params["seed"], (float, int)):
            raise StyxValidationError(f'`seed` has the wrong type: Received `{type(params.get("seed", None))}` expected `float | None`')
    if params.get("restart", None) is not None:
        if not isinstance(params["restart"], (pathlib.Path, str)):
            raise StyxValidationError(f'`restart` has the wrong type: Received `{type(params.get("restart", None))}` expected `InputPathType | None`')
    if params.get("save", False) is None:
        raise StyxValidationError("`save` must not be None")
    if not isinstance(params["save"], bool):
        raise StyxValidationError(f'`save` has the wrong type: Received `{type(params.get("save", False))}` expected `bool`')
    if params.get("exp", False) is None:
        raise StyxValidationError("`exp` must not be None")
    if not isinstance(params["exp"], bool):
        raise StyxValidationError(f'`exp` has the wrong type: Received `{type(params.get("exp", False))}` expected `bool`')
    if params.get("log", False) is None:
        raise StyxValidationError("`log` must not be None")
    if not isinstance(params["log"], bool):
        raise StyxValidationError(f'`log` has the wrong type: Received `{type(params.get("log", False))}` expected `bool`')
    if params.get("sin", False) is None:
        raise StyxValidationError("`sin` must not be None")
    if not isinstance(params["sin"], bool):
        raise StyxValidationError(f'`sin` has the wrong type: Received `{type(params.get("sin", False))}` expected `bool`')
    if params.get("cos", False) is None:
        raise StyxValidationError("`cos` must not be None")
    if not isinstance(params["cos"], bool):
        raise StyxValidationError(f'`cos` has the wrong type: Received `{type(params.get("cos", False))}` expected `bool`')
    if params.get("tan", False) is None:
        raise StyxValidationError("`tan` must not be None")
    if not isinstance(params["tan"], bool):
        raise StyxValidationError(f'`tan` has the wrong type: Received `{type(params.get("tan", False))}` expected `bool`')
    if params.get("asin", False) is None:
        raise StyxValidationError("`asin` must not be None")
    if not isinstance(params["asin"], bool):
        raise StyxValidationError(f'`asin` has the wrong type: Received `{type(params.get("asin", False))}` expected `bool`')
    if params.get("acos", False) is None:
        raise StyxValidationError("`acos` must not be None")
    if not isinstance(params["acos"], bool):
        raise StyxValidationError(f'`acos` has the wrong type: Received `{type(params.get("acos", False))}` expected `bool`')
    if params.get("atan", False) is None:
        raise StyxValidationError("`atan` must not be None")
    if not isinstance(params["atan"], bool):
        raise StyxValidationError(f'`atan` has the wrong type: Received `{type(params.get("atan", False))}` expected `bool`')
    if params.get("sqr", False) is None:
        raise StyxValidationError("`sqr` must not be None")
    if not isinstance(params["sqr"], bool):
        raise StyxValidationError(f'`sqr` has the wrong type: Received `{type(params.get("sqr", False))}` expected `bool`')
    if params.get("sqrt", False) is None:
        raise StyxValidationError("`sqrt` must not be None")
    if not isinstance(params["sqrt"], bool):
        raise StyxValidationError(f'`sqrt` has the wrong type: Received `{type(params.get("sqrt", False))}` expected `bool`')
    if params.get("recip", False) is None:
        raise StyxValidationError("`recip` must not be None")
    if not isinstance(params["recip"], bool):
        raise StyxValidationError(f'`recip` has the wrong type: Received `{type(params.get("recip", False))}` expected `bool`')
    if params.get("abs", False) is None:
        raise StyxValidationError("`abs` must not be None")
    if not isinstance(params["abs"], bool):
        raise StyxValidationError(f'`abs` has the wrong type: Received `{type(params.get("abs", False))}` expected `bool`')
    if params.get("bin", False) is None:
        raise StyxValidationError("`bin` must not be None")
    if not isinstance(params["bin"], bool):
        raise StyxValidationError(f'`bin` has the wrong type: Received `{type(params.get("bin", False))}` expected `bool`')
    if params.get("binv", False) is None:
        raise StyxValidationError("`binv` must not be None")
    if not isinstance(params["binv"], bool):
        raise StyxValidationError(f'`binv` has the wrong type: Received `{type(params.get("binv", False))}` expected `bool`')
    if params.get("fillh", False) is None:
        raise StyxValidationError("`fillh` must not be None")
    if not isinstance(params["fillh"], bool):
        raise StyxValidationError(f'`fillh` has the wrong type: Received `{type(params.get("fillh", False))}` expected `bool`')
    if params.get("fillh26", False) is None:
        raise StyxValidationError("`fillh26` must not be None")
    if not isinstance(params["fillh26"], bool):
        raise StyxValidationError(f'`fillh26` has the wrong type: Received `{type(params.get("fillh26", False))}` expected `bool`')
    if params.get("index", False) is None:
        raise StyxValidationError("`index` must not be None")
    if not isinstance(params["index"], bool):
        raise StyxValidationError(f'`index` has the wrong type: Received `{type(params.get("index", False))}` expected `bool`')
    if params.get("grid", None) is not None:
        if not isinstance(params["grid"], list):
            raise StyxValidationError(f'`grid` has the wrong type: Received `{type(params.get("grid", None))}` expected `list[float] | None`')
        for e in params["grid"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`grid` has the wrong type: Received `{type(params.get("grid", None))}` expected `list[float] | None`')
    if params.get("edge", False) is None:
        raise StyxValidationError("`edge` must not be None")
    if not isinstance(params["edge"], bool):
        raise StyxValidationError(f'`edge` has the wrong type: Received `{type(params.get("edge", False))}` expected `bool`')
    if params.get("tfce", None) is not None:
        if not isinstance(params["tfce"], list):
            raise StyxValidationError(f'`tfce` has the wrong type: Received `{type(params.get("tfce", None))}` expected `list[float] | None`')
        for e in params["tfce"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`tfce` has the wrong type: Received `{type(params.get("tfce", None))}` expected `list[float] | None`')
    if params.get("tfceS", None) is not None:
        if not isinstance(params["tfceS"], list):
            raise StyxValidationError(f'`tfceS` has the wrong type: Received `{type(params.get("tfceS", None))}` expected `list[float] | None`')
        for e in params["tfceS"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`tfceS` has the wrong type: Received `{type(params.get("tfceS", None))}` expected `list[float] | None`')
    if params.get("nan", False) is None:
        raise StyxValidationError("`nan` must not be None")
    if not isinstance(params["nan"], bool):
        raise StyxValidationError(f'`nan` has the wrong type: Received `{type(params.get("nan", False))}` expected `bool`')
    if params.get("nanm", False) is None:
        raise StyxValidationError("`nanm` must not be None")
    if not isinstance(params["nanm"], bool):
        raise StyxValidationError(f'`nanm` has the wrong type: Received `{type(params.get("nanm", False))}` expected `bool`')
    if params.get("rand", False) is None:
        raise StyxValidationError("`rand` must not be None")
    if not isinstance(params["rand"], bool):
        raise StyxValidationError(f'`rand` has the wrong type: Received `{type(params.get("rand", False))}` expected `bool`')
    if params.get("randn", False) is None:
        raise StyxValidationError("`randn` must not be None")
    if not isinstance(params["randn"], bool):
        raise StyxValidationError(f'`randn` has the wrong type: Received `{type(params.get("randn", False))}` expected `bool`')
    if params.get("inm", None) is not None:
        if not isinstance(params["inm"], (float, int)):
            raise StyxValidationError(f'`inm` has the wrong type: Received `{type(params.get("inm", None))}` expected `float | None`')
    if params.get("ing", None) is not None:
        if not isinstance(params["ing"], (float, int)):
            raise StyxValidationError(f'`ing` has the wrong type: Received `{type(params.get("ing", None))}` expected `float | None`')
    if params.get("range", False) is None:
        raise StyxValidationError("`range` must not be None")
    if not isinstance(params["range"], bool):
        raise StyxValidationError(f'`range` has the wrong type: Received `{type(params.get("range", False))}` expected `bool`')
    if params.get("tensor_decomp", False) is None:
        raise StyxValidationError("`tensor_decomp` must not be None")
    if not isinstance(params["tensor_decomp"], bool):
        raise StyxValidationError(f'`tensor_decomp` has the wrong type: Received `{type(params.get("tensor_decomp", False))}` expected `bool`')
    if params.get("kernel_3D", False) is None:
        raise StyxValidationError("`kernel_3D` must not be None")
    if not isinstance(params["kernel_3D"], bool):
        raise StyxValidationError(f'`kernel_3D` has the wrong type: Received `{type(params.get("kernel_3D", False))}` expected `bool`')
    if params.get("kernel_2D", False) is None:
        raise StyxValidationError("`kernel_2D` must not be None")
    if not isinstance(params["kernel_2D"], bool):
        raise StyxValidationError(f'`kernel_2D` has the wrong type: Received `{type(params.get("kernel_2D", False))}` expected `bool`')
    if params.get("kernel_box", None) is not None:
        if not isinstance(params["kernel_box"], (float, int)):
            raise StyxValidationError(f'`kernel_box` has the wrong type: Received `{type(params.get("kernel_box", None))}` expected `float | None`')
    if params.get("kernel_boxv", None) is not None:
        if not isinstance(params["kernel_boxv"], (float, int)):
            raise StyxValidationError(f'`kernel_boxv` has the wrong type: Received `{type(params.get("kernel_boxv", None))}` expected `float | None`')
    if params.get("kernel_boxv3", None) is not None:
        if not isinstance(params["kernel_boxv3"], list):
            raise StyxValidationError(f'`kernel_boxv3` has the wrong type: Received `{type(params.get("kernel_boxv3", None))}` expected `list[float] | None`')
        if len(params["kernel_boxv3"]) != 3:
            raise StyxValidationError("Parameter `kernel_boxv3` must contain exactly 3 elements")
        for e in params["kernel_boxv3"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`kernel_boxv3` has the wrong type: Received `{type(params.get("kernel_boxv3", None))}` expected `list[float] | None`')
    if params.get("kernel_gauss", None) is not None:
        if not isinstance(params["kernel_gauss"], (float, int)):
            raise StyxValidationError(f'`kernel_gauss` has the wrong type: Received `{type(params.get("kernel_gauss", None))}` expected `float | None`')
    if params.get("kernel_sphere", None) is not None:
        if not isinstance(params["kernel_sphere"], (float, int)):
            raise StyxValidationError(f'`kernel_sphere` has the wrong type: Received `{type(params.get("kernel_sphere", None))}` expected `float | None`')
    if params.get("kernel_file", None) is not None:
        if not isinstance(params["kernel_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`kernel_file` has the wrong type: Received `{type(params.get("kernel_file", None))}` expected `InputPathType | None`')
    if params.get("dilM", False) is None:
        raise StyxValidationError("`dilM` must not be None")
    if not isinstance(params["dilM"], bool):
        raise StyxValidationError(f'`dilM` has the wrong type: Received `{type(params.get("dilM", False))}` expected `bool`')
    if params.get("dilD", False) is None:
        raise StyxValidationError("`dilD` must not be None")
    if not isinstance(params["dilD"], bool):
        raise StyxValidationError(f'`dilD` has the wrong type: Received `{type(params.get("dilD", False))}` expected `bool`')
    if params.get("dilF", False) is None:
        raise StyxValidationError("`dilF` must not be None")
    if not isinstance(params["dilF"], bool):
        raise StyxValidationError(f'`dilF` has the wrong type: Received `{type(params.get("dilF", False))}` expected `bool`')
    if params.get("dilall", False) is None:
        raise StyxValidationError("`dilall` must not be None")
    if not isinstance(params["dilall"], bool):
        raise StyxValidationError(f'`dilall` has the wrong type: Received `{type(params.get("dilall", False))}` expected `bool`')
    if params.get("ero", False) is None:
        raise StyxValidationError("`ero` must not be None")
    if not isinstance(params["ero"], bool):
        raise StyxValidationError(f'`ero` has the wrong type: Received `{type(params.get("ero", False))}` expected `bool`')
    if params.get("eroF", False) is None:
        raise StyxValidationError("`eroF` must not be None")
    if not isinstance(params["eroF"], bool):
        raise StyxValidationError(f'`eroF` has the wrong type: Received `{type(params.get("eroF", False))}` expected `bool`')
    if params.get("fmedian", False) is None:
        raise StyxValidationError("`fmedian` must not be None")
    if not isinstance(params["fmedian"], bool):
        raise StyxValidationError(f'`fmedian` has the wrong type: Received `{type(params.get("fmedian", False))}` expected `bool`')
    if params.get("fmean", False) is None:
        raise StyxValidationError("`fmean` must not be None")
    if not isinstance(params["fmean"], bool):
        raise StyxValidationError(f'`fmean` has the wrong type: Received `{type(params.get("fmean", False))}` expected `bool`')
    if params.get("fmeanu", False) is None:
        raise StyxValidationError("`fmeanu` must not be None")
    if not isinstance(params["fmeanu"], bool):
        raise StyxValidationError(f'`fmeanu` has the wrong type: Received `{type(params.get("fmeanu", False))}` expected `bool`')
    if params.get("s", None) is not None:
        if not isinstance(params["s"], (float, int)):
            raise StyxValidationError(f'`s` has the wrong type: Received `{type(params.get("s", None))}` expected `float | None`')
    if params.get("subsamp2", False) is None:
        raise StyxValidationError("`subsamp2` must not be None")
    if not isinstance(params["subsamp2"], bool):
        raise StyxValidationError(f'`subsamp2` has the wrong type: Received `{type(params.get("subsamp2", False))}` expected `bool`')
    if params.get("subsamp2offc", False) is None:
        raise StyxValidationError("`subsamp2offc` must not be None")
    if not isinstance(params["subsamp2offc"], bool):
        raise StyxValidationError(f'`subsamp2offc` has the wrong type: Received `{type(params.get("subsamp2offc", False))}` expected `bool`')
    if params.get("Tmean", False) is None:
        raise StyxValidationError("`Tmean` must not be None")
    if not isinstance(params["Tmean"], bool):
        raise StyxValidationError(f'`Tmean` has the wrong type: Received `{type(params.get("Tmean", False))}` expected `bool`')
    if params.get("Xmean", False) is None:
        raise StyxValidationError("`Xmean` must not be None")
    if not isinstance(params["Xmean"], bool):
        raise StyxValidationError(f'`Xmean` has the wrong type: Received `{type(params.get("Xmean", False))}` expected `bool`')
    if params.get("Ymean", False) is None:
        raise StyxValidationError("`Ymean` must not be None")
    if not isinstance(params["Ymean"], bool):
        raise StyxValidationError(f'`Ymean` has the wrong type: Received `{type(params.get("Ymean", False))}` expected `bool`')
    if params.get("Zmean", False) is None:
        raise StyxValidationError("`Zmean` must not be None")
    if not isinstance(params["Zmean"], bool):
        raise StyxValidationError(f'`Zmean` has the wrong type: Received `{type(params.get("Zmean", False))}` expected `bool`')
    if params.get("Tstd", False) is None:
        raise StyxValidationError("`Tstd` must not be None")
    if not isinstance(params["Tstd"], bool):
        raise StyxValidationError(f'`Tstd` has the wrong type: Received `{type(params.get("Tstd", False))}` expected `bool`')
    if params.get("Xstd", False) is None:
        raise StyxValidationError("`Xstd` must not be None")
    if not isinstance(params["Xstd"], bool):
        raise StyxValidationError(f'`Xstd` has the wrong type: Received `{type(params.get("Xstd", False))}` expected `bool`')
    if params.get("Ystd", False) is None:
        raise StyxValidationError("`Ystd` must not be None")
    if not isinstance(params["Ystd"], bool):
        raise StyxValidationError(f'`Ystd` has the wrong type: Received `{type(params.get("Ystd", False))}` expected `bool`')
    if params.get("Zstd", False) is None:
        raise StyxValidationError("`Zstd` must not be None")
    if not isinstance(params["Zstd"], bool):
        raise StyxValidationError(f'`Zstd` has the wrong type: Received `{type(params.get("Zstd", False))}` expected `bool`')
    if params.get("Tmax", False) is None:
        raise StyxValidationError("`Tmax` must not be None")
    if not isinstance(params["Tmax"], bool):
        raise StyxValidationError(f'`Tmax` has the wrong type: Received `{type(params.get("Tmax", False))}` expected `bool`')
    if params.get("Xmax", False) is None:
        raise StyxValidationError("`Xmax` must not be None")
    if not isinstance(params["Xmax"], bool):
        raise StyxValidationError(f'`Xmax` has the wrong type: Received `{type(params.get("Xmax", False))}` expected `bool`')
    if params.get("Ymax", False) is None:
        raise StyxValidationError("`Ymax` must not be None")
    if not isinstance(params["Ymax"], bool):
        raise StyxValidationError(f'`Ymax` has the wrong type: Received `{type(params.get("Ymax", False))}` expected `bool`')
    if params.get("Zmax", False) is None:
        raise StyxValidationError("`Zmax` must not be None")
    if not isinstance(params["Zmax"], bool):
        raise StyxValidationError(f'`Zmax` has the wrong type: Received `{type(params.get("Zmax", False))}` expected `bool`')
    if params.get("Tmaxn", False) is None:
        raise StyxValidationError("`Tmaxn` must not be None")
    if not isinstance(params["Tmaxn"], bool):
        raise StyxValidationError(f'`Tmaxn` has the wrong type: Received `{type(params.get("Tmaxn", False))}` expected `bool`')
    if params.get("Xmaxn", False) is None:
        raise StyxValidationError("`Xmaxn` must not be None")
    if not isinstance(params["Xmaxn"], bool):
        raise StyxValidationError(f'`Xmaxn` has the wrong type: Received `{type(params.get("Xmaxn", False))}` expected `bool`')
    if params.get("Ymaxn", False) is None:
        raise StyxValidationError("`Ymaxn` must not be None")
    if not isinstance(params["Ymaxn"], bool):
        raise StyxValidationError(f'`Ymaxn` has the wrong type: Received `{type(params.get("Ymaxn", False))}` expected `bool`')
    if params.get("Zmaxn", False) is None:
        raise StyxValidationError("`Zmaxn` must not be None")
    if not isinstance(params["Zmaxn"], bool):
        raise StyxValidationError(f'`Zmaxn` has the wrong type: Received `{type(params.get("Zmaxn", False))}` expected `bool`')
    if params.get("Tmin", False) is None:
        raise StyxValidationError("`Tmin` must not be None")
    if not isinstance(params["Tmin"], bool):
        raise StyxValidationError(f'`Tmin` has the wrong type: Received `{type(params.get("Tmin", False))}` expected `bool`')
    if params.get("Xmin", False) is None:
        raise StyxValidationError("`Xmin` must not be None")
    if not isinstance(params["Xmin"], bool):
        raise StyxValidationError(f'`Xmin` has the wrong type: Received `{type(params.get("Xmin", False))}` expected `bool`')
    if params.get("Ymin", False) is None:
        raise StyxValidationError("`Ymin` must not be None")
    if not isinstance(params["Ymin"], bool):
        raise StyxValidationError(f'`Ymin` has the wrong type: Received `{type(params.get("Ymin", False))}` expected `bool`')
    if params.get("Zmin", False) is None:
        raise StyxValidationError("`Zmin` must not be None")
    if not isinstance(params["Zmin"], bool):
        raise StyxValidationError(f'`Zmin` has the wrong type: Received `{type(params.get("Zmin", False))}` expected `bool`')
    if params.get("Tmedian", False) is None:
        raise StyxValidationError("`Tmedian` must not be None")
    if not isinstance(params["Tmedian"], bool):
        raise StyxValidationError(f'`Tmedian` has the wrong type: Received `{type(params.get("Tmedian", False))}` expected `bool`')
    if params.get("Xmedian", False) is None:
        raise StyxValidationError("`Xmedian` must not be None")
    if not isinstance(params["Xmedian"], bool):
        raise StyxValidationError(f'`Xmedian` has the wrong type: Received `{type(params.get("Xmedian", False))}` expected `bool`')
    if params.get("Ymedian", False) is None:
        raise StyxValidationError("`Ymedian` must not be None")
    if not isinstance(params["Ymedian"], bool):
        raise StyxValidationError(f'`Ymedian` has the wrong type: Received `{type(params.get("Ymedian", False))}` expected `bool`')
    if params.get("Zmedian", False) is None:
        raise StyxValidationError("`Zmedian` must not be None")
    if not isinstance(params["Zmedian"], bool):
        raise StyxValidationError(f'`Zmedian` has the wrong type: Received `{type(params.get("Zmedian", False))}` expected `bool`')
    if params.get("Tperc", None) is not None:
        if not isinstance(params["Tperc"], (float, int)):
            raise StyxValidationError(f'`Tperc` has the wrong type: Received `{type(params.get("Tperc", None))}` expected `float | None`')
        if not (0 <= params["Tperc"] <= 100):
            raise StyxValidationError("Parameter `Tperc` must be between 0 and 100 (inclusive)")
    if params.get("Xperc", None) is not None:
        if not isinstance(params["Xperc"], (float, int)):
            raise StyxValidationError(f'`Xperc` has the wrong type: Received `{type(params.get("Xperc", None))}` expected `float | None`')
        if not (0 <= params["Xperc"] <= 100):
            raise StyxValidationError("Parameter `Xperc` must be between 0 and 100 (inclusive)")
    if params.get("Yperc", None) is not None:
        if not isinstance(params["Yperc"], (float, int)):
            raise StyxValidationError(f'`Yperc` has the wrong type: Received `{type(params.get("Yperc", None))}` expected `float | None`')
        if not (0 <= params["Yperc"] <= 100):
            raise StyxValidationError("Parameter `Yperc` must be between 0 and 100 (inclusive)")
    if params.get("Zperc", None) is not None:
        if not isinstance(params["Zperc"], (float, int)):
            raise StyxValidationError(f'`Zperc` has the wrong type: Received `{type(params.get("Zperc", None))}` expected `float | None`')
        if not (0 <= params["Zperc"] <= 100):
            raise StyxValidationError("Parameter `Zperc` must be between 0 and 100 (inclusive)")
    if params.get("Tar1", False) is None:
        raise StyxValidationError("`Tar1` must not be None")
    if not isinstance(params["Tar1"], bool):
        raise StyxValidationError(f'`Tar1` has the wrong type: Received `{type(params.get("Tar1", False))}` expected `bool`')
    if params.get("roi", None) is not None:
        if not isinstance(params["roi"], list):
            raise StyxValidationError(f'`roi` has the wrong type: Received `{type(params.get("roi", None))}` expected `list[float] | None`')
        if len(params["roi"]) != 6:
            raise StyxValidationError("Parameter `roi` must contain exactly 6 elements")
        for e in params["roi"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`roi` has the wrong type: Received `{type(params.get("roi", None))}` expected `list[float] | None`')
    if params.get("bptf", None) is not None:
        if not isinstance(params["bptf"], list):
            raise StyxValidationError(f'`bptf` has the wrong type: Received `{type(params.get("bptf", None))}` expected `list[float] | None`')
        if len(params["bptf"]) != 2:
            raise StyxValidationError("Parameter `bptf` must contain exactly 2 elements")
        for e in params["bptf"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`bptf` has the wrong type: Received `{type(params.get("bptf", None))}` expected `list[float] | None`')
    if params.get("roc", None) is not None:
        if not isinstance(params["roc"], list):
            raise StyxValidationError(f'`roc` has the wrong type: Received `{type(params.get("roc", None))}` expected `list[float] | None`')
        for e in params["roc"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`roc` has the wrong type: Received `{type(params.get("roc", None))}` expected `list[float] | None`')


def fslmaths_operation_cargs(
    params: FslmathsOperationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("add", None) is not None:
        cargs.extend([
            "-add",
            str(params.get("add", None))
        ])
    if params.get("sub", None) is not None:
        cargs.extend([
            "-sub",
            str(params.get("sub", None))
        ])
    if params.get("mul", None) is not None:
        cargs.extend([
            "-mul",
            str(params.get("mul", None))
        ])
    if params.get("div", None) is not None:
        cargs.extend([
            "-div",
            str(params.get("div", None))
        ])
    if params.get("rem", None) is not None:
        cargs.extend([
            "-rem",
            str(params.get("rem", None))
        ])
    if params.get("mas", None) is not None:
        cargs.extend([
            "-mas",
            execution.input_file(params.get("mas", None))
        ])
    if params.get("thr", None) is not None:
        cargs.extend([
            "-thr",
            str(params.get("thr", None))
        ])
    if params.get("thrp", None) is not None:
        cargs.extend([
            "-thrp",
            str(params.get("thrp", None))
        ])
    if params.get("thrP", None) is not None:
        cargs.extend([
            "-thrP",
            str(params.get("thrP", None))
        ])
    if params.get("uthr", None) is not None:
        cargs.extend([
            "-uthr",
            str(params.get("uthr", None))
        ])
    if params.get("uthrp", None) is not None:
        cargs.extend([
            "-uthrp",
            str(params.get("uthrp", None))
        ])
    if params.get("uthrP", None) is not None:
        cargs.extend([
            "-uthrP",
            str(params.get("uthrP", None))
        ])
    if params.get("max", None) is not None:
        cargs.extend([
            "-max",
            str(params.get("max", None))
        ])
    if params.get("min", None) is not None:
        cargs.extend([
            "-min",
            str(params.get("min", None))
        ])
    if params.get("seed", None) is not None:
        cargs.extend([
            "-seed",
            str(params.get("seed", None))
        ])
    if params.get("restart", None) is not None:
        cargs.extend([
            "-restart",
            execution.input_file(params.get("restart", None))
        ])
    if params.get("save", False):
        cargs.append("-save")
    if params.get("exp", False):
        cargs.append("-exp")
    if params.get("log", False):
        cargs.append("-log")
    if params.get("sin", False):
        cargs.append("-sin")
    if params.get("cos", False):
        cargs.append("-cos")
    if params.get("tan", False):
        cargs.append("-tan")
    if params.get("asin", False):
        cargs.append("-asin")
    if params.get("acos", False):
        cargs.append("-acos")
    if params.get("atan", False):
        cargs.append("-atan")
    if params.get("sqr", False):
        cargs.append("-sqr")
    if params.get("sqrt", False):
        cargs.append("-sqrt")
    if params.get("recip", False):
        cargs.append("-recip")
    if params.get("abs", False):
        cargs.append("-abs")
    if params.get("bin", False):
        cargs.append("-bin")
    if params.get("binv", False):
        cargs.append("-binv")
    if params.get("fillh", False):
        cargs.append("-fillh")
    if params.get("fillh26", False):
        cargs.append("-fillh26")
    if params.get("index", False):
        cargs.append("-index")
    if params.get("grid", None) is not None:
        cargs.extend([
            "-grid",
            *map(str, params.get("grid", None))
        ])
    if params.get("edge", False):
        cargs.append("-edge")
    if params.get("tfce", None) is not None:
        cargs.extend([
            "-tfce",
            *map(str, params.get("tfce", None))
        ])
    if params.get("tfceS", None) is not None:
        cargs.extend([
            "-tfceS",
            *map(str, params.get("tfceS", None))
        ])
    if params.get("nan", False):
        cargs.append("-nan")
    if params.get("nanm", False):
        cargs.append("-nanm")
    if params.get("rand", False):
        cargs.append("-rand")
    if params.get("randn", False):
        cargs.append("-randn")
    if params.get("inm", None) is not None:
        cargs.extend([
            "-inm",
            str(params.get("inm", None))
        ])
    if params.get("ing", None) is not None:
        cargs.extend([
            "-ing",
            str(params.get("ing", None))
        ])
    if params.get("range", False):
        cargs.append("-range")
    if params.get("tensor_decomp", False):
        cargs.append("-tensor_decomp")
    if params.get("kernel_3D", False):
        cargs.append("-kernel 3D")
    if params.get("kernel_2D", False):
        cargs.append("-kernel 2D")
    if params.get("kernel_box", None) is not None:
        cargs.extend([
            "-kernel box",
            str(params.get("kernel_box", None))
        ])
    if params.get("kernel_boxv", None) is not None:
        cargs.extend([
            "-kernel boxv",
            str(params.get("kernel_boxv", None))
        ])
    if params.get("kernel_boxv3", None) is not None:
        cargs.extend([
            "-kernel boxv3",
            *map(str, params.get("kernel_boxv3", None))
        ])
    if params.get("kernel_gauss", None) is not None:
        cargs.extend([
            "-kernel gauss",
            str(params.get("kernel_gauss", None))
        ])
    if params.get("kernel_sphere", None) is not None:
        cargs.extend([
            "-kernel sphere",
            str(params.get("kernel_sphere", None))
        ])
    if params.get("kernel_file", None) is not None:
        cargs.extend([
            "-kernel file",
            execution.input_file(params.get("kernel_file", None))
        ])
    if params.get("dilM", False):
        cargs.append("-dilM")
    if params.get("dilD", False):
        cargs.append("-dilD")
    if params.get("dilF", False):
        cargs.append("-dilF")
    if params.get("dilall", False):
        cargs.append("-dilall")
    if params.get("ero", False):
        cargs.append("-ero")
    if params.get("eroF", False):
        cargs.append("-eroF")
    if params.get("fmedian", False):
        cargs.append("-fmedian")
    if params.get("fmean", False):
        cargs.append("-fmean")
    if params.get("fmeanu", False):
        cargs.append("-fmeanu")
    if params.get("s", None) is not None:
        cargs.extend([
            "-s",
            str(params.get("s", None))
        ])
    if params.get("subsamp2", False):
        cargs.append("-subsamp2")
    if params.get("subsamp2offc", False):
        cargs.append("-subsamp2offc")
    if params.get("Tmean", False):
        cargs.append("-Tmean")
    if params.get("Xmean", False):
        cargs.append("-Xmean")
    if params.get("Ymean", False):
        cargs.append("-Ymean")
    if params.get("Zmean", False):
        cargs.append("-Zmean")
    if params.get("Tstd", False):
        cargs.append("-Tstd")
    if params.get("Xstd", False):
        cargs.append("-Xstd")
    if params.get("Ystd", False):
        cargs.append("-Ystd")
    if params.get("Zstd", False):
        cargs.append("-Zstd")
    if params.get("Tmax", False):
        cargs.append("-Tmax")
    if params.get("Xmax", False):
        cargs.append("-Xmax")
    if params.get("Ymax", False):
        cargs.append("-Ymax")
    if params.get("Zmax", False):
        cargs.append("-Zmax")
    if params.get("Tmaxn", False):
        cargs.append("-Tmaxn")
    if params.get("Xmaxn", False):
        cargs.append("-Xmaxn")
    if params.get("Ymaxn", False):
        cargs.append("-Ymaxn")
    if params.get("Zmaxn", False):
        cargs.append("-Zmaxn")
    if params.get("Tmin", False):
        cargs.append("-Tmin")
    if params.get("Xmin", False):
        cargs.append("-Xmin")
    if params.get("Ymin", False):
        cargs.append("-Ymin")
    if params.get("Zmin", False):
        cargs.append("-Zmin")
    if params.get("Tmedian", False):
        cargs.append("-Tmedian")
    if params.get("Xmedian", False):
        cargs.append("-Xmedian")
    if params.get("Ymedian", False):
        cargs.append("-Ymedian")
    if params.get("Zmedian", False):
        cargs.append("-Zmedian")
    if params.get("Tperc", None) is not None:
        cargs.extend([
            "-Tperc",
            str(params.get("Tperc", None))
        ])
    if params.get("Xperc", None) is not None:
        cargs.extend([
            "-Xperc",
            str(params.get("Xperc", None))
        ])
    if params.get("Yperc", None) is not None:
        cargs.extend([
            "-Yperc",
            str(params.get("Yperc", None))
        ])
    if params.get("Zperc", None) is not None:
        cargs.extend([
            "-Zperc",
            str(params.get("Zperc", None))
        ])
    if params.get("Tar1", False):
        cargs.append("-Tar1")
    if params.get("roi", None) is not None:
        cargs.extend([
            "-roi",
            *map(str, params.get("roi", None))
        ])
    if params.get("bptf", None) is not None:
        cargs.extend([
            "-bptf",
            *map(str, params.get("bptf", None))
        ])
    if params.get("roc", None) is not None:
        cargs.extend([
            "-roc",
            *map(str, params.get("roc", None))
        ])
    return cargs


class FslmathsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `FslmathsParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType
    """The main output file produced by fslmaths"""


def fslmaths_params(
    input_files: list[InputPathType],
    operations: list[FslmathsOperationParamsDict],
    output: str,
    datatype_internal: typing.Literal["char", "short", "int", "float", "double", "input"] | None = None,
    output_datatype: typing.Literal["char", "short", "int", "float", "double", "input"] | None = None,
) -> FslmathsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_files: Input images for processing.
        operations: Operations to perform on input images.
        output: Output image file.
        datatype_internal: Datatype used internally for calculations.
        output_datatype: Datatype used for the output image.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/fslmaths",
        "input_files": input_files,
        "operations": operations,
        "output": output,
    }
    if datatype_internal is not None:
        params["datatype_internal"] = datatype_internal
    if output_datatype is not None:
        params["output_datatype"] = output_datatype
    return params


def fslmaths_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `FslmathsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("datatype_internal", None) is not None:
        if not isinstance(params["datatype_internal"], str):
            raise StyxValidationError(f'`datatype_internal` has the wrong type: Received `{type(params.get("datatype_internal", None))}` expected `typing.Literal["char", "short", "int", "float", "double", "input"] | None`')
        if params["datatype_internal"] not in ["char", "short", "int", "float", "double", "input"]:
            raise StyxValidationError("Parameter `datatype_internal` must be one of [\"char\", \"short\", \"int\", \"float\", \"double\", \"input\"]")
    if params.get("input_files", None) is None:
        raise StyxValidationError("`input_files` must not be None")
    if not isinstance(params["input_files"], list):
        raise StyxValidationError(f'`input_files` has the wrong type: Received `{type(params.get("input_files", None))}` expected `list[InputPathType]`')
    for e in params["input_files"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`input_files` has the wrong type: Received `{type(params.get("input_files", None))}` expected `list[InputPathType]`')
    if params.get("operations", None) is None:
        raise StyxValidationError("`operations` must not be None")
    if not isinstance(params["operations"], list):
        raise StyxValidationError(f'`operations` has the wrong type: Received `{type(params.get("operations", None))}` expected `list[FslmathsOperationParamsDict]`')
    for e in params["operations"]:
        fslmaths_operation_validate(e)
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')
    if params.get("output_datatype", None) is not None:
        if not isinstance(params["output_datatype"], str):
            raise StyxValidationError(f'`output_datatype` has the wrong type: Received `{type(params.get("output_datatype", None))}` expected `typing.Literal["char", "short", "int", "float", "double", "input"] | None`')
        if params["output_datatype"] not in ["char", "short", "int", "float", "double", "input"]:
            raise StyxValidationError("Parameter `output_datatype` must be one of [\"char\", \"short\", \"int\", \"float\", \"double\", \"input\"]")


def fslmaths_cargs(
    params: FslmathsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("fslmaths")
    if params.get("datatype_internal", None) is not None:
        cargs.extend([
            "-dt",
            params.get("datatype_internal", None)
        ])
    cargs.extend([execution.input_file(f) for f in params.get("input_files", None)])
    cargs.extend([a for c in [fslmaths_operation_cargs(s, execution) for s in params.get("operations", None)] for a in c])
    cargs.append(params.get("output", None))
    if params.get("output_datatype", None) is not None:
        cargs.extend([
            "-odt",
            params.get("output_datatype", None)
        ])
    return cargs


def fslmaths_outputs(
    params: FslmathsParamsDict,
    execution: Execution,
) -> FslmathsOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = FslmathsOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(params.get("output", None)),
    )
    return ret


def fslmaths_execute(
    params: FslmathsParamsDict,
    runner: Runner | None = None,
) -> FslmathsOutputs:
    """
    fslmaths
    
    FSL utility for image arithmetic, statistics, and mathematical operations.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FslmathsOutputs`).
    """
    fslmaths_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(FSLMATHS_METADATA)
    params = execution.params(params)
    cargs = fslmaths_cargs(params, execution)
    ret = fslmaths_outputs(params, execution)
    execution.run(cargs)
    return ret


def fslmaths(
    input_files: list[InputPathType],
    operations: list[FslmathsOperationParamsDict],
    output: str,
    datatype_internal: typing.Literal["char", "short", "int", "float", "double", "input"] | None = None,
    output_datatype: typing.Literal["char", "short", "int", "float", "double", "input"] | None = None,
    runner: Runner | None = None,
) -> FslmathsOutputs:
    """
    fslmaths
    
    FSL utility for image arithmetic, statistics, and mathematical operations.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        input_files: Input images for processing.
        operations: Operations to perform on input images.
        output: Output image file.
        datatype_internal: Datatype used internally for calculations.
        output_datatype: Datatype used for the output image.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FslmathsOutputs`).
    """
    params = fslmaths_params(
        datatype_internal=datatype_internal,
        input_files=input_files,
        operations=operations,
        output=output,
        output_datatype=output_datatype,
    )
    return fslmaths_execute(params, runner)


__all__ = [
    "FSLMATHS_METADATA",
    "FslmathsOperationParamsDict",
    "FslmathsOperationParamsDictTagged",
    "FslmathsOutputs",
    "FslmathsParamsDict",
    "FslmathsParamsDictTagged",
    "fslmaths",
    "fslmaths_execute",
    "fslmaths_operation",
    "fslmaths_params",
]
