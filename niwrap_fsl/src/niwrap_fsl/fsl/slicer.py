# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

SLICER_METADATA = Metadata(
    id="2c353c43c88ab74b4b6869b7fe3454ebdb0d76f8.boutiques",
    name="slicer",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_SlicerParamsDictNoTag = typing.TypedDict('_SlicerParamsDictNoTag', {
    "in_file": InputPathType,
    "overlay_file": typing.NotRequired[InputPathType | None],
    "label_slices": bool,
    "colour_map": typing.NotRequired[InputPathType | None],
    "scaling": typing.NotRequired[float | None],
    "intensity_range": typing.NotRequired[list[float] | None],
    "threshold_edges": typing.NotRequired[float | None],
    "dither_edges": bool,
    "nearest_neighbour": bool,
    "show_orientation": bool,
    "red_dot_marker": bool,
    "output_single_image": typing.NotRequired[str | None],
    "output_sagittal_slice": bool,
    "output_sagittal_slice_fname": typing.NotRequired[str | None],
    "output_axial_slice": bool,
    "output_axial_slice_fname": typing.NotRequired[str | None],
    "output_coronal_slice": bool,
    "output_coronal_slice_fname": typing.NotRequired[str | None],
    "output_all_axial_slices": bool,
    "output_all_axial_slices_fname": typing.NotRequired[str | None],
    "output_sample_axial_slices": bool,
    "output_sample_axial_slices_width": typing.NotRequired[str | None],
    "output_sample_axial_slices_fname": typing.NotRequired[str | None],
})
SlicerParamsDictTagged = typing.TypedDict('SlicerParamsDictTagged', {
    "@type": typing.Literal["fsl/slicer"],
    "in_file": InputPathType,
    "overlay_file": typing.NotRequired[InputPathType | None],
    "label_slices": bool,
    "colour_map": typing.NotRequired[InputPathType | None],
    "scaling": typing.NotRequired[float | None],
    "intensity_range": typing.NotRequired[list[float] | None],
    "threshold_edges": typing.NotRequired[float | None],
    "dither_edges": bool,
    "nearest_neighbour": bool,
    "show_orientation": bool,
    "red_dot_marker": bool,
    "output_single_image": typing.NotRequired[str | None],
    "output_sagittal_slice": bool,
    "output_sagittal_slice_fname": typing.NotRequired[str | None],
    "output_axial_slice": bool,
    "output_axial_slice_fname": typing.NotRequired[str | None],
    "output_coronal_slice": bool,
    "output_coronal_slice_fname": typing.NotRequired[str | None],
    "output_all_axial_slices": bool,
    "output_all_axial_slices_fname": typing.NotRequired[str | None],
    "output_sample_axial_slices": bool,
    "output_sample_axial_slices_width": typing.NotRequired[str | None],
    "output_sample_axial_slices_fname": typing.NotRequired[str | None],
})
SlicerParamsDict = _SlicerParamsDictNoTag | SlicerParamsDictTagged


class SlicerOutputs(typing.NamedTuple):
    """
    Output object returned when calling `SlicerParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    sagittal_slice_outfile: OutputPathType | None
    """Output sagittal slice."""
    axial_slice_outfile: OutputPathType | None
    """Output axial slice."""
    coronal_slice_outfile: OutputPathType | None
    """Output coronal slice."""
    single_image_outfile: OutputPathType | None
    """Output mid-sagittal, -coronal, and -axial slices into one image."""
    all_axial_slices_outfile: OutputPathType | None
    """File name of every <sample'th> axial slice output image."""


def slicer_params(
    in_file: InputPathType,
    overlay_file: InputPathType | None = None,
    label_slices: bool = False,
    colour_map: InputPathType | None = None,
    scaling: float | None = None,
    intensity_range: list[float] | None = None,
    threshold_edges: float | None = None,
    dither_edges: bool = False,
    nearest_neighbour: bool = False,
    show_orientation: bool = False,
    red_dot_marker: bool = False,
    output_single_image: str | None = None,
    output_sagittal_slice: bool = False,
    output_sagittal_slice_fname: str | None = None,
    output_axial_slice: bool = False,
    output_axial_slice_fname: str | None = None,
    output_coronal_slice: bool = False,
    output_coronal_slice_fname: str | None = None,
    output_all_axial_slices: bool = False,
    output_all_axial_slices_fname: str | None = None,
    output_sample_axial_slices: bool = False,
    output_sample_axial_slices_width: str | None = None,
    output_sample_axial_slices_fname: str | None = None,
) -> SlicerParamsDictTagged:
    """
    Build parameters.
    
    Args:
        in_file: Input volume.
        overlay_file: Overlay volume.
        label_slices: Label slices with slice number.
        colour_map: Use different colour map from that specified in the header.
        scaling: Image scale.
        intensity_range: Specify intensity min and max for display range.
        threshold_edges: Use specified threshold for edges (if >0 use this\
            proportion of max-min, if <0, use the absolute value).
        dither_edges: Produce semi-transparent (dithered) edges.
        nearest_neighbour: Use nearest neighbor interpolation for output.
        show_orientation: Do not put left-right labels in output.
        red_dot_marker: Add a red dot marker to topright of image.
        output_single_image: Output mid-sagittal, -coronal, and -axial slices\
            into one image.
        output_sagittal_slice: Output sagittal slice (if slice >0, it is a\
            fraction of image dimension, if <0, it is absolute slice number).
        output_sagittal_slice_fname: Output file name sagittal slice.
        output_axial_slice: Output axial slice (if slice >0, it is a fraction\
            of image dimension, if <0, it is absolute slice number).
        output_axial_slice_fname: Output file name axial slice.
        output_coronal_slice: Output coronal slice (if slice >0, it is a\
            fraction of image dimension, if <0, it is absolute slice number).
        output_coronal_slice_fname: Output file name coronal slice.
        output_all_axial_slices: Maximum width of image of all axial slices.
        output_all_axial_slices_fname: File name of all axial slice output\
            image.
        output_sample_axial_slices: Ouput every <sample>'th axial slice.
        output_sample_axial_slices_width: Width of every <sample'th> axial\
            slice output image.
        output_sample_axial_slices_fname: File name of every <sample'th> axial\
            slice output image.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/slicer",
        "in_file": in_file,
        "label_slices": label_slices,
        "dither_edges": dither_edges,
        "nearest_neighbour": nearest_neighbour,
        "show_orientation": show_orientation,
        "red_dot_marker": red_dot_marker,
        "output_sagittal_slice": output_sagittal_slice,
        "output_axial_slice": output_axial_slice,
        "output_coronal_slice": output_coronal_slice,
        "output_all_axial_slices": output_all_axial_slices,
        "output_sample_axial_slices": output_sample_axial_slices,
    }
    if overlay_file is not None:
        params["overlay_file"] = overlay_file
    if colour_map is not None:
        params["colour_map"] = colour_map
    if scaling is not None:
        params["scaling"] = scaling
    if intensity_range is not None:
        params["intensity_range"] = intensity_range
    if threshold_edges is not None:
        params["threshold_edges"] = threshold_edges
    if output_single_image is not None:
        params["output_single_image"] = output_single_image
    if output_sagittal_slice_fname is not None:
        params["output_sagittal_slice_fname"] = output_sagittal_slice_fname
    if output_axial_slice_fname is not None:
        params["output_axial_slice_fname"] = output_axial_slice_fname
    if output_coronal_slice_fname is not None:
        params["output_coronal_slice_fname"] = output_coronal_slice_fname
    if output_all_axial_slices_fname is not None:
        params["output_all_axial_slices_fname"] = output_all_axial_slices_fname
    if output_sample_axial_slices_width is not None:
        params["output_sample_axial_slices_width"] = output_sample_axial_slices_width
    if output_sample_axial_slices_fname is not None:
        params["output_sample_axial_slices_fname"] = output_sample_axial_slices_fname
    return params


def slicer_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `SlicerParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("in_file", None) is None:
        raise StyxValidationError("`in_file` must not be None")
    if not isinstance(params["in_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`in_file` has the wrong type: Received `{type(params.get("in_file", None))}` expected `InputPathType`')
    if params.get("overlay_file", None) is not None:
        if not isinstance(params["overlay_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`overlay_file` has the wrong type: Received `{type(params.get("overlay_file", None))}` expected `InputPathType | None`')
    if params.get("label_slices", False) is None:
        raise StyxValidationError("`label_slices` must not be None")
    if not isinstance(params["label_slices"], bool):
        raise StyxValidationError(f'`label_slices` has the wrong type: Received `{type(params.get("label_slices", False))}` expected `bool`')
    if params.get("colour_map", None) is not None:
        if not isinstance(params["colour_map"], (pathlib.Path, str)):
            raise StyxValidationError(f'`colour_map` has the wrong type: Received `{type(params.get("colour_map", None))}` expected `InputPathType | None`')
    if params.get("scaling", None) is not None:
        if not isinstance(params["scaling"], (float, int)):
            raise StyxValidationError(f'`scaling` has the wrong type: Received `{type(params.get("scaling", None))}` expected `float | None`')
    if params.get("intensity_range", None) is not None:
        if not isinstance(params["intensity_range"], list):
            raise StyxValidationError(f'`intensity_range` has the wrong type: Received `{type(params.get("intensity_range", None))}` expected `list[float] | None`')
        if len(params["intensity_range"]) != 2:
            raise StyxValidationError("Parameter `intensity_range` must contain exactly 2 elements")
        for e in params["intensity_range"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`intensity_range` has the wrong type: Received `{type(params.get("intensity_range", None))}` expected `list[float] | None`')
    if params.get("threshold_edges", None) is not None:
        if not isinstance(params["threshold_edges"], (float, int)):
            raise StyxValidationError(f'`threshold_edges` has the wrong type: Received `{type(params.get("threshold_edges", None))}` expected `float | None`')
    if params.get("dither_edges", False) is None:
        raise StyxValidationError("`dither_edges` must not be None")
    if not isinstance(params["dither_edges"], bool):
        raise StyxValidationError(f'`dither_edges` has the wrong type: Received `{type(params.get("dither_edges", False))}` expected `bool`')
    if params.get("nearest_neighbour", False) is None:
        raise StyxValidationError("`nearest_neighbour` must not be None")
    if not isinstance(params["nearest_neighbour"], bool):
        raise StyxValidationError(f'`nearest_neighbour` has the wrong type: Received `{type(params.get("nearest_neighbour", False))}` expected `bool`')
    if params.get("show_orientation", False) is None:
        raise StyxValidationError("`show_orientation` must not be None")
    if not isinstance(params["show_orientation"], bool):
        raise StyxValidationError(f'`show_orientation` has the wrong type: Received `{type(params.get("show_orientation", False))}` expected `bool`')
    if params.get("red_dot_marker", False) is None:
        raise StyxValidationError("`red_dot_marker` must not be None")
    if not isinstance(params["red_dot_marker"], bool):
        raise StyxValidationError(f'`red_dot_marker` has the wrong type: Received `{type(params.get("red_dot_marker", False))}` expected `bool`')
    if params.get("output_single_image", None) is not None:
        if not isinstance(params["output_single_image"], str):
            raise StyxValidationError(f'`output_single_image` has the wrong type: Received `{type(params.get("output_single_image", None))}` expected `str | None`')
    if params.get("output_sagittal_slice", False) is None:
        raise StyxValidationError("`output_sagittal_slice` must not be None")
    if not isinstance(params["output_sagittal_slice"], bool):
        raise StyxValidationError(f'`output_sagittal_slice` has the wrong type: Received `{type(params.get("output_sagittal_slice", False))}` expected `bool`')
    if params.get("output_sagittal_slice_fname", None) is not None:
        if not isinstance(params["output_sagittal_slice_fname"], str):
            raise StyxValidationError(f'`output_sagittal_slice_fname` has the wrong type: Received `{type(params.get("output_sagittal_slice_fname", None))}` expected `str | None`')
    if params.get("output_axial_slice", False) is None:
        raise StyxValidationError("`output_axial_slice` must not be None")
    if not isinstance(params["output_axial_slice"], bool):
        raise StyxValidationError(f'`output_axial_slice` has the wrong type: Received `{type(params.get("output_axial_slice", False))}` expected `bool`')
    if params.get("output_axial_slice_fname", None) is not None:
        if not isinstance(params["output_axial_slice_fname"], str):
            raise StyxValidationError(f'`output_axial_slice_fname` has the wrong type: Received `{type(params.get("output_axial_slice_fname", None))}` expected `str | None`')
    if params.get("output_coronal_slice", False) is None:
        raise StyxValidationError("`output_coronal_slice` must not be None")
    if not isinstance(params["output_coronal_slice"], bool):
        raise StyxValidationError(f'`output_coronal_slice` has the wrong type: Received `{type(params.get("output_coronal_slice", False))}` expected `bool`')
    if params.get("output_coronal_slice_fname", None) is not None:
        if not isinstance(params["output_coronal_slice_fname"], str):
            raise StyxValidationError(f'`output_coronal_slice_fname` has the wrong type: Received `{type(params.get("output_coronal_slice_fname", None))}` expected `str | None`')
    if params.get("output_all_axial_slices", False) is None:
        raise StyxValidationError("`output_all_axial_slices` must not be None")
    if not isinstance(params["output_all_axial_slices"], bool):
        raise StyxValidationError(f'`output_all_axial_slices` has the wrong type: Received `{type(params.get("output_all_axial_slices", False))}` expected `bool`')
    if params.get("output_all_axial_slices_fname", None) is not None:
        if not isinstance(params["output_all_axial_slices_fname"], str):
            raise StyxValidationError(f'`output_all_axial_slices_fname` has the wrong type: Received `{type(params.get("output_all_axial_slices_fname", None))}` expected `str | None`')
    if params.get("output_sample_axial_slices", False) is None:
        raise StyxValidationError("`output_sample_axial_slices` must not be None")
    if not isinstance(params["output_sample_axial_slices"], bool):
        raise StyxValidationError(f'`output_sample_axial_slices` has the wrong type: Received `{type(params.get("output_sample_axial_slices", False))}` expected `bool`')
    if params.get("output_sample_axial_slices_width", None) is not None:
        if not isinstance(params["output_sample_axial_slices_width"], str):
            raise StyxValidationError(f'`output_sample_axial_slices_width` has the wrong type: Received `{type(params.get("output_sample_axial_slices_width", None))}` expected `str | None`')
    if params.get("output_sample_axial_slices_fname", None) is not None:
        if not isinstance(params["output_sample_axial_slices_fname"], str):
            raise StyxValidationError(f'`output_sample_axial_slices_fname` has the wrong type: Received `{type(params.get("output_sample_axial_slices_fname", None))}` expected `str | None`')


def slicer_cargs(
    params: SlicerParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("slicer")
    cargs.append(execution.input_file(params.get("in_file", None)))
    if params.get("overlay_file", None) is not None:
        cargs.append(execution.input_file(params.get("overlay_file", None)))
    if params.get("label_slices", False):
        cargs.append("-L")
    if params.get("colour_map", None) is not None:
        cargs.extend([
            "-l",
            execution.input_file(params.get("colour_map", None))
        ])
    if params.get("scaling", None) is not None:
        cargs.extend([
            "-s",
            str(params.get("scaling", None))
        ])
    if params.get("intensity_range", None) is not None:
        cargs.extend([
            "-i",
            *map(str, params.get("intensity_range", None))
        ])
    if params.get("threshold_edges", None) is not None:
        cargs.extend([
            "-e",
            str(params.get("threshold_edges", None))
        ])
    if params.get("dither_edges", False):
        cargs.append("-t")
    if params.get("nearest_neighbour", False):
        cargs.append("-n")
    if params.get("show_orientation", False):
        cargs.append("-u")
    if params.get("red_dot_marker", False):
        cargs.append("-c")
    if params.get("output_single_image", None) is not None:
        cargs.extend([
            "-a",
            params.get("output_single_image", None)
        ])
    if params.get("output_sagittal_slice", False):
        cargs.append("-x")
    if params.get("output_sagittal_slice_fname", None) is not None:
        cargs.append(params.get("output_sagittal_slice_fname", None))
    if params.get("output_axial_slice", False):
        cargs.append("-y")
    if params.get("output_axial_slice_fname", None) is not None:
        cargs.append(params.get("output_axial_slice_fname", None))
    if params.get("output_coronal_slice", False):
        cargs.append("-z")
    if params.get("output_coronal_slice_fname", None) is not None:
        cargs.append(params.get("output_coronal_slice_fname", None))
    if params.get("output_all_axial_slices", False):
        cargs.append("-A")
    if params.get("output_all_axial_slices_fname", None) is not None:
        cargs.append(params.get("output_all_axial_slices_fname", None))
    if params.get("output_sample_axial_slices", False):
        cargs.append("-S")
    if params.get("output_sample_axial_slices_width", None) is not None:
        cargs.append(params.get("output_sample_axial_slices_width", None))
    if params.get("output_sample_axial_slices_fname", None) is not None:
        cargs.append(params.get("output_sample_axial_slices_fname", None))
    return cargs


def slicer_outputs(
    params: SlicerParamsDict,
    execution: Execution,
) -> SlicerOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = SlicerOutputs(
        root=execution.output_file("."),
        sagittal_slice_outfile=execution.output_file(params.get("output_sagittal_slice_fname", None)) if (params.get("output_sagittal_slice_fname") is not None) else None,
        axial_slice_outfile=execution.output_file(params.get("output_axial_slice_fname", None)) if (params.get("output_axial_slice_fname") is not None) else None,
        coronal_slice_outfile=execution.output_file(params.get("output_coronal_slice_fname", None)) if (params.get("output_coronal_slice_fname") is not None) else None,
        single_image_outfile=execution.output_file(params.get("output_single_image", None)) if (params.get("output_single_image") is not None) else None,
        all_axial_slices_outfile=execution.output_file(params.get("output_sample_axial_slices_fname", None)) if (params.get("output_sample_axial_slices_fname") is not None) else None,
    )
    return ret


def slicer_execute(
    params: SlicerParamsDict,
    runner: Runner | None = None,
) -> SlicerOutputs:
    """
    slicer
    
    the main program which takes in one or two input images and produces as many
    separate output pictures of slices as are requested. The basic output
    options (-x, -y and -z) produce single slice pictures. The more advanced
    options (-a, -A and -S) produce montages of various slices. slicer outputs
    PPM format pictures.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SlicerOutputs`).
    """
    slicer_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(SLICER_METADATA)
    params = execution.params(params)
    cargs = slicer_cargs(params, execution)
    ret = slicer_outputs(params, execution)
    execution.run(cargs)
    return ret


def slicer(
    in_file: InputPathType,
    overlay_file: InputPathType | None = None,
    label_slices: bool = False,
    colour_map: InputPathType | None = None,
    scaling: float | None = None,
    intensity_range: list[float] | None = None,
    threshold_edges: float | None = None,
    dither_edges: bool = False,
    nearest_neighbour: bool = False,
    show_orientation: bool = False,
    red_dot_marker: bool = False,
    output_single_image: str | None = None,
    output_sagittal_slice: bool = False,
    output_sagittal_slice_fname: str | None = None,
    output_axial_slice: bool = False,
    output_axial_slice_fname: str | None = None,
    output_coronal_slice: bool = False,
    output_coronal_slice_fname: str | None = None,
    output_all_axial_slices: bool = False,
    output_all_axial_slices_fname: str | None = None,
    output_sample_axial_slices: bool = False,
    output_sample_axial_slices_width: str | None = None,
    output_sample_axial_slices_fname: str | None = None,
    runner: Runner | None = None,
) -> SlicerOutputs:
    """
    slicer
    
    the main program which takes in one or two input images and produces as many
    separate output pictures of slices as are requested. The basic output
    options (-x, -y and -z) produce single slice pictures. The more advanced
    options (-a, -A and -S) produce montages of various slices. slicer outputs
    PPM format pictures.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        in_file: Input volume.
        overlay_file: Overlay volume.
        label_slices: Label slices with slice number.
        colour_map: Use different colour map from that specified in the header.
        scaling: Image scale.
        intensity_range: Specify intensity min and max for display range.
        threshold_edges: Use specified threshold for edges (if >0 use this\
            proportion of max-min, if <0, use the absolute value).
        dither_edges: Produce semi-transparent (dithered) edges.
        nearest_neighbour: Use nearest neighbor interpolation for output.
        show_orientation: Do not put left-right labels in output.
        red_dot_marker: Add a red dot marker to topright of image.
        output_single_image: Output mid-sagittal, -coronal, and -axial slices\
            into one image.
        output_sagittal_slice: Output sagittal slice (if slice >0, it is a\
            fraction of image dimension, if <0, it is absolute slice number).
        output_sagittal_slice_fname: Output file name sagittal slice.
        output_axial_slice: Output axial slice (if slice >0, it is a fraction\
            of image dimension, if <0, it is absolute slice number).
        output_axial_slice_fname: Output file name axial slice.
        output_coronal_slice: Output coronal slice (if slice >0, it is a\
            fraction of image dimension, if <0, it is absolute slice number).
        output_coronal_slice_fname: Output file name coronal slice.
        output_all_axial_slices: Maximum width of image of all axial slices.
        output_all_axial_slices_fname: File name of all axial slice output\
            image.
        output_sample_axial_slices: Ouput every <sample>'th axial slice.
        output_sample_axial_slices_width: Width of every <sample'th> axial\
            slice output image.
        output_sample_axial_slices_fname: File name of every <sample'th> axial\
            slice output image.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SlicerOutputs`).
    """
    params = slicer_params(
        in_file=in_file,
        overlay_file=overlay_file,
        label_slices=label_slices,
        colour_map=colour_map,
        scaling=scaling,
        intensity_range=intensity_range,
        threshold_edges=threshold_edges,
        dither_edges=dither_edges,
        nearest_neighbour=nearest_neighbour,
        show_orientation=show_orientation,
        red_dot_marker=red_dot_marker,
        output_single_image=output_single_image,
        output_sagittal_slice=output_sagittal_slice,
        output_sagittal_slice_fname=output_sagittal_slice_fname,
        output_axial_slice=output_axial_slice,
        output_axial_slice_fname=output_axial_slice_fname,
        output_coronal_slice=output_coronal_slice,
        output_coronal_slice_fname=output_coronal_slice_fname,
        output_all_axial_slices=output_all_axial_slices,
        output_all_axial_slices_fname=output_all_axial_slices_fname,
        output_sample_axial_slices=output_sample_axial_slices,
        output_sample_axial_slices_width=output_sample_axial_slices_width,
        output_sample_axial_slices_fname=output_sample_axial_slices_fname,
    )
    return slicer_execute(params, runner)


__all__ = [
    "SLICER_METADATA",
    "SlicerOutputs",
    "SlicerParamsDict",
    "SlicerParamsDictTagged",
    "slicer",
    "slicer_execute",
    "slicer_params",
]
