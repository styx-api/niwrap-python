# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

FABBER_DCE_METADATA = Metadata(
    id="d8f4063f9bb1b10c953bc36c87196c925fa3f2a6.boutiques",
    name="fabber_dce",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


_FabberDceParamsDictNoTag = typing.TypedDict('_FabberDceParamsDictNoTag', {
    "output_directory": str,
    "inference_method": str,
    "forward_model": str,
    "input_data": InputPathType,
    "help_flag": bool,
    "list_methods": bool,
    "list_models": bool,
    "list_params": bool,
    "describe_params": bool,
    "list_outputs": bool,
    "evaluate_model": typing.NotRequired[str | None],
    "evaluate_params": typing.NotRequired[list[float] | None],
    "evaluate_nt": typing.NotRequired[float | None],
    "simple_output": bool,
    "overwrite": bool,
    "link_to_latest": bool,
    "load_models": typing.NotRequired[InputPathType | None],
    "multiple_data": typing.NotRequired[list[InputPathType] | None],
    "data_order": typing.NotRequired[str | None],
    "mask": typing.NotRequired[InputPathType | None],
    "masked_time_points": typing.NotRequired[list[float] | None],
    "supplemental_data": typing.NotRequired[InputPathType | None],
    "dump_param_names": bool,
    "save_model_fit": bool,
    "save_residuals": bool,
    "save_model_extras": bool,
    "save_mvn": bool,
    "save_mean": bool,
    "save_std": bool,
    "save_variances": bool,
    "save_zstat": bool,
    "save_noise_mean": bool,
    "save_noise_std": bool,
    "save_free_energy": bool,
    "option_file": typing.NotRequired[InputPathType | None],
    "debug": bool,
})
FabberDceParamsDictTagged = typing.TypedDict('FabberDceParamsDictTagged', {
    "@type": typing.Literal["fsl/fabber_dce"],
    "output_directory": str,
    "inference_method": str,
    "forward_model": str,
    "input_data": InputPathType,
    "help_flag": bool,
    "list_methods": bool,
    "list_models": bool,
    "list_params": bool,
    "describe_params": bool,
    "list_outputs": bool,
    "evaluate_model": typing.NotRequired[str | None],
    "evaluate_params": typing.NotRequired[list[float] | None],
    "evaluate_nt": typing.NotRequired[float | None],
    "simple_output": bool,
    "overwrite": bool,
    "link_to_latest": bool,
    "load_models": typing.NotRequired[InputPathType | None],
    "multiple_data": typing.NotRequired[list[InputPathType] | None],
    "data_order": typing.NotRequired[str | None],
    "mask": typing.NotRequired[InputPathType | None],
    "masked_time_points": typing.NotRequired[list[float] | None],
    "supplemental_data": typing.NotRequired[InputPathType | None],
    "dump_param_names": bool,
    "save_model_fit": bool,
    "save_residuals": bool,
    "save_model_extras": bool,
    "save_mvn": bool,
    "save_mean": bool,
    "save_std": bool,
    "save_variances": bool,
    "save_zstat": bool,
    "save_noise_mean": bool,
    "save_noise_std": bool,
    "save_free_energy": bool,
    "option_file": typing.NotRequired[InputPathType | None],
    "debug": bool,
})
FabberDceParamsDict = _FabberDceParamsDictNoTag | FabberDceParamsDictTagged


class FabberDceOutputs(typing.NamedTuple):
    """
    Output object returned when calling `FabberDceParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_directory: OutputPathType
    """Directory containing files generated by Fabber DCE"""


def fabber_dce_params(
    output_directory: str,
    inference_method: str,
    forward_model: str,
    input_data: InputPathType,
    help_flag: bool = False,
    list_methods: bool = False,
    list_models: bool = False,
    list_params: bool = False,
    describe_params: bool = False,
    list_outputs: bool = False,
    evaluate_model: str | None = None,
    evaluate_params: list[float] | None = None,
    evaluate_nt: float | None = None,
    simple_output: bool = False,
    overwrite: bool = False,
    link_to_latest: bool = False,
    load_models: InputPathType | None = None,
    multiple_data: list[InputPathType] | None = None,
    data_order: str | None = None,
    mask: InputPathType | None = None,
    masked_time_points: list[float] | None = None,
    supplemental_data: InputPathType | None = None,
    dump_param_names: bool = False,
    save_model_fit: bool = False,
    save_residuals: bool = False,
    save_model_extras: bool = False,
    save_mvn: bool = False,
    save_mean: bool = False,
    save_std: bool = False,
    save_variances: bool = False,
    save_zstat: bool = False,
    save_noise_mean: bool = False,
    save_noise_std: bool = False,
    save_free_energy: bool = False,
    option_file: InputPathType | None = None,
    debug: bool = False,
) -> FabberDceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output_directory: Directory for output files (including logfile).
        inference_method: Inference method to use.
        forward_model: Forward model to use.
        input_data: Single input data file.
        help_flag: Print this usage message.
        list_methods: List all known inference methods.
        list_models: List all known forward models.
        list_params: List model parameters (requires model configuration\
            options to be given).
        describe_params: Describe model parameters (name, description, units) -\
            requires model configuration options to be given.
        list_outputs: List additional model outputs (requires model\
            configuration options to be given).
        evaluate_model: Evaluate model. Set to name of output required or blank\
            for default output. Requires model configuration options,\
            --evaluate-params and --evaluate-nt.
        evaluate_params: List of parameter values for evaluation.
        evaluate_nt: Number of time points for evaluation - must be consistent\
            with model options where appropriate.
        simple_output: Instead of usual output, simply output series of lines\
            each giving progress as percentage.
        overwrite: If set will overwrite existing output. If not set, new\
            output directories will be created by appending '+' to the directory\
            name.
        link_to_latest: Try to create a link to the most recent output\
            directory with the prefix _latest.
        load_models: Load models dynamically from the specified filename, which\
            should be a DLL/shared library.
        multiple_data: Specify multiple data files for n=1, 2, 3...
        data_order: If multiple data files are specified, how they will be\
            handled: concatenate = one after the other, interleave = first record\
            from each file, then second, etc.
        mask: Mask file. Inference will only be performed where mask value > 0.
        masked_time_points: List of masked time points, indexed from 1. These\
            will be ignored in the parameter updates.
        supplemental_data: 'Supplemental' timeseries data, required for some\
            models.
        dump_param_names: Write the file paramnames.txt containing the names of\
            the model parameters.
        save_model_fit: Output the model prediction as a 4D volume.
        save_residuals: Output the residuals (difference between the data and\
            the model prediction).
        save_model_extras: Output any additional model-specific timeseries data.
        save_mvn: Output the final MVN distributions.
        save_mean: Output the parameter means.
        save_std: Output the parameter standard deviations.
        save_variances: Output the parameter variances.
        save_zstat: Output the parameter Z-stats.
        save_noise_mean: Output the noise means. The noise distribution\
            inferred is the precision of a Gaussian noise source.
        save_noise_std: Output the noise standard deviations.
        save_free_energy: Output the free energy, if calculated.
        option_file: File containing additional options, one per line, in the\
            same form as specified on the command line.
        debug: Output large amounts of debug information. ONLY USE WITH VERY\
            SMALL NUMBERS OF VOXELS.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/fabber_dce",
        "output_directory": output_directory,
        "inference_method": inference_method,
        "forward_model": forward_model,
        "input_data": input_data,
        "help_flag": help_flag,
        "list_methods": list_methods,
        "list_models": list_models,
        "list_params": list_params,
        "describe_params": describe_params,
        "list_outputs": list_outputs,
        "simple_output": simple_output,
        "overwrite": overwrite,
        "link_to_latest": link_to_latest,
        "dump_param_names": dump_param_names,
        "save_model_fit": save_model_fit,
        "save_residuals": save_residuals,
        "save_model_extras": save_model_extras,
        "save_mvn": save_mvn,
        "save_mean": save_mean,
        "save_std": save_std,
        "save_variances": save_variances,
        "save_zstat": save_zstat,
        "save_noise_mean": save_noise_mean,
        "save_noise_std": save_noise_std,
        "save_free_energy": save_free_energy,
        "debug": debug,
    }
    if evaluate_model is not None:
        params["evaluate_model"] = evaluate_model
    if evaluate_params is not None:
        params["evaluate_params"] = evaluate_params
    if evaluate_nt is not None:
        params["evaluate_nt"] = evaluate_nt
    if load_models is not None:
        params["load_models"] = load_models
    if multiple_data is not None:
        params["multiple_data"] = multiple_data
    if data_order is not None:
        params["data_order"] = data_order
    if mask is not None:
        params["mask"] = mask
    if masked_time_points is not None:
        params["masked_time_points"] = masked_time_points
    if supplemental_data is not None:
        params["supplemental_data"] = supplemental_data
    if option_file is not None:
        params["option_file"] = option_file
    return params


def fabber_dce_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `FabberDceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output_directory", None) is None:
        raise StyxValidationError("`output_directory` must not be None")
    if not isinstance(params["output_directory"], str):
        raise StyxValidationError(f'`output_directory` has the wrong type: Received `{type(params.get("output_directory", None))}` expected `str`')
    if params.get("inference_method", None) is None:
        raise StyxValidationError("`inference_method` must not be None")
    if not isinstance(params["inference_method"], str):
        raise StyxValidationError(f'`inference_method` has the wrong type: Received `{type(params.get("inference_method", None))}` expected `str`')
    if params.get("forward_model", None) is None:
        raise StyxValidationError("`forward_model` must not be None")
    if not isinstance(params["forward_model"], str):
        raise StyxValidationError(f'`forward_model` has the wrong type: Received `{type(params.get("forward_model", None))}` expected `str`')
    if params.get("input_data", None) is None:
        raise StyxValidationError("`input_data` must not be None")
    if not isinstance(params["input_data"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input_data` has the wrong type: Received `{type(params.get("input_data", None))}` expected `InputPathType`')
    if params.get("help_flag", False) is None:
        raise StyxValidationError("`help_flag` must not be None")
    if not isinstance(params["help_flag"], bool):
        raise StyxValidationError(f'`help_flag` has the wrong type: Received `{type(params.get("help_flag", False))}` expected `bool`')
    if params.get("list_methods", False) is None:
        raise StyxValidationError("`list_methods` must not be None")
    if not isinstance(params["list_methods"], bool):
        raise StyxValidationError(f'`list_methods` has the wrong type: Received `{type(params.get("list_methods", False))}` expected `bool`')
    if params.get("list_models", False) is None:
        raise StyxValidationError("`list_models` must not be None")
    if not isinstance(params["list_models"], bool):
        raise StyxValidationError(f'`list_models` has the wrong type: Received `{type(params.get("list_models", False))}` expected `bool`')
    if params.get("list_params", False) is None:
        raise StyxValidationError("`list_params` must not be None")
    if not isinstance(params["list_params"], bool):
        raise StyxValidationError(f'`list_params` has the wrong type: Received `{type(params.get("list_params", False))}` expected `bool`')
    if params.get("describe_params", False) is None:
        raise StyxValidationError("`describe_params` must not be None")
    if not isinstance(params["describe_params"], bool):
        raise StyxValidationError(f'`describe_params` has the wrong type: Received `{type(params.get("describe_params", False))}` expected `bool`')
    if params.get("list_outputs", False) is None:
        raise StyxValidationError("`list_outputs` must not be None")
    if not isinstance(params["list_outputs"], bool):
        raise StyxValidationError(f'`list_outputs` has the wrong type: Received `{type(params.get("list_outputs", False))}` expected `bool`')
    if params.get("evaluate_model", None) is not None:
        if not isinstance(params["evaluate_model"], str):
            raise StyxValidationError(f'`evaluate_model` has the wrong type: Received `{type(params.get("evaluate_model", None))}` expected `str | None`')
    if params.get("evaluate_params", None) is not None:
        if not isinstance(params["evaluate_params"], list):
            raise StyxValidationError(f'`evaluate_params` has the wrong type: Received `{type(params.get("evaluate_params", None))}` expected `list[float] | None`')
        for e in params["evaluate_params"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`evaluate_params` has the wrong type: Received `{type(params.get("evaluate_params", None))}` expected `list[float] | None`')
    if params.get("evaluate_nt", None) is not None:
        if not isinstance(params["evaluate_nt"], (float, int)):
            raise StyxValidationError(f'`evaluate_nt` has the wrong type: Received `{type(params.get("evaluate_nt", None))}` expected `float | None`')
    if params.get("simple_output", False) is None:
        raise StyxValidationError("`simple_output` must not be None")
    if not isinstance(params["simple_output"], bool):
        raise StyxValidationError(f'`simple_output` has the wrong type: Received `{type(params.get("simple_output", False))}` expected `bool`')
    if params.get("overwrite", False) is None:
        raise StyxValidationError("`overwrite` must not be None")
    if not isinstance(params["overwrite"], bool):
        raise StyxValidationError(f'`overwrite` has the wrong type: Received `{type(params.get("overwrite", False))}` expected `bool`')
    if params.get("link_to_latest", False) is None:
        raise StyxValidationError("`link_to_latest` must not be None")
    if not isinstance(params["link_to_latest"], bool):
        raise StyxValidationError(f'`link_to_latest` has the wrong type: Received `{type(params.get("link_to_latest", False))}` expected `bool`')
    if params.get("load_models", None) is not None:
        if not isinstance(params["load_models"], (pathlib.Path, str)):
            raise StyxValidationError(f'`load_models` has the wrong type: Received `{type(params.get("load_models", None))}` expected `InputPathType | None`')
    if params.get("multiple_data", None) is not None:
        if not isinstance(params["multiple_data"], list):
            raise StyxValidationError(f'`multiple_data` has the wrong type: Received `{type(params.get("multiple_data", None))}` expected `list[InputPathType] | None`')
        for e in params["multiple_data"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`multiple_data` has the wrong type: Received `{type(params.get("multiple_data", None))}` expected `list[InputPathType] | None`')
    if params.get("data_order", None) is not None:
        if not isinstance(params["data_order"], str):
            raise StyxValidationError(f'`data_order` has the wrong type: Received `{type(params.get("data_order", None))}` expected `str | None`')
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType | None`')
    if params.get("masked_time_points", None) is not None:
        if not isinstance(params["masked_time_points"], list):
            raise StyxValidationError(f'`masked_time_points` has the wrong type: Received `{type(params.get("masked_time_points", None))}` expected `list[float] | None`')
        for e in params["masked_time_points"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`masked_time_points` has the wrong type: Received `{type(params.get("masked_time_points", None))}` expected `list[float] | None`')
    if params.get("supplemental_data", None) is not None:
        if not isinstance(params["supplemental_data"], (pathlib.Path, str)):
            raise StyxValidationError(f'`supplemental_data` has the wrong type: Received `{type(params.get("supplemental_data", None))}` expected `InputPathType | None`')
    if params.get("dump_param_names", False) is None:
        raise StyxValidationError("`dump_param_names` must not be None")
    if not isinstance(params["dump_param_names"], bool):
        raise StyxValidationError(f'`dump_param_names` has the wrong type: Received `{type(params.get("dump_param_names", False))}` expected `bool`')
    if params.get("save_model_fit", False) is None:
        raise StyxValidationError("`save_model_fit` must not be None")
    if not isinstance(params["save_model_fit"], bool):
        raise StyxValidationError(f'`save_model_fit` has the wrong type: Received `{type(params.get("save_model_fit", False))}` expected `bool`')
    if params.get("save_residuals", False) is None:
        raise StyxValidationError("`save_residuals` must not be None")
    if not isinstance(params["save_residuals"], bool):
        raise StyxValidationError(f'`save_residuals` has the wrong type: Received `{type(params.get("save_residuals", False))}` expected `bool`')
    if params.get("save_model_extras", False) is None:
        raise StyxValidationError("`save_model_extras` must not be None")
    if not isinstance(params["save_model_extras"], bool):
        raise StyxValidationError(f'`save_model_extras` has the wrong type: Received `{type(params.get("save_model_extras", False))}` expected `bool`')
    if params.get("save_mvn", False) is None:
        raise StyxValidationError("`save_mvn` must not be None")
    if not isinstance(params["save_mvn"], bool):
        raise StyxValidationError(f'`save_mvn` has the wrong type: Received `{type(params.get("save_mvn", False))}` expected `bool`')
    if params.get("save_mean", False) is None:
        raise StyxValidationError("`save_mean` must not be None")
    if not isinstance(params["save_mean"], bool):
        raise StyxValidationError(f'`save_mean` has the wrong type: Received `{type(params.get("save_mean", False))}` expected `bool`')
    if params.get("save_std", False) is None:
        raise StyxValidationError("`save_std` must not be None")
    if not isinstance(params["save_std"], bool):
        raise StyxValidationError(f'`save_std` has the wrong type: Received `{type(params.get("save_std", False))}` expected `bool`')
    if params.get("save_variances", False) is None:
        raise StyxValidationError("`save_variances` must not be None")
    if not isinstance(params["save_variances"], bool):
        raise StyxValidationError(f'`save_variances` has the wrong type: Received `{type(params.get("save_variances", False))}` expected `bool`')
    if params.get("save_zstat", False) is None:
        raise StyxValidationError("`save_zstat` must not be None")
    if not isinstance(params["save_zstat"], bool):
        raise StyxValidationError(f'`save_zstat` has the wrong type: Received `{type(params.get("save_zstat", False))}` expected `bool`')
    if params.get("save_noise_mean", False) is None:
        raise StyxValidationError("`save_noise_mean` must not be None")
    if not isinstance(params["save_noise_mean"], bool):
        raise StyxValidationError(f'`save_noise_mean` has the wrong type: Received `{type(params.get("save_noise_mean", False))}` expected `bool`')
    if params.get("save_noise_std", False) is None:
        raise StyxValidationError("`save_noise_std` must not be None")
    if not isinstance(params["save_noise_std"], bool):
        raise StyxValidationError(f'`save_noise_std` has the wrong type: Received `{type(params.get("save_noise_std", False))}` expected `bool`')
    if params.get("save_free_energy", False) is None:
        raise StyxValidationError("`save_free_energy` must not be None")
    if not isinstance(params["save_free_energy"], bool):
        raise StyxValidationError(f'`save_free_energy` has the wrong type: Received `{type(params.get("save_free_energy", False))}` expected `bool`')
    if params.get("option_file", None) is not None:
        if not isinstance(params["option_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`option_file` has the wrong type: Received `{type(params.get("option_file", None))}` expected `InputPathType | None`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')


def fabber_dce_cargs(
    params: FabberDceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("fabber_dce")
    cargs.extend([
        "--output",
        params.get("output_directory", None)
    ])
    cargs.extend([
        "--method",
        params.get("inference_method", None)
    ])
    cargs.extend([
        "--model",
        params.get("forward_model", None)
    ])
    cargs.extend([
        "--data",
        execution.input_file(params.get("input_data", None))
    ])
    if params.get("help_flag", False):
        cargs.append("--help")
    if params.get("list_methods", False):
        cargs.append("--listmethods")
    if params.get("list_models", False):
        cargs.append("--listmodels")
    if params.get("list_params", False):
        cargs.append("--listparams")
    if params.get("describe_params", False):
        cargs.append("--descparams")
    if params.get("list_outputs", False):
        cargs.append("--listoutputs")
    if params.get("evaluate_model", None) is not None:
        cargs.extend([
            "--evaluate",
            params.get("evaluate_model", None)
        ])
    if params.get("evaluate_params", None) is not None:
        cargs.extend([
            "--evaluate-params",
            *map(str, params.get("evaluate_params", None))
        ])
    if params.get("evaluate_nt", None) is not None:
        cargs.extend([
            "--evaluate-nt",
            str(params.get("evaluate_nt", None))
        ])
    if params.get("simple_output", False):
        cargs.append("--simple-output")
    if params.get("overwrite", False):
        cargs.append("--overwrite")
    if params.get("link_to_latest", False):
        cargs.append("--link-to-latest")
    if params.get("load_models", None) is not None:
        cargs.extend([
            "--loadmodels",
            execution.input_file(params.get("load_models", None))
        ])
    if params.get("multiple_data", None) is not None:
        cargs.extend([
            "--data<n>",
            *[execution.input_file(f) for f in params.get("multiple_data", None)]
        ])
    if params.get("data_order", None) is not None:
        cargs.extend([
            "--data-order",
            params.get("data_order", None)
        ])
    if params.get("mask", None) is not None:
        cargs.extend([
            "--mask",
            execution.input_file(params.get("mask", None))
        ])
    if params.get("masked_time_points", None) is not None:
        cargs.extend([
            "--mt<n>",
            *map(str, params.get("masked_time_points", None))
        ])
    if params.get("supplemental_data", None) is not None:
        cargs.extend([
            "--suppdata",
            execution.input_file(params.get("supplemental_data", None))
        ])
    if params.get("dump_param_names", False):
        cargs.append("--dump-param-names")
    if params.get("save_model_fit", False):
        cargs.append("--save-model-fit")
    if params.get("save_residuals", False):
        cargs.append("--save-residuals")
    if params.get("save_model_extras", False):
        cargs.append("--save-model-extras")
    if params.get("save_mvn", False):
        cargs.append("--save-mvn")
    if params.get("save_mean", False):
        cargs.append("--save-mean")
    if params.get("save_std", False):
        cargs.append("--save-std")
    if params.get("save_variances", False):
        cargs.append("--save-var")
    if params.get("save_zstat", False):
        cargs.append("--save-zstat")
    if params.get("save_noise_mean", False):
        cargs.append("--save-noise-mean")
    if params.get("save_noise_std", False):
        cargs.append("--save-noise-std")
    if params.get("save_free_energy", False):
        cargs.append("--save-free-energy")
    if params.get("option_file", None) is not None:
        cargs.extend([
            "--optfile",
            execution.input_file(params.get("option_file", None))
        ])
    if params.get("debug", False):
        cargs.append("--debug")
    return cargs


def fabber_dce_outputs(
    params: FabberDceParamsDict,
    execution: Execution,
) -> FabberDceOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = FabberDceOutputs(
        root=execution.output_file("."),
        output_directory=execution.output_file(params.get("output_directory", None)),
    )
    return ret


def fabber_dce_execute(
    params: FabberDceParamsDict,
    runner: Runner | None = None,
) -> FabberDceOutputs:
    """
    fabber_dce
    
    Fabber DCE analysis tool for model-based analysis of dynamic
    contrast-enhanced imaging data.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FabberDceOutputs`).
    """
    fabber_dce_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(FABBER_DCE_METADATA)
    params = execution.params(params)
    cargs = fabber_dce_cargs(params, execution)
    ret = fabber_dce_outputs(params, execution)
    execution.run(cargs)
    return ret


def fabber_dce(
    output_directory: str,
    inference_method: str,
    forward_model: str,
    input_data: InputPathType,
    help_flag: bool = False,
    list_methods: bool = False,
    list_models: bool = False,
    list_params: bool = False,
    describe_params: bool = False,
    list_outputs: bool = False,
    evaluate_model: str | None = None,
    evaluate_params: list[float] | None = None,
    evaluate_nt: float | None = None,
    simple_output: bool = False,
    overwrite: bool = False,
    link_to_latest: bool = False,
    load_models: InputPathType | None = None,
    multiple_data: list[InputPathType] | None = None,
    data_order: str | None = None,
    mask: InputPathType | None = None,
    masked_time_points: list[float] | None = None,
    supplemental_data: InputPathType | None = None,
    dump_param_names: bool = False,
    save_model_fit: bool = False,
    save_residuals: bool = False,
    save_model_extras: bool = False,
    save_mvn: bool = False,
    save_mean: bool = False,
    save_std: bool = False,
    save_variances: bool = False,
    save_zstat: bool = False,
    save_noise_mean: bool = False,
    save_noise_std: bool = False,
    save_free_energy: bool = False,
    option_file: InputPathType | None = None,
    debug: bool = False,
    runner: Runner | None = None,
) -> FabberDceOutputs:
    """
    fabber_dce
    
    Fabber DCE analysis tool for model-based analysis of dynamic
    contrast-enhanced imaging data.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        output_directory: Directory for output files (including logfile).
        inference_method: Inference method to use.
        forward_model: Forward model to use.
        input_data: Single input data file.
        help_flag: Print this usage message.
        list_methods: List all known inference methods.
        list_models: List all known forward models.
        list_params: List model parameters (requires model configuration\
            options to be given).
        describe_params: Describe model parameters (name, description, units) -\
            requires model configuration options to be given.
        list_outputs: List additional model outputs (requires model\
            configuration options to be given).
        evaluate_model: Evaluate model. Set to name of output required or blank\
            for default output. Requires model configuration options,\
            --evaluate-params and --evaluate-nt.
        evaluate_params: List of parameter values for evaluation.
        evaluate_nt: Number of time points for evaluation - must be consistent\
            with model options where appropriate.
        simple_output: Instead of usual output, simply output series of lines\
            each giving progress as percentage.
        overwrite: If set will overwrite existing output. If not set, new\
            output directories will be created by appending '+' to the directory\
            name.
        link_to_latest: Try to create a link to the most recent output\
            directory with the prefix _latest.
        load_models: Load models dynamically from the specified filename, which\
            should be a DLL/shared library.
        multiple_data: Specify multiple data files for n=1, 2, 3...
        data_order: If multiple data files are specified, how they will be\
            handled: concatenate = one after the other, interleave = first record\
            from each file, then second, etc.
        mask: Mask file. Inference will only be performed where mask value > 0.
        masked_time_points: List of masked time points, indexed from 1. These\
            will be ignored in the parameter updates.
        supplemental_data: 'Supplemental' timeseries data, required for some\
            models.
        dump_param_names: Write the file paramnames.txt containing the names of\
            the model parameters.
        save_model_fit: Output the model prediction as a 4D volume.
        save_residuals: Output the residuals (difference between the data and\
            the model prediction).
        save_model_extras: Output any additional model-specific timeseries data.
        save_mvn: Output the final MVN distributions.
        save_mean: Output the parameter means.
        save_std: Output the parameter standard deviations.
        save_variances: Output the parameter variances.
        save_zstat: Output the parameter Z-stats.
        save_noise_mean: Output the noise means. The noise distribution\
            inferred is the precision of a Gaussian noise source.
        save_noise_std: Output the noise standard deviations.
        save_free_energy: Output the free energy, if calculated.
        option_file: File containing additional options, one per line, in the\
            same form as specified on the command line.
        debug: Output large amounts of debug information. ONLY USE WITH VERY\
            SMALL NUMBERS OF VOXELS.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FabberDceOutputs`).
    """
    params = fabber_dce_params(
        output_directory=output_directory,
        inference_method=inference_method,
        forward_model=forward_model,
        input_data=input_data,
        help_flag=help_flag,
        list_methods=list_methods,
        list_models=list_models,
        list_params=list_params,
        describe_params=describe_params,
        list_outputs=list_outputs,
        evaluate_model=evaluate_model,
        evaluate_params=evaluate_params,
        evaluate_nt=evaluate_nt,
        simple_output=simple_output,
        overwrite=overwrite,
        link_to_latest=link_to_latest,
        load_models=load_models,
        multiple_data=multiple_data,
        data_order=data_order,
        mask=mask,
        masked_time_points=masked_time_points,
        supplemental_data=supplemental_data,
        dump_param_names=dump_param_names,
        save_model_fit=save_model_fit,
        save_residuals=save_residuals,
        save_model_extras=save_model_extras,
        save_mvn=save_mvn,
        save_mean=save_mean,
        save_std=save_std,
        save_variances=save_variances,
        save_zstat=save_zstat,
        save_noise_mean=save_noise_mean,
        save_noise_std=save_noise_std,
        save_free_energy=save_free_energy,
        option_file=option_file,
        debug=debug,
    )
    return fabber_dce_execute(params, runner)


__all__ = [
    "FABBER_DCE_METADATA",
    "FabberDceOutputs",
    "FabberDceParamsDict",
    "FabberDceParamsDictTagged",
    "fabber_dce",
    "fabber_dce_execute",
    "fabber_dce_params",
]
