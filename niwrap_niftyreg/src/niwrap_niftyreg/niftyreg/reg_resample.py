# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

REG_RESAMPLE_METADATA = Metadata(
    id="ed85cc93b3eb54e130c8763b6772b991e6af28be.boutiques",
    name="reg_resample",
    package="niftyreg",
    container_image_tag="vnmd/niftyreg_1.4.0:20220819",
)


_RegResampleParamsDictNoTag = typing.TypedDict('_RegResampleParamsDictNoTag', {
    "reference_image": InputPathType,
    "floating_image": InputPathType,
    "affine_transform": typing.NotRequired[InputPathType | None],
    "flirt_affine_transform": typing.NotRequired[InputPathType | None],
    "control_point_grid": typing.NotRequired[InputPathType | None],
    "deformation_field": typing.NotRequired[InputPathType | None],
    "resampled_image": typing.NotRequired[str | None],
    "resampled_blank": typing.NotRequired[str | None],
    "nearest_neighbor": bool,
    "linear_interpolation": bool,
})
RegResampleParamsDictTagged = typing.TypedDict('RegResampleParamsDictTagged', {
    "@type": typing.Literal["niftyreg/reg_resample"],
    "reference_image": InputPathType,
    "floating_image": InputPathType,
    "affine_transform": typing.NotRequired[InputPathType | None],
    "flirt_affine_transform": typing.NotRequired[InputPathType | None],
    "control_point_grid": typing.NotRequired[InputPathType | None],
    "deformation_field": typing.NotRequired[InputPathType | None],
    "resampled_image": typing.NotRequired[str | None],
    "resampled_blank": typing.NotRequired[str | None],
    "nearest_neighbor": bool,
    "linear_interpolation": bool,
})
RegResampleParamsDict = _RegResampleParamsDictNoTag | RegResampleParamsDictTagged


class RegResampleOutputs(typing.NamedTuple):
    """
    Output object returned when calling `RegResampleParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_resampled_image: OutputPathType | None
    """File containing the resampled image"""
    output_resampled_blank: OutputPathType | None
    """File containing the resampled blank grid"""


def reg_resample_params(
    reference_image: InputPathType,
    floating_image: InputPathType,
    affine_transform: InputPathType | None = None,
    flirt_affine_transform: InputPathType | None = None,
    control_point_grid: InputPathType | None = None,
    deformation_field: InputPathType | None = None,
    resampled_image: str | None = None,
    resampled_blank: str | None = None,
    nearest_neighbor: bool = False,
    linear_interpolation: bool = False,
) -> RegResampleParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reference_image: Filename of the reference image.
        floating_image: Filename of the floating image.
        affine_transform: Filename which contains an affine transformation\
            (Affine*Reference=Floating).
        flirt_affine_transform: Filename which contains a radiological flirt\
            affine transformation.
        control_point_grid: Filename of the control point grid image (from\
            reg_f3d).
        deformation_field: Filename of the deformation field image (from\
            reg_transform).
        resampled_image: Filename of the resampled image.
        resampled_blank: Filename of the resampled blank grid.
        nearest_neighbor: Use a Nearest Neighbor interpolation for the source\
            resampling (cubic spline by default).
        linear_interpolation: Use a Linear interpolation for the source\
            resampling (cubic spline by default).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "niftyreg/reg_resample",
        "reference_image": reference_image,
        "floating_image": floating_image,
        "nearest_neighbor": nearest_neighbor,
        "linear_interpolation": linear_interpolation,
    }
    if affine_transform is not None:
        params["affine_transform"] = affine_transform
    if flirt_affine_transform is not None:
        params["flirt_affine_transform"] = flirt_affine_transform
    if control_point_grid is not None:
        params["control_point_grid"] = control_point_grid
    if deformation_field is not None:
        params["deformation_field"] = deformation_field
    if resampled_image is not None:
        params["resampled_image"] = resampled_image
    if resampled_blank is not None:
        params["resampled_blank"] = resampled_blank
    return params


def reg_resample_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `RegResampleParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("reference_image", None) is None:
        raise StyxValidationError("`reference_image` must not be None")
    if not isinstance(params["reference_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`reference_image` has the wrong type: Received `{type(params.get("reference_image", None))}` expected `InputPathType`')
    if params.get("floating_image", None) is None:
        raise StyxValidationError("`floating_image` must not be None")
    if not isinstance(params["floating_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`floating_image` has the wrong type: Received `{type(params.get("floating_image", None))}` expected `InputPathType`')
    if params.get("affine_transform", None) is not None:
        if not isinstance(params["affine_transform"], (pathlib.Path, str)):
            raise StyxValidationError(f'`affine_transform` has the wrong type: Received `{type(params.get("affine_transform", None))}` expected `InputPathType | None`')
    if params.get("flirt_affine_transform", None) is not None:
        if not isinstance(params["flirt_affine_transform"], (pathlib.Path, str)):
            raise StyxValidationError(f'`flirt_affine_transform` has the wrong type: Received `{type(params.get("flirt_affine_transform", None))}` expected `InputPathType | None`')
    if params.get("control_point_grid", None) is not None:
        if not isinstance(params["control_point_grid"], (pathlib.Path, str)):
            raise StyxValidationError(f'`control_point_grid` has the wrong type: Received `{type(params.get("control_point_grid", None))}` expected `InputPathType | None`')
    if params.get("deformation_field", None) is not None:
        if not isinstance(params["deformation_field"], (pathlib.Path, str)):
            raise StyxValidationError(f'`deformation_field` has the wrong type: Received `{type(params.get("deformation_field", None))}` expected `InputPathType | None`')
    if params.get("resampled_image", None) is not None:
        if not isinstance(params["resampled_image"], str):
            raise StyxValidationError(f'`resampled_image` has the wrong type: Received `{type(params.get("resampled_image", None))}` expected `str | None`')
    if params.get("resampled_blank", None) is not None:
        if not isinstance(params["resampled_blank"], str):
            raise StyxValidationError(f'`resampled_blank` has the wrong type: Received `{type(params.get("resampled_blank", None))}` expected `str | None`')
    if params.get("nearest_neighbor", False) is None:
        raise StyxValidationError("`nearest_neighbor` must not be None")
    if not isinstance(params["nearest_neighbor"], bool):
        raise StyxValidationError(f'`nearest_neighbor` has the wrong type: Received `{type(params.get("nearest_neighbor", False))}` expected `bool`')
    if params.get("linear_interpolation", False) is None:
        raise StyxValidationError("`linear_interpolation` must not be None")
    if not isinstance(params["linear_interpolation"], bool):
        raise StyxValidationError(f'`linear_interpolation` has the wrong type: Received `{type(params.get("linear_interpolation", False))}` expected `bool`')


def reg_resample_cargs(
    params: RegResampleParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("reg_resample")
    cargs.extend([
        "-ref",
        execution.input_file(params.get("reference_image", None))
    ])
    cargs.extend([
        "-flo",
        execution.input_file(params.get("floating_image", None))
    ])
    if params.get("affine_transform", None) is not None:
        cargs.extend([
            "-aff",
            execution.input_file(params.get("affine_transform", None))
        ])
    if params.get("flirt_affine_transform", None) is not None:
        cargs.extend([
            "-affFlirt",
            execution.input_file(params.get("flirt_affine_transform", None))
        ])
    if params.get("control_point_grid", None) is not None:
        cargs.extend([
            "-cpp",
            execution.input_file(params.get("control_point_grid", None))
        ])
    if params.get("deformation_field", None) is not None:
        cargs.extend([
            "-def",
            execution.input_file(params.get("deformation_field", None))
        ])
    if params.get("resampled_image", None) is not None:
        cargs.extend([
            "-res",
            params.get("resampled_image", None)
        ])
    if params.get("resampled_blank", None) is not None:
        cargs.extend([
            "-blank",
            params.get("resampled_blank", None)
        ])
    if params.get("nearest_neighbor", False):
        cargs.append("-NN")
    if params.get("linear_interpolation", False):
        cargs.append("-LIN")
    return cargs


def reg_resample_outputs(
    params: RegResampleParamsDict,
    execution: Execution,
) -> RegResampleOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = RegResampleOutputs(
        root=execution.output_file("."),
        output_resampled_image=execution.output_file(params.get("resampled_image", None)) if (params.get("resampled_image") is not None) else None,
        output_resampled_blank=execution.output_file(params.get("resampled_blank", None)) if (params.get("resampled_blank") is not None) else None,
    )
    return ret


def reg_resample_execute(
    params: RegResampleParamsDict,
    runner: Runner | None = None,
) -> RegResampleOutputs:
    """
    reg_resample
    
    Tool for resampling floating images to the reference image space using
    different transformations.
    
    Author: NiftyReg Developers
    
    URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `RegResampleOutputs`).
    """
    reg_resample_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(REG_RESAMPLE_METADATA)
    params = execution.params(params)
    cargs = reg_resample_cargs(params, execution)
    ret = reg_resample_outputs(params, execution)
    execution.run(cargs)
    return ret


def reg_resample(
    reference_image: InputPathType,
    floating_image: InputPathType,
    affine_transform: InputPathType | None = None,
    flirt_affine_transform: InputPathType | None = None,
    control_point_grid: InputPathType | None = None,
    deformation_field: InputPathType | None = None,
    resampled_image: str | None = None,
    resampled_blank: str | None = None,
    nearest_neighbor: bool = False,
    linear_interpolation: bool = False,
    runner: Runner | None = None,
) -> RegResampleOutputs:
    """
    reg_resample
    
    Tool for resampling floating images to the reference image space using
    different transformations.
    
    Author: NiftyReg Developers
    
    URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
    
    Args:
        reference_image: Filename of the reference image.
        floating_image: Filename of the floating image.
        affine_transform: Filename which contains an affine transformation\
            (Affine*Reference=Floating).
        flirt_affine_transform: Filename which contains a radiological flirt\
            affine transformation.
        control_point_grid: Filename of the control point grid image (from\
            reg_f3d).
        deformation_field: Filename of the deformation field image (from\
            reg_transform).
        resampled_image: Filename of the resampled image.
        resampled_blank: Filename of the resampled blank grid.
        nearest_neighbor: Use a Nearest Neighbor interpolation for the source\
            resampling (cubic spline by default).
        linear_interpolation: Use a Linear interpolation for the source\
            resampling (cubic spline by default).
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `RegResampleOutputs`).
    """
    params = reg_resample_params(
        reference_image=reference_image,
        floating_image=floating_image,
        affine_transform=affine_transform,
        flirt_affine_transform=flirt_affine_transform,
        control_point_grid=control_point_grid,
        deformation_field=deformation_field,
        resampled_image=resampled_image,
        resampled_blank=resampled_blank,
        nearest_neighbor=nearest_neighbor,
        linear_interpolation=linear_interpolation,
    )
    return reg_resample_execute(params, runner)


__all__ = [
    "REG_RESAMPLE_METADATA",
    "RegResampleOutputs",
    "RegResampleParamsDict",
    "RegResampleParamsDictTagged",
    "reg_resample",
    "reg_resample_execute",
    "reg_resample_params",
]
