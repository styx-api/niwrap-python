# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

VOLUME_TO_SURFACE_MAPPING_METADATA = Metadata(
    id="8506ce44812c4aebe401b46dcdf27231e04f47d0.workbench",
    name="volume-to-surface-mapping",
    package="workbench",
    container_image_tag="nx10x/workbench:2.1.0",
)


_VolumeToSurfaceMappingVolumeRoiParamsDictNoTag = typing.TypedDict('_VolumeToSurfaceMappingVolumeRoiParamsDictNoTag', {
    "roi-volume": InputPathType,
    "weighted": bool,
})
VolumeToSurfaceMappingVolumeRoiParamsDictTagged = typing.TypedDict('VolumeToSurfaceMappingVolumeRoiParamsDictTagged', {
    "@type": typing.Literal["volume-roi"],
    "roi-volume": InputPathType,
    "weighted": bool,
})
VolumeToSurfaceMappingVolumeRoiParamsDict = _VolumeToSurfaceMappingVolumeRoiParamsDictNoTag | VolumeToSurfaceMappingVolumeRoiParamsDictTagged


_VolumeToSurfaceMappingDilateMissingParamsDictNoTag = typing.TypedDict('_VolumeToSurfaceMappingDilateMissingParamsDictNoTag', {
    "dist": float,
    "nearest": bool,
})
VolumeToSurfaceMappingDilateMissingParamsDictTagged = typing.TypedDict('VolumeToSurfaceMappingDilateMissingParamsDictTagged', {
    "@type": typing.Literal["dilate-missing"],
    "dist": float,
    "nearest": bool,
})
VolumeToSurfaceMappingDilateMissingParamsDict = _VolumeToSurfaceMappingDilateMissingParamsDictNoTag | VolumeToSurfaceMappingDilateMissingParamsDictTagged


_VolumeToSurfaceMappingBadVerticesOutParamsDictNoTag = typing.TypedDict('_VolumeToSurfaceMappingBadVerticesOutParamsDictNoTag', {
    "roi-out": str,
})
VolumeToSurfaceMappingBadVerticesOutParamsDictTagged = typing.TypedDict('VolumeToSurfaceMappingBadVerticesOutParamsDictTagged', {
    "@type": typing.Literal["bad-vertices-out"],
    "roi-out": str,
})
VolumeToSurfaceMappingBadVerticesOutParamsDict = _VolumeToSurfaceMappingBadVerticesOutParamsDictNoTag | VolumeToSurfaceMappingBadVerticesOutParamsDictTagged


_VolumeToSurfaceMappingOutputWeightsParamsDictNoTag = typing.TypedDict('_VolumeToSurfaceMappingOutputWeightsParamsDictNoTag', {
    "vertex": int,
    "weights-out": str,
})
VolumeToSurfaceMappingOutputWeightsParamsDictTagged = typing.TypedDict('VolumeToSurfaceMappingOutputWeightsParamsDictTagged', {
    "@type": typing.Literal["output-weights"],
    "vertex": int,
    "weights-out": str,
})
VolumeToSurfaceMappingOutputWeightsParamsDict = _VolumeToSurfaceMappingOutputWeightsParamsDictNoTag | VolumeToSurfaceMappingOutputWeightsParamsDictTagged


_VolumeToSurfaceMappingRibbonConstrainedParamsDictNoTag = typing.TypedDict('_VolumeToSurfaceMappingRibbonConstrainedParamsDictNoTag', {
    "inner-surf": InputPathType,
    "outer-surf": InputPathType,
    "volume-roi": typing.NotRequired[VolumeToSurfaceMappingVolumeRoiParamsDict | None],
    "dilate-missing": typing.NotRequired[VolumeToSurfaceMappingDilateMissingParamsDict | None],
    "bad-vertices-out": typing.NotRequired[VolumeToSurfaceMappingBadVerticesOutParamsDict | None],
    "output-weights": typing.NotRequired[VolumeToSurfaceMappingOutputWeightsParamsDict | None],
    "text-out": typing.NotRequired[str | None],
    "method": typing.NotRequired[str | None],
    "scale": typing.NotRequired[float | None],
    "subdiv-num": typing.NotRequired[int | None],
    "thin-columns": bool,
})
VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged = typing.TypedDict('VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged', {
    "@type": typing.Literal["ribbon-constrained"],
    "inner-surf": InputPathType,
    "outer-surf": InputPathType,
    "volume-roi": typing.NotRequired[VolumeToSurfaceMappingVolumeRoiParamsDict | None],
    "dilate-missing": typing.NotRequired[VolumeToSurfaceMappingDilateMissingParamsDict | None],
    "bad-vertices-out": typing.NotRequired[VolumeToSurfaceMappingBadVerticesOutParamsDict | None],
    "output-weights": typing.NotRequired[VolumeToSurfaceMappingOutputWeightsParamsDict | None],
    "text-out": typing.NotRequired[str | None],
    "method": typing.NotRequired[str | None],
    "scale": typing.NotRequired[float | None],
    "subdiv-num": typing.NotRequired[int | None],
    "thin-columns": bool,
})
VolumeToSurfaceMappingRibbonConstrainedParamsDict = _VolumeToSurfaceMappingRibbonConstrainedParamsDictNoTag | VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged


_VolumeToSurfaceMappingMyelinStyleParamsDictNoTag = typing.TypedDict('_VolumeToSurfaceMappingMyelinStyleParamsDictNoTag', {
    "ribbon-roi": InputPathType,
    "thickness": InputPathType,
    "sigma": float,
    "legacy-bug": bool,
})
VolumeToSurfaceMappingMyelinStyleParamsDictTagged = typing.TypedDict('VolumeToSurfaceMappingMyelinStyleParamsDictTagged', {
    "@type": typing.Literal["myelin-style"],
    "ribbon-roi": InputPathType,
    "thickness": InputPathType,
    "sigma": float,
    "legacy-bug": bool,
})
VolumeToSurfaceMappingMyelinStyleParamsDict = _VolumeToSurfaceMappingMyelinStyleParamsDictNoTag | VolumeToSurfaceMappingMyelinStyleParamsDictTagged


_VolumeToSurfaceMappingParamsDictNoTag = typing.TypedDict('_VolumeToSurfaceMappingParamsDictNoTag', {
    "volume": InputPathType,
    "surface": InputPathType,
    "metric-out": str,
    "ribbon-constrained": typing.NotRequired[VolumeToSurfaceMappingRibbonConstrainedParamsDict | None],
    "myelin-style": typing.NotRequired[VolumeToSurfaceMappingMyelinStyleParamsDict | None],
    "subvol": typing.NotRequired[str | None],
    "cubic": bool,
    "enclosing": bool,
    "trilinear": bool,
})
VolumeToSurfaceMappingParamsDictTagged = typing.TypedDict('VolumeToSurfaceMappingParamsDictTagged', {
    "@type": typing.Literal["workbench/volume-to-surface-mapping"],
    "volume": InputPathType,
    "surface": InputPathType,
    "metric-out": str,
    "ribbon-constrained": typing.NotRequired[VolumeToSurfaceMappingRibbonConstrainedParamsDict | None],
    "myelin-style": typing.NotRequired[VolumeToSurfaceMappingMyelinStyleParamsDict | None],
    "subvol": typing.NotRequired[str | None],
    "cubic": bool,
    "enclosing": bool,
    "trilinear": bool,
})
VolumeToSurfaceMappingParamsDict = _VolumeToSurfaceMappingParamsDictNoTag | VolumeToSurfaceMappingParamsDictTagged


def volume_to_surface_mapping_volume_roi(
    roi_volume: InputPathType,
    weighted: bool = False,
) -> VolumeToSurfaceMappingVolumeRoiParamsDictTagged:
    """
    Build parameters.
    
    Args:
        roi_volume: the roi volume file.
        weighted: treat the roi values as weightings rather than binary.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "volume-roi",
        "roi-volume": roi_volume,
        "weighted": weighted,
    }
    return params


def volume_to_surface_mapping_volume_roi_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `VolumeToSurfaceMappingVolumeRoiParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("roi-volume", None) is None:
        raise StyxValidationError("`roi-volume` must not be None")
    if not isinstance(params["roi-volume"], (pathlib.Path, str)):
        raise StyxValidationError(f'`roi-volume` has the wrong type: Received `{type(params.get("roi-volume", None))}` expected `InputPathType`')
    if params.get("weighted", False) is None:
        raise StyxValidationError("`weighted` must not be None")
    if not isinstance(params["weighted"], bool):
        raise StyxValidationError(f'`weighted` has the wrong type: Received `{type(params.get("weighted", False))}` expected `bool`')


def volume_to_surface_mapping_volume_roi_cargs(
    params: VolumeToSurfaceMappingVolumeRoiParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-volume-roi",
        execution.input_file(params.get("roi-volume", None))
    ])
    if params.get("weighted", False):
        cargs.append("-weighted")
    return cargs


def volume_to_surface_mapping_dilate_missing(
    dist: float,
    nearest: bool = False,
) -> VolumeToSurfaceMappingDilateMissingParamsDictTagged:
    """
    Build parameters.
    
    Args:
        dist: distance in mm for dilation (can be small, like 1mm).
        nearest: use nearest neighbor dilation (mainly useful for integer data).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "dilate-missing",
        "dist": dist,
        "nearest": nearest,
    }
    return params


def volume_to_surface_mapping_dilate_missing_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `VolumeToSurfaceMappingDilateMissingParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dist", None) is None:
        raise StyxValidationError("`dist` must not be None")
    if not isinstance(params["dist"], (float, int)):
        raise StyxValidationError(f'`dist` has the wrong type: Received `{type(params.get("dist", None))}` expected `float`')
    if params.get("nearest", False) is None:
        raise StyxValidationError("`nearest` must not be None")
    if not isinstance(params["nearest"], bool):
        raise StyxValidationError(f'`nearest` has the wrong type: Received `{type(params.get("nearest", False))}` expected `bool`')


def volume_to_surface_mapping_dilate_missing_cargs(
    params: VolumeToSurfaceMappingDilateMissingParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-dilate-missing",
        str(params.get("dist", None))
    ])
    if params.get("nearest", False):
        cargs.append("-nearest")
    return cargs


class VolumeToSurfaceMappingBadVerticesOutOutputs(typing.NamedTuple):
    """
    Output object returned when calling `VolumeToSurfaceMappingBadVerticesOutParamsDict | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    roi_out: OutputPathType
    """the output metric file of vertices that have no data"""


def volume_to_surface_mapping_bad_vertices_out(
    roi_out: str,
) -> VolumeToSurfaceMappingBadVerticesOutParamsDictTagged:
    """
    Build parameters.
    
    Args:
        roi_out: the output metric file of vertices that have no data.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "bad-vertices-out",
        "roi-out": roi_out,
    }
    return params


def volume_to_surface_mapping_bad_vertices_out_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `VolumeToSurfaceMappingBadVerticesOutParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("roi-out", None) is None:
        raise StyxValidationError("`roi-out` must not be None")
    if not isinstance(params["roi-out"], str):
        raise StyxValidationError(f'`roi-out` has the wrong type: Received `{type(params.get("roi-out", None))}` expected `str`')


def volume_to_surface_mapping_bad_vertices_out_cargs(
    params: VolumeToSurfaceMappingBadVerticesOutParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-bad-vertices-out",
        params.get("roi-out", None)
    ])
    return cargs


def volume_to_surface_mapping_bad_vertices_out_outputs(
    params: VolumeToSurfaceMappingBadVerticesOutParamsDict,
    execution: Execution,
) -> VolumeToSurfaceMappingBadVerticesOutOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = VolumeToSurfaceMappingBadVerticesOutOutputs(
        root=execution.output_file("."),
        roi_out=execution.output_file(params.get("roi-out", None)),
    )
    return ret


class VolumeToSurfaceMappingOutputWeightsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `VolumeToSurfaceMappingOutputWeightsParamsDict | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    weights_out: OutputPathType
    """volume to write the weights to"""


def volume_to_surface_mapping_output_weights(
    vertex: int,
    weights_out: str,
) -> VolumeToSurfaceMappingOutputWeightsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        vertex: the vertex number to get the voxel weights for, 0-based.
        weights_out: volume to write the weights to.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "output-weights",
        "vertex": vertex,
        "weights-out": weights_out,
    }
    return params


def volume_to_surface_mapping_output_weights_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `VolumeToSurfaceMappingOutputWeightsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("vertex", None) is None:
        raise StyxValidationError("`vertex` must not be None")
    if not isinstance(params["vertex"], int):
        raise StyxValidationError(f'`vertex` has the wrong type: Received `{type(params.get("vertex", None))}` expected `int`')
    if params.get("weights-out", None) is None:
        raise StyxValidationError("`weights-out` must not be None")
    if not isinstance(params["weights-out"], str):
        raise StyxValidationError(f'`weights-out` has the wrong type: Received `{type(params.get("weights-out", None))}` expected `str`')


def volume_to_surface_mapping_output_weights_cargs(
    params: VolumeToSurfaceMappingOutputWeightsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-output-weights",
        str(params.get("vertex", None)),
        params.get("weights-out", None)
    ])
    return cargs


def volume_to_surface_mapping_output_weights_outputs(
    params: VolumeToSurfaceMappingOutputWeightsParamsDict,
    execution: Execution,
) -> VolumeToSurfaceMappingOutputWeightsOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = VolumeToSurfaceMappingOutputWeightsOutputs(
        root=execution.output_file("."),
        weights_out=execution.output_file(params.get("weights-out", None)),
    )
    return ret


class VolumeToSurfaceMappingRibbonConstrainedOutputs(typing.NamedTuple):
    """
    Output object returned when calling `VolumeToSurfaceMappingRibbonConstrainedParamsDict | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    bad_vertices_out: VolumeToSurfaceMappingBadVerticesOutOutputs | None
    """Outputs from `volume_to_surface_mapping_bad_vertices_out_outputs`."""
    output_weights: VolumeToSurfaceMappingOutputWeightsOutputs | None
    """Outputs from `volume_to_surface_mapping_output_weights_outputs`."""


def volume_to_surface_mapping_ribbon_constrained(
    inner_surf: InputPathType,
    outer_surf: InputPathType,
    volume_roi: VolumeToSurfaceMappingVolumeRoiParamsDict | None = None,
    dilate_missing: VolumeToSurfaceMappingDilateMissingParamsDict | None = None,
    bad_vertices_out: VolumeToSurfaceMappingBadVerticesOutParamsDict | None = None,
    output_weights: VolumeToSurfaceMappingOutputWeightsParamsDict | None = None,
    text_out: str | None = None,
    method: str | None = None,
    scale: float | None = None,
    subdiv_num: int | None = None,
    thin_columns: bool = False,
) -> VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged:
    """
    Build parameters.
    
    Args:
        inner_surf: the inner surface of the ribbon.
        outer_surf: the outer surface of the ribbon.
        volume_roi: use a volume roi.
        dilate_missing: use dilation for small vertices that 'missed' the\
            geometry tests.
        bad_vertices_out: output an ROI of which vertices didn't intersect any\
            valid voxels.
        output_weights: write the voxel weights for a vertex to a volume file.
        text_out: write the voxel weights for all vertices to a text file\
            \
            output - the output text filename.
        method: instead of a weighted average of voxels, interpolate at\
            subpoints inside the ribbon\
            \
            interpolation method, must be CUBIC, ENCLOSING_VOXEL, or TRILINEAR.
        scale: reduce weight to voxels that aren't near <surface>\
            \
            value to multiply the local thickness by, to get the gaussian sigma.
        subdiv_num: voxel divisions while estimating voxel weights\
            \
            number of subdivisions, default 3.
        thin_columns: use non-overlapping polyhedra.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ribbon-constrained",
        "inner-surf": inner_surf,
        "outer-surf": outer_surf,
        "thin-columns": thin_columns,
    }
    if volume_roi is not None:
        params["volume-roi"] = volume_roi
    if dilate_missing is not None:
        params["dilate-missing"] = dilate_missing
    if bad_vertices_out is not None:
        params["bad-vertices-out"] = bad_vertices_out
    if output_weights is not None:
        params["output-weights"] = output_weights
    if text_out is not None:
        params["text-out"] = text_out
    if method is not None:
        params["method"] = method
    if scale is not None:
        params["scale"] = scale
    if subdiv_num is not None:
        params["subdiv-num"] = subdiv_num
    return params


def volume_to_surface_mapping_ribbon_constrained_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `VolumeToSurfaceMappingRibbonConstrainedParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("inner-surf", None) is None:
        raise StyxValidationError("`inner-surf` must not be None")
    if not isinstance(params["inner-surf"], (pathlib.Path, str)):
        raise StyxValidationError(f'`inner-surf` has the wrong type: Received `{type(params.get("inner-surf", None))}` expected `InputPathType`')
    if params.get("outer-surf", None) is None:
        raise StyxValidationError("`outer-surf` must not be None")
    if not isinstance(params["outer-surf"], (pathlib.Path, str)):
        raise StyxValidationError(f'`outer-surf` has the wrong type: Received `{type(params.get("outer-surf", None))}` expected `InputPathType`')
    if params.get("volume-roi", None) is not None:
        volume_to_surface_mapping_volume_roi_validate(params["volume-roi"])
    if params.get("dilate-missing", None) is not None:
        volume_to_surface_mapping_dilate_missing_validate(params["dilate-missing"])
    if params.get("bad-vertices-out", None) is not None:
        volume_to_surface_mapping_bad_vertices_out_validate(params["bad-vertices-out"])
    if params.get("output-weights", None) is not None:
        volume_to_surface_mapping_output_weights_validate(params["output-weights"])
    if params.get("text-out", None) is not None:
        if not isinstance(params["text-out"], str):
            raise StyxValidationError(f'`text-out` has the wrong type: Received `{type(params.get("text-out", None))}` expected `str | None`')
    if params.get("method", None) is not None:
        if not isinstance(params["method"], str):
            raise StyxValidationError(f'`method` has the wrong type: Received `{type(params.get("method", None))}` expected `str | None`')
    if params.get("scale", None) is not None:
        if not isinstance(params["scale"], (float, int)):
            raise StyxValidationError(f'`scale` has the wrong type: Received `{type(params.get("scale", None))}` expected `float | None`')
    if params.get("subdiv-num", None) is not None:
        if not isinstance(params["subdiv-num"], int):
            raise StyxValidationError(f'`subdiv-num` has the wrong type: Received `{type(params.get("subdiv-num", None))}` expected `int | None`')
    if params.get("thin-columns", False) is None:
        raise StyxValidationError("`thin-columns` must not be None")
    if not isinstance(params["thin-columns"], bool):
        raise StyxValidationError(f'`thin-columns` has the wrong type: Received `{type(params.get("thin-columns", False))}` expected `bool`')


def volume_to_surface_mapping_ribbon_constrained_cargs(
    params: VolumeToSurfaceMappingRibbonConstrainedParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-ribbon-constrained",
        execution.input_file(params.get("inner-surf", None)),
        execution.input_file(params.get("outer-surf", None)),
        *(volume_to_surface_mapping_volume_roi_cargs(params.get("volume-roi", None), execution) if (params.get("volume-roi", None) is not None) else []),
        *(volume_to_surface_mapping_dilate_missing_cargs(params.get("dilate-missing", None), execution) if (params.get("dilate-missing", None) is not None) else []),
        *(volume_to_surface_mapping_bad_vertices_out_cargs(params.get("bad-vertices-out", None), execution) if (params.get("bad-vertices-out", None) is not None) else []),
        *(volume_to_surface_mapping_output_weights_cargs(params.get("output-weights", None), execution) if (params.get("output-weights", None) is not None) else [])
    ])
    if params.get("text-out", None) is not None:
        cargs.extend([
            "-output-weights-text",
            params.get("text-out", None)
        ])
    if params.get("method", None) is not None:
        cargs.extend([
            "-interpolate",
            params.get("method", None)
        ])
    if params.get("scale", None) is not None:
        cargs.extend([
            "-gaussian",
            str(params.get("scale", None))
        ])
    if params.get("subdiv-num", None) is not None:
        cargs.extend([
            "-voxel-subdiv",
            str(params.get("subdiv-num", None))
        ])
    if params.get("thin-columns", False):
        cargs.append("-thin-columns")
    return cargs


def volume_to_surface_mapping_ribbon_constrained_outputs(
    params: VolumeToSurfaceMappingRibbonConstrainedParamsDict,
    execution: Execution,
) -> VolumeToSurfaceMappingRibbonConstrainedOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = VolumeToSurfaceMappingRibbonConstrainedOutputs(
        root=execution.output_file("."),
        bad_vertices_out=volume_to_surface_mapping_bad_vertices_out_outputs(params.get("bad-vertices-out"), execution) if params.get("bad-vertices-out") else None,
        output_weights=volume_to_surface_mapping_output_weights_outputs(params.get("output-weights"), execution) if params.get("output-weights") else None,
    )
    return ret


def volume_to_surface_mapping_myelin_style(
    ribbon_roi: InputPathType,
    thickness: InputPathType,
    sigma: float,
    legacy_bug: bool = False,
) -> VolumeToSurfaceMappingMyelinStyleParamsDictTagged:
    """
    Build parameters.
    
    Args:
        ribbon_roi: an roi volume of the cortical ribbon for this hemisphere.
        thickness: a metric file of cortical thickness.
        sigma: gaussian kernel in mm for weighting voxels within range.
        legacy_bug: emulate old v1.2.3 and earlier code that didn't follow a\
            cylinder cutoff.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "myelin-style",
        "ribbon-roi": ribbon_roi,
        "thickness": thickness,
        "sigma": sigma,
        "legacy-bug": legacy_bug,
    }
    return params


def volume_to_surface_mapping_myelin_style_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `VolumeToSurfaceMappingMyelinStyleParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("ribbon-roi", None) is None:
        raise StyxValidationError("`ribbon-roi` must not be None")
    if not isinstance(params["ribbon-roi"], (pathlib.Path, str)):
        raise StyxValidationError(f'`ribbon-roi` has the wrong type: Received `{type(params.get("ribbon-roi", None))}` expected `InputPathType`')
    if params.get("thickness", None) is None:
        raise StyxValidationError("`thickness` must not be None")
    if not isinstance(params["thickness"], (pathlib.Path, str)):
        raise StyxValidationError(f'`thickness` has the wrong type: Received `{type(params.get("thickness", None))}` expected `InputPathType`')
    if params.get("sigma", None) is None:
        raise StyxValidationError("`sigma` must not be None")
    if not isinstance(params["sigma"], (float, int)):
        raise StyxValidationError(f'`sigma` has the wrong type: Received `{type(params.get("sigma", None))}` expected `float`')
    if params.get("legacy-bug", False) is None:
        raise StyxValidationError("`legacy-bug` must not be None")
    if not isinstance(params["legacy-bug"], bool):
        raise StyxValidationError(f'`legacy-bug` has the wrong type: Received `{type(params.get("legacy-bug", False))}` expected `bool`')


def volume_to_surface_mapping_myelin_style_cargs(
    params: VolumeToSurfaceMappingMyelinStyleParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-myelin-style",
        execution.input_file(params.get("ribbon-roi", None)),
        execution.input_file(params.get("thickness", None)),
        str(params.get("sigma", None))
    ])
    if params.get("legacy-bug", False):
        cargs.append("-legacy-bug")
    return cargs


class VolumeToSurfaceMappingOutputs(typing.NamedTuple):
    """
    Output object returned when calling `VolumeToSurfaceMappingParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    metric_out: OutputPathType
    """the output metric file"""
    ribbon_constrained: VolumeToSurfaceMappingRibbonConstrainedOutputs | None
    """Outputs from `volume_to_surface_mapping_ribbon_constrained_outputs`."""


def volume_to_surface_mapping_params(
    volume: InputPathType,
    surface: InputPathType,
    metric_out: str,
    ribbon_constrained: VolumeToSurfaceMappingRibbonConstrainedParamsDict | None = None,
    myelin_style: VolumeToSurfaceMappingMyelinStyleParamsDict | None = None,
    subvol: str | None = None,
    cubic: bool = False,
    enclosing: bool = False,
    trilinear: bool = False,
) -> VolumeToSurfaceMappingParamsDictTagged:
    """
    Build parameters.
    
    Args:
        volume: the volume to map data from.
        surface: the surface to map the data onto.
        metric_out: the output metric file.
        ribbon_constrained: use ribbon constrained mapping algorithm.
        myelin_style: use the method from myelin mapping.
        subvol: select a single subvolume to map\
            \
            the subvolume number or name.
        cubic: use cubic splines.
        enclosing: use value of the enclosing voxel.
        trilinear: use trilinear volume interpolation.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "workbench/volume-to-surface-mapping",
        "volume": volume,
        "surface": surface,
        "metric-out": metric_out,
        "cubic": cubic,
        "enclosing": enclosing,
        "trilinear": trilinear,
    }
    if ribbon_constrained is not None:
        params["ribbon-constrained"] = ribbon_constrained
    if myelin_style is not None:
        params["myelin-style"] = myelin_style
    if subvol is not None:
        params["subvol"] = subvol
    return params


def volume_to_surface_mapping_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `VolumeToSurfaceMappingParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("volume", None) is None:
        raise StyxValidationError("`volume` must not be None")
    if not isinstance(params["volume"], (pathlib.Path, str)):
        raise StyxValidationError(f'`volume` has the wrong type: Received `{type(params.get("volume", None))}` expected `InputPathType`')
    if params.get("surface", None) is None:
        raise StyxValidationError("`surface` must not be None")
    if not isinstance(params["surface"], (pathlib.Path, str)):
        raise StyxValidationError(f'`surface` has the wrong type: Received `{type(params.get("surface", None))}` expected `InputPathType`')
    if params.get("metric-out", None) is None:
        raise StyxValidationError("`metric-out` must not be None")
    if not isinstance(params["metric-out"], str):
        raise StyxValidationError(f'`metric-out` has the wrong type: Received `{type(params.get("metric-out", None))}` expected `str`')
    if params.get("ribbon-constrained", None) is not None:
        volume_to_surface_mapping_ribbon_constrained_validate(params["ribbon-constrained"])
    if params.get("myelin-style", None) is not None:
        volume_to_surface_mapping_myelin_style_validate(params["myelin-style"])
    if params.get("subvol", None) is not None:
        if not isinstance(params["subvol"], str):
            raise StyxValidationError(f'`subvol` has the wrong type: Received `{type(params.get("subvol", None))}` expected `str | None`')
    if params.get("cubic", False) is None:
        raise StyxValidationError("`cubic` must not be None")
    if not isinstance(params["cubic"], bool):
        raise StyxValidationError(f'`cubic` has the wrong type: Received `{type(params.get("cubic", False))}` expected `bool`')
    if params.get("enclosing", False) is None:
        raise StyxValidationError("`enclosing` must not be None")
    if not isinstance(params["enclosing"], bool):
        raise StyxValidationError(f'`enclosing` has the wrong type: Received `{type(params.get("enclosing", False))}` expected `bool`')
    if params.get("trilinear", False) is None:
        raise StyxValidationError("`trilinear` must not be None")
    if not isinstance(params["trilinear"], bool):
        raise StyxValidationError(f'`trilinear` has the wrong type: Received `{type(params.get("trilinear", False))}` expected `bool`')


def volume_to_surface_mapping_cargs(
    params: VolumeToSurfaceMappingParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "wb_command",
        "-volume-to-surface-mapping"
    ])
    cargs.append(execution.input_file(params.get("volume", None)))
    cargs.append(execution.input_file(params.get("surface", None)))
    cargs.append(params.get("metric-out", None))
    if params.get("ribbon-constrained", None) is not None or params.get("myelin-style", None) is not None:
        cargs.extend([
            *(volume_to_surface_mapping_ribbon_constrained_cargs(params.get("ribbon-constrained", None), execution) if (params.get("ribbon-constrained", None) is not None) else []),
            *(volume_to_surface_mapping_myelin_style_cargs(params.get("myelin-style", None), execution) if (params.get("myelin-style", None) is not None) else [])
        ])
    if params.get("subvol", None) is not None:
        cargs.extend([
            "-subvol-select",
            params.get("subvol", None)
        ])
    if params.get("cubic", False):
        cargs.append("-cubic")
    if params.get("enclosing", False):
        cargs.append("-enclosing")
    if params.get("trilinear", False):
        cargs.append("-trilinear")
    return cargs


def volume_to_surface_mapping_outputs(
    params: VolumeToSurfaceMappingParamsDict,
    execution: Execution,
) -> VolumeToSurfaceMappingOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = VolumeToSurfaceMappingOutputs(
        root=execution.output_file("."),
        metric_out=execution.output_file(params.get("metric-out", None)),
        ribbon_constrained=volume_to_surface_mapping_ribbon_constrained_outputs(params.get("ribbon-constrained"), execution) if params.get("ribbon-constrained") else None,
    )
    return ret


def volume_to_surface_mapping_execute(
    params: VolumeToSurfaceMappingParamsDict,
    runner: Runner | None = None,
) -> VolumeToSurfaceMappingOutputs:
    """
    MAP VOLUME TO SURFACE.
    
    You must specify exactly one mapping method. Enclosing voxel uses the value
    from the voxel the vertex lies inside, while trilinear does a 3D linear
    interpolation based on the voxels immediately on each side of the vertex's
    position.
    
    The ribbon mapping method constructs a polyhedron from the vertex's
    neighbors on each surface, and estimates the amount of this polyhedron's
    volume that falls inside any nearby voxels, to use as the weights for
    sampling. If -thin-columns is specified, the polyhedron uses the edge
    midpoints and triangle centroids, so that neighboring vertices do not have
    overlapping polyhedra. This may require increasing -voxel-subdiv to get
    enough samples in each voxel to reliably land inside these smaller
    polyhedra. The volume ROI is useful to exclude partial volume effects of
    voxels the surfaces pass through, and will cause the mapping to ignore
    voxels that don't have a positive value in the mask. The subdivision number
    specifies how it approximates the amount of the volume the polyhedron
    intersects, by splitting each voxel into NxNxN pieces, and checking whether
    the center of each piece is inside the polyhedron. If you have very large
    voxels, consider increasing this if you get zeros in your output. The
    -gaussian option makes it act more like the myelin method, where the
    distance of a voxel from <surface> is used to downweight the voxel. The
    -interpolate suboption, instead of doing a weighted average of voxels,
    interpolates from the volume at the subdivided points inside the ribbon. If
    using both -interpolate and the -weighted suboption to -volume-roi, the roi
    volume weights are linearly interpolated, unless the -interpolate method is
    ENCLOSING_VOXEL, in which case ENCLOSING_VOXEL is also used for sampling the
    roi volume weights.
    
    The myelin style method uses part of the caret5 myelin mapping command to do
    the mapping: for each surface vertex, take all voxels that are in a cylinder
    with radius and height equal to cortical thickness, centered on the vertex
    and aligned with the surface normal, and that are also within the ribbon
    ROI, and apply a gaussian kernel with the specified sigma to them to get the
    weights to use. The -legacy-bug flag reverts to the unintended behavior
    present from the initial implementation up to and including v1.2.3, which
    had only the tangential cutoff and a bounding box intended to be larger than
    where the cylinder cutoff should have been.
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `VolumeToSurfaceMappingOutputs`).
    """
    volume_to_surface_mapping_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(VOLUME_TO_SURFACE_MAPPING_METADATA)
    params = execution.params(params)
    cargs = volume_to_surface_mapping_cargs(params, execution)
    ret = volume_to_surface_mapping_outputs(params, execution)
    execution.run(cargs)
    return ret


def volume_to_surface_mapping(
    volume: InputPathType,
    surface: InputPathType,
    metric_out: str,
    ribbon_constrained: VolumeToSurfaceMappingRibbonConstrainedParamsDict | None = None,
    myelin_style: VolumeToSurfaceMappingMyelinStyleParamsDict | None = None,
    subvol: str | None = None,
    cubic: bool = False,
    enclosing: bool = False,
    trilinear: bool = False,
    runner: Runner | None = None,
) -> VolumeToSurfaceMappingOutputs:
    """
    MAP VOLUME TO SURFACE.
    
    You must specify exactly one mapping method. Enclosing voxel uses the value
    from the voxel the vertex lies inside, while trilinear does a 3D linear
    interpolation based on the voxels immediately on each side of the vertex's
    position.
    
    The ribbon mapping method constructs a polyhedron from the vertex's
    neighbors on each surface, and estimates the amount of this polyhedron's
    volume that falls inside any nearby voxels, to use as the weights for
    sampling. If -thin-columns is specified, the polyhedron uses the edge
    midpoints and triangle centroids, so that neighboring vertices do not have
    overlapping polyhedra. This may require increasing -voxel-subdiv to get
    enough samples in each voxel to reliably land inside these smaller
    polyhedra. The volume ROI is useful to exclude partial volume effects of
    voxels the surfaces pass through, and will cause the mapping to ignore
    voxels that don't have a positive value in the mask. The subdivision number
    specifies how it approximates the amount of the volume the polyhedron
    intersects, by splitting each voxel into NxNxN pieces, and checking whether
    the center of each piece is inside the polyhedron. If you have very large
    voxels, consider increasing this if you get zeros in your output. The
    -gaussian option makes it act more like the myelin method, where the
    distance of a voxel from <surface> is used to downweight the voxel. The
    -interpolate suboption, instead of doing a weighted average of voxels,
    interpolates from the volume at the subdivided points inside the ribbon. If
    using both -interpolate and the -weighted suboption to -volume-roi, the roi
    volume weights are linearly interpolated, unless the -interpolate method is
    ENCLOSING_VOXEL, in which case ENCLOSING_VOXEL is also used for sampling the
    roi volume weights.
    
    The myelin style method uses part of the caret5 myelin mapping command to do
    the mapping: for each surface vertex, take all voxels that are in a cylinder
    with radius and height equal to cortical thickness, centered on the vertex
    and aligned with the surface normal, and that are also within the ribbon
    ROI, and apply a gaussian kernel with the specified sigma to them to get the
    weights to use. The -legacy-bug flag reverts to the unintended behavior
    present from the initial implementation up to and including v1.2.3, which
    had only the tangential cutoff and a bounding box intended to be larger than
    where the cylinder cutoff should have been.
    
    Args:
        volume: the volume to map data from.
        surface: the surface to map the data onto.
        metric_out: the output metric file.
        ribbon_constrained: use ribbon constrained mapping algorithm.
        myelin_style: use the method from myelin mapping.
        subvol: select a single subvolume to map\
            \
            the subvolume number or name.
        cubic: use cubic splines.
        enclosing: use value of the enclosing voxel.
        trilinear: use trilinear volume interpolation.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `VolumeToSurfaceMappingOutputs`).
    """
    params = volume_to_surface_mapping_params(
        volume=volume,
        surface=surface,
        metric_out=metric_out,
        ribbon_constrained=ribbon_constrained,
        myelin_style=myelin_style,
        subvol=subvol,
        cubic=cubic,
        enclosing=enclosing,
        trilinear=trilinear,
    )
    return volume_to_surface_mapping_execute(params, runner)


__all__ = [
    "VOLUME_TO_SURFACE_MAPPING_METADATA",
    "VolumeToSurfaceMappingBadVerticesOutOutputs",
    "VolumeToSurfaceMappingBadVerticesOutParamsDict",
    "VolumeToSurfaceMappingBadVerticesOutParamsDictTagged",
    "VolumeToSurfaceMappingDilateMissingParamsDict",
    "VolumeToSurfaceMappingDilateMissingParamsDictTagged",
    "VolumeToSurfaceMappingMyelinStyleParamsDict",
    "VolumeToSurfaceMappingMyelinStyleParamsDictTagged",
    "VolumeToSurfaceMappingOutputWeightsOutputs",
    "VolumeToSurfaceMappingOutputWeightsParamsDict",
    "VolumeToSurfaceMappingOutputWeightsParamsDictTagged",
    "VolumeToSurfaceMappingOutputs",
    "VolumeToSurfaceMappingParamsDict",
    "VolumeToSurfaceMappingParamsDictTagged",
    "VolumeToSurfaceMappingRibbonConstrainedOutputs",
    "VolumeToSurfaceMappingRibbonConstrainedParamsDict",
    "VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged",
    "VolumeToSurfaceMappingVolumeRoiParamsDict",
    "VolumeToSurfaceMappingVolumeRoiParamsDictTagged",
    "volume_to_surface_mapping",
    "volume_to_surface_mapping_bad_vertices_out",
    "volume_to_surface_mapping_dilate_missing",
    "volume_to_surface_mapping_execute",
    "volume_to_surface_mapping_myelin_style",
    "volume_to_surface_mapping_output_weights",
    "volume_to_surface_mapping_params",
    "volume_to_surface_mapping_ribbon_constrained",
    "volume_to_surface_mapping_volume_roi",
]
