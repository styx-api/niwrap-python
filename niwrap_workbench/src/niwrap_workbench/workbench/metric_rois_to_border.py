# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

METRIC_ROIS_TO_BORDER_METADATA = Metadata(
    id="ae7c7bdc27fb14b4ccb473f0ba599b0647222c8f.workbench",
    name="metric-rois-to-border",
    package="workbench",
    container_image_tag="nx10x/workbench:2.1.0",
)


_MetricRoisToBorderParamsDictNoTag = typing.TypedDict('_MetricRoisToBorderParamsDictNoTag', {
    "surface": InputPathType,
    "metric": InputPathType,
    "class-name": str,
    "border-out": str,
    "column": typing.NotRequired[str | None],
    "fraction": typing.NotRequired[float | None],
})
MetricRoisToBorderParamsDictTagged = typing.TypedDict('MetricRoisToBorderParamsDictTagged', {
    "@type": typing.Literal["workbench/metric-rois-to-border"],
    "surface": InputPathType,
    "metric": InputPathType,
    "class-name": str,
    "border-out": str,
    "column": typing.NotRequired[str | None],
    "fraction": typing.NotRequired[float | None],
})
MetricRoisToBorderParamsDict = _MetricRoisToBorderParamsDictNoTag | MetricRoisToBorderParamsDictTagged


class MetricRoisToBorderOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MetricRoisToBorderParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    border_out: OutputPathType
    """the output border file"""


def metric_rois_to_border_params(
    surface: InputPathType,
    metric: InputPathType,
    class_name: str,
    border_out: str,
    column: str | None = None,
    fraction: float | None = None,
) -> MetricRoisToBorderParamsDictTagged:
    """
    Build parameters.
    
    Args:
        surface: the surface to use for neighbor information.
        metric: the input metric containing ROIs.
        class_name: the name to use for the class of the output borders.
        border_out: the output border file.
        column: select a single column\
            \
            the column number or name.
        fraction: set how far along the edge border points are drawn\
            \
            fraction along edge from inside vertex (default 0.33).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "workbench/metric-rois-to-border",
        "surface": surface,
        "metric": metric,
        "class-name": class_name,
        "border-out": border_out,
    }
    if column is not None:
        params["column"] = column
    if fraction is not None:
        params["fraction"] = fraction
    return params


def metric_rois_to_border_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricRoisToBorderParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("surface", None) is None:
        raise StyxValidationError("`surface` must not be None")
    if not isinstance(params["surface"], (pathlib.Path, str)):
        raise StyxValidationError(f'`surface` has the wrong type: Received `{type(params.get("surface", None))}` expected `InputPathType`')
    if params.get("metric", None) is None:
        raise StyxValidationError("`metric` must not be None")
    if not isinstance(params["metric"], (pathlib.Path, str)):
        raise StyxValidationError(f'`metric` has the wrong type: Received `{type(params.get("metric", None))}` expected `InputPathType`')
    if params.get("class-name", None) is None:
        raise StyxValidationError("`class-name` must not be None")
    if not isinstance(params["class-name"], str):
        raise StyxValidationError(f'`class-name` has the wrong type: Received `{type(params.get("class-name", None))}` expected `str`')
    if params.get("border-out", None) is None:
        raise StyxValidationError("`border-out` must not be None")
    if not isinstance(params["border-out"], str):
        raise StyxValidationError(f'`border-out` has the wrong type: Received `{type(params.get("border-out", None))}` expected `str`')
    if params.get("column", None) is not None:
        if not isinstance(params["column"], str):
            raise StyxValidationError(f'`column` has the wrong type: Received `{type(params.get("column", None))}` expected `str | None`')
    if params.get("fraction", None) is not None:
        if not isinstance(params["fraction"], (float, int)):
            raise StyxValidationError(f'`fraction` has the wrong type: Received `{type(params.get("fraction", None))}` expected `float | None`')


def metric_rois_to_border_cargs(
    params: MetricRoisToBorderParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "wb_command",
        "-metric-rois-to-border"
    ])
    cargs.append(execution.input_file(params.get("surface", None)))
    cargs.append(execution.input_file(params.get("metric", None)))
    cargs.append(params.get("class-name", None))
    cargs.append(params.get("border-out", None))
    if params.get("column", None) is not None:
        cargs.extend([
            "-column",
            params.get("column", None)
        ])
    if params.get("fraction", None) is not None:
        cargs.extend([
            "-placement",
            str(params.get("fraction", None))
        ])
    return cargs


def metric_rois_to_border_outputs(
    params: MetricRoisToBorderParamsDict,
    execution: Execution,
) -> MetricRoisToBorderOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MetricRoisToBorderOutputs(
        root=execution.output_file("."),
        border_out=execution.output_file(params.get("border-out", None)),
    )
    return ret


def metric_rois_to_border_execute(
    params: MetricRoisToBorderParamsDict,
    runner: Runner | None = None,
) -> MetricRoisToBorderOutputs:
    """
    DRAW BORDERS AROUND METRIC ROIS.
    
    For each ROI column, finds all edges on the mesh that cross the boundary of
    the ROI, and draws borders through them. By default, this is done on all
    columns in the input file, using the map name as the name for the border.
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MetricRoisToBorderOutputs`).
    """
    metric_rois_to_border_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(METRIC_ROIS_TO_BORDER_METADATA)
    params = execution.params(params)
    cargs = metric_rois_to_border_cargs(params, execution)
    ret = metric_rois_to_border_outputs(params, execution)
    execution.run(cargs)
    return ret


def metric_rois_to_border(
    surface: InputPathType,
    metric: InputPathType,
    class_name: str,
    border_out: str,
    column: str | None = None,
    fraction: float | None = None,
    runner: Runner | None = None,
) -> MetricRoisToBorderOutputs:
    """
    DRAW BORDERS AROUND METRIC ROIS.
    
    For each ROI column, finds all edges on the mesh that cross the boundary of
    the ROI, and draws borders through them. By default, this is done on all
    columns in the input file, using the map name as the name for the border.
    
    Args:
        surface: the surface to use for neighbor information.
        metric: the input metric containing ROIs.
        class_name: the name to use for the class of the output borders.
        border_out: the output border file.
        column: select a single column\
            \
            the column number or name.
        fraction: set how far along the edge border points are drawn\
            \
            fraction along edge from inside vertex (default 0.33).
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MetricRoisToBorderOutputs`).
    """
    params = metric_rois_to_border_params(
        surface=surface,
        metric=metric,
        class_name=class_name,
        border_out=border_out,
        column=column,
        fraction=fraction,
    )
    return metric_rois_to_border_execute(params, runner)


__all__ = [
    "METRIC_ROIS_TO_BORDER_METADATA",
    "MetricRoisToBorderOutputs",
    "MetricRoisToBorderParamsDict",
    "MetricRoisToBorderParamsDictTagged",
    "metric_rois_to_border",
    "metric_rois_to_border_execute",
    "metric_rois_to_border_params",
]
