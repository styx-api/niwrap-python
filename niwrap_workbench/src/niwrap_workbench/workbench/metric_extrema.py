# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

METRIC_EXTREMA_METADATA = Metadata(
    id="fb4c43ba07a28fe93481caee84a1b4079b198219.workbench",
    name="metric-extrema",
    package="workbench",
)


MetricExtremaPresmoothParamsDict = typing.TypedDict('MetricExtremaPresmoothParamsDict', {
    "@type": typing.NotRequired[typing.Literal["presmooth"]],
    "kernel": float,
    "fwhm": bool,
})
MetricExtremaPresmoothParamsDictTagged = typing.TypedDict('MetricExtremaPresmoothParamsDictTagged', {
    "@type": typing.Literal["presmooth"],
    "kernel": float,
    "fwhm": bool,
})


MetricExtremaThresholdParamsDict = typing.TypedDict('MetricExtremaThresholdParamsDict', {
    "@type": typing.NotRequired[typing.Literal["threshold"]],
    "low": float,
    "high": float,
})
MetricExtremaThresholdParamsDictTagged = typing.TypedDict('MetricExtremaThresholdParamsDictTagged', {
    "@type": typing.Literal["threshold"],
    "low": float,
    "high": float,
})


MetricExtremaParamsDict = typing.TypedDict('MetricExtremaParamsDict', {
    "@type": typing.NotRequired[typing.Literal["workbench/metric-extrema"]],
    "metric-out": str,
    "presmooth": typing.NotRequired[MetricExtremaPresmoothParamsDict | None],
    "roi-metric": typing.NotRequired[InputPathType | None],
    "threshold": typing.NotRequired[MetricExtremaThresholdParamsDict | None],
    "sum-columns": bool,
    "consolidate-mode": bool,
    "only-maxima": bool,
    "only-minima": bool,
    "column": typing.NotRequired[str | None],
    "surface": InputPathType,
    "metric-in": InputPathType,
    "distance": float,
})
MetricExtremaParamsDictTagged = typing.TypedDict('MetricExtremaParamsDictTagged', {
    "@type": typing.Literal["workbench/metric-extrema"],
    "metric-out": str,
    "presmooth": typing.NotRequired[MetricExtremaPresmoothParamsDict | None],
    "roi-metric": typing.NotRequired[InputPathType | None],
    "threshold": typing.NotRequired[MetricExtremaThresholdParamsDict | None],
    "sum-columns": bool,
    "consolidate-mode": bool,
    "only-maxima": bool,
    "only-minima": bool,
    "column": typing.NotRequired[str | None],
    "surface": InputPathType,
    "metric-in": InputPathType,
    "distance": float,
})


def metric_extrema_presmooth(
    kernel: float,
    fwhm: bool = False,
) -> MetricExtremaPresmoothParamsDictTagged:
    """
    Build parameters.
    
    Args:
        kernel: the size of the gaussian smoothing kernel in mm, as sigma by\
            default.
        fwhm: kernel size is FWHM, not sigma.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "presmooth",
        "kernel": kernel,
        "fwhm": fwhm,
    }
    return params


def metric_extrema_presmooth_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricExtremaPresmoothParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("kernel", None) is None:
        raise StyxValidationError("`kernel` must not be None")
    if not isinstance(params["kernel"], (float, int)):
        raise StyxValidationError(f'`kernel` has the wrong type: Received `{type(params.get("kernel", None))}` expected `float`')
    if params.get("fwhm", False) is None:
        raise StyxValidationError("`fwhm` must not be None")
    if not isinstance(params["fwhm"], bool):
        raise StyxValidationError(f'`fwhm` has the wrong type: Received `{type(params.get("fwhm", False))}` expected `bool`')


def metric_extrema_presmooth_cargs(
    params: MetricExtremaPresmoothParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("fwhm", False):
        cargs.extend([
            "-presmooth",
            str(params.get("kernel", None)),
            "-fwhm"
        ])
    return cargs


def metric_extrema_threshold(
    low: float,
    high: float,
) -> MetricExtremaThresholdParamsDictTagged:
    """
    Build parameters.
    
    Args:
        low: the largest value to consider for being a minimum.
        high: the smallest value to consider for being a maximum.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "threshold",
        "low": low,
        "high": high,
    }
    return params


def metric_extrema_threshold_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricExtremaThresholdParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("low", None) is None:
        raise StyxValidationError("`low` must not be None")
    if not isinstance(params["low"], (float, int)):
        raise StyxValidationError(f'`low` has the wrong type: Received `{type(params.get("low", None))}` expected `float`')
    if params.get("high", None) is None:
        raise StyxValidationError("`high` must not be None")
    if not isinstance(params["high"], (float, int)):
        raise StyxValidationError(f'`high` has the wrong type: Received `{type(params.get("high", None))}` expected `float`')


def metric_extrema_threshold_cargs(
    params: MetricExtremaThresholdParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-threshold",
        str(params.get("low", None)),
        str(params.get("high", None))
    ])
    return cargs


class MetricExtremaOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MetricExtremaParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    metric_out: OutputPathType
    """the output extrema metric"""


def metric_extrema_params(
    metric_out: str,
    roi_metric: InputPathType | None,
    column: str | None,
    surface: InputPathType,
    metric_in: InputPathType,
    distance: float,
    presmooth: MetricExtremaPresmoothParamsDict | None = None,
    threshold: MetricExtremaThresholdParamsDict | None = None,
    sum_columns: bool = False,
    consolidate_mode: bool = False,
    only_maxima: bool = False,
    only_minima: bool = False,
) -> MetricExtremaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        metric_out: the output extrema metric.
        roi_metric: ignore values outside the selected area\
            \
            the area to find extrema in, as a metric.
        column: select a single column to find extrema in\
            \
            the column number or name.
        surface: the surface to use for distance information.
        metric_in: the metric to find the extrema of.
        distance: the minimum distance between identified extrema of the same\
            type.
        presmooth: smooth the metric before finding extrema.
        threshold: ignore small extrema.
        sum_columns: output the sum of the extrema columns instead of each\
            column separately.
        consolidate_mode: use consolidation of local minima instead of a large\
            neighborhood.
        only_maxima: only find the maxima.
        only_minima: only find the minima.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "workbench/metric-extrema",
        "metric-out": metric_out,
        "sum-columns": sum_columns,
        "consolidate-mode": consolidate_mode,
        "only-maxima": only_maxima,
        "only-minima": only_minima,
        "surface": surface,
        "metric-in": metric_in,
        "distance": distance,
    }
    if presmooth is not None:
        params["presmooth"] = presmooth
    if roi_metric is not None:
        params["roi-metric"] = roi_metric
    if threshold is not None:
        params["threshold"] = threshold
    if column is not None:
        params["column"] = column
    return params


def metric_extrema_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricExtremaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("metric-out", None) is None:
        raise StyxValidationError("`metric-out` must not be None")
    if not isinstance(params["metric-out"], str):
        raise StyxValidationError(f'`metric-out` has the wrong type: Received `{type(params.get("metric-out", None))}` expected `str`')
    if params.get("presmooth", None) is not None:
        metric_extrema_presmooth_validate(params["presmooth"])
    if params.get("roi-metric", None) is not None:
        if not isinstance(params["roi-metric"], (pathlib.Path, str)):
            raise StyxValidationError(f'`roi-metric` has the wrong type: Received `{type(params.get("roi-metric", None))}` expected `InputPathType | None`')
    if params.get("threshold", None) is not None:
        metric_extrema_threshold_validate(params["threshold"])
    if params.get("sum-columns", False) is None:
        raise StyxValidationError("`sum-columns` must not be None")
    if not isinstance(params["sum-columns"], bool):
        raise StyxValidationError(f'`sum-columns` has the wrong type: Received `{type(params.get("sum-columns", False))}` expected `bool`')
    if params.get("consolidate-mode", False) is None:
        raise StyxValidationError("`consolidate-mode` must not be None")
    if not isinstance(params["consolidate-mode"], bool):
        raise StyxValidationError(f'`consolidate-mode` has the wrong type: Received `{type(params.get("consolidate-mode", False))}` expected `bool`')
    if params.get("only-maxima", False) is None:
        raise StyxValidationError("`only-maxima` must not be None")
    if not isinstance(params["only-maxima"], bool):
        raise StyxValidationError(f'`only-maxima` has the wrong type: Received `{type(params.get("only-maxima", False))}` expected `bool`')
    if params.get("only-minima", False) is None:
        raise StyxValidationError("`only-minima` must not be None")
    if not isinstance(params["only-minima"], bool):
        raise StyxValidationError(f'`only-minima` has the wrong type: Received `{type(params.get("only-minima", False))}` expected `bool`')
    if params.get("column", None) is not None:
        if not isinstance(params["column"], str):
            raise StyxValidationError(f'`column` has the wrong type: Received `{type(params.get("column", None))}` expected `str | None`')
    if params.get("surface", None) is None:
        raise StyxValidationError("`surface` must not be None")
    if not isinstance(params["surface"], (pathlib.Path, str)):
        raise StyxValidationError(f'`surface` has the wrong type: Received `{type(params.get("surface", None))}` expected `InputPathType`')
    if params.get("metric-in", None) is None:
        raise StyxValidationError("`metric-in` must not be None")
    if not isinstance(params["metric-in"], (pathlib.Path, str)):
        raise StyxValidationError(f'`metric-in` has the wrong type: Received `{type(params.get("metric-in", None))}` expected `InputPathType`')
    if params.get("distance", None) is None:
        raise StyxValidationError("`distance` must not be None")
    if not isinstance(params["distance"], (float, int)):
        raise StyxValidationError(f'`distance` has the wrong type: Received `{type(params.get("distance", None))}` expected `float`')


def metric_extrema_cargs(
    params: MetricExtremaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("presmooth", None) is not None or params.get("roi-metric", None) is not None or params.get("threshold", None) is not None or params.get("sum-columns", False) or params.get("consolidate-mode", False) or params.get("only-maxima", False) or params.get("only-minima", False) or params.get("column", None) is not None:
        cargs.extend([
            "wb_command",
            "-metric-extrema",
            params.get("metric-out", None),
            *(metric_extrema_presmooth_cargs(params.get("presmooth", None), execution) if (params.get("presmooth", None) is not None) else []),
            "-roi",
            (execution.input_file(params.get("roi-metric", None)) if (params.get("roi-metric", None) is not None) else ""),
            *(metric_extrema_threshold_cargs(params.get("threshold", None), execution) if (params.get("threshold", None) is not None) else []),
            ("-sum-columns" if (params.get("sum-columns", False)) else ""),
            ("-consolidate-mode" if (params.get("consolidate-mode", False)) else ""),
            ("-only-maxima" if (params.get("only-maxima", False)) else ""),
            ("-only-minima" if (params.get("only-minima", False)) else ""),
            "-column",
            (params.get("column", None) if (params.get("column", None) is not None) else "")
        ])
    cargs.append(execution.input_file(params.get("surface", None)))
    cargs.append(execution.input_file(params.get("metric-in", None)))
    cargs.append(str(params.get("distance", None)))
    return cargs


def metric_extrema_outputs(
    params: MetricExtremaParamsDict,
    execution: Execution,
) -> MetricExtremaOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MetricExtremaOutputs(
        root=execution.output_file("."),
        metric_out=execution.output_file(params.get("metric-out", None)),
    )
    return ret


def metric_extrema_execute(
    params: MetricExtremaParamsDict,
    runner: Runner | None = None,
) -> MetricExtremaOutputs:
    """
    FIND EXTREMA IN A METRIC FILE.
    
    Finds extrema in a metric file, such that no two extrema of the same type
    are within <distance> of each other. The extrema are labeled as -1 for
    minima, 1 for maxima, 0 otherwise. If -only-maxima or -only-minima is
    specified, then it will ignore extrema not of the specified type. These
    options are mutually exclusive.
    
    If -roi is specified, not only is data outside the roi not used, but any
    vertex on the edge of the ROI will never be counted as an extrema, in case
    the ROI cuts across a gradient, which would otherwise generate extrema where
    there should be none.
    
    If -sum-columns is specified, these extrema columns are summed, and the
    output has a single column with this result.
    
    By default, a datapoint is an extrema only if it is more extreme than every
    other datapoint that is within <distance> from it. If -consolidate-mode is
    used, it instead starts by finding all datapoints that are more extreme than
    their immediate neighbors, then while there are any extrema within
    <distance> of each other, take the two extrema closest to each other and
    merge them into one by a weighted average based on how many original extrema
    have been merged into each.
    
    By default, all input columns are used with no smoothing, use -column to
    specify a single column to use, and -presmooth to smooth the input before
    finding the extrema.
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MetricExtremaOutputs`).
    """
    metric_extrema_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(METRIC_EXTREMA_METADATA)
    params = execution.params(params)
    cargs = metric_extrema_cargs(params, execution)
    ret = metric_extrema_outputs(params, execution)
    execution.run(cargs)
    return ret


def metric_extrema(
    metric_out: str,
    roi_metric: InputPathType | None,
    column: str | None,
    surface: InputPathType,
    metric_in: InputPathType,
    distance: float,
    presmooth: MetricExtremaPresmoothParamsDict | None = None,
    threshold: MetricExtremaThresholdParamsDict | None = None,
    sum_columns: bool = False,
    consolidate_mode: bool = False,
    only_maxima: bool = False,
    only_minima: bool = False,
    runner: Runner | None = None,
) -> MetricExtremaOutputs:
    """
    FIND EXTREMA IN A METRIC FILE.
    
    Finds extrema in a metric file, such that no two extrema of the same type
    are within <distance> of each other. The extrema are labeled as -1 for
    minima, 1 for maxima, 0 otherwise. If -only-maxima or -only-minima is
    specified, then it will ignore extrema not of the specified type. These
    options are mutually exclusive.
    
    If -roi is specified, not only is data outside the roi not used, but any
    vertex on the edge of the ROI will never be counted as an extrema, in case
    the ROI cuts across a gradient, which would otherwise generate extrema where
    there should be none.
    
    If -sum-columns is specified, these extrema columns are summed, and the
    output has a single column with this result.
    
    By default, a datapoint is an extrema only if it is more extreme than every
    other datapoint that is within <distance> from it. If -consolidate-mode is
    used, it instead starts by finding all datapoints that are more extreme than
    their immediate neighbors, then while there are any extrema within
    <distance> of each other, take the two extrema closest to each other and
    merge them into one by a weighted average based on how many original extrema
    have been merged into each.
    
    By default, all input columns are used with no smoothing, use -column to
    specify a single column to use, and -presmooth to smooth the input before
    finding the extrema.
    
    Args:
        metric_out: the output extrema metric.
        roi_metric: ignore values outside the selected area\
            \
            the area to find extrema in, as a metric.
        column: select a single column to find extrema in\
            \
            the column number or name.
        surface: the surface to use for distance information.
        metric_in: the metric to find the extrema of.
        distance: the minimum distance between identified extrema of the same\
            type.
        presmooth: smooth the metric before finding extrema.
        threshold: ignore small extrema.
        sum_columns: output the sum of the extrema columns instead of each\
            column separately.
        consolidate_mode: use consolidation of local minima instead of a large\
            neighborhood.
        only_maxima: only find the maxima.
        only_minima: only find the minima.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MetricExtremaOutputs`).
    """
    params = metric_extrema_params(
        metric_out=metric_out,
        presmooth=presmooth,
        roi_metric=roi_metric,
        threshold=threshold,
        sum_columns=sum_columns,
        consolidate_mode=consolidate_mode,
        only_maxima=only_maxima,
        only_minima=only_minima,
        column=column,
        surface=surface,
        metric_in=metric_in,
        distance=distance,
    )
    return metric_extrema_execute(params, runner)


__all__ = [
    "METRIC_EXTREMA_METADATA",
    "MetricExtremaOutputs",
    "MetricExtremaParamsDict",
    "MetricExtremaParamsDictTagged",
    "MetricExtremaPresmoothParamsDict",
    "MetricExtremaPresmoothParamsDictTagged",
    "MetricExtremaThresholdParamsDict",
    "MetricExtremaThresholdParamsDictTagged",
    "metric_extrema",
    "metric_extrema_execute",
    "metric_extrema_params",
    "metric_extrema_presmooth",
    "metric_extrema_threshold",
]
