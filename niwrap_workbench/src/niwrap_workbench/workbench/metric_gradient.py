# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

METRIC_GRADIENT_METADATA = Metadata(
    id="d0c9eab5fa3f31d0fe5fc41483f4bc8eb1ff5488.workbench",
    name="metric-gradient",
    package="workbench",
    container_image_tag="nx10x/workbench:2.1.0",
)


_MetricGradientPresmoothParamsDictNoTag = typing.TypedDict('_MetricGradientPresmoothParamsDictNoTag', {
    "kernel": float,
    "fwhm": bool,
})
MetricGradientPresmoothParamsDictTagged = typing.TypedDict('MetricGradientPresmoothParamsDictTagged', {
    "@type": typing.Literal["presmooth"],
    "kernel": float,
    "fwhm": bool,
})
MetricGradientPresmoothParamsDict = _MetricGradientPresmoothParamsDictNoTag | MetricGradientPresmoothParamsDictTagged


_MetricGradientRoiParamsDictNoTag = typing.TypedDict('_MetricGradientRoiParamsDictNoTag', {
    "roi-metric": InputPathType,
    "match-columns": bool,
})
MetricGradientRoiParamsDictTagged = typing.TypedDict('MetricGradientRoiParamsDictTagged', {
    "@type": typing.Literal["roi"],
    "roi-metric": InputPathType,
    "match-columns": bool,
})
MetricGradientRoiParamsDict = _MetricGradientRoiParamsDictNoTag | MetricGradientRoiParamsDictTagged


_MetricGradientVectorsParamsDictNoTag = typing.TypedDict('_MetricGradientVectorsParamsDictNoTag', {
    "vector-metric-out": str,
})
MetricGradientVectorsParamsDictTagged = typing.TypedDict('MetricGradientVectorsParamsDictTagged', {
    "@type": typing.Literal["vectors"],
    "vector-metric-out": str,
})
MetricGradientVectorsParamsDict = _MetricGradientVectorsParamsDictNoTag | MetricGradientVectorsParamsDictTagged


_MetricGradientParamsDictNoTag = typing.TypedDict('_MetricGradientParamsDictNoTag', {
    "surface": InputPathType,
    "metric-in": InputPathType,
    "metric-out": str,
    "presmooth": typing.NotRequired[MetricGradientPresmoothParamsDict | None],
    "roi": typing.NotRequired[MetricGradientRoiParamsDict | None],
    "vectors": typing.NotRequired[MetricGradientVectorsParamsDict | None],
    "area-metric": typing.NotRequired[InputPathType | None],
    "column": typing.NotRequired[str | None],
    "average-normals": bool,
})
MetricGradientParamsDictTagged = typing.TypedDict('MetricGradientParamsDictTagged', {
    "@type": typing.Literal["workbench/metric-gradient"],
    "surface": InputPathType,
    "metric-in": InputPathType,
    "metric-out": str,
    "presmooth": typing.NotRequired[MetricGradientPresmoothParamsDict | None],
    "roi": typing.NotRequired[MetricGradientRoiParamsDict | None],
    "vectors": typing.NotRequired[MetricGradientVectorsParamsDict | None],
    "area-metric": typing.NotRequired[InputPathType | None],
    "column": typing.NotRequired[str | None],
    "average-normals": bool,
})
MetricGradientParamsDict = _MetricGradientParamsDictNoTag | MetricGradientParamsDictTagged


def metric_gradient_presmooth(
    kernel: float,
    fwhm: bool = False,
) -> MetricGradientPresmoothParamsDictTagged:
    """
    Build parameters.
    
    Args:
        kernel: the size of the gaussian smoothing kernel in mm, as sigma by\
            default.
        fwhm: kernel size is FWHM, not sigma.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "presmooth",
        "kernel": kernel,
        "fwhm": fwhm,
    }
    return params


def metric_gradient_presmooth_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricGradientPresmoothParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("kernel", None) is None:
        raise StyxValidationError("`kernel` must not be None")
    if not isinstance(params["kernel"], (float, int)):
        raise StyxValidationError(f'`kernel` has the wrong type: Received `{type(params.get("kernel", None))}` expected `float`')
    if params.get("fwhm", False) is None:
        raise StyxValidationError("`fwhm` must not be None")
    if not isinstance(params["fwhm"], bool):
        raise StyxValidationError(f'`fwhm` has the wrong type: Received `{type(params.get("fwhm", False))}` expected `bool`')


def metric_gradient_presmooth_cargs(
    params: MetricGradientPresmoothParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-presmooth",
        str(params.get("kernel", None))
    ])
    if params.get("fwhm", False):
        cargs.append("-fwhm")
    return cargs


def metric_gradient_roi(
    roi_metric: InputPathType,
    match_columns: bool = False,
) -> MetricGradientRoiParamsDictTagged:
    """
    Build parameters.
    
    Args:
        roi_metric: the area to take the gradient within, as a metric.
        match_columns: for each input column, use the corresponding column from\
            the roi.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "roi",
        "roi-metric": roi_metric,
        "match-columns": match_columns,
    }
    return params


def metric_gradient_roi_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricGradientRoiParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("roi-metric", None) is None:
        raise StyxValidationError("`roi-metric` must not be None")
    if not isinstance(params["roi-metric"], (pathlib.Path, str)):
        raise StyxValidationError(f'`roi-metric` has the wrong type: Received `{type(params.get("roi-metric", None))}` expected `InputPathType`')
    if params.get("match-columns", False) is None:
        raise StyxValidationError("`match-columns` must not be None")
    if not isinstance(params["match-columns"], bool):
        raise StyxValidationError(f'`match-columns` has the wrong type: Received `{type(params.get("match-columns", False))}` expected `bool`')


def metric_gradient_roi_cargs(
    params: MetricGradientRoiParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-roi",
        execution.input_file(params.get("roi-metric", None))
    ])
    if params.get("match-columns", False):
        cargs.append("-match-columns")
    return cargs


class MetricGradientVectorsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MetricGradientVectorsParamsDict | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    vector_metric_out: OutputPathType
    """the vectors as a metric file"""


def metric_gradient_vectors(
    vector_metric_out: str,
) -> MetricGradientVectorsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        vector_metric_out: the vectors as a metric file.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "vectors",
        "vector-metric-out": vector_metric_out,
    }
    return params


def metric_gradient_vectors_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricGradientVectorsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("vector-metric-out", None) is None:
        raise StyxValidationError("`vector-metric-out` must not be None")
    if not isinstance(params["vector-metric-out"], str):
        raise StyxValidationError(f'`vector-metric-out` has the wrong type: Received `{type(params.get("vector-metric-out", None))}` expected `str`')


def metric_gradient_vectors_cargs(
    params: MetricGradientVectorsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-vectors",
        params.get("vector-metric-out", None)
    ])
    return cargs


def metric_gradient_vectors_outputs(
    params: MetricGradientVectorsParamsDict,
    execution: Execution,
) -> MetricGradientVectorsOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MetricGradientVectorsOutputs(
        root=execution.output_file("."),
        vector_metric_out=execution.output_file(params.get("vector-metric-out", None)),
    )
    return ret


class MetricGradientOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MetricGradientParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    metric_out: OutputPathType
    """the magnitude of the gradient"""
    vectors: MetricGradientVectorsOutputs | None
    """Outputs from `metric_gradient_vectors_outputs`."""


def metric_gradient_params(
    surface: InputPathType,
    metric_in: InputPathType,
    metric_out: str,
    presmooth: MetricGradientPresmoothParamsDict | None = None,
    roi: MetricGradientRoiParamsDict | None = None,
    vectors: MetricGradientVectorsParamsDict | None = None,
    area_metric: InputPathType | None = None,
    column: str | None = None,
    average_normals: bool = False,
) -> MetricGradientParamsDictTagged:
    """
    Build parameters.
    
    Args:
        surface: the surface to compute the gradient on.
        metric_in: the metric to compute the gradient of.
        metric_out: the magnitude of the gradient.
        presmooth: smooth the metric before computing the gradient.
        roi: select a region of interest to take the gradient of.
        vectors: output gradient vectors.
        area_metric: vertex areas to use instead of computing them from the\
            surface\
            \
            the corrected vertex areas, as a metric.
        column: select a single column to compute the gradient of\
            \
            the column number or name.
        average_normals: average the normals of each vertex with its neighbors\
            before using them to compute the gradient.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "workbench/metric-gradient",
        "surface": surface,
        "metric-in": metric_in,
        "metric-out": metric_out,
        "average-normals": average_normals,
    }
    if presmooth is not None:
        params["presmooth"] = presmooth
    if roi is not None:
        params["roi"] = roi
    if vectors is not None:
        params["vectors"] = vectors
    if area_metric is not None:
        params["area-metric"] = area_metric
    if column is not None:
        params["column"] = column
    return params


def metric_gradient_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MetricGradientParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("surface", None) is None:
        raise StyxValidationError("`surface` must not be None")
    if not isinstance(params["surface"], (pathlib.Path, str)):
        raise StyxValidationError(f'`surface` has the wrong type: Received `{type(params.get("surface", None))}` expected `InputPathType`')
    if params.get("metric-in", None) is None:
        raise StyxValidationError("`metric-in` must not be None")
    if not isinstance(params["metric-in"], (pathlib.Path, str)):
        raise StyxValidationError(f'`metric-in` has the wrong type: Received `{type(params.get("metric-in", None))}` expected `InputPathType`')
    if params.get("metric-out", None) is None:
        raise StyxValidationError("`metric-out` must not be None")
    if not isinstance(params["metric-out"], str):
        raise StyxValidationError(f'`metric-out` has the wrong type: Received `{type(params.get("metric-out", None))}` expected `str`')
    if params.get("presmooth", None) is not None:
        metric_gradient_presmooth_validate(params["presmooth"])
    if params.get("roi", None) is not None:
        metric_gradient_roi_validate(params["roi"])
    if params.get("vectors", None) is not None:
        metric_gradient_vectors_validate(params["vectors"])
    if params.get("area-metric", None) is not None:
        if not isinstance(params["area-metric"], (pathlib.Path, str)):
            raise StyxValidationError(f'`area-metric` has the wrong type: Received `{type(params.get("area-metric", None))}` expected `InputPathType | None`')
    if params.get("column", None) is not None:
        if not isinstance(params["column"], str):
            raise StyxValidationError(f'`column` has the wrong type: Received `{type(params.get("column", None))}` expected `str | None`')
    if params.get("average-normals", False) is None:
        raise StyxValidationError("`average-normals` must not be None")
    if not isinstance(params["average-normals"], bool):
        raise StyxValidationError(f'`average-normals` has the wrong type: Received `{type(params.get("average-normals", False))}` expected `bool`')


def metric_gradient_cargs(
    params: MetricGradientParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "wb_command",
        "-metric-gradient"
    ])
    cargs.append(execution.input_file(params.get("surface", None)))
    cargs.append(execution.input_file(params.get("metric-in", None)))
    cargs.append(params.get("metric-out", None))
    if params.get("presmooth", None) is not None or params.get("roi", None) is not None or params.get("vectors", None) is not None:
        cargs.extend([
            *(metric_gradient_presmooth_cargs(params.get("presmooth", None), execution) if (params.get("presmooth", None) is not None) else []),
            *(metric_gradient_roi_cargs(params.get("roi", None), execution) if (params.get("roi", None) is not None) else []),
            *(metric_gradient_vectors_cargs(params.get("vectors", None), execution) if (params.get("vectors", None) is not None) else [])
        ])
    if params.get("area-metric", None) is not None:
        cargs.extend([
            "-corrected-areas",
            execution.input_file(params.get("area-metric", None))
        ])
    if params.get("column", None) is not None:
        cargs.extend([
            "-column",
            params.get("column", None)
        ])
    if params.get("average-normals", False):
        cargs.append("-average-normals")
    return cargs


def metric_gradient_outputs(
    params: MetricGradientParamsDict,
    execution: Execution,
) -> MetricGradientOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MetricGradientOutputs(
        root=execution.output_file("."),
        metric_out=execution.output_file(params.get("metric-out", None)),
        vectors=metric_gradient_vectors_outputs(params.get("vectors"), execution) if params.get("vectors") else None,
    )
    return ret


def metric_gradient_execute(
    params: MetricGradientParamsDict,
    runner: Runner | None = None,
) -> MetricGradientOutputs:
    """
    SURFACE GRADIENT OF A METRIC FILE.
    
    At each vertex, the immediate neighbors are unfolded onto a plane tangent to
    the surface at the vertex (specifically, perpendicular to the normal). The
    gradient is computed using a regression between the unfolded positions of
    the vertices and their values. The gradient is then given by the slopes of
    the regression, and reconstructed as a 3D gradient vector. By default, takes
    the gradient of all columns, with no presmoothing, across the whole surface,
    without averaging the normals of the surface among neighbors.
    
    When using -corrected-areas, note that it is an approximate correction.
    Doing smoothing on individual surfaces before averaging/gradient is
    preferred, when possible, in order to make use of the original surface
    structure.
    
    Specifying an ROI will restrict the gradient to only use data from where the
    ROI metric is positive, and output zeros anywhere the ROI metric is not
    positive.
    
    By default, the first column of the roi metric is used for all input
    columns. When -match-columns is specified to the -roi option, the input and
    roi metrics must have the same number of columns, and for each input
    column's index, the same column index is used in the roi metric. If the
    -match-columns option to -roi is used while the -column option is also used,
    the number of columns of the roi metric must match the input metric, and it
    will use the roi column with the index of the selected input column.
    
    The vector output metric is organized such that the X, Y, and Z components
    from a single input column are consecutive columns.
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MetricGradientOutputs`).
    """
    metric_gradient_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(METRIC_GRADIENT_METADATA)
    params = execution.params(params)
    cargs = metric_gradient_cargs(params, execution)
    ret = metric_gradient_outputs(params, execution)
    execution.run(cargs)
    return ret


def metric_gradient(
    surface: InputPathType,
    metric_in: InputPathType,
    metric_out: str,
    presmooth: MetricGradientPresmoothParamsDict | None = None,
    roi: MetricGradientRoiParamsDict | None = None,
    vectors: MetricGradientVectorsParamsDict | None = None,
    area_metric: InputPathType | None = None,
    column: str | None = None,
    average_normals: bool = False,
    runner: Runner | None = None,
) -> MetricGradientOutputs:
    """
    SURFACE GRADIENT OF A METRIC FILE.
    
    At each vertex, the immediate neighbors are unfolded onto a plane tangent to
    the surface at the vertex (specifically, perpendicular to the normal). The
    gradient is computed using a regression between the unfolded positions of
    the vertices and their values. The gradient is then given by the slopes of
    the regression, and reconstructed as a 3D gradient vector. By default, takes
    the gradient of all columns, with no presmoothing, across the whole surface,
    without averaging the normals of the surface among neighbors.
    
    When using -corrected-areas, note that it is an approximate correction.
    Doing smoothing on individual surfaces before averaging/gradient is
    preferred, when possible, in order to make use of the original surface
    structure.
    
    Specifying an ROI will restrict the gradient to only use data from where the
    ROI metric is positive, and output zeros anywhere the ROI metric is not
    positive.
    
    By default, the first column of the roi metric is used for all input
    columns. When -match-columns is specified to the -roi option, the input and
    roi metrics must have the same number of columns, and for each input
    column's index, the same column index is used in the roi metric. If the
    -match-columns option to -roi is used while the -column option is also used,
    the number of columns of the roi metric must match the input metric, and it
    will use the roi column with the index of the selected input column.
    
    The vector output metric is organized such that the X, Y, and Z components
    from a single input column are consecutive columns.
    
    Args:
        surface: the surface to compute the gradient on.
        metric_in: the metric to compute the gradient of.
        metric_out: the magnitude of the gradient.
        presmooth: smooth the metric before computing the gradient.
        roi: select a region of interest to take the gradient of.
        vectors: output gradient vectors.
        area_metric: vertex areas to use instead of computing them from the\
            surface\
            \
            the corrected vertex areas, as a metric.
        column: select a single column to compute the gradient of\
            \
            the column number or name.
        average_normals: average the normals of each vertex with its neighbors\
            before using them to compute the gradient.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MetricGradientOutputs`).
    """
    params = metric_gradient_params(
        surface=surface,
        metric_in=metric_in,
        metric_out=metric_out,
        presmooth=presmooth,
        roi=roi,
        vectors=vectors,
        area_metric=area_metric,
        column=column,
        average_normals=average_normals,
    )
    return metric_gradient_execute(params, runner)


__all__ = [
    "METRIC_GRADIENT_METADATA",
    "MetricGradientOutputs",
    "MetricGradientParamsDict",
    "MetricGradientParamsDictTagged",
    "MetricGradientPresmoothParamsDict",
    "MetricGradientPresmoothParamsDictTagged",
    "MetricGradientRoiParamsDict",
    "MetricGradientRoiParamsDictTagged",
    "MetricGradientVectorsOutputs",
    "MetricGradientVectorsParamsDict",
    "MetricGradientVectorsParamsDictTagged",
    "metric_gradient",
    "metric_gradient_execute",
    "metric_gradient_params",
    "metric_gradient_presmooth",
    "metric_gradient_roi",
    "metric_gradient_vectors",
]
