# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

C3D_METADATA = Metadata(
    id="85914b6dd698c9ef51ecebdc85ba5d9e1bd8f06c.boutiques",
    name="c3d",
    package="c3d",
    container_image_tag="pyushkevich/itksnap:v3.8.2",
)


_C3dAccumParamsDictNoTag = typing.TypedDict('_C3dAccumParamsDictNoTag', {
    "accum": str,
})
C3dAccumParamsDictTagged = typing.TypedDict('C3dAccumParamsDictTagged', {
    "@type": typing.Literal["accum"],
    "accum": str,
})
C3dAccumParamsDict = _C3dAccumParamsDictNoTag | C3dAccumParamsDictTagged


_C3dAcosParamsDictNoTag = typing.TypedDict('_C3dAcosParamsDictNoTag', {
    "acos": str,
})
C3dAcosParamsDictTagged = typing.TypedDict('C3dAcosParamsDictTagged', {
    "@type": typing.Literal["acos"],
    "acos": str,
})
C3dAcosParamsDict = _C3dAcosParamsDictNoTag | C3dAcosParamsDictTagged


_C3dAddParamsDictNoTag = typing.TypedDict('_C3dAddParamsDictNoTag', {
    "add": str,
})
C3dAddParamsDictTagged = typing.TypedDict('C3dAddParamsDictTagged', {
    "@type": typing.Literal["add"],
    "add": str,
})
C3dAddParamsDict = _C3dAddParamsDictNoTag | C3dAddParamsDictTagged


_C3dAlignLandmarksParamsDictNoTag = typing.TypedDict('_C3dAlignLandmarksParamsDictNoTag', {
    "align_landmarks": str,
})
C3dAlignLandmarksParamsDictTagged = typing.TypedDict('C3dAlignLandmarksParamsDictTagged', {
    "@type": typing.Literal["align_landmarks"],
    "align_landmarks": str,
})
C3dAlignLandmarksParamsDict = _C3dAlignLandmarksParamsDictNoTag | C3dAlignLandmarksParamsDictTagged


_C3dAnisotropicDiffusionParamsDictNoTag = typing.TypedDict('_C3dAnisotropicDiffusionParamsDictNoTag', {
    "anisotropic_diffusion": str,
})
C3dAnisotropicDiffusionParamsDictTagged = typing.TypedDict('C3dAnisotropicDiffusionParamsDictTagged', {
    "@type": typing.Literal["anisotropic_diffusion"],
    "anisotropic_diffusion": str,
})
C3dAnisotropicDiffusionParamsDict = _C3dAnisotropicDiffusionParamsDictNoTag | C3dAnisotropicDiffusionParamsDictTagged


_C3dAntialiasParamsDictNoTag = typing.TypedDict('_C3dAntialiasParamsDictNoTag', {
    "antialias": str,
})
C3dAntialiasParamsDictTagged = typing.TypedDict('C3dAntialiasParamsDictTagged', {
    "@type": typing.Literal["antialias"],
    "antialias": str,
})
C3dAntialiasParamsDict = _C3dAntialiasParamsDictNoTag | C3dAntialiasParamsDictTagged


_C3dSetParamsDictNoTag = typing.TypedDict('_C3dSetParamsDictNoTag', {
    "set": str,
})
C3dSetParamsDictTagged = typing.TypedDict('C3dSetParamsDictTagged', {
    "@type": typing.Literal["set"],
    "set": str,
})
C3dSetParamsDict = _C3dSetParamsDictNoTag | C3dSetParamsDictTagged


_C3dAsinParamsDictNoTag = typing.TypedDict('_C3dAsinParamsDictNoTag', {
    "asin": str,
})
C3dAsinParamsDictTagged = typing.TypedDict('C3dAsinParamsDictTagged', {
    "@type": typing.Literal["asin"],
    "asin": str,
})
C3dAsinParamsDict = _C3dAsinParamsDictNoTag | C3dAsinParamsDictTagged


_C3dAtan2ParamsDictNoTag = typing.TypedDict('_C3dAtan2ParamsDictNoTag', {
    "atan2": str,
})
C3dAtan2ParamsDictTagged = typing.TypedDict('C3dAtan2ParamsDictTagged', {
    "@type": typing.Literal["atan2"],
    "atan2": str,
})
C3dAtan2ParamsDict = _C3dAtan2ParamsDictNoTag | C3dAtan2ParamsDictTagged


_C3dBackgroundParamsDictNoTag = typing.TypedDict('_C3dBackgroundParamsDictNoTag', {
    "background": str,
})
C3dBackgroundParamsDictTagged = typing.TypedDict('C3dBackgroundParamsDictTagged', {
    "@type": typing.Literal["background"],
    "background": str,
})
C3dBackgroundParamsDict = _C3dBackgroundParamsDictNoTag | C3dBackgroundParamsDictTagged


_C3dN4BiasCorrectionParamsDictNoTag = typing.TypedDict('_C3dN4BiasCorrectionParamsDictNoTag', {
    "n4_bias_correction": str,
})
C3dN4BiasCorrectionParamsDictTagged = typing.TypedDict('C3dN4BiasCorrectionParamsDictTagged', {
    "@type": typing.Literal["n4_bias_correction"],
    "n4_bias_correction": str,
})
C3dN4BiasCorrectionParamsDict = _C3dN4BiasCorrectionParamsDictNoTag | C3dN4BiasCorrectionParamsDictTagged


_C3dBinarizeParamsDictNoTag = typing.TypedDict('_C3dBinarizeParamsDictNoTag', {
    "binarize": str,
})
C3dBinarizeParamsDictTagged = typing.TypedDict('C3dBinarizeParamsDictTagged', {
    "@type": typing.Literal["binarize"],
    "binarize": str,
})
C3dBinarizeParamsDict = _C3dBinarizeParamsDictNoTag | C3dBinarizeParamsDictTagged


_C3dCannyParamsDictNoTag = typing.TypedDict('_C3dCannyParamsDictNoTag', {
    "canny": str,
})
C3dCannyParamsDictTagged = typing.TypedDict('C3dCannyParamsDictTagged', {
    "@type": typing.Literal["canny"],
    "canny": str,
})
C3dCannyParamsDict = _C3dCannyParamsDictNoTag | C3dCannyParamsDictTagged


_C3dCeilParamsDictNoTag = typing.TypedDict('_C3dCeilParamsDictNoTag', {
    "ceil": str,
})
C3dCeilParamsDictTagged = typing.TypedDict('C3dCeilParamsDictTagged', {
    "@type": typing.Literal["ceil"],
    "ceil": str,
})
C3dCeilParamsDict = _C3dCeilParamsDictNoTag | C3dCeilParamsDictTagged


_C3dCentroidParamsDictNoTag = typing.TypedDict('_C3dCentroidParamsDictNoTag', {
    "centroid": str,
})
C3dCentroidParamsDictTagged = typing.TypedDict('C3dCentroidParamsDictTagged', {
    "@type": typing.Literal["centroid"],
    "centroid": str,
})
C3dCentroidParamsDict = _C3dCentroidParamsDictNoTag | C3dCentroidParamsDictTagged


_C3dCentroidMarkParamsDictNoTag = typing.TypedDict('_C3dCentroidMarkParamsDictNoTag', {
    "centroid_mark": str,
})
C3dCentroidMarkParamsDictTagged = typing.TypedDict('C3dCentroidMarkParamsDictTagged', {
    "@type": typing.Literal["centroid_mark"],
    "centroid_mark": str,
})
C3dCentroidMarkParamsDict = _C3dCentroidMarkParamsDictNoTag | C3dCentroidMarkParamsDictTagged


_C3dConnectedComponentsParamsDictNoTag = typing.TypedDict('_C3dConnectedComponentsParamsDictNoTag', {
    "connected_components": str,
})
C3dConnectedComponentsParamsDictTagged = typing.TypedDict('C3dConnectedComponentsParamsDictTagged', {
    "@type": typing.Literal["connected_components"],
    "connected_components": str,
})
C3dConnectedComponentsParamsDict = _C3dConnectedComponentsParamsDictNoTag | C3dConnectedComponentsParamsDictTagged


_C3dClearParamsDictNoTag = typing.TypedDict('_C3dClearParamsDictNoTag', {
    "clear": str,
})
C3dClearParamsDictTagged = typing.TypedDict('C3dClearParamsDictTagged', {
    "@type": typing.Literal["clear"],
    "clear": str,
})
C3dClearParamsDict = _C3dClearParamsDictNoTag | C3dClearParamsDictTagged


_C3dClipParamsDictNoTag = typing.TypedDict('_C3dClipParamsDictNoTag', {
    "clip": str,
})
C3dClipParamsDictTagged = typing.TypedDict('C3dClipParamsDictTagged', {
    "@type": typing.Literal["clip"],
    "clip": str,
})
C3dClipParamsDict = _C3dClipParamsDictNoTag | C3dClipParamsDictTagged


_C3dColorMapParamsDictNoTag = typing.TypedDict('_C3dColorMapParamsDictNoTag', {
    "color_map": str,
})
C3dColorMapParamsDictTagged = typing.TypedDict('C3dColorMapParamsDictTagged', {
    "@type": typing.Literal["color_map"],
    "color_map": str,
})
C3dColorMapParamsDict = _C3dColorMapParamsDictNoTag | C3dColorMapParamsDictTagged


_C3dCompressParamsDictNoTag = typing.TypedDict('_C3dCompressParamsDictNoTag', {
    "compress": str,
})
C3dCompressParamsDictTagged = typing.TypedDict('C3dCompressParamsDictTagged', {
    "@type": typing.Literal["compress"],
    "compress": str,
})
C3dCompressParamsDict = _C3dCompressParamsDictNoTag | C3dCompressParamsDictTagged


_C3dNoCompressParamsDictNoTag = typing.TypedDict('_C3dNoCompressParamsDictNoTag', {
    "no_compress": str,
})
C3dNoCompressParamsDictTagged = typing.TypedDict('C3dNoCompressParamsDictTagged', {
    "@type": typing.Literal["no_compress"],
    "no_compress": str,
})
C3dNoCompressParamsDict = _C3dNoCompressParamsDictNoTag | C3dNoCompressParamsDictTagged


_C3dConvParamsDictNoTag = typing.TypedDict('_C3dConvParamsDictNoTag', {
    "conv": str,
})
C3dConvParamsDictTagged = typing.TypedDict('C3dConvParamsDictTagged', {
    "@type": typing.Literal["conv"],
    "conv": str,
})
C3dConvParamsDict = _C3dConvParamsDictNoTag | C3dConvParamsDictTagged


_C3dCoordinateMapVoxelParamsDictNoTag = typing.TypedDict('_C3dCoordinateMapVoxelParamsDictNoTag', {
    "coordinate_map_voxel": str,
})
C3dCoordinateMapVoxelParamsDictTagged = typing.TypedDict('C3dCoordinateMapVoxelParamsDictTagged', {
    "@type": typing.Literal["coordinate_map_voxel"],
    "coordinate_map_voxel": str,
})
C3dCoordinateMapVoxelParamsDict = _C3dCoordinateMapVoxelParamsDictNoTag | C3dCoordinateMapVoxelParamsDictTagged


_C3dCoordinateMapPhysicalParamsDictNoTag = typing.TypedDict('_C3dCoordinateMapPhysicalParamsDictNoTag', {
    "coordinate_map_physical": str,
})
C3dCoordinateMapPhysicalParamsDictTagged = typing.TypedDict('C3dCoordinateMapPhysicalParamsDictTagged', {
    "@type": typing.Literal["coordinate_map_physical"],
    "coordinate_map_physical": str,
})
C3dCoordinateMapPhysicalParamsDict = _C3dCoordinateMapPhysicalParamsDictNoTag | C3dCoordinateMapPhysicalParamsDictTagged


_C3dCopyTransformParamsDictNoTag = typing.TypedDict('_C3dCopyTransformParamsDictNoTag', {
    "copy_transform": str,
})
C3dCopyTransformParamsDictTagged = typing.TypedDict('C3dCopyTransformParamsDictTagged', {
    "@type": typing.Literal["copy_transform"],
    "copy_transform": str,
})
C3dCopyTransformParamsDict = _C3dCopyTransformParamsDictNoTag | C3dCopyTransformParamsDictTagged


_C3dCosParamsDictNoTag = typing.TypedDict('_C3dCosParamsDictNoTag', {
    "cos": str,
})
C3dCosParamsDictTagged = typing.TypedDict('C3dCosParamsDictTagged', {
    "@type": typing.Literal["cos"],
    "cos": str,
})
C3dCosParamsDict = _C3dCosParamsDictNoTag | C3dCosParamsDictTagged


_C3dCreateParamsDictNoTag = typing.TypedDict('_C3dCreateParamsDictNoTag', {
    "create": str,
})
C3dCreateParamsDictTagged = typing.TypedDict('C3dCreateParamsDictTagged', {
    "@type": typing.Literal["create"],
    "create": str,
})
C3dCreateParamsDict = _C3dCreateParamsDictNoTag | C3dCreateParamsDictTagged


_C3dDicomSeriesListParamsDictNoTag = typing.TypedDict('_C3dDicomSeriesListParamsDictNoTag', {
    "dicom_series_list": str,
})
C3dDicomSeriesListParamsDictTagged = typing.TypedDict('C3dDicomSeriesListParamsDictTagged', {
    "@type": typing.Literal["dicom_series_list"],
    "dicom_series_list": str,
})
C3dDicomSeriesListParamsDict = _C3dDicomSeriesListParamsDictNoTag | C3dDicomSeriesListParamsDictTagged


_C3dDicomSeriesReadParamsDictNoTag = typing.TypedDict('_C3dDicomSeriesReadParamsDictNoTag', {
    "dicom_series_read": str,
})
C3dDicomSeriesReadParamsDictTagged = typing.TypedDict('C3dDicomSeriesReadParamsDictTagged', {
    "@type": typing.Literal["dicom_series_read"],
    "dicom_series_read": str,
})
C3dDicomSeriesReadParamsDict = _C3dDicomSeriesReadParamsDictNoTag | C3dDicomSeriesReadParamsDictTagged


_C3dDilateParamsDictNoTag = typing.TypedDict('_C3dDilateParamsDictNoTag', {
    "dilate": str,
})
C3dDilateParamsDictTagged = typing.TypedDict('C3dDilateParamsDictTagged', {
    "@type": typing.Literal["dilate"],
    "dilate": str,
})
C3dDilateParamsDict = _C3dDilateParamsDictNoTag | C3dDilateParamsDictTagged


_C3dDivideParamsDictNoTag = typing.TypedDict('_C3dDivideParamsDictNoTag', {
    "divide": str,
})
C3dDivideParamsDictTagged = typing.TypedDict('C3dDivideParamsDictTagged', {
    "@type": typing.Literal["divide"],
    "divide": str,
})
C3dDivideParamsDict = _C3dDivideParamsDictNoTag | C3dDivideParamsDictTagged


_C3dDuplicateParamsDictNoTag = typing.TypedDict('_C3dDuplicateParamsDictNoTag', {
    "duplicate": str,
})
C3dDuplicateParamsDictTagged = typing.TypedDict('C3dDuplicateParamsDictTagged', {
    "@type": typing.Literal["duplicate"],
    "duplicate": str,
})
C3dDuplicateParamsDict = _C3dDuplicateParamsDictNoTag | C3dDuplicateParamsDictTagged


_C3dEndaccumParamsDictNoTag = typing.TypedDict('_C3dEndaccumParamsDictNoTag', {
    "endaccum": str,
})
C3dEndaccumParamsDictTagged = typing.TypedDict('C3dEndaccumParamsDictTagged', {
    "@type": typing.Literal["endaccum"],
    "endaccum": str,
})
C3dEndaccumParamsDict = _C3dEndaccumParamsDictNoTag | C3dEndaccumParamsDictTagged


_C3dEndforParamsDictNoTag = typing.TypedDict('_C3dEndforParamsDictNoTag', {
    "endfor": str,
})
C3dEndforParamsDictTagged = typing.TypedDict('C3dEndforParamsDictTagged', {
    "@type": typing.Literal["endfor"],
    "endfor": str,
})
C3dEndforParamsDict = _C3dEndforParamsDictNoTag | C3dEndforParamsDictTagged


_C3dErodeParamsDictNoTag = typing.TypedDict('_C3dErodeParamsDictNoTag', {
    "erode": str,
})
C3dErodeParamsDictTagged = typing.TypedDict('C3dErodeParamsDictTagged', {
    "@type": typing.Literal["erode"],
    "erode": str,
})
C3dErodeParamsDict = _C3dErodeParamsDictNoTag | C3dErodeParamsDictTagged


_C3dErfParamsDictNoTag = typing.TypedDict('_C3dErfParamsDictNoTag', {
    "erf": str,
})
C3dErfParamsDictTagged = typing.TypedDict('C3dErfParamsDictTagged', {
    "@type": typing.Literal["erf"],
    "erf": str,
})
C3dErfParamsDict = _C3dErfParamsDictNoTag | C3dErfParamsDictTagged


_C3dExpParamsDictNoTag = typing.TypedDict('_C3dExpParamsDictNoTag', {
    "exp": str,
})
C3dExpParamsDictTagged = typing.TypedDict('C3dExpParamsDictTagged', {
    "@type": typing.Literal["exp"],
    "exp": str,
})
C3dExpParamsDict = _C3dExpParamsDictNoTag | C3dExpParamsDictTagged


_C3dExportPatchesParamsDictNoTag = typing.TypedDict('_C3dExportPatchesParamsDictNoTag', {
    "export_patches": str,
})
C3dExportPatchesParamsDictTagged = typing.TypedDict('C3dExportPatchesParamsDictTagged', {
    "@type": typing.Literal["export_patches"],
    "export_patches": str,
})
C3dExportPatchesParamsDict = _C3dExportPatchesParamsDictNoTag | C3dExportPatchesParamsDictTagged


_C3dExportPatchesAugParamsDictNoTag = typing.TypedDict('_C3dExportPatchesAugParamsDictNoTag', {
    "export_patches_aug": str,
})
C3dExportPatchesAugParamsDictTagged = typing.TypedDict('C3dExportPatchesAugParamsDictTagged', {
    "@type": typing.Literal["export_patches_aug"],
    "export_patches_aug": str,
})
C3dExportPatchesAugParamsDict = _C3dExportPatchesAugParamsDictNoTag | C3dExportPatchesAugParamsDictTagged


_C3dExtrudeSegParamsDictNoTag = typing.TypedDict('_C3dExtrudeSegParamsDictNoTag', {
    "extrude_seg": str,
})
C3dExtrudeSegParamsDictTagged = typing.TypedDict('C3dExtrudeSegParamsDictTagged', {
    "@type": typing.Literal["extrude_seg"],
    "extrude_seg": str,
})
C3dExtrudeSegParamsDict = _C3dExtrudeSegParamsDictNoTag | C3dExtrudeSegParamsDictTagged


_C3dFillBackgroundWithNoiseParamsDictNoTag = typing.TypedDict('_C3dFillBackgroundWithNoiseParamsDictNoTag', {
    "fill_background_with_noise": str,
})
C3dFillBackgroundWithNoiseParamsDictTagged = typing.TypedDict('C3dFillBackgroundWithNoiseParamsDictTagged', {
    "@type": typing.Literal["fill_background_with_noise"],
    "fill_background_with_noise": str,
})
C3dFillBackgroundWithNoiseParamsDict = _C3dFillBackgroundWithNoiseParamsDictNoTag | C3dFillBackgroundWithNoiseParamsDictTagged


_C3dFftParamsDictNoTag = typing.TypedDict('_C3dFftParamsDictNoTag', {
    "fft": str,
})
C3dFftParamsDictTagged = typing.TypedDict('C3dFftParamsDictTagged', {
    "@type": typing.Literal["fft"],
    "fft": str,
})
C3dFftParamsDict = _C3dFftParamsDictNoTag | C3dFftParamsDictTagged


_C3dFlipParamsDictNoTag = typing.TypedDict('_C3dFlipParamsDictNoTag', {
    "flip": str,
})
C3dFlipParamsDictTagged = typing.TypedDict('C3dFlipParamsDictTagged', {
    "@type": typing.Literal["flip"],
    "flip": str,
})
C3dFlipParamsDict = _C3dFlipParamsDictNoTag | C3dFlipParamsDictTagged


_C3dFloorParamsDictNoTag = typing.TypedDict('_C3dFloorParamsDictNoTag', {
    "floor": str,
})
C3dFloorParamsDictTagged = typing.TypedDict('C3dFloorParamsDictTagged', {
    "@type": typing.Literal["floor"],
    "floor": str,
})
C3dFloorParamsDict = _C3dFloorParamsDictNoTag | C3dFloorParamsDictTagged


_C3dForeachParamsDictNoTag = typing.TypedDict('_C3dForeachParamsDictNoTag', {
    "foreach": str,
})
C3dForeachParamsDictTagged = typing.TypedDict('C3dForeachParamsDictTagged', {
    "@type": typing.Literal["foreach"],
    "foreach": str,
})
C3dForeachParamsDict = _C3dForeachParamsDictNoTag | C3dForeachParamsDictTagged


_C3dForeachCompParamsDictNoTag = typing.TypedDict('_C3dForeachCompParamsDictNoTag', {
    "foreach_comp": str,
})
C3dForeachCompParamsDictTagged = typing.TypedDict('C3dForeachCompParamsDictTagged', {
    "@type": typing.Literal["foreach_comp"],
    "foreach_comp": str,
})
C3dForeachCompParamsDict = _C3dForeachCompParamsDictNoTag | C3dForeachCompParamsDictTagged


_C3dGlmParamsDictNoTag = typing.TypedDict('_C3dGlmParamsDictNoTag', {
    "glm": str,
})
C3dGlmParamsDictTagged = typing.TypedDict('C3dGlmParamsDictTagged', {
    "@type": typing.Literal["glm"],
    "glm": str,
})
C3dGlmParamsDict = _C3dGlmParamsDictNoTag | C3dGlmParamsDictTagged


_C3dGradientParamsDictNoTag = typing.TypedDict('_C3dGradientParamsDictNoTag', {
    "gradient": str,
})
C3dGradientParamsDictTagged = typing.TypedDict('C3dGradientParamsDictTagged', {
    "@type": typing.Literal["gradient"],
    "gradient": str,
})
C3dGradientParamsDict = _C3dGradientParamsDictNoTag | C3dGradientParamsDictTagged


_C3dHelpParamsDictNoTag = typing.TypedDict('_C3dHelpParamsDictNoTag', {
    "_help": str,
})
C3dHelpParamsDictTagged = typing.TypedDict('C3dHelpParamsDictTagged', {
    "@type": typing.Literal["_help"],
    "_help": str,
})
C3dHelpParamsDict = _C3dHelpParamsDictNoTag | C3dHelpParamsDictTagged


_C3dHolefillParamsDictNoTag = typing.TypedDict('_C3dHolefillParamsDictNoTag', {
    "holefill": str,
})
C3dHolefillParamsDictTagged = typing.TypedDict('C3dHolefillParamsDictTagged', {
    "@type": typing.Literal["holefill"],
    "holefill": str,
})
C3dHolefillParamsDict = _C3dHolefillParamsDictNoTag | C3dHolefillParamsDictTagged


_C3dHessianEigenvaluesParamsDictNoTag = typing.TypedDict('_C3dHessianEigenvaluesParamsDictNoTag', {
    "hessian_eigenvalues": str,
})
C3dHessianEigenvaluesParamsDictTagged = typing.TypedDict('C3dHessianEigenvaluesParamsDictTagged', {
    "@type": typing.Literal["hessian_eigenvalues"],
    "hessian_eigenvalues": str,
})
C3dHessianEigenvaluesParamsDict = _C3dHessianEigenvaluesParamsDictNoTag | C3dHessianEigenvaluesParamsDictTagged


_C3dHessianObjectnessParamsDictNoTag = typing.TypedDict('_C3dHessianObjectnessParamsDictNoTag', {
    "hessian_objectness": str,
})
C3dHessianObjectnessParamsDictTagged = typing.TypedDict('C3dHessianObjectnessParamsDictTagged', {
    "@type": typing.Literal["hessian_objectness"],
    "hessian_objectness": str,
})
C3dHessianObjectnessParamsDict = _C3dHessianObjectnessParamsDictNoTag | C3dHessianObjectnessParamsDictTagged


_C3dHistogramMatchParamsDictNoTag = typing.TypedDict('_C3dHistogramMatchParamsDictNoTag', {
    "histogram_match": str,
})
C3dHistogramMatchParamsDictTagged = typing.TypedDict('C3dHistogramMatchParamsDictTagged', {
    "@type": typing.Literal["histogram_match"],
    "histogram_match": str,
})
C3dHistogramMatchParamsDict = _C3dHistogramMatchParamsDictNoTag | C3dHistogramMatchParamsDictTagged


_C3dInfoParamsDictNoTag = typing.TypedDict('_C3dInfoParamsDictNoTag', {
    "info": str,
})
C3dInfoParamsDictTagged = typing.TypedDict('C3dInfoParamsDictTagged', {
    "@type": typing.Literal["info"],
    "info": str,
})
C3dInfoParamsDict = _C3dInfoParamsDictNoTag | C3dInfoParamsDictTagged


_C3dInfoFullParamsDictNoTag = typing.TypedDict('_C3dInfoFullParamsDictNoTag', {
    "info_full": str,
})
C3dInfoFullParamsDictTagged = typing.TypedDict('C3dInfoFullParamsDictTagged', {
    "@type": typing.Literal["info_full"],
    "info_full": str,
})
C3dInfoFullParamsDict = _C3dInfoFullParamsDictNoTag | C3dInfoFullParamsDictTagged


_C3dInsertParamsDictNoTag = typing.TypedDict('_C3dInsertParamsDictNoTag', {
    "insert": str,
})
C3dInsertParamsDictTagged = typing.TypedDict('C3dInsertParamsDictTagged', {
    "@type": typing.Literal["insert"],
    "insert": str,
})
C3dInsertParamsDict = _C3dInsertParamsDictNoTag | C3dInsertParamsDictTagged


_C3dInterpolationParamsDictNoTag = typing.TypedDict('_C3dInterpolationParamsDictNoTag', {
    "interpolation": str,
})
C3dInterpolationParamsDictTagged = typing.TypedDict('C3dInterpolationParamsDictTagged', {
    "@type": typing.Literal["interpolation"],
    "interpolation": str,
})
C3dInterpolationParamsDict = _C3dInterpolationParamsDictNoTag | C3dInterpolationParamsDictTagged


_C3dIterationsParamsDictNoTag = typing.TypedDict('_C3dIterationsParamsDictNoTag', {
    "iterations": str,
})
C3dIterationsParamsDictTagged = typing.TypedDict('C3dIterationsParamsDictTagged', {
    "@type": typing.Literal["iterations"],
    "iterations": str,
})
C3dIterationsParamsDict = _C3dIterationsParamsDictNoTag | C3dIterationsParamsDictTagged


_C3dLabelOverlapParamsDictNoTag = typing.TypedDict('_C3dLabelOverlapParamsDictNoTag', {
    "label_overlap": str,
})
C3dLabelOverlapParamsDictTagged = typing.TypedDict('C3dLabelOverlapParamsDictTagged', {
    "@type": typing.Literal["label_overlap"],
    "label_overlap": str,
})
C3dLabelOverlapParamsDict = _C3dLabelOverlapParamsDictNoTag | C3dLabelOverlapParamsDictTagged


_C3dLabelStatisticsParamsDictNoTag = typing.TypedDict('_C3dLabelStatisticsParamsDictNoTag', {
    "label_statistics": str,
})
C3dLabelStatisticsParamsDictTagged = typing.TypedDict('C3dLabelStatisticsParamsDictTagged', {
    "@type": typing.Literal["label_statistics"],
    "label_statistics": str,
})
C3dLabelStatisticsParamsDict = _C3dLabelStatisticsParamsDictNoTag | C3dLabelStatisticsParamsDictTagged


_C3dLandmarksToSpheresParamsDictNoTag = typing.TypedDict('_C3dLandmarksToSpheresParamsDictNoTag', {
    "landmarks_to_spheres": str,
})
C3dLandmarksToSpheresParamsDictTagged = typing.TypedDict('C3dLandmarksToSpheresParamsDictTagged', {
    "@type": typing.Literal["landmarks_to_spheres"],
    "landmarks_to_spheres": str,
})
C3dLandmarksToSpheresParamsDict = _C3dLandmarksToSpheresParamsDictNoTag | C3dLandmarksToSpheresParamsDictTagged


_C3dLaplacianParamsDictNoTag = typing.TypedDict('_C3dLaplacianParamsDictNoTag', {
    "laplacian": str,
})
C3dLaplacianParamsDictTagged = typing.TypedDict('C3dLaplacianParamsDictTagged', {
    "@type": typing.Literal["laplacian"],
    "laplacian": str,
})
C3dLaplacianParamsDict = _C3dLaplacianParamsDictNoTag | C3dLaplacianParamsDictTagged


_C3dLevelsetParamsDictNoTag = typing.TypedDict('_C3dLevelsetParamsDictNoTag', {
    "levelset": str,
})
C3dLevelsetParamsDictTagged = typing.TypedDict('C3dLevelsetParamsDictTagged', {
    "@type": typing.Literal["levelset"],
    "levelset": str,
})
C3dLevelsetParamsDict = _C3dLevelsetParamsDictNoTag | C3dLevelsetParamsDictTagged


_C3dLevelsetCurvatureParamsDictNoTag = typing.TypedDict('_C3dLevelsetCurvatureParamsDictNoTag', {
    "levelset_curvature": str,
})
C3dLevelsetCurvatureParamsDictTagged = typing.TypedDict('C3dLevelsetCurvatureParamsDictTagged', {
    "@type": typing.Literal["levelset_curvature"],
    "levelset_curvature": str,
})
C3dLevelsetCurvatureParamsDict = _C3dLevelsetCurvatureParamsDictNoTag | C3dLevelsetCurvatureParamsDictTagged


_C3dLevelsetAdvectionParamsDictNoTag = typing.TypedDict('_C3dLevelsetAdvectionParamsDictNoTag', {
    "levelset_advection": str,
})
C3dLevelsetAdvectionParamsDictTagged = typing.TypedDict('C3dLevelsetAdvectionParamsDictTagged', {
    "@type": typing.Literal["levelset_advection"],
    "levelset_advection": str,
})
C3dLevelsetAdvectionParamsDict = _C3dLevelsetAdvectionParamsDictNoTag | C3dLevelsetAdvectionParamsDictTagged


_C3dLogParamsDictNoTag = typing.TypedDict('_C3dLogParamsDictNoTag', {
    "log": str,
})
C3dLogParamsDictTagged = typing.TypedDict('C3dLogParamsDictTagged', {
    "@type": typing.Literal["log"],
    "log": str,
})
C3dLogParamsDict = _C3dLogParamsDictNoTag | C3dLogParamsDictTagged


_C3dLog10ParamsDictNoTag = typing.TypedDict('_C3dLog10ParamsDictNoTag', {
    "log10": str,
})
C3dLog10ParamsDictTagged = typing.TypedDict('C3dLog10ParamsDictTagged', {
    "@type": typing.Literal["log10"],
    "log10": str,
})
C3dLog10ParamsDict = _C3dLog10ParamsDictNoTag | C3dLog10ParamsDictTagged


_C3dManualParamsDictNoTag = typing.TypedDict('_C3dManualParamsDictNoTag', {
    "manual": str,
})
C3dManualParamsDictTagged = typing.TypedDict('C3dManualParamsDictTagged', {
    "@type": typing.Literal["manual"],
    "manual": str,
})
C3dManualParamsDict = _C3dManualParamsDictNoTag | C3dManualParamsDictTagged


_C3dMatchBoundingBoxParamsDictNoTag = typing.TypedDict('_C3dMatchBoundingBoxParamsDictNoTag', {
    "match_bounding_box": str,
})
C3dMatchBoundingBoxParamsDictTagged = typing.TypedDict('C3dMatchBoundingBoxParamsDictTagged', {
    "@type": typing.Literal["match_bounding_box"],
    "match_bounding_box": str,
})
C3dMatchBoundingBoxParamsDict = _C3dMatchBoundingBoxParamsDictNoTag | C3dMatchBoundingBoxParamsDictTagged


_C3dMaximumParamsDictNoTag = typing.TypedDict('_C3dMaximumParamsDictNoTag', {
    "maximum": str,
})
C3dMaximumParamsDictTagged = typing.TypedDict('C3dMaximumParamsDictTagged', {
    "@type": typing.Literal["maximum"],
    "maximum": str,
})
C3dMaximumParamsDict = _C3dMaximumParamsDictNoTag | C3dMaximumParamsDictTagged


_C3dMulticomponentSplitParamsDictNoTag = typing.TypedDict('_C3dMulticomponentSplitParamsDictNoTag', {
    "multicomponent_split": str,
})
C3dMulticomponentSplitParamsDictTagged = typing.TypedDict('C3dMulticomponentSplitParamsDictTagged', {
    "@type": typing.Literal["multicomponent_split"],
    "multicomponent_split": str,
})
C3dMulticomponentSplitParamsDict = _C3dMulticomponentSplitParamsDictNoTag | C3dMulticomponentSplitParamsDictTagged


_C3dMeanParamsDictNoTag = typing.TypedDict('_C3dMeanParamsDictNoTag', {
    "mean": str,
})
C3dMeanParamsDictTagged = typing.TypedDict('C3dMeanParamsDictTagged', {
    "@type": typing.Literal["mean"],
    "mean": str,
})
C3dMeanParamsDict = _C3dMeanParamsDictNoTag | C3dMeanParamsDictTagged


_C3dMedianFilterParamsDictNoTag = typing.TypedDict('_C3dMedianFilterParamsDictNoTag', {
    "median_filter": str,
})
C3dMedianFilterParamsDictTagged = typing.TypedDict('C3dMedianFilterParamsDictTagged', {
    "@type": typing.Literal["median_filter"],
    "median_filter": str,
})
C3dMedianFilterParamsDict = _C3dMedianFilterParamsDictNoTag | C3dMedianFilterParamsDictTagged


_C3dMergeParamsDictNoTag = typing.TypedDict('_C3dMergeParamsDictNoTag', {
    "merge": str,
})
C3dMergeParamsDictTagged = typing.TypedDict('C3dMergeParamsDictTagged', {
    "@type": typing.Literal["merge"],
    "merge": str,
})
C3dMergeParamsDict = _C3dMergeParamsDictNoTag | C3dMergeParamsDictTagged


_C3dMeanFilterParamsDictNoTag = typing.TypedDict('_C3dMeanFilterParamsDictNoTag', {
    "mean_filter": str,
})
C3dMeanFilterParamsDictTagged = typing.TypedDict('C3dMeanFilterParamsDictTagged', {
    "@type": typing.Literal["mean_filter"],
    "mean_filter": str,
})
C3dMeanFilterParamsDict = _C3dMeanFilterParamsDictNoTag | C3dMeanFilterParamsDictTagged


_C3dMutualInfoParamsDictNoTag = typing.TypedDict('_C3dMutualInfoParamsDictNoTag', {
    "mutual_info": str,
})
C3dMutualInfoParamsDictTagged = typing.TypedDict('C3dMutualInfoParamsDictTagged', {
    "@type": typing.Literal["mutual_info"],
    "mutual_info": str,
})
C3dMutualInfoParamsDict = _C3dMutualInfoParamsDictNoTag | C3dMutualInfoParamsDictTagged


_C3dMinimumParamsDictNoTag = typing.TypedDict('_C3dMinimumParamsDictNoTag', {
    "minimum": str,
})
C3dMinimumParamsDictTagged = typing.TypedDict('C3dMinimumParamsDictTagged', {
    "@type": typing.Literal["minimum"],
    "minimum": str,
})
C3dMinimumParamsDict = _C3dMinimumParamsDictNoTag | C3dMinimumParamsDictTagged


_C3dMixtureModelParamsDictNoTag = typing.TypedDict('_C3dMixtureModelParamsDictNoTag', {
    "mixture_model": str,
})
C3dMixtureModelParamsDictTagged = typing.TypedDict('C3dMixtureModelParamsDictTagged', {
    "@type": typing.Literal["mixture_model"],
    "mixture_model": str,
})
C3dMixtureModelParamsDict = _C3dMixtureModelParamsDictNoTag | C3dMixtureModelParamsDictTagged


_C3dMomentsParamsDictNoTag = typing.TypedDict('_C3dMomentsParamsDictNoTag', {
    "moments": str,
})
C3dMomentsParamsDictTagged = typing.TypedDict('C3dMomentsParamsDictTagged', {
    "@type": typing.Literal["moments"],
    "moments": str,
})
C3dMomentsParamsDict = _C3dMomentsParamsDictNoTag | C3dMomentsParamsDictTagged


_C3dMattesMutualInfoParamsDictNoTag = typing.TypedDict('_C3dMattesMutualInfoParamsDictNoTag', {
    "mattes_mutual_info": str,
})
C3dMattesMutualInfoParamsDictTagged = typing.TypedDict('C3dMattesMutualInfoParamsDictTagged', {
    "@type": typing.Literal["mattes_mutual_info"],
    "mattes_mutual_info": str,
})
C3dMattesMutualInfoParamsDict = _C3dMattesMutualInfoParamsDictNoTag | C3dMattesMutualInfoParamsDictTagged


_C3dMeanSquareParamsDictNoTag = typing.TypedDict('_C3dMeanSquareParamsDictNoTag', {
    "mean_square": str,
})
C3dMeanSquareParamsDictTagged = typing.TypedDict('C3dMeanSquareParamsDictTagged', {
    "@type": typing.Literal["mean_square"],
    "mean_square": str,
})
C3dMeanSquareParamsDict = _C3dMeanSquareParamsDictNoTag | C3dMeanSquareParamsDictTagged


_C3dMultiplyParamsDictNoTag = typing.TypedDict('_C3dMultiplyParamsDictNoTag', {
    "multiply": str,
})
C3dMultiplyParamsDictTagged = typing.TypedDict('C3dMultiplyParamsDictTagged', {
    "@type": typing.Literal["multiply"],
    "multiply": str,
})
C3dMultiplyParamsDict = _C3dMultiplyParamsDictNoTag | C3dMultiplyParamsDictTagged


_C3dNormalizedCrossCorrelationParamsDictNoTag = typing.TypedDict('_C3dNormalizedCrossCorrelationParamsDictNoTag', {
    "normalized_cross_correlation": str,
})
C3dNormalizedCrossCorrelationParamsDictTagged = typing.TypedDict('C3dNormalizedCrossCorrelationParamsDictTagged', {
    "@type": typing.Literal["normalized_cross_correlation"],
    "normalized_cross_correlation": str,
})
C3dNormalizedCrossCorrelationParamsDict = _C3dNormalizedCrossCorrelationParamsDictNoTag | C3dNormalizedCrossCorrelationParamsDictTagged


_C3dNormalizedCorrelationParamsDictNoTag = typing.TypedDict('_C3dNormalizedCorrelationParamsDictNoTag', {
    "normalized_correlation": str,
})
C3dNormalizedCorrelationParamsDictTagged = typing.TypedDict('C3dNormalizedCorrelationParamsDictTagged', {
    "@type": typing.Literal["normalized_correlation"],
    "normalized_correlation": str,
})
C3dNormalizedCorrelationParamsDict = _C3dNormalizedCorrelationParamsDictNoTag | C3dNormalizedCorrelationParamsDictTagged


_C3dNormalizedMutualInfoParamsDictNoTag = typing.TypedDict('_C3dNormalizedMutualInfoParamsDictNoTag', {
    "normalized_mutual_info": str,
})
C3dNormalizedMutualInfoParamsDictTagged = typing.TypedDict('C3dNormalizedMutualInfoParamsDictTagged', {
    "@type": typing.Literal["normalized_mutual_info"],
    "normalized_mutual_info": str,
})
C3dNormalizedMutualInfoParamsDict = _C3dNormalizedMutualInfoParamsDictNoTag | C3dNormalizedMutualInfoParamsDictTagged


_C3dNoiseGaussianParamsDictNoTag = typing.TypedDict('_C3dNoiseGaussianParamsDictNoTag', {
    "noise_gaussian": str,
})
C3dNoiseGaussianParamsDictTagged = typing.TypedDict('C3dNoiseGaussianParamsDictTagged', {
    "@type": typing.Literal["noise_gaussian"],
    "noise_gaussian": str,
})
C3dNoiseGaussianParamsDict = _C3dNoiseGaussianParamsDictNoTag | C3dNoiseGaussianParamsDictTagged


_C3dNoisePoissonParamsDictNoTag = typing.TypedDict('_C3dNoisePoissonParamsDictNoTag', {
    "noise_poisson": str,
})
C3dNoisePoissonParamsDictTagged = typing.TypedDict('C3dNoisePoissonParamsDictTagged', {
    "@type": typing.Literal["noise_poisson"],
    "noise_poisson": str,
})
C3dNoisePoissonParamsDict = _C3dNoisePoissonParamsDictNoTag | C3dNoisePoissonParamsDictTagged


_C3dNoiseSpeckleParamsDictNoTag = typing.TypedDict('_C3dNoiseSpeckleParamsDictNoTag', {
    "noise_speckle": str,
})
C3dNoiseSpeckleParamsDictTagged = typing.TypedDict('C3dNoiseSpeckleParamsDictTagged', {
    "@type": typing.Literal["noise_speckle"],
    "noise_speckle": str,
})
C3dNoiseSpeckleParamsDict = _C3dNoiseSpeckleParamsDictNoTag | C3dNoiseSpeckleParamsDictTagged


_C3dNoiseSaltPepperParamsDictNoTag = typing.TypedDict('_C3dNoiseSaltPepperParamsDictNoTag', {
    "noise_salt_pepper": str,
})
C3dNoiseSaltPepperParamsDictTagged = typing.TypedDict('C3dNoiseSaltPepperParamsDictTagged', {
    "@type": typing.Literal["noise_salt_pepper"],
    "noise_salt_pepper": str,
})
C3dNoiseSaltPepperParamsDict = _C3dNoiseSaltPepperParamsDictNoTag | C3dNoiseSaltPepperParamsDictTagged


_C3dNoMulticomponentSplitParamsDictNoTag = typing.TypedDict('_C3dNoMulticomponentSplitParamsDictNoTag', {
    "no_multicomponent_split": str,
})
C3dNoMulticomponentSplitParamsDictTagged = typing.TypedDict('C3dNoMulticomponentSplitParamsDictTagged', {
    "@type": typing.Literal["no_multicomponent_split"],
    "no_multicomponent_split": str,
})
C3dNoMulticomponentSplitParamsDict = _C3dNoMulticomponentSplitParamsDictNoTag | C3dNoMulticomponentSplitParamsDictTagged


_C3dNormalizeLocalWindowParamsDictNoTag = typing.TypedDict('_C3dNormalizeLocalWindowParamsDictNoTag', {
    "normalize_local_window": str,
})
C3dNormalizeLocalWindowParamsDictTagged = typing.TypedDict('C3dNormalizeLocalWindowParamsDictTagged', {
    "@type": typing.Literal["normalize_local_window"],
    "normalize_local_window": str,
})
C3dNormalizeLocalWindowParamsDict = _C3dNormalizeLocalWindowParamsDictNoTag | C3dNormalizeLocalWindowParamsDictTagged


_C3dNormpdfParamsDictNoTag = typing.TypedDict('_C3dNormpdfParamsDictNoTag', {
    "normpdf": str,
})
C3dNormpdfParamsDictTagged = typing.TypedDict('C3dNormpdfParamsDictTagged', {
    "@type": typing.Literal["normpdf"],
    "normpdf": str,
})
C3dNormpdfParamsDict = _C3dNormpdfParamsDictNoTag | C3dNormpdfParamsDictTagged


_C3dNoroundParamsDictNoTag = typing.TypedDict('_C3dNoroundParamsDictNoTag', {
    "noround": str,
})
C3dNoroundParamsDictTagged = typing.TypedDict('C3dNoroundParamsDictTagged', {
    "@type": typing.Literal["noround"],
    "noround": str,
})
C3dNoroundParamsDict = _C3dNoroundParamsDictNoTag | C3dNoroundParamsDictTagged


_C3dNospmParamsDictNoTag = typing.TypedDict('_C3dNospmParamsDictNoTag', {
    "nospm": str,
})
C3dNospmParamsDictTagged = typing.TypedDict('C3dNospmParamsDictTagged', {
    "@type": typing.Literal["nospm"],
    "nospm": str,
})
C3dNospmParamsDict = _C3dNospmParamsDictNoTag | C3dNospmParamsDictTagged


_C3dOutputParamsDictNoTag = typing.TypedDict('_C3dOutputParamsDictNoTag', {
    "output": str,
})
C3dOutputParamsDictTagged = typing.TypedDict('C3dOutputParamsDictTagged', {
    "@type": typing.Literal["output"],
    "output": str,
})
C3dOutputParamsDict = _C3dOutputParamsDictNoTag | C3dOutputParamsDictTagged


_C3dOutputMulticomponentParamsDictNoTag = typing.TypedDict('_C3dOutputMulticomponentParamsDictNoTag', {
    "output_multicomponent": str,
})
C3dOutputMulticomponentParamsDictTagged = typing.TypedDict('C3dOutputMulticomponentParamsDictTagged', {
    "@type": typing.Literal["output_multicomponent"],
    "output_multicomponent": str,
})
C3dOutputMulticomponentParamsDict = _C3dOutputMulticomponentParamsDictNoTag | C3dOutputMulticomponentParamsDictTagged


_C3dOutputMultipleMulticomponentParamsDictNoTag = typing.TypedDict('_C3dOutputMultipleMulticomponentParamsDictNoTag', {
    "output_multiple_multicomponent": str,
})
C3dOutputMultipleMulticomponentParamsDictTagged = typing.TypedDict('C3dOutputMultipleMulticomponentParamsDictTagged', {
    "@type": typing.Literal["output_multiple_multicomponent"],
    "output_multiple_multicomponent": str,
})
C3dOutputMultipleMulticomponentParamsDict = _C3dOutputMultipleMulticomponentParamsDictNoTag | C3dOutputMultipleMulticomponentParamsDictTagged


_C3dOrientParamsDictNoTag = typing.TypedDict('_C3dOrientParamsDictNoTag', {
    "orient": str,
})
C3dOrientParamsDictTagged = typing.TypedDict('C3dOrientParamsDictTagged', {
    "@type": typing.Literal["orient"],
    "orient": str,
})
C3dOrientParamsDict = _C3dOrientParamsDictNoTag | C3dOrientParamsDictTagged


_C3dOutputMultipleParamsDictNoTag = typing.TypedDict('_C3dOutputMultipleParamsDictNoTag', {
    "output_multiple": str,
})
C3dOutputMultipleParamsDictTagged = typing.TypedDict('C3dOutputMultipleParamsDictTagged', {
    "@type": typing.Literal["output_multiple"],
    "output_multiple": str,
})
C3dOutputMultipleParamsDict = _C3dOutputMultipleParamsDictNoTag | C3dOutputMultipleParamsDictTagged


_C3dOrient1ParamsDictNoTag = typing.TypedDict('_C3dOrient1ParamsDictNoTag', {
    "orient": str,
})
C3dOrient1ParamsDictTagged = typing.TypedDict('C3dOrient1ParamsDictTagged', {
    "@type": typing.Literal["orient_1"],
    "orient": str,
})
C3dOrient1ParamsDict = _C3dOrient1ParamsDictNoTag | C3dOrient1ParamsDictTagged


_C3dOriginParamsDictNoTag = typing.TypedDict('_C3dOriginParamsDictNoTag', {
    "origin": str,
})
C3dOriginParamsDictTagged = typing.TypedDict('C3dOriginParamsDictTagged', {
    "@type": typing.Literal["origin"],
    "origin": str,
})
C3dOriginParamsDict = _C3dOriginParamsDictNoTag | C3dOriginParamsDictTagged


_C3dOriginVoxelParamsDictNoTag = typing.TypedDict('_C3dOriginVoxelParamsDictNoTag', {
    "origin_voxel": str,
})
C3dOriginVoxelParamsDictTagged = typing.TypedDict('C3dOriginVoxelParamsDictTagged', {
    "@type": typing.Literal["origin_voxel"],
    "origin_voxel": str,
})
C3dOriginVoxelParamsDict = _C3dOriginVoxelParamsDictNoTag | C3dOriginVoxelParamsDictTagged


_C3dOriginVoxelCoordParamsDictNoTag = typing.TypedDict('_C3dOriginVoxelCoordParamsDictNoTag', {
    "origin_voxel_coord": str,
})
C3dOriginVoxelCoordParamsDictTagged = typing.TypedDict('C3dOriginVoxelCoordParamsDictTagged', {
    "@type": typing.Literal["origin_voxel_coord"],
    "origin_voxel_coord": str,
})
C3dOriginVoxelCoordParamsDict = _C3dOriginVoxelCoordParamsDictNoTag | C3dOriginVoxelCoordParamsDictTagged


_C3dOverlapParamsDictNoTag = typing.TypedDict('_C3dOverlapParamsDictNoTag', {
    "overlap": str,
})
C3dOverlapParamsDictTagged = typing.TypedDict('C3dOverlapParamsDictTagged', {
    "@type": typing.Literal["overlap"],
    "overlap": str,
})
C3dOverlapParamsDict = _C3dOverlapParamsDictNoTag | C3dOverlapParamsDictTagged


_C3dOverlayLabelImageParamsDictNoTag = typing.TypedDict('_C3dOverlayLabelImageParamsDictNoTag', {
    "overlay_label_image": str,
})
C3dOverlayLabelImageParamsDictTagged = typing.TypedDict('C3dOverlayLabelImageParamsDictTagged', {
    "@type": typing.Literal["overlay_label_image"],
    "overlay_label_image": str,
})
C3dOverlayLabelImageParamsDict = _C3dOverlayLabelImageParamsDictNoTag | C3dOverlayLabelImageParamsDictTagged


_C3dPadParamsDictNoTag = typing.TypedDict('_C3dPadParamsDictNoTag', {
    "pad": str,
})
C3dPadParamsDictTagged = typing.TypedDict('C3dPadParamsDictTagged', {
    "@type": typing.Literal["pad"],
    "pad": str,
})
C3dPadParamsDict = _C3dPadParamsDictNoTag | C3dPadParamsDictTagged


_C3dPadToParamsDictNoTag = typing.TypedDict('_C3dPadToParamsDictNoTag', {
    "pad_to": str,
})
C3dPadToParamsDictTagged = typing.TypedDict('C3dPadToParamsDictTagged', {
    "@type": typing.Literal["pad_to"],
    "pad_to": str,
})
C3dPadToParamsDict = _C3dPadToParamsDictNoTag | C3dPadToParamsDictTagged


_C3dPcaParamsDictNoTag = typing.TypedDict('_C3dPcaParamsDictNoTag', {
    "pca": str,
})
C3dPcaParamsDictTagged = typing.TypedDict('C3dPcaParamsDictTagged', {
    "@type": typing.Literal["pca"],
    "pca": str,
})
C3dPcaParamsDict = _C3dPcaParamsDictNoTag | C3dPcaParamsDictTagged


_C3dPercentIntensityModeParamsDictNoTag = typing.TypedDict('_C3dPercentIntensityModeParamsDictNoTag', {
    "percent_intensity_mode": str,
})
C3dPercentIntensityModeParamsDictTagged = typing.TypedDict('C3dPercentIntensityModeParamsDictTagged', {
    "@type": typing.Literal["percent_intensity_mode"],
    "percent_intensity_mode": str,
})
C3dPercentIntensityModeParamsDict = _C3dPercentIntensityModeParamsDictNoTag | C3dPercentIntensityModeParamsDictTagged


_C3dPixelParamsDictNoTag = typing.TypedDict('_C3dPixelParamsDictNoTag', {
    "pixel": str,
})
C3dPixelParamsDictTagged = typing.TypedDict('C3dPixelParamsDictTagged', {
    "@type": typing.Literal["pixel"],
    "pixel": str,
})
C3dPixelParamsDict = _C3dPixelParamsDictNoTag | C3dPixelParamsDictTagged


_C3dPopParamsDictNoTag = typing.TypedDict('_C3dPopParamsDictNoTag', {
    "pop": str,
})
C3dPopParamsDictTagged = typing.TypedDict('C3dPopParamsDictTagged', {
    "@type": typing.Literal["pop"],
    "pop": str,
})
C3dPopParamsDict = _C3dPopParamsDictNoTag | C3dPopParamsDictTagged


_C3dPopasParamsDictNoTag = typing.TypedDict('_C3dPopasParamsDictNoTag', {
    "popas": str,
})
C3dPopasParamsDictTagged = typing.TypedDict('C3dPopasParamsDictTagged', {
    "@type": typing.Literal["popas"],
    "popas": str,
})
C3dPopasParamsDict = _C3dPopasParamsDictNoTag | C3dPopasParamsDictTagged


_C3dProbeParamsDictNoTag = typing.TypedDict('_C3dProbeParamsDictNoTag', {
    "probe": str,
})
C3dProbeParamsDictTagged = typing.TypedDict('C3dProbeParamsDictTagged', {
    "@type": typing.Literal["probe"],
    "probe": str,
})
C3dProbeParamsDict = _C3dProbeParamsDictNoTag | C3dProbeParamsDictTagged


_C3dPushParamsDictNoTag = typing.TypedDict('_C3dPushParamsDictNoTag', {
    "push": str,
})
C3dPushParamsDictTagged = typing.TypedDict('C3dPushParamsDictTagged', {
    "@type": typing.Literal["push"],
    "push": str,
})
C3dPushParamsDict = _C3dPushParamsDictNoTag | C3dPushParamsDictTagged


_C3dRankParamsDictNoTag = typing.TypedDict('_C3dRankParamsDictNoTag', {
    "rank": str,
})
C3dRankParamsDictTagged = typing.TypedDict('C3dRankParamsDictTagged', {
    "@type": typing.Literal["rank"],
    "rank": str,
})
C3dRankParamsDict = _C3dRankParamsDictNoTag | C3dRankParamsDictTagged


_C3dReciprocalParamsDictNoTag = typing.TypedDict('_C3dReciprocalParamsDictNoTag', {
    "reciprocal": str,
})
C3dReciprocalParamsDictTagged = typing.TypedDict('C3dReciprocalParamsDictTagged', {
    "@type": typing.Literal["reciprocal"],
    "reciprocal": str,
})
C3dReciprocalParamsDict = _C3dReciprocalParamsDictNoTag | C3dReciprocalParamsDictTagged


_C3dRegionParamsDictNoTag = typing.TypedDict('_C3dRegionParamsDictNoTag', {
    "region": str,
})
C3dRegionParamsDictTagged = typing.TypedDict('C3dRegionParamsDictTagged', {
    "@type": typing.Literal["region"],
    "region": str,
})
C3dRegionParamsDict = _C3dRegionParamsDictNoTag | C3dRegionParamsDictTagged


_C3dReorderParamsDictNoTag = typing.TypedDict('_C3dReorderParamsDictNoTag', {
    "reorder": str,
})
C3dReorderParamsDictTagged = typing.TypedDict('C3dReorderParamsDictTagged', {
    "@type": typing.Literal["reorder"],
    "reorder": str,
})
C3dReorderParamsDict = _C3dReorderParamsDictNoTag | C3dReorderParamsDictTagged


_C3dRetainLabelsParamsDictNoTag = typing.TypedDict('_C3dRetainLabelsParamsDictNoTag', {
    "retain_labels": str,
})
C3dRetainLabelsParamsDictTagged = typing.TypedDict('C3dRetainLabelsParamsDictTagged', {
    "@type": typing.Literal["retain_labels"],
    "retain_labels": str,
})
C3dRetainLabelsParamsDict = _C3dRetainLabelsParamsDictNoTag | C3dRetainLabelsParamsDictTagged


_C3dRfApplyParamsDictNoTag = typing.TypedDict('_C3dRfApplyParamsDictNoTag', {
    "rf_apply": str,
})
C3dRfApplyParamsDictTagged = typing.TypedDict('C3dRfApplyParamsDictTagged', {
    "@type": typing.Literal["rf_apply"],
    "rf_apply": str,
})
C3dRfApplyParamsDict = _C3dRfApplyParamsDictNoTag | C3dRfApplyParamsDictTagged


_C3dRfTrainParamsDictNoTag = typing.TypedDict('_C3dRfTrainParamsDictNoTag', {
    "rf_train": str,
})
C3dRfTrainParamsDictTagged = typing.TypedDict('C3dRfTrainParamsDictTagged', {
    "@type": typing.Literal["rf_train"],
    "rf_train": str,
})
C3dRfTrainParamsDict = _C3dRfTrainParamsDictNoTag | C3dRfTrainParamsDictTagged


_C3dRfParamPatchParamsDictNoTag = typing.TypedDict('_C3dRfParamPatchParamsDictNoTag', {
    "rf_param_patch": str,
})
C3dRfParamPatchParamsDictTagged = typing.TypedDict('C3dRfParamPatchParamsDictTagged', {
    "@type": typing.Literal["rf_param_patch"],
    "rf_param_patch": str,
})
C3dRfParamPatchParamsDict = _C3dRfParamPatchParamsDictNoTag | C3dRfParamPatchParamsDictTagged


_C3dRfParamUsexyzParamsDictNoTag = typing.TypedDict('_C3dRfParamUsexyzParamsDictNoTag', {
    "rf_param_usexyz": str,
})
C3dRfParamUsexyzParamsDictTagged = typing.TypedDict('C3dRfParamUsexyzParamsDictTagged', {
    "@type": typing.Literal["rf_param_usexyz"],
    "rf_param_usexyz": str,
})
C3dRfParamUsexyzParamsDict = _C3dRfParamUsexyzParamsDictNoTag | C3dRfParamUsexyzParamsDictTagged


_C3dRfParamNousexyzParamsDictNoTag = typing.TypedDict('_C3dRfParamNousexyzParamsDictNoTag', {
    "rf_param_nousexyz": str,
})
C3dRfParamNousexyzParamsDictTagged = typing.TypedDict('C3dRfParamNousexyzParamsDictTagged', {
    "@type": typing.Literal["rf_param_nousexyz"],
    "rf_param_nousexyz": str,
})
C3dRfParamNousexyzParamsDict = _C3dRfParamNousexyzParamsDictNoTag | C3dRfParamNousexyzParamsDictTagged


_C3dRfParamNtreesParamsDictNoTag = typing.TypedDict('_C3dRfParamNtreesParamsDictNoTag', {
    "rf_param_ntrees": str,
})
C3dRfParamNtreesParamsDictTagged = typing.TypedDict('C3dRfParamNtreesParamsDictTagged', {
    "@type": typing.Literal["rf_param_ntrees"],
    "rf_param_ntrees": str,
})
C3dRfParamNtreesParamsDict = _C3dRfParamNtreesParamsDictNoTag | C3dRfParamNtreesParamsDictTagged


_C3dRfParamTreedepthParamsDictNoTag = typing.TypedDict('_C3dRfParamTreedepthParamsDictNoTag', {
    "rf_param_treedepth": str,
})
C3dRfParamTreedepthParamsDictTagged = typing.TypedDict('C3dRfParamTreedepthParamsDictTagged', {
    "@type": typing.Literal["rf_param_treedepth"],
    "rf_param_treedepth": str,
})
C3dRfParamTreedepthParamsDict = _C3dRfParamTreedepthParamsDictNoTag | C3dRfParamTreedepthParamsDictTagged


_C3dSetSformParamsDictNoTag = typing.TypedDict('_C3dSetSformParamsDictNoTag', {
    "set_sform": str,
})
C3dSetSformParamsDictTagged = typing.TypedDict('C3dSetSformParamsDictTagged', {
    "@type": typing.Literal["set_sform"],
    "set_sform": str,
})
C3dSetSformParamsDict = _C3dSetSformParamsDictNoTag | C3dSetSformParamsDictTagged


_C3dReplaceParamsDictNoTag = typing.TypedDict('_C3dReplaceParamsDictNoTag', {
    "replace": str,
})
C3dReplaceParamsDictTagged = typing.TypedDict('C3dReplaceParamsDictTagged', {
    "@type": typing.Literal["replace"],
    "replace": str,
})
C3dReplaceParamsDict = _C3dReplaceParamsDictNoTag | C3dReplaceParamsDictTagged


_C3dResampleParamsDictNoTag = typing.TypedDict('_C3dResampleParamsDictNoTag', {
    "resample": str,
})
C3dResampleParamsDictTagged = typing.TypedDict('C3dResampleParamsDictTagged', {
    "@type": typing.Literal["resample"],
    "resample": str,
})
C3dResampleParamsDict = _C3dResampleParamsDictNoTag | C3dResampleParamsDictTagged


_C3dResampleIsoParamsDictNoTag = typing.TypedDict('_C3dResampleIsoParamsDictNoTag', {
    "resample_iso": str,
})
C3dResampleIsoParamsDictTagged = typing.TypedDict('C3dResampleIsoParamsDictTagged', {
    "@type": typing.Literal["resample_iso"],
    "resample_iso": str,
})
C3dResampleIsoParamsDict = _C3dResampleIsoParamsDictNoTag | C3dResampleIsoParamsDictTagged


_C3dResampleMmParamsDictNoTag = typing.TypedDict('_C3dResampleMmParamsDictNoTag', {
    "resample_mm": str,
})
C3dResampleMmParamsDictTagged = typing.TypedDict('C3dResampleMmParamsDictTagged', {
    "@type": typing.Literal["resample_mm"],
    "resample_mm": str,
})
C3dResampleMmParamsDict = _C3dResampleMmParamsDictNoTag | C3dResampleMmParamsDictTagged


_C3dResliceItkParamsDictNoTag = typing.TypedDict('_C3dResliceItkParamsDictNoTag', {
    "reslice_itk": str,
})
C3dResliceItkParamsDictTagged = typing.TypedDict('C3dResliceItkParamsDictTagged', {
    "@type": typing.Literal["reslice_itk"],
    "reslice_itk": str,
})
C3dResliceItkParamsDict = _C3dResliceItkParamsDictNoTag | C3dResliceItkParamsDictTagged


_C3dResliceMatrixParamsDictNoTag = typing.TypedDict('_C3dResliceMatrixParamsDictNoTag', {
    "reslice_matrix": str,
})
C3dResliceMatrixParamsDictTagged = typing.TypedDict('C3dResliceMatrixParamsDictTagged', {
    "@type": typing.Literal["reslice_matrix"],
    "reslice_matrix": str,
})
C3dResliceMatrixParamsDict = _C3dResliceMatrixParamsDictNoTag | C3dResliceMatrixParamsDictTagged


_C3dResliceIdentityParamsDictNoTag = typing.TypedDict('_C3dResliceIdentityParamsDictNoTag', {
    "reslice_identity": str,
})
C3dResliceIdentityParamsDictTagged = typing.TypedDict('C3dResliceIdentityParamsDictTagged', {
    "@type": typing.Literal["reslice_identity"],
    "reslice_identity": str,
})
C3dResliceIdentityParamsDict = _C3dResliceIdentityParamsDictNoTag | C3dResliceIdentityParamsDictTagged


_C3dRgb2hsvParamsDictNoTag = typing.TypedDict('_C3dRgb2hsvParamsDictNoTag', {
    "rgb2hsv": str,
})
C3dRgb2hsvParamsDictTagged = typing.TypedDict('C3dRgb2hsvParamsDictTagged', {
    "@type": typing.Literal["rgb2hsv"],
    "rgb2hsv": str,
})
C3dRgb2hsvParamsDict = _C3dRgb2hsvParamsDictNoTag | C3dRgb2hsvParamsDictTagged


_C3dRmsParamsDictNoTag = typing.TypedDict('_C3dRmsParamsDictNoTag', {
    "rms": str,
})
C3dRmsParamsDictTagged = typing.TypedDict('C3dRmsParamsDictTagged', {
    "@type": typing.Literal["rms"],
    "rms": str,
})
C3dRmsParamsDict = _C3dRmsParamsDictNoTag | C3dRmsParamsDictTagged


_C3dRoundParamsDictNoTag = typing.TypedDict('_C3dRoundParamsDictNoTag', {
    "round": str,
})
C3dRoundParamsDictTagged = typing.TypedDict('C3dRoundParamsDictTagged', {
    "@type": typing.Literal["round"],
    "round": str,
})
C3dRoundParamsDict = _C3dRoundParamsDictNoTag | C3dRoundParamsDictTagged


_C3dScaleParamsDictNoTag = typing.TypedDict('_C3dScaleParamsDictNoTag', {
    "scale": str,
})
C3dScaleParamsDictTagged = typing.TypedDict('C3dScaleParamsDictTagged', {
    "@type": typing.Literal["scale"],
    "scale": str,
})
C3dScaleParamsDict = _C3dScaleParamsDictNoTag | C3dScaleParamsDictTagged


_C3dSetSform1ParamsDictNoTag = typing.TypedDict('_C3dSetSform1ParamsDictNoTag', {
    "set_sform": str,
})
C3dSetSform1ParamsDictTagged = typing.TypedDict('C3dSetSform1ParamsDictTagged', {
    "@type": typing.Literal["set_sform_1"],
    "set_sform": str,
})
C3dSetSform1ParamsDict = _C3dSetSform1ParamsDictNoTag | C3dSetSform1ParamsDictTagged


_C3dSinParamsDictNoTag = typing.TypedDict('_C3dSinParamsDictNoTag', {
    "sin": str,
})
C3dSinParamsDictTagged = typing.TypedDict('C3dSinParamsDictTagged', {
    "@type": typing.Literal["sin"],
    "sin": str,
})
C3dSinParamsDict = _C3dSinParamsDictNoTag | C3dSinParamsDictTagged


_C3dSliceParamsDictNoTag = typing.TypedDict('_C3dSliceParamsDictNoTag', {
    "slice": str,
})
C3dSliceParamsDictTagged = typing.TypedDict('C3dSliceParamsDictTagged', {
    "@type": typing.Literal["slice"],
    "slice": str,
})
C3dSliceParamsDict = _C3dSliceParamsDictNoTag | C3dSliceParamsDictTagged


_C3dSliceAllParamsDictNoTag = typing.TypedDict('_C3dSliceAllParamsDictNoTag', {
    "slice_all": str,
})
C3dSliceAllParamsDictTagged = typing.TypedDict('C3dSliceAllParamsDictTagged', {
    "@type": typing.Literal["slice_all"],
    "slice_all": str,
})
C3dSliceAllParamsDict = _C3dSliceAllParamsDictNoTag | C3dSliceAllParamsDictTagged


_C3dSharpenParamsDictNoTag = typing.TypedDict('_C3dSharpenParamsDictNoTag', {
    "sharpen": str,
})
C3dSharpenParamsDictTagged = typing.TypedDict('C3dSharpenParamsDictTagged', {
    "@type": typing.Literal["sharpen"],
    "sharpen": str,
})
C3dSharpenParamsDict = _C3dSharpenParamsDictNoTag | C3dSharpenParamsDictTagged


_C3dShiftParamsDictNoTag = typing.TypedDict('_C3dShiftParamsDictNoTag', {
    "shift": str,
})
C3dShiftParamsDictTagged = typing.TypedDict('C3dShiftParamsDictTagged', {
    "@type": typing.Literal["shift"],
    "shift": str,
})
C3dShiftParamsDict = _C3dShiftParamsDictNoTag | C3dShiftParamsDictTagged


_C3dSignedDistanceTransformParamsDictNoTag = typing.TypedDict('_C3dSignedDistanceTransformParamsDictNoTag', {
    "signed_distance_transform": str,
})
C3dSignedDistanceTransformParamsDictTagged = typing.TypedDict('C3dSignedDistanceTransformParamsDictTagged', {
    "@type": typing.Literal["signed_distance_transform"],
    "signed_distance_transform": str,
})
C3dSignedDistanceTransformParamsDict = _C3dSignedDistanceTransformParamsDictNoTag | C3dSignedDistanceTransformParamsDictTagged


_C3dSmoothParamsDictNoTag = typing.TypedDict('_C3dSmoothParamsDictNoTag', {
    "smooth": str,
})
C3dSmoothParamsDictTagged = typing.TypedDict('C3dSmoothParamsDictTagged', {
    "@type": typing.Literal["smooth"],
    "smooth": str,
})
C3dSmoothParamsDict = _C3dSmoothParamsDictNoTag | C3dSmoothParamsDictTagged


_C3dSmoothFastParamsDictNoTag = typing.TypedDict('_C3dSmoothFastParamsDictNoTag', {
    "smooth_fast": str,
})
C3dSmoothFastParamsDictTagged = typing.TypedDict('C3dSmoothFastParamsDictTagged', {
    "@type": typing.Literal["smooth_fast"],
    "smooth_fast": str,
})
C3dSmoothFastParamsDict = _C3dSmoothFastParamsDictNoTag | C3dSmoothFastParamsDictTagged


_C3dSpacingParamsDictNoTag = typing.TypedDict('_C3dSpacingParamsDictNoTag', {
    "spacing": str,
})
C3dSpacingParamsDictTagged = typing.TypedDict('C3dSpacingParamsDictTagged', {
    "@type": typing.Literal["spacing"],
    "spacing": str,
})
C3dSpacingParamsDict = _C3dSpacingParamsDictNoTag | C3dSpacingParamsDictTagged


_C3dSplitParamsDictNoTag = typing.TypedDict('_C3dSplitParamsDictNoTag', {
    "split": str,
})
C3dSplitParamsDictTagged = typing.TypedDict('C3dSplitParamsDictTagged', {
    "@type": typing.Literal["split"],
    "split": str,
})
C3dSplitParamsDict = _C3dSplitParamsDictNoTag | C3dSplitParamsDictTagged


_C3dSqrtParamsDictNoTag = typing.TypedDict('_C3dSqrtParamsDictNoTag', {
    "sqrt": str,
})
C3dSqrtParamsDictTagged = typing.TypedDict('C3dSqrtParamsDictTagged', {
    "@type": typing.Literal["sqrt"],
    "sqrt": str,
})
C3dSqrtParamsDict = _C3dSqrtParamsDictNoTag | C3dSqrtParamsDictTagged


_C3dStapleParamsDictNoTag = typing.TypedDict('_C3dStapleParamsDictNoTag', {
    "staple": str,
})
C3dStapleParamsDictTagged = typing.TypedDict('C3dStapleParamsDictTagged', {
    "@type": typing.Literal["staple"],
    "staple": str,
})
C3dStapleParamsDict = _C3dStapleParamsDictNoTag | C3dStapleParamsDictTagged


_C3dStructureTensorEigenvaluesParamsDictNoTag = typing.TypedDict('_C3dStructureTensorEigenvaluesParamsDictNoTag', {
    "structure_tensor_eigenvalues": str,
})
C3dStructureTensorEigenvaluesParamsDictTagged = typing.TypedDict('C3dStructureTensorEigenvaluesParamsDictTagged', {
    "@type": typing.Literal["structure_tensor_eigenvalues"],
    "structure_tensor_eigenvalues": str,
})
C3dStructureTensorEigenvaluesParamsDict = _C3dStructureTensorEigenvaluesParamsDictNoTag | C3dStructureTensorEigenvaluesParamsDictTagged


_C3dSpmParamsDictNoTag = typing.TypedDict('_C3dSpmParamsDictNoTag', {
    "spm": str,
})
C3dSpmParamsDictTagged = typing.TypedDict('C3dSpmParamsDictTagged', {
    "@type": typing.Literal["spm"],
    "spm": str,
})
C3dSpmParamsDict = _C3dSpmParamsDictNoTag | C3dSpmParamsDictTagged


_C3dSubtractParamsDictNoTag = typing.TypedDict('_C3dSubtractParamsDictNoTag', {
    "subtract": str,
})
C3dSubtractParamsDictTagged = typing.TypedDict('C3dSubtractParamsDictTagged', {
    "@type": typing.Literal["subtract"],
    "subtract": str,
})
C3dSubtractParamsDict = _C3dSubtractParamsDictNoTag | C3dSubtractParamsDictTagged


_C3dSupervoxelParamsDictNoTag = typing.TypedDict('_C3dSupervoxelParamsDictNoTag', {
    "supervoxel": str,
})
C3dSupervoxelParamsDictTagged = typing.TypedDict('C3dSupervoxelParamsDictTagged', {
    "@type": typing.Literal["supervoxel"],
    "supervoxel": str,
})
C3dSupervoxelParamsDict = _C3dSupervoxelParamsDictNoTag | C3dSupervoxelParamsDictTagged


_C3dStretchParamsDictNoTag = typing.TypedDict('_C3dStretchParamsDictNoTag', {
    "stretch": str,
})
C3dStretchParamsDictTagged = typing.TypedDict('C3dStretchParamsDictTagged', {
    "@type": typing.Literal["stretch"],
    "stretch": str,
})
C3dStretchParamsDict = _C3dStretchParamsDictNoTag | C3dStretchParamsDictTagged


_C3dSwapdimParamsDictNoTag = typing.TypedDict('_C3dSwapdimParamsDictNoTag', {
    "swapdim": str,
})
C3dSwapdimParamsDictTagged = typing.TypedDict('C3dSwapdimParamsDictTagged', {
    "@type": typing.Literal["swapdim"],
    "swapdim": str,
})
C3dSwapdimParamsDict = _C3dSwapdimParamsDictNoTag | C3dSwapdimParamsDictTagged


_C3dTestImageParamsDictNoTag = typing.TypedDict('_C3dTestImageParamsDictNoTag', {
    "test_image": str,
})
C3dTestImageParamsDictTagged = typing.TypedDict('C3dTestImageParamsDictTagged', {
    "@type": typing.Literal["test_image"],
    "test_image": str,
})
C3dTestImageParamsDict = _C3dTestImageParamsDictNoTag | C3dTestImageParamsDictTagged


_C3dTestProbeParamsDictNoTag = typing.TypedDict('_C3dTestProbeParamsDictNoTag', {
    "test_probe": str,
})
C3dTestProbeParamsDictTagged = typing.TypedDict('C3dTestProbeParamsDictTagged', {
    "@type": typing.Literal["test_probe"],
    "test_probe": str,
})
C3dTestProbeParamsDict = _C3dTestProbeParamsDictNoTag | C3dTestProbeParamsDictTagged


_C3dThresholdParamsDictNoTag = typing.TypedDict('_C3dThresholdParamsDictNoTag', {
    "threshold": str,
})
C3dThresholdParamsDictTagged = typing.TypedDict('C3dThresholdParamsDictTagged', {
    "@type": typing.Literal["threshold"],
    "threshold": str,
})
C3dThresholdParamsDict = _C3dThresholdParamsDictNoTag | C3dThresholdParamsDictTagged


_C3dTileParamsDictNoTag = typing.TypedDict('_C3dTileParamsDictNoTag', {
    "tile": str,
})
C3dTileParamsDictTagged = typing.TypedDict('C3dTileParamsDictTagged', {
    "@type": typing.Literal["tile"],
    "tile": str,
})
C3dTileParamsDict = _C3dTileParamsDictNoTag | C3dTileParamsDictTagged


_C3dTrimParamsDictNoTag = typing.TypedDict('_C3dTrimParamsDictNoTag', {
    "trim": str,
})
C3dTrimParamsDictTagged = typing.TypedDict('C3dTrimParamsDictTagged', {
    "@type": typing.Literal["trim"],
    "trim": str,
})
C3dTrimParamsDict = _C3dTrimParamsDictNoTag | C3dTrimParamsDictTagged


_C3dTrimToSizeParamsDictNoTag = typing.TypedDict('_C3dTrimToSizeParamsDictNoTag', {
    "trim_to_size": str,
})
C3dTrimToSizeParamsDictTagged = typing.TypedDict('C3dTrimToSizeParamsDictTagged', {
    "@type": typing.Literal["trim_to_size"],
    "trim_to_size": str,
})
C3dTrimToSizeParamsDict = _C3dTrimToSizeParamsDictNoTag | C3dTrimToSizeParamsDictTagged


_C3dTypeParamsDictNoTag = typing.TypedDict('_C3dTypeParamsDictNoTag', {
    "type": str,
})
C3dTypeParamsDictTagged = typing.TypedDict('C3dTypeParamsDictTagged', {
    "@type": typing.Literal["type"],
    "type": str,
})
C3dTypeParamsDict = _C3dTypeParamsDictNoTag | C3dTypeParamsDictTagged


_C3dVerboseParamsDictNoTag = typing.TypedDict('_C3dVerboseParamsDictNoTag', {
    "verbose": str,
})
C3dVerboseParamsDictTagged = typing.TypedDict('C3dVerboseParamsDictTagged', {
    "@type": typing.Literal["verbose"],
    "verbose": str,
})
C3dVerboseParamsDict = _C3dVerboseParamsDictNoTag | C3dVerboseParamsDictTagged


_C3dNoverboseParamsDictNoTag = typing.TypedDict('_C3dNoverboseParamsDictNoTag', {
    "noverbose": str,
})
C3dNoverboseParamsDictTagged = typing.TypedDict('C3dNoverboseParamsDictTagged', {
    "@type": typing.Literal["noverbose"],
    "noverbose": str,
})
C3dNoverboseParamsDict = _C3dNoverboseParamsDictNoTag | C3dNoverboseParamsDictTagged


_C3dVersionParamsDictNoTag = typing.TypedDict('_C3dVersionParamsDictNoTag', {
    "version": str,
})
C3dVersionParamsDictTagged = typing.TypedDict('C3dVersionParamsDictTagged', {
    "@type": typing.Literal["version"],
    "version": str,
})
C3dVersionParamsDict = _C3dVersionParamsDictNoTag | C3dVersionParamsDictTagged


_C3dVoteParamsDictNoTag = typing.TypedDict('_C3dVoteParamsDictNoTag', {
    "vote": str,
})
C3dVoteParamsDictTagged = typing.TypedDict('C3dVoteParamsDictTagged', {
    "@type": typing.Literal["vote"],
    "vote": str,
})
C3dVoteParamsDict = _C3dVoteParamsDictNoTag | C3dVoteParamsDictTagged


_C3dVoteMrfParamsDictNoTag = typing.TypedDict('_C3dVoteMrfParamsDictNoTag', {
    "vote_mrf": str,
})
C3dVoteMrfParamsDictTagged = typing.TypedDict('C3dVoteMrfParamsDictTagged', {
    "@type": typing.Literal["vote_mrf"],
    "vote_mrf": str,
})
C3dVoteMrfParamsDict = _C3dVoteMrfParamsDictNoTag | C3dVoteMrfParamsDictTagged


_C3dVoteLabelParamsDictNoTag = typing.TypedDict('_C3dVoteLabelParamsDictNoTag', {
    "vote_label": str,
})
C3dVoteLabelParamsDictTagged = typing.TypedDict('C3dVoteLabelParamsDictTagged', {
    "@type": typing.Literal["vote_label"],
    "vote_label": str,
})
C3dVoteLabelParamsDict = _C3dVoteLabelParamsDictNoTag | C3dVoteLabelParamsDictTagged


_C3dVoxelSumParamsDictNoTag = typing.TypedDict('_C3dVoxelSumParamsDictNoTag', {
    "voxel_sum": str,
})
C3dVoxelSumParamsDictTagged = typing.TypedDict('C3dVoxelSumParamsDictTagged', {
    "@type": typing.Literal["voxel_sum"],
    "voxel_sum": str,
})
C3dVoxelSumParamsDict = _C3dVoxelSumParamsDictNoTag | C3dVoxelSumParamsDictTagged


_C3dVoxelIntegralParamsDictNoTag = typing.TypedDict('_C3dVoxelIntegralParamsDictNoTag', {
    "voxel_integral": str,
})
C3dVoxelIntegralParamsDictTagged = typing.TypedDict('C3dVoxelIntegralParamsDictTagged', {
    "@type": typing.Literal["voxel_integral"],
    "voxel_integral": str,
})
C3dVoxelIntegralParamsDict = _C3dVoxelIntegralParamsDictNoTag | C3dVoxelIntegralParamsDictTagged


_C3dVoxelwiseRegressionParamsDictNoTag = typing.TypedDict('_C3dVoxelwiseRegressionParamsDictNoTag', {
    "voxelwise_regression": str,
})
C3dVoxelwiseRegressionParamsDictTagged = typing.TypedDict('C3dVoxelwiseRegressionParamsDictTagged', {
    "@type": typing.Literal["voxelwise_regression"],
    "voxelwise_regression": str,
})
C3dVoxelwiseRegressionParamsDict = _C3dVoxelwiseRegressionParamsDictNoTag | C3dVoxelwiseRegressionParamsDictTagged


_C3dWarpParamsDictNoTag = typing.TypedDict('_C3dWarpParamsDictNoTag', {
    "warp": str,
})
C3dWarpParamsDictTagged = typing.TypedDict('C3dWarpParamsDictTagged', {
    "@type": typing.Literal["warp"],
    "warp": str,
})
C3dWarpParamsDict = _C3dWarpParamsDictNoTag | C3dWarpParamsDictTagged


_C3dWarpLabelParamsDictNoTag = typing.TypedDict('_C3dWarpLabelParamsDictNoTag', {
    "warp_label": str,
})
C3dWarpLabelParamsDictTagged = typing.TypedDict('C3dWarpLabelParamsDictTagged', {
    "@type": typing.Literal["warp_label"],
    "warp_label": str,
})
C3dWarpLabelParamsDict = _C3dWarpLabelParamsDictNoTag | C3dWarpLabelParamsDictTagged


_C3dWrapParamsDictNoTag = typing.TypedDict('_C3dWrapParamsDictNoTag', {
    "wrap": str,
})
C3dWrapParamsDictTagged = typing.TypedDict('C3dWrapParamsDictTagged', {
    "@type": typing.Literal["wrap"],
    "wrap": str,
})
C3dWrapParamsDict = _C3dWrapParamsDictNoTag | C3dWrapParamsDictTagged


_C3dWeightedSumParamsDictNoTag = typing.TypedDict('_C3dWeightedSumParamsDictNoTag', {
    "weighted_sum": str,
})
C3dWeightedSumParamsDictTagged = typing.TypedDict('C3dWeightedSumParamsDictTagged', {
    "@type": typing.Literal["weighted_sum"],
    "weighted_sum": str,
})
C3dWeightedSumParamsDict = _C3dWeightedSumParamsDictNoTag | C3dWeightedSumParamsDictTagged


_C3dWeightedSumVoxelwiseParamsDictNoTag = typing.TypedDict('_C3dWeightedSumVoxelwiseParamsDictNoTag', {
    "weighted_sum_voxelwise": str,
})
C3dWeightedSumVoxelwiseParamsDictTagged = typing.TypedDict('C3dWeightedSumVoxelwiseParamsDictTagged', {
    "@type": typing.Literal["weighted_sum_voxelwise"],
    "weighted_sum_voxelwise": str,
})
C3dWeightedSumVoxelwiseParamsDict = _C3dWeightedSumVoxelwiseParamsDictNoTag | C3dWeightedSumVoxelwiseParamsDictTagged


_C3dParamsDictNoTag = typing.TypedDict('_C3dParamsDictNoTag', {
    "input": list[InputPathType],
    "operations": list[typing.Union[C3dAccumParamsDictTagged, C3dAcosParamsDictTagged, C3dAddParamsDictTagged, C3dAlignLandmarksParamsDictTagged, C3dAnisotropicDiffusionParamsDictTagged, C3dAntialiasParamsDictTagged, C3dSetParamsDictTagged, C3dAsinParamsDictTagged, C3dAtan2ParamsDictTagged, C3dBackgroundParamsDictTagged, C3dN4BiasCorrectionParamsDictTagged, C3dBinarizeParamsDictTagged, C3dCannyParamsDictTagged, C3dCeilParamsDictTagged, C3dCentroidParamsDictTagged, C3dCentroidMarkParamsDictTagged, C3dConnectedComponentsParamsDictTagged, C3dClearParamsDictTagged, C3dClipParamsDictTagged, C3dColorMapParamsDictTagged, C3dCompressParamsDictTagged, C3dNoCompressParamsDictTagged, C3dConvParamsDictTagged, C3dCoordinateMapVoxelParamsDictTagged, C3dCoordinateMapPhysicalParamsDictTagged, C3dCopyTransformParamsDictTagged, C3dCosParamsDictTagged, C3dCreateParamsDictTagged, C3dDicomSeriesListParamsDictTagged, C3dDicomSeriesReadParamsDictTagged, C3dDilateParamsDictTagged, C3dDivideParamsDictTagged, C3dDuplicateParamsDictTagged, C3dEndaccumParamsDictTagged, C3dEndforParamsDictTagged, C3dErodeParamsDictTagged, C3dErfParamsDictTagged, C3dExpParamsDictTagged, C3dExportPatchesParamsDictTagged, C3dExportPatchesAugParamsDictTagged, C3dExtrudeSegParamsDictTagged, C3dFillBackgroundWithNoiseParamsDictTagged, C3dFftParamsDictTagged, C3dFlipParamsDictTagged, C3dFloorParamsDictTagged, C3dForeachParamsDictTagged, C3dForeachCompParamsDictTagged, C3dGlmParamsDictTagged, C3dGradientParamsDictTagged, C3dHelpParamsDictTagged, C3dHolefillParamsDictTagged, C3dHessianEigenvaluesParamsDictTagged, C3dHessianObjectnessParamsDictTagged, C3dHistogramMatchParamsDictTagged, C3dInfoParamsDictTagged, C3dInfoFullParamsDictTagged, C3dInsertParamsDictTagged, C3dInterpolationParamsDictTagged, C3dIterationsParamsDictTagged, C3dLabelOverlapParamsDictTagged, C3dLabelStatisticsParamsDictTagged, C3dLandmarksToSpheresParamsDictTagged, C3dLaplacianParamsDictTagged, C3dLevelsetParamsDictTagged, C3dLevelsetCurvatureParamsDictTagged, C3dLevelsetAdvectionParamsDictTagged, C3dLogParamsDictTagged, C3dLog10ParamsDictTagged, C3dManualParamsDictTagged, C3dMatchBoundingBoxParamsDictTagged, C3dMaximumParamsDictTagged, C3dMulticomponentSplitParamsDictTagged, C3dMeanParamsDictTagged, C3dMedianFilterParamsDictTagged, C3dMergeParamsDictTagged, C3dMeanFilterParamsDictTagged, C3dMutualInfoParamsDictTagged, C3dMinimumParamsDictTagged, C3dMixtureModelParamsDictTagged, C3dMomentsParamsDictTagged, C3dMattesMutualInfoParamsDictTagged, C3dMeanSquareParamsDictTagged, C3dMultiplyParamsDictTagged, C3dNormalizedCrossCorrelationParamsDictTagged, C3dNormalizedCorrelationParamsDictTagged, C3dNormalizedMutualInfoParamsDictTagged, C3dNoiseGaussianParamsDictTagged, C3dNoisePoissonParamsDictTagged, C3dNoiseSpeckleParamsDictTagged, C3dNoiseSaltPepperParamsDictTagged, C3dNoMulticomponentSplitParamsDictTagged, C3dNormalizeLocalWindowParamsDictTagged, C3dNormpdfParamsDictTagged, C3dNoroundParamsDictTagged, C3dNospmParamsDictTagged, C3dOutputParamsDictTagged, C3dOutputMulticomponentParamsDictTagged, C3dOutputMultipleMulticomponentParamsDictTagged, C3dOrientParamsDictTagged, C3dOutputMultipleParamsDictTagged, C3dOrient1ParamsDictTagged, C3dOriginParamsDictTagged, C3dOriginVoxelParamsDictTagged, C3dOriginVoxelCoordParamsDictTagged, C3dOverlapParamsDictTagged, C3dOverlayLabelImageParamsDictTagged, C3dPadParamsDictTagged, C3dPadToParamsDictTagged, C3dPcaParamsDictTagged, C3dPercentIntensityModeParamsDictTagged, C3dPixelParamsDictTagged, C3dPopParamsDictTagged, C3dPopasParamsDictTagged, C3dProbeParamsDictTagged, C3dPushParamsDictTagged, C3dRankParamsDictTagged, C3dReciprocalParamsDictTagged, C3dRegionParamsDictTagged, C3dReorderParamsDictTagged, C3dRetainLabelsParamsDictTagged, C3dRfApplyParamsDictTagged, C3dRfTrainParamsDictTagged, C3dRfParamPatchParamsDictTagged, C3dRfParamUsexyzParamsDictTagged, C3dRfParamNousexyzParamsDictTagged, C3dRfParamNtreesParamsDictTagged, C3dRfParamTreedepthParamsDictTagged, C3dSetSformParamsDictTagged, C3dReplaceParamsDictTagged, C3dResampleParamsDictTagged, C3dResampleIsoParamsDictTagged, C3dResampleMmParamsDictTagged, C3dResliceItkParamsDictTagged, C3dResliceMatrixParamsDictTagged, C3dResliceIdentityParamsDictTagged, C3dRgb2hsvParamsDictTagged, C3dRmsParamsDictTagged, C3dRoundParamsDictTagged, C3dScaleParamsDictTagged, C3dSetSform1ParamsDictTagged, C3dSinParamsDictTagged, C3dSliceParamsDictTagged, C3dSliceAllParamsDictTagged, C3dSharpenParamsDictTagged, C3dShiftParamsDictTagged, C3dSignedDistanceTransformParamsDictTagged, C3dSmoothParamsDictTagged, C3dSmoothFastParamsDictTagged, C3dSpacingParamsDictTagged, C3dSplitParamsDictTagged, C3dSqrtParamsDictTagged, C3dStapleParamsDictTagged, C3dStructureTensorEigenvaluesParamsDictTagged, C3dSpmParamsDictTagged, C3dSubtractParamsDictTagged, C3dSupervoxelParamsDictTagged, C3dStretchParamsDictTagged, C3dSwapdimParamsDictTagged, C3dTestImageParamsDictTagged, C3dTestProbeParamsDictTagged, C3dThresholdParamsDictTagged, C3dTileParamsDictTagged, C3dTrimParamsDictTagged, C3dTrimToSizeParamsDictTagged, C3dTypeParamsDictTagged, C3dVerboseParamsDictTagged, C3dNoverboseParamsDictTagged, C3dVersionParamsDictTagged, C3dVoteParamsDictTagged, C3dVoteMrfParamsDictTagged, C3dVoteLabelParamsDictTagged, C3dVoxelSumParamsDictTagged, C3dVoxelIntegralParamsDictTagged, C3dVoxelwiseRegressionParamsDictTagged, C3dWarpParamsDictTagged, C3dWarpLabelParamsDictTagged, C3dWrapParamsDictTagged, C3dWeightedSumParamsDictTagged, C3dWeightedSumVoxelwiseParamsDictTagged]],
    "output": str,
})
C3dParamsDictTagged = typing.TypedDict('C3dParamsDictTagged', {
    "@type": typing.Literal["c3d/c3d"],
    "input": list[InputPathType],
    "operations": list[typing.Union[C3dAccumParamsDictTagged, C3dAcosParamsDictTagged, C3dAddParamsDictTagged, C3dAlignLandmarksParamsDictTagged, C3dAnisotropicDiffusionParamsDictTagged, C3dAntialiasParamsDictTagged, C3dSetParamsDictTagged, C3dAsinParamsDictTagged, C3dAtan2ParamsDictTagged, C3dBackgroundParamsDictTagged, C3dN4BiasCorrectionParamsDictTagged, C3dBinarizeParamsDictTagged, C3dCannyParamsDictTagged, C3dCeilParamsDictTagged, C3dCentroidParamsDictTagged, C3dCentroidMarkParamsDictTagged, C3dConnectedComponentsParamsDictTagged, C3dClearParamsDictTagged, C3dClipParamsDictTagged, C3dColorMapParamsDictTagged, C3dCompressParamsDictTagged, C3dNoCompressParamsDictTagged, C3dConvParamsDictTagged, C3dCoordinateMapVoxelParamsDictTagged, C3dCoordinateMapPhysicalParamsDictTagged, C3dCopyTransformParamsDictTagged, C3dCosParamsDictTagged, C3dCreateParamsDictTagged, C3dDicomSeriesListParamsDictTagged, C3dDicomSeriesReadParamsDictTagged, C3dDilateParamsDictTagged, C3dDivideParamsDictTagged, C3dDuplicateParamsDictTagged, C3dEndaccumParamsDictTagged, C3dEndforParamsDictTagged, C3dErodeParamsDictTagged, C3dErfParamsDictTagged, C3dExpParamsDictTagged, C3dExportPatchesParamsDictTagged, C3dExportPatchesAugParamsDictTagged, C3dExtrudeSegParamsDictTagged, C3dFillBackgroundWithNoiseParamsDictTagged, C3dFftParamsDictTagged, C3dFlipParamsDictTagged, C3dFloorParamsDictTagged, C3dForeachParamsDictTagged, C3dForeachCompParamsDictTagged, C3dGlmParamsDictTagged, C3dGradientParamsDictTagged, C3dHelpParamsDictTagged, C3dHolefillParamsDictTagged, C3dHessianEigenvaluesParamsDictTagged, C3dHessianObjectnessParamsDictTagged, C3dHistogramMatchParamsDictTagged, C3dInfoParamsDictTagged, C3dInfoFullParamsDictTagged, C3dInsertParamsDictTagged, C3dInterpolationParamsDictTagged, C3dIterationsParamsDictTagged, C3dLabelOverlapParamsDictTagged, C3dLabelStatisticsParamsDictTagged, C3dLandmarksToSpheresParamsDictTagged, C3dLaplacianParamsDictTagged, C3dLevelsetParamsDictTagged, C3dLevelsetCurvatureParamsDictTagged, C3dLevelsetAdvectionParamsDictTagged, C3dLogParamsDictTagged, C3dLog10ParamsDictTagged, C3dManualParamsDictTagged, C3dMatchBoundingBoxParamsDictTagged, C3dMaximumParamsDictTagged, C3dMulticomponentSplitParamsDictTagged, C3dMeanParamsDictTagged, C3dMedianFilterParamsDictTagged, C3dMergeParamsDictTagged, C3dMeanFilterParamsDictTagged, C3dMutualInfoParamsDictTagged, C3dMinimumParamsDictTagged, C3dMixtureModelParamsDictTagged, C3dMomentsParamsDictTagged, C3dMattesMutualInfoParamsDictTagged, C3dMeanSquareParamsDictTagged, C3dMultiplyParamsDictTagged, C3dNormalizedCrossCorrelationParamsDictTagged, C3dNormalizedCorrelationParamsDictTagged, C3dNormalizedMutualInfoParamsDictTagged, C3dNoiseGaussianParamsDictTagged, C3dNoisePoissonParamsDictTagged, C3dNoiseSpeckleParamsDictTagged, C3dNoiseSaltPepperParamsDictTagged, C3dNoMulticomponentSplitParamsDictTagged, C3dNormalizeLocalWindowParamsDictTagged, C3dNormpdfParamsDictTagged, C3dNoroundParamsDictTagged, C3dNospmParamsDictTagged, C3dOutputParamsDictTagged, C3dOutputMulticomponentParamsDictTagged, C3dOutputMultipleMulticomponentParamsDictTagged, C3dOrientParamsDictTagged, C3dOutputMultipleParamsDictTagged, C3dOrient1ParamsDictTagged, C3dOriginParamsDictTagged, C3dOriginVoxelParamsDictTagged, C3dOriginVoxelCoordParamsDictTagged, C3dOverlapParamsDictTagged, C3dOverlayLabelImageParamsDictTagged, C3dPadParamsDictTagged, C3dPadToParamsDictTagged, C3dPcaParamsDictTagged, C3dPercentIntensityModeParamsDictTagged, C3dPixelParamsDictTagged, C3dPopParamsDictTagged, C3dPopasParamsDictTagged, C3dProbeParamsDictTagged, C3dPushParamsDictTagged, C3dRankParamsDictTagged, C3dReciprocalParamsDictTagged, C3dRegionParamsDictTagged, C3dReorderParamsDictTagged, C3dRetainLabelsParamsDictTagged, C3dRfApplyParamsDictTagged, C3dRfTrainParamsDictTagged, C3dRfParamPatchParamsDictTagged, C3dRfParamUsexyzParamsDictTagged, C3dRfParamNousexyzParamsDictTagged, C3dRfParamNtreesParamsDictTagged, C3dRfParamTreedepthParamsDictTagged, C3dSetSformParamsDictTagged, C3dReplaceParamsDictTagged, C3dResampleParamsDictTagged, C3dResampleIsoParamsDictTagged, C3dResampleMmParamsDictTagged, C3dResliceItkParamsDictTagged, C3dResliceMatrixParamsDictTagged, C3dResliceIdentityParamsDictTagged, C3dRgb2hsvParamsDictTagged, C3dRmsParamsDictTagged, C3dRoundParamsDictTagged, C3dScaleParamsDictTagged, C3dSetSform1ParamsDictTagged, C3dSinParamsDictTagged, C3dSliceParamsDictTagged, C3dSliceAllParamsDictTagged, C3dSharpenParamsDictTagged, C3dShiftParamsDictTagged, C3dSignedDistanceTransformParamsDictTagged, C3dSmoothParamsDictTagged, C3dSmoothFastParamsDictTagged, C3dSpacingParamsDictTagged, C3dSplitParamsDictTagged, C3dSqrtParamsDictTagged, C3dStapleParamsDictTagged, C3dStructureTensorEigenvaluesParamsDictTagged, C3dSpmParamsDictTagged, C3dSubtractParamsDictTagged, C3dSupervoxelParamsDictTagged, C3dStretchParamsDictTagged, C3dSwapdimParamsDictTagged, C3dTestImageParamsDictTagged, C3dTestProbeParamsDictTagged, C3dThresholdParamsDictTagged, C3dTileParamsDictTagged, C3dTrimParamsDictTagged, C3dTrimToSizeParamsDictTagged, C3dTypeParamsDictTagged, C3dVerboseParamsDictTagged, C3dNoverboseParamsDictTagged, C3dVersionParamsDictTagged, C3dVoteParamsDictTagged, C3dVoteMrfParamsDictTagged, C3dVoteLabelParamsDictTagged, C3dVoxelSumParamsDictTagged, C3dVoxelIntegralParamsDictTagged, C3dVoxelwiseRegressionParamsDictTagged, C3dWarpParamsDictTagged, C3dWarpLabelParamsDictTagged, C3dWrapParamsDictTagged, C3dWeightedSumParamsDictTagged, C3dWeightedSumVoxelwiseParamsDictTagged]],
    "output": str,
})
C3dParamsDict = _C3dParamsDictNoTag | C3dParamsDictTagged


def c3d_operations_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "accum": c3d_accum_cargs,
        "acos": c3d_acos_cargs,
        "add": c3d_add_cargs,
        "align_landmarks": c3d_align_landmarks_cargs,
        "anisotropic_diffusion": c3d_anisotropic_diffusion_cargs,
        "antialias": c3d_antialias_cargs,
        "set": c3d_set_cargs,
        "asin": c3d_asin_cargs,
        "atan2": c3d_atan2_cargs,
        "background": c3d_background_cargs,
        "n4_bias_correction": c3d_n4_bias_correction_cargs,
        "binarize": c3d_binarize_cargs,
        "canny": c3d_canny_cargs,
        "ceil": c3d_ceil_cargs,
        "centroid": c3d_centroid_cargs,
        "centroid_mark": c3d_centroid_mark_cargs,
        "connected_components": c3d_connected_components_cargs,
        "clear": c3d_clear_cargs,
        "clip": c3d_clip_cargs,
        "color_map": c3d_color_map_cargs,
        "compress": c3d_compress_cargs,
        "no_compress": c3d_no_compress_cargs,
        "conv": c3d_conv_cargs,
        "coordinate_map_voxel": c3d_coordinate_map_voxel_cargs,
        "coordinate_map_physical": c3d_coordinate_map_physical_cargs,
        "copy_transform": c3d_copy_transform_cargs,
        "cos": c3d_cos_cargs,
        "create": c3d_create_cargs,
        "dicom_series_list": c3d_dicom_series_list_cargs,
        "dicom_series_read": c3d_dicom_series_read_cargs,
        "dilate": c3d_dilate_cargs,
        "divide": c3d_divide_cargs,
        "duplicate": c3d_duplicate_cargs,
        "endaccum": c3d_endaccum_cargs,
        "endfor": c3d_endfor_cargs,
        "erode": c3d_erode_cargs,
        "erf": c3d_erf_cargs,
        "exp": c3d_exp_cargs,
        "export_patches": c3d_export_patches_cargs,
        "export_patches_aug": c3d_export_patches_aug_cargs,
        "extrude_seg": c3d_extrude_seg_cargs,
        "fill_background_with_noise": c3d_fill_background_with_noise_cargs,
        "fft": c3d_fft_cargs,
        "flip": c3d_flip_cargs,
        "floor": c3d_floor_cargs,
        "foreach": c3d_foreach_cargs,
        "foreach_comp": c3d_foreach_comp_cargs,
        "glm": c3d_glm_cargs,
        "gradient": c3d_gradient_cargs,
        "_help": c3d__help_cargs,
        "holefill": c3d_holefill_cargs,
        "hessian_eigenvalues": c3d_hessian_eigenvalues_cargs,
        "hessian_objectness": c3d_hessian_objectness_cargs,
        "histogram_match": c3d_histogram_match_cargs,
        "info": c3d_info_cargs,
        "info_full": c3d_info_full_cargs,
        "insert": c3d_insert_cargs,
        "interpolation": c3d_interpolation_cargs,
        "iterations": c3d_iterations_cargs,
        "label_overlap": c3d_label_overlap_cargs,
        "label_statistics": c3d_label_statistics_cargs,
        "landmarks_to_spheres": c3d_landmarks_to_spheres_cargs,
        "laplacian": c3d_laplacian_cargs,
        "levelset": c3d_levelset_cargs,
        "levelset_curvature": c3d_levelset_curvature_cargs,
        "levelset_advection": c3d_levelset_advection_cargs,
        "log": c3d_log_cargs,
        "log10": c3d_log10_cargs,
        "manual": c3d_manual_cargs,
        "match_bounding_box": c3d_match_bounding_box_cargs,
        "maximum": c3d_maximum_cargs,
        "multicomponent_split": c3d_multicomponent_split_cargs,
        "mean": c3d_mean_cargs,
        "median_filter": c3d_median_filter_cargs,
        "merge": c3d_merge_cargs,
        "mean_filter": c3d_mean_filter_cargs,
        "mutual_info": c3d_mutual_info_cargs,
        "minimum": c3d_minimum_cargs,
        "mixture_model": c3d_mixture_model_cargs,
        "moments": c3d_moments_cargs,
        "mattes_mutual_info": c3d_mattes_mutual_info_cargs,
        "mean_square": c3d_mean_square_cargs,
        "multiply": c3d_multiply_cargs,
        "normalized_cross_correlation": c3d_normalized_cross_correlation_cargs,
        "normalized_correlation": c3d_normalized_correlation_cargs,
        "normalized_mutual_info": c3d_normalized_mutual_info_cargs,
        "noise_gaussian": c3d_noise_gaussian_cargs,
        "noise_poisson": c3d_noise_poisson_cargs,
        "noise_speckle": c3d_noise_speckle_cargs,
        "noise_salt_pepper": c3d_noise_salt_pepper_cargs,
        "no_multicomponent_split": c3d_no_multicomponent_split_cargs,
        "normalize_local_window": c3d_normalize_local_window_cargs,
        "normpdf": c3d_normpdf_cargs,
        "noround": c3d_noround_cargs,
        "nospm": c3d_nospm_cargs,
        "output": c3d_output_cargs,
        "output_multicomponent": c3d_output_multicomponent_cargs,
        "output_multiple_multicomponent": c3d_output_multiple_multicomponent_cargs,
        "orient": c3d_orient_cargs,
        "output_multiple": c3d_output_multiple_cargs,
        "orient_1": c3d_orient_1_cargs,
        "origin": c3d_origin_cargs,
        "origin_voxel": c3d_origin_voxel_cargs,
        "origin_voxel_coord": c3d_origin_voxel_coord_cargs,
        "overlap": c3d_overlap_cargs,
        "overlay_label_image": c3d_overlay_label_image_cargs,
        "pad": c3d_pad_cargs,
        "pad_to": c3d_pad_to_cargs,
        "pca": c3d_pca_cargs,
        "percent_intensity_mode": c3d_percent_intensity_mode_cargs,
        "pixel": c3d_pixel_cargs,
        "pop": c3d_pop_cargs,
        "popas": c3d_popas_cargs,
        "probe": c3d_probe_cargs,
        "push": c3d_push_cargs,
        "rank": c3d_rank_cargs,
        "reciprocal": c3d_reciprocal_cargs,
        "region": c3d_region_cargs,
        "reorder": c3d_reorder_cargs,
        "retain_labels": c3d_retain_labels_cargs,
        "rf_apply": c3d_rf_apply_cargs,
        "rf_train": c3d_rf_train_cargs,
        "rf_param_patch": c3d_rf_param_patch_cargs,
        "rf_param_usexyz": c3d_rf_param_usexyz_cargs,
        "rf_param_nousexyz": c3d_rf_param_nousexyz_cargs,
        "rf_param_ntrees": c3d_rf_param_ntrees_cargs,
        "rf_param_treedepth": c3d_rf_param_treedepth_cargs,
        "set_sform": c3d_set_sform_cargs,
        "replace": c3d_replace_cargs,
        "resample": c3d_resample_cargs,
        "resample_iso": c3d_resample_iso_cargs,
        "resample_mm": c3d_resample_mm_cargs,
        "reslice_itk": c3d_reslice_itk_cargs,
        "reslice_matrix": c3d_reslice_matrix_cargs,
        "reslice_identity": c3d_reslice_identity_cargs,
        "rgb2hsv": c3d_rgb2hsv_cargs,
        "rms": c3d_rms_cargs,
        "round": c3d_round_cargs,
        "scale": c3d_scale_cargs,
        "set_sform_1": c3d_set_sform_1_cargs,
        "sin": c3d_sin_cargs,
        "slice": c3d_slice_cargs,
        "slice_all": c3d_slice_all_cargs,
        "sharpen": c3d_sharpen_cargs,
        "shift": c3d_shift_cargs,
        "signed_distance_transform": c3d_signed_distance_transform_cargs,
        "smooth": c3d_smooth_cargs,
        "smooth_fast": c3d_smooth_fast_cargs,
        "spacing": c3d_spacing_cargs,
        "split": c3d_split_cargs,
        "sqrt": c3d_sqrt_cargs,
        "staple": c3d_staple_cargs,
        "structure_tensor_eigenvalues": c3d_structure_tensor_eigenvalues_cargs,
        "spm": c3d_spm_cargs,
        "subtract": c3d_subtract_cargs,
        "supervoxel": c3d_supervoxel_cargs,
        "stretch": c3d_stretch_cargs,
        "swapdim": c3d_swapdim_cargs,
        "test_image": c3d_test_image_cargs,
        "test_probe": c3d_test_probe_cargs,
        "threshold": c3d_threshold_cargs,
        "tile": c3d_tile_cargs,
        "trim": c3d_trim_cargs,
        "trim_to_size": c3d_trim_to_size_cargs,
        "type": c3d_type_cargs,
        "verbose": c3d_verbose_cargs,
        "noverbose": c3d_noverbose_cargs,
        "version": c3d_version_cargs,
        "vote": c3d_vote_cargs,
        "vote_mrf": c3d_vote_mrf_cargs,
        "vote_label": c3d_vote_label_cargs,
        "voxel_sum": c3d_voxel_sum_cargs,
        "voxel_integral": c3d_voxel_integral_cargs,
        "voxelwise_regression": c3d_voxelwise_regression_cargs,
        "warp": c3d_warp_cargs,
        "warp_label": c3d_warp_label_cargs,
        "wrap": c3d_wrap_cargs,
        "weighted_sum": c3d_weighted_sum_cargs,
        "weighted_sum_voxelwise": c3d_weighted_sum_voxelwise_cargs,
    }.get(t)


def c3d_operations_outputs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build outputs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build outputs function.
    """
    return {
        "output": c3d_output_outputs,
    }.get(t)


def c3d_operations_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "accum": c3d_accum_validate,
        "acos": c3d_acos_validate,
        "add": c3d_add_validate,
        "align_landmarks": c3d_align_landmarks_validate,
        "anisotropic_diffusion": c3d_anisotropic_diffusion_validate,
        "antialias": c3d_antialias_validate,
        "set": c3d_set_validate,
        "asin": c3d_asin_validate,
        "atan2": c3d_atan2_validate,
        "background": c3d_background_validate,
        "n4_bias_correction": c3d_n4_bias_correction_validate,
        "binarize": c3d_binarize_validate,
        "canny": c3d_canny_validate,
        "ceil": c3d_ceil_validate,
        "centroid": c3d_centroid_validate,
        "centroid_mark": c3d_centroid_mark_validate,
        "connected_components": c3d_connected_components_validate,
        "clear": c3d_clear_validate,
        "clip": c3d_clip_validate,
        "color_map": c3d_color_map_validate,
        "compress": c3d_compress_validate,
        "no_compress": c3d_no_compress_validate,
        "conv": c3d_conv_validate,
        "coordinate_map_voxel": c3d_coordinate_map_voxel_validate,
        "coordinate_map_physical": c3d_coordinate_map_physical_validate,
        "copy_transform": c3d_copy_transform_validate,
        "cos": c3d_cos_validate,
        "create": c3d_create_validate,
        "dicom_series_list": c3d_dicom_series_list_validate,
        "dicom_series_read": c3d_dicom_series_read_validate,
        "dilate": c3d_dilate_validate,
        "divide": c3d_divide_validate,
        "duplicate": c3d_duplicate_validate,
        "endaccum": c3d_endaccum_validate,
        "endfor": c3d_endfor_validate,
        "erode": c3d_erode_validate,
        "erf": c3d_erf_validate,
        "exp": c3d_exp_validate,
        "export_patches": c3d_export_patches_validate,
        "export_patches_aug": c3d_export_patches_aug_validate,
        "extrude_seg": c3d_extrude_seg_validate,
        "fill_background_with_noise": c3d_fill_background_with_noise_validate,
        "fft": c3d_fft_validate,
        "flip": c3d_flip_validate,
        "floor": c3d_floor_validate,
        "foreach": c3d_foreach_validate,
        "foreach_comp": c3d_foreach_comp_validate,
        "glm": c3d_glm_validate,
        "gradient": c3d_gradient_validate,
        "_help": c3d__help_validate,
        "holefill": c3d_holefill_validate,
        "hessian_eigenvalues": c3d_hessian_eigenvalues_validate,
        "hessian_objectness": c3d_hessian_objectness_validate,
        "histogram_match": c3d_histogram_match_validate,
        "info": c3d_info_validate,
        "info_full": c3d_info_full_validate,
        "insert": c3d_insert_validate,
        "interpolation": c3d_interpolation_validate,
        "iterations": c3d_iterations_validate,
        "label_overlap": c3d_label_overlap_validate,
        "label_statistics": c3d_label_statistics_validate,
        "landmarks_to_spheres": c3d_landmarks_to_spheres_validate,
        "laplacian": c3d_laplacian_validate,
        "levelset": c3d_levelset_validate,
        "levelset_curvature": c3d_levelset_curvature_validate,
        "levelset_advection": c3d_levelset_advection_validate,
        "log": c3d_log_validate,
        "log10": c3d_log10_validate,
        "manual": c3d_manual_validate,
        "match_bounding_box": c3d_match_bounding_box_validate,
        "maximum": c3d_maximum_validate,
        "multicomponent_split": c3d_multicomponent_split_validate,
        "mean": c3d_mean_validate,
        "median_filter": c3d_median_filter_validate,
        "merge": c3d_merge_validate,
        "mean_filter": c3d_mean_filter_validate,
        "mutual_info": c3d_mutual_info_validate,
        "minimum": c3d_minimum_validate,
        "mixture_model": c3d_mixture_model_validate,
        "moments": c3d_moments_validate,
        "mattes_mutual_info": c3d_mattes_mutual_info_validate,
        "mean_square": c3d_mean_square_validate,
        "multiply": c3d_multiply_validate,
        "normalized_cross_correlation": c3d_normalized_cross_correlation_validate,
        "normalized_correlation": c3d_normalized_correlation_validate,
        "normalized_mutual_info": c3d_normalized_mutual_info_validate,
        "noise_gaussian": c3d_noise_gaussian_validate,
        "noise_poisson": c3d_noise_poisson_validate,
        "noise_speckle": c3d_noise_speckle_validate,
        "noise_salt_pepper": c3d_noise_salt_pepper_validate,
        "no_multicomponent_split": c3d_no_multicomponent_split_validate,
        "normalize_local_window": c3d_normalize_local_window_validate,
        "normpdf": c3d_normpdf_validate,
        "noround": c3d_noround_validate,
        "nospm": c3d_nospm_validate,
        "output": c3d_output_validate,
        "output_multicomponent": c3d_output_multicomponent_validate,
        "output_multiple_multicomponent": c3d_output_multiple_multicomponent_validate,
        "orient": c3d_orient_validate,
        "output_multiple": c3d_output_multiple_validate,
        "orient_1": c3d_orient_1_validate,
        "origin": c3d_origin_validate,
        "origin_voxel": c3d_origin_voxel_validate,
        "origin_voxel_coord": c3d_origin_voxel_coord_validate,
        "overlap": c3d_overlap_validate,
        "overlay_label_image": c3d_overlay_label_image_validate,
        "pad": c3d_pad_validate,
        "pad_to": c3d_pad_to_validate,
        "pca": c3d_pca_validate,
        "percent_intensity_mode": c3d_percent_intensity_mode_validate,
        "pixel": c3d_pixel_validate,
        "pop": c3d_pop_validate,
        "popas": c3d_popas_validate,
        "probe": c3d_probe_validate,
        "push": c3d_push_validate,
        "rank": c3d_rank_validate,
        "reciprocal": c3d_reciprocal_validate,
        "region": c3d_region_validate,
        "reorder": c3d_reorder_validate,
        "retain_labels": c3d_retain_labels_validate,
        "rf_apply": c3d_rf_apply_validate,
        "rf_train": c3d_rf_train_validate,
        "rf_param_patch": c3d_rf_param_patch_validate,
        "rf_param_usexyz": c3d_rf_param_usexyz_validate,
        "rf_param_nousexyz": c3d_rf_param_nousexyz_validate,
        "rf_param_ntrees": c3d_rf_param_ntrees_validate,
        "rf_param_treedepth": c3d_rf_param_treedepth_validate,
        "set_sform": c3d_set_sform_validate,
        "replace": c3d_replace_validate,
        "resample": c3d_resample_validate,
        "resample_iso": c3d_resample_iso_validate,
        "resample_mm": c3d_resample_mm_validate,
        "reslice_itk": c3d_reslice_itk_validate,
        "reslice_matrix": c3d_reslice_matrix_validate,
        "reslice_identity": c3d_reslice_identity_validate,
        "rgb2hsv": c3d_rgb2hsv_validate,
        "rms": c3d_rms_validate,
        "round": c3d_round_validate,
        "scale": c3d_scale_validate,
        "set_sform_1": c3d_set_sform_1_validate,
        "sin": c3d_sin_validate,
        "slice": c3d_slice_validate,
        "slice_all": c3d_slice_all_validate,
        "sharpen": c3d_sharpen_validate,
        "shift": c3d_shift_validate,
        "signed_distance_transform": c3d_signed_distance_transform_validate,
        "smooth": c3d_smooth_validate,
        "smooth_fast": c3d_smooth_fast_validate,
        "spacing": c3d_spacing_validate,
        "split": c3d_split_validate,
        "sqrt": c3d_sqrt_validate,
        "staple": c3d_staple_validate,
        "structure_tensor_eigenvalues": c3d_structure_tensor_eigenvalues_validate,
        "spm": c3d_spm_validate,
        "subtract": c3d_subtract_validate,
        "supervoxel": c3d_supervoxel_validate,
        "stretch": c3d_stretch_validate,
        "swapdim": c3d_swapdim_validate,
        "test_image": c3d_test_image_validate,
        "test_probe": c3d_test_probe_validate,
        "threshold": c3d_threshold_validate,
        "tile": c3d_tile_validate,
        "trim": c3d_trim_validate,
        "trim_to_size": c3d_trim_to_size_validate,
        "type": c3d_type_validate,
        "verbose": c3d_verbose_validate,
        "noverbose": c3d_noverbose_validate,
        "version": c3d_version_validate,
        "vote": c3d_vote_validate,
        "vote_mrf": c3d_vote_mrf_validate,
        "vote_label": c3d_vote_label_validate,
        "voxel_sum": c3d_voxel_sum_validate,
        "voxel_integral": c3d_voxel_integral_validate,
        "voxelwise_regression": c3d_voxelwise_regression_validate,
        "warp": c3d_warp_validate,
        "warp_label": c3d_warp_label_validate,
        "wrap": c3d_wrap_validate,
        "weighted_sum": c3d_weighted_sum_validate,
        "weighted_sum_voxelwise": c3d_weighted_sum_voxelwise_validate,
    }.get(t)


def c3d_accum(
    accum: str,
) -> C3dAccumParamsDictTagged:
    """
    Build parameters.
    
    Args:
        accum: -accum, -endaccum: Accumulate operations over all images\
            \
            Syntax: `-accum command-list -endaccum`\
            \
            Apply a binary operation (such as addition or multiplication) to\
            all the images on the stack in a cumulative fashion. The command(s)\
            will be applied to the last and second-to-last images on the stack,\
            then to the result of this operation and the third-to-last image on\
            the stack and so on. Below is the example of using the command to\
            add multiple images.\
            \
            c3d image*.nii -accum -add -endaccum -o sum.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "accum",
        "accum": accum,
    }
    return params


def c3d_accum_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAccumParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("accum", None) is None:
        raise StyxValidationError("`accum` must not be None")
    if not isinstance(params["accum"], str):
        raise StyxValidationError(f'`accum` has the wrong type: Received `{type(params.get("accum", None))}` expected `str`')


def c3d_accum_cargs(
    params: C3dAccumParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-accum",
        params.get("accum", None)
    ])
    return cargs


def c3d_acos(
    acos: str,
) -> C3dAcosParamsDictTagged:
    """
    Build parameters.
    
    Args:
        acos: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "acos",
        "acos": acos,
    }
    return params


def c3d_acos_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAcosParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("acos", None) is None:
        raise StyxValidationError("`acos` must not be None")
    if not isinstance(params["acos"], str):
        raise StyxValidationError(f'`acos` has the wrong type: Received `{type(params.get("acos", None))}` expected `str`')


def c3d_acos_cargs(
    params: C3dAcosParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-acos",
        params.get("acos", None)
    ])
    return cargs


def c3d_add(
    add: str,
) -> C3dAddParamsDictTagged:
    """
    Build parameters.
    
    Args:
        add: -add: Voxelwise image addition\
            \
            Syntax: `-add`\
            \
            Adds the last two images on the stack, and places the sum at the\
            end of the stack.\
            \
            # Add two images: x = a + b\
            c3d a.img b.img -add -o x.img\
            \
            # Add three images, x = (a + b) + c in the first example, x = a +\
            (b + c) in the second\
            c3d a.img b.img -add c.img -add -o x.img\
            c3d a.img b.img c.img -add -add -o x.img\
            \
            # Subtract two images, using -scale command: x = a - b\
            c3d a.img b.img -scale -1 -add -o x.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "add",
        "add": add,
    }
    return params


def c3d_add_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAddParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("add", None) is None:
        raise StyxValidationError("`add` must not be None")
    if not isinstance(params["add"], str):
        raise StyxValidationError(f'`add` has the wrong type: Received `{type(params.get("add", None))}` expected `str`')


def c3d_add_cargs(
    params: C3dAddParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-add",
        params.get("add", None)
    ])
    return cargs


def c3d_align_landmarks(
    align_landmarks: str,
) -> C3dAlignLandmarksParamsDictTagged:
    """
    Build parameters.
    
    Args:
        align_landmarks: -alm, -align-landmarks: Align images based on landmark\
            matching\
            \
            Syntax: `-alm dof outfile`\
            \
            Performs rigid or affine alignment between to sets of landmark\
            images. A landmark image is an image where for every intensity\
            value, the centroid of all voxels with that intensity represents a\
            landmark. Landmarks can be created using the paintbrush tool in\
            ITK-SNAP (they can be spheres, cubes, etc). The first image on the\
            stack is the target/fixed/reference image, and the second is the\
            moving image. The parameters are the degrees of freedom, which is a\
            number (6 for rigid, 7 for rigid+scale, 12 for affine) and the\
            output matrix file. In this example, we have images **fixed.nii*\
            and **moving.nii** with corresponding landmark images. We use\
            landmarks to align the moving image to the fixed:\
            \
            c3d fixed_landmarks.nii moving_landmarks.nii -alm 6 rigid.mat\
            c3d fixed.nii moving.nii -reslice-matrix rigid.mat -o\
            moving_resliced_to_fixed.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "align_landmarks",
        "align_landmarks": align_landmarks,
    }
    return params


def c3d_align_landmarks_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAlignLandmarksParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("align_landmarks", None) is None:
        raise StyxValidationError("`align_landmarks` must not be None")
    if not isinstance(params["align_landmarks"], str):
        raise StyxValidationError(f'`align_landmarks` has the wrong type: Received `{type(params.get("align_landmarks", None))}` expected `str`')


def c3d_align_landmarks_cargs(
    params: C3dAlignLandmarksParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-align-landmarks",
        params.get("align_landmarks", None)
    ])
    return cargs


def c3d_anisotropic_diffusion(
    anisotropic_diffusion: str,
) -> C3dAnisotropicDiffusionParamsDictTagged:
    """
    Build parameters.
    
    Args:
        anisotropic_diffusion: -add: Voxelwise image addition\
            \
            Syntax: `-add`\
            \
            Adds the last two images on the stack, and places the sum at the\
            end of the stack.\
            \
            # Add two images: x = a + b\
            c3d a.img b.img -add -o x.img\
            \
            # Add three images, x = (a + b) + c in the first example, x = a +\
            (b + c) in the second\
            c3d a.img b.img -add c.img -add -o x.img\
            c3d a.img b.img c.img -add -add -o x.img\
            \
            # Subtract two images, using -scale command: x = a - b\
            c3d a.img b.img -scale -1 -add -o x.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "anisotropic_diffusion",
        "anisotropic_diffusion": anisotropic_diffusion,
    }
    return params


def c3d_anisotropic_diffusion_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAnisotropicDiffusionParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("anisotropic_diffusion", None) is None:
        raise StyxValidationError("`anisotropic_diffusion` must not be None")
    if not isinstance(params["anisotropic_diffusion"], str):
        raise StyxValidationError(f'`anisotropic_diffusion` has the wrong type: Received `{type(params.get("anisotropic_diffusion", None))}` expected `str`')


def c3d_anisotropic_diffusion_cargs(
    params: C3dAnisotropicDiffusionParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-anisotropic-diffusion",
        params.get("anisotropic_diffusion", None)
    ])
    return cargs


def c3d_antialias(
    antialias: str,
) -> C3dAntialiasParamsDictTagged:
    """
    Build parameters.
    
    Args:
        antialias: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "antialias",
        "antialias": antialias,
    }
    return params


def c3d_antialias_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAntialiasParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("antialias", None) is None:
        raise StyxValidationError("`antialias` must not be None")
    if not isinstance(params["antialias"], str):
        raise StyxValidationError(f'`antialias` has the wrong type: Received `{type(params.get("antialias", None))}` expected `str`')


def c3d_antialias_cargs(
    params: C3dAntialiasParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-antialias",
        params.get("antialias", None)
    ])
    return cargs


def c3d_set(
    set_: str,
) -> C3dSetParamsDictTagged:
    """
    Build parameters.
    
    Args:
        set_: -as: Assign image at the end of the stack to a variable\
            \
            Syntax: `-as var`\
            \
            Associates the image currently at the end of the stack with\
            variable name 'var'. This allows you to retrieve the image later on\
            the command line using the **-push** command. The **-as** and\
            **-push** commands are useful when you need to use a certain image\
            more than once during a convert3d operation. For example, if you\
            want to compute the distance transform of a binary image and mask\
            it so that the values outside of the binary image region have value\
            0, you would use the following command:\
            \
            c3d binary.img -as A -sdt -push A -times -o masked_distance.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "set",
        "set": set_,
    }
    return params


def c3d_set_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSetParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("set", None) is None:
        raise StyxValidationError("`set` must not be None")
    if not isinstance(params["set"], str):
        raise StyxValidationError(f'`set` has the wrong type: Received `{type(params.get("set", None))}` expected `str`')


def c3d_set_cargs(
    params: C3dSetParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-as",
        params.get("set", None)
    ])
    return cargs


def c3d_asin(
    asin: str,
) -> C3dAsinParamsDictTagged:
    """
    Build parameters.
    
    Args:
        asin: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "asin",
        "asin": asin,
    }
    return params


def c3d_asin_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAsinParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("asin", None) is None:
        raise StyxValidationError("`asin` must not be None")
    if not isinstance(params["asin"], str):
        raise StyxValidationError(f'`asin` has the wrong type: Received `{type(params.get("asin", None))}` expected `str`')


def c3d_asin_cargs(
    params: C3dAsinParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-asin",
        params.get("asin", None)
    ])
    return cargs


def c3d_atan2(
    atan2: str,
) -> C3dAtan2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        atan2: -atan2: Voxelwise angle from sine and cosine\
            \
            Syntax: `-atan2`\
            \
            Computes the angle in radians from images containing sine and\
            cosine. This is a voxel-wise operation. It requires two images on\
            the stack (sine followed by cosine):\
            \
            c3d sin_theta.nii.gz cos_theta.nii.gz -atan2 -o theta.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "atan2",
        "atan2": atan2,
    }
    return params


def c3d_atan2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dAtan2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("atan2", None) is None:
        raise StyxValidationError("`atan2` must not be None")
    if not isinstance(params["atan2"], str):
        raise StyxValidationError(f'`atan2` has the wrong type: Received `{type(params.get("atan2", None))}` expected `str`')


def c3d_atan2_cargs(
    params: C3dAtan2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-atan2",
        params.get("atan2", None)
    ])
    return cargs


def c3d_background(
    background: str,
) -> C3dBackgroundParamsDictTagged:
    """
    Build parameters.
    
    Args:
        background: -background: Specify background intensity\
            \
            Syntax: `-background <value> `\
            \
            Sets the background intensity for interpolation and other\
            operations where some default background value is needed. Default\
            is 0.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "background",
        "background": background,
    }
    return params


def c3d_background_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dBackgroundParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("background", None) is None:
        raise StyxValidationError("`background` must not be None")
    if not isinstance(params["background"], str):
        raise StyxValidationError(f'`background` has the wrong type: Received `{type(params.get("background", None))}` expected `str`')


def c3d_background_cargs(
    params: C3dBackgroundParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-background",
        params.get("background", None)
    ])
    return cargs


def c3d_n4_bias_correction(
    n4_bias_correction: str,
) -> C3dN4BiasCorrectionParamsDictTagged:
    """
    Build parameters.
    
    Args:
        n4_bias_correction: -biascorr: Automatic MRI bias field correction\
            \
            Syntax: `-biascorr`\
            \
            Performs automatic bias field correction for MRI images. This\
            feature uses the [N3 implementation in ITK by Dr. Tustison][4],\
            based on the N3 algorithm by Sled et al.\
            \
            c3d mri.nii.gz -biascorr -o mricorr.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "n4_bias_correction",
        "n4_bias_correction": n4_bias_correction,
    }
    return params


def c3d_n4_bias_correction_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dN4BiasCorrectionParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("n4_bias_correction", None) is None:
        raise StyxValidationError("`n4_bias_correction` must not be None")
    if not isinstance(params["n4_bias_correction"], str):
        raise StyxValidationError(f'`n4_bias_correction` has the wrong type: Received `{type(params.get("n4_bias_correction", None))}` expected `str`')


def c3d_n4_bias_correction_cargs(
    params: C3dN4BiasCorrectionParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-biascorr",
        params.get("n4_bias_correction", None)
    ])
    return cargs


def c3d_binarize(
    binarize: str,
) -> C3dBinarizeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        binarize: -binarize: Convert image to binary\
            \
            Syntax: `-binarize`\
            \
            Converts an image to binary by mapping all background values (the\
            background is 0 by default and can be changed by the option\
            **-background**) to 0 and all non-background values to 1. The\
            **-binarize** command is shorthand for the **-threshold** command.\
            \
            c3d test.img -binarize -o binary.img\
            c3d -background 10 -binarize -o binary.img\
            c3d test.img -threshold 10 10 0 1 // equivalent to above command.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "binarize",
        "binarize": binarize,
    }
    return params


def c3d_binarize_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dBinarizeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("binarize", None) is None:
        raise StyxValidationError("`binarize` must not be None")
    if not isinstance(params["binarize"], str):
        raise StyxValidationError(f'`binarize` has the wrong type: Received `{type(params.get("binarize", None))}` expected `str`')


def c3d_binarize_cargs(
    params: C3dBinarizeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-binarize",
        params.get("binarize", None)
    ])
    return cargs


def c3d_canny(
    canny: str,
) -> C3dCannyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        canny: -canny: Canny edge detector\
            \
            Syntax: `-canny <sigma_vector> <t_lower> <t_upper>`\
            \
            Performs edge detection on the last image on the stack using the\
            Canny filter. The parameters are a vector of standard deviations\
            defining the scale of the edges detected and lower and upper\
            thresholds for edge selection. See documentation on the [ITK Canny\
            Filter][14].
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "canny",
        "canny": canny,
    }
    return params


def c3d_canny_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCannyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("canny", None) is None:
        raise StyxValidationError("`canny` must not be None")
    if not isinstance(params["canny"], str):
        raise StyxValidationError(f'`canny` has the wrong type: Received `{type(params.get("canny", None))}` expected `str`')


def c3d_canny_cargs(
    params: C3dCannyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-canny",
        params.get("canny", None)
    ])
    return cargs


def c3d_ceil(
    ceil: str,
) -> C3dCeilParamsDictTagged:
    """
    Build parameters.
    
    Args:
        ceil: -ceil: Round up image intensities\
            \
            Syntax: `-ceil `\
            \
            Each image intensity is replaced by the smallest integer larger or\
            equal to it\
            \
            c3d input.img -ceil -o output.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ceil",
        "ceil": ceil,
    }
    return params


def c3d_ceil_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCeilParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("ceil", None) is None:
        raise StyxValidationError("`ceil` must not be None")
    if not isinstance(params["ceil"], str):
        raise StyxValidationError(f'`ceil` has the wrong type: Received `{type(params.get("ceil", None))}` expected `str`')


def c3d_ceil_cargs(
    params: C3dCeilParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-ceil",
        params.get("ceil", None)
    ])
    return cargs


def c3d_centroid(
    centroid: str,
) -> C3dCentroidParamsDictTagged:
    """
    Build parameters.
    
    Args:
        centroid: -centroid: Report centroid of foreground voxels\
            \
            Syntax: `-centroid`\
            \
            Reports the centroid, in physical coordinates, of all foreground\
            voxels in the image.\
            \
            c3d binaryimage.img -centroid // centroid of all non-0 voxels\
            c3d grayimage.img -thresh 1000 7000 1 0 -centroid 1 // centroid of\
            all voxels in range 1000-7000\
            c3d labelimage.img -thresh 5 5 1 0 -centroid // centroid of all\
            voxels with label 5\
            c3d labelimage.img -split -foreach -centroid -endfor // centroids\
            of all labels (including 0).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "centroid",
        "centroid": centroid,
    }
    return params


def c3d_centroid_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCentroidParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("centroid", None) is None:
        raise StyxValidationError("`centroid` must not be None")
    if not isinstance(params["centroid"], str):
        raise StyxValidationError(f'`centroid` has the wrong type: Received `{type(params.get("centroid", None))}` expected `str`')


def c3d_centroid_cargs(
    params: C3dCentroidParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-centroid",
        params.get("centroid", None)
    ])
    return cargs


def c3d_centroid_mark(
    centroid_mark: str,
) -> C3dCentroidMarkParamsDictTagged:
    """
    Build parameters.
    
    Args:
        centroid_mark: -centroid-mark: Mark the centroid of foreground voxels\
            \
            Syntax: `-centroid-mark <label>`\
            \
            Marks the centroid of the foreground voxels in an image. Unlike\
            **-centroid**, this command does not print the centroid location,\
            but marks the closest voxel in the image with the intensity\
            **label**. The remaining voxels are assigned 0 intensity. Combined\
            with -dilate, this can be used to mark centers of regions with\
            spheres.\
            \
            c3d binaryimage.nii -centroid-mark -dilate 1 3x3x3\
            c3d labelimage.nii -split -foreach -centroid-mark -endfor -merge -o\
            centers.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "centroid_mark",
        "centroid_mark": centroid_mark,
    }
    return params


def c3d_centroid_mark_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCentroidMarkParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("centroid_mark", None) is None:
        raise StyxValidationError("`centroid_mark` must not be None")
    if not isinstance(params["centroid_mark"], str):
        raise StyxValidationError(f'`centroid_mark` has the wrong type: Received `{type(params.get("centroid_mark", None))}` expected `str`')


def c3d_centroid_mark_cargs(
    params: C3dCentroidMarkParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-centroid-mark",
        params.get("centroid_mark", None)
    ])
    return cargs


def c3d_connected_components(
    connected_components: str,
) -> C3dConnectedComponentsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        connected_components: -comp, -connected-components: Compute connected\
            components\
            \
            Syntax: `-comp`\
            \
            Computes the connected components of a binary image. Each connected\
            component is assigned an integer index. Indices are ordered by the\
            size of the component, so the component assigned index 1 is the\
            largest. The background is assigned index 0. To select the largest\
            connected component, combine the call to **-comp** with a call to\
            **-threshold**.\
            \
            c3d binary.img -comp -o comp.img\
            c3d binary.img -comp -threshold 1 1 1 0 -o largest_comp.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "connected_components",
        "connected_components": connected_components,
    }
    return params


def c3d_connected_components_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dConnectedComponentsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("connected_components", None) is None:
        raise StyxValidationError("`connected_components` must not be None")
    if not isinstance(params["connected_components"], str):
        raise StyxValidationError(f'`connected_components` has the wrong type: Received `{type(params.get("connected_components", None))}` expected `str`')


def c3d_connected_components_cargs(
    params: C3dConnectedComponentsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-connected-components",
        params.get("connected_components", None)
    ])
    return cargs


def c3d_clear(
    clear_: str,
) -> C3dClearParamsDictTagged:
    """
    Build parameters.
    
    Args:
        clear_: -clear: Clear the image stack\
            \
            Syntax: `-clear`\
            \
            Clears the image stack. Images assigned a name with the **-as**\
            command will remain in memory.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "clear",
        "clear": clear_,
    }
    return params


def c3d_clear_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dClearParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("clear", None) is None:
        raise StyxValidationError("`clear` must not be None")
    if not isinstance(params["clear"], str):
        raise StyxValidationError(f'`clear` has the wrong type: Received `{type(params.get("clear", None))}` expected `str`')


def c3d_clear_cargs(
    params: C3dClearParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-clear",
        params.get("clear", None)
    ])
    return cargs


def c3d_clip(
    clip: str,
) -> C3dClipParamsDictTagged:
    """
    Build parameters.
    
    Args:
        clip: -clip: Clip image intensity to range\
            \
            Syntax: `-clip iMin iMax`\
            \
            Clips image intensities, so that the values below *iMin* are\
            converted to *iMin* and values greater than *iMax* are converted to\
            *iMax*. This is useful for eliminating hyperintensities in images.\
            Values *iMin* and *iMax* are intensity specifications (see below).\
            \
            c3d mri.img -clip 1000 8000 -o mriclip01.img // Clips below and\
            above\
            c3d mri.img -clip -inf 8000 -o mriclip02.img // Clips above only\
            c3d mri.img -clip -inf 95% -o mriclip03.img // Clips at 95th\
            percentile.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "clip",
        "clip": clip,
    }
    return params


def c3d_clip_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dClipParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("clip", None) is None:
        raise StyxValidationError("`clip` must not be None")
    if not isinstance(params["clip"], str):
        raise StyxValidationError(f'`clip` has the wrong type: Received `{type(params.get("clip", None))}` expected `str`')


def c3d_clip_cargs(
    params: C3dClipParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-clip",
        params.get("clip", None)
    ])
    return cargs


def c3d_color_map(
    color_map: str,
) -> C3dColorMapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        color_map: -color-map, -colormap: Convert scalar image to RGB using\
            color map\
            \
            Syntax: `-color-map <ColormapName> [min max]`\
            \
            Converts a scalar image to a color (RGB) image using a specified\
            color map. The output of the command are three images, containing\
            the red, green and blue channels of the RGB image. The mapping uses\
            the range of the input image, e.g., using the **jet** color map,\
            the lowest intensity pixel in the image will be mapped to blue, and\
            the highest intesnity pixel will be mapped to red. The admissible\
            color maps are\
            **hot,cool,spring,summer,autumn,winter,copper,jet,hsv,red,green,blue,grey,overunder**.\
            The command can be used with the -omc command to write RGB images.\
            The example below generates a PNG image from a slice in a scalar\
            image.\
            \
            c3d scalar.nii.gz -slice z 50% -flip y -color-map jet -type uchar\
            -omc colorslice.png\
            \
            By default the full image intensity range is mapped. The optional\
            **min** and **max** parameters can be used to set the range of the\
            color map.\
            \
            c3d scalar.nii.gz -slice z 50% -flip y -color-map jet 0 1 -type\
            uchar -omc colorslice.png.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "color_map",
        "color_map": color_map,
    }
    return params


def c3d_color_map_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dColorMapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("color_map", None) is None:
        raise StyxValidationError("`color_map` must not be None")
    if not isinstance(params["color_map"], str):
        raise StyxValidationError(f'`color_map` has the wrong type: Received `{type(params.get("color_map", None))}` expected `str`')


def c3d_color_map_cargs(
    params: C3dColorMapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-colormap",
        params.get("color_map", None)
    ])
    return cargs


def c3d_compress(
    compress: str,
) -> C3dCompressParamsDictTagged:
    """
    Build parameters.
    
    Args:
        compress: -compress, -no-compress: Enable/disable compression for some\
            image files\
            \
            Syntax: `-compress` or `-no-compress`\
            \
            Turns on compressing for image file formats that support it. For\
            some file formats, like NIFTI (.nii), compression is enabled\
            automatically when the filename includes the **.gz** extension. For\
            other formats, like MetaImage, you need to specify **-compress** to\
            enable compression. The following two commands save the image as\
            compressed NIFTI and MetaImage files:\
            \
            c3d input.nii -o output.nii.gz\
            c3d input.nii -compress -o output.mha.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "compress",
        "compress": compress,
    }
    return params


def c3d_compress_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCompressParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("compress", None) is None:
        raise StyxValidationError("`compress` must not be None")
    if not isinstance(params["compress"], str):
        raise StyxValidationError(f'`compress` has the wrong type: Received `{type(params.get("compress", None))}` expected `str`')


def c3d_compress_cargs(
    params: C3dCompressParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-compress",
        params.get("compress", None)
    ])
    return cargs


def c3d_no_compress(
    no_compress: str,
) -> C3dNoCompressParamsDictTagged:
    """
    Build parameters.
    
    Args:
        no_compress: -compress, -no-compress: Enable/disable compression for\
            some image files\
            \
            Syntax: `-compress` or `-no-compress`\
            \
            Turns on compressing for image file formats that support it. For\
            some file formats, like NIFTI (.nii), compression is enabled\
            automatically when the filename includes the **.gz** extension. For\
            other formats, like MetaImage, you need to specify **-compress** to\
            enable compression. The following two commands save the image as\
            compressed NIFTI and MetaImage files:\
            \
            c3d input.nii -o output.nii.gz\
            c3d input.nii -compress -o output.mha.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "no_compress",
        "no_compress": no_compress,
    }
    return params


def c3d_no_compress_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoCompressParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("no_compress", None) is None:
        raise StyxValidationError("`no_compress` must not be None")
    if not isinstance(params["no_compress"], str):
        raise StyxValidationError(f'`no_compress` has the wrong type: Received `{type(params.get("no_compress", None))}` expected `str`')


def c3d_no_compress_cargs(
    params: C3dNoCompressParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-no-compress",
        params.get("no_compress", None)
    ])
    return cargs


def c3d_conv(
    conv: str,
) -> C3dConvParamsDictTagged:
    """
    Build parameters.
    
    Args:
        conv: -conv: Convolution\
            \
            Syntax `-conv`\
            \
            Performs convolution between the last two images on the stack. The\
            convolution is performed using the Fourier transform. The result is\
            an image of the same dimensions as the first image. For more\
            details, see ["FFT Based Convolution" by Gaetan Lehmann][Lehmann].\
            \
            c3d image.nii kernel.nii -conv -o result.nii\
            \
            \
            [Lehmann]: https://hdl.handle.net/10380/3154.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "conv",
        "conv": conv,
    }
    return params


def c3d_conv_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dConvParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("conv", None) is None:
        raise StyxValidationError("`conv` must not be None")
    if not isinstance(params["conv"], str):
        raise StyxValidationError(f'`conv` has the wrong type: Received `{type(params.get("conv", None))}` expected `str`')


def c3d_conv_cargs(
    params: C3dConvParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-conv",
        params.get("conv", None)
    ])
    return cargs


def c3d_coordinate_map_voxel(
    coordinate_map_voxel: str,
) -> C3dCoordinateMapVoxelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        coordinate_map_voxel: -cmv, -coordinate-map-voxel: Generate voxel\
            coordinate maps (voxel units)\
            \
            Syntax: `-cmv`\
            \
            For a *N*-dimensional image, replaces the last image on the stack\
            with *N* images. The *k*-th output image at each voxel contains the\
            $k$-th coordinate of that voxel, in voxel units.\
            \
            c3d image.nii -cmv -oo coordmap%d.nii.gz\
            \
            One can use this command to split a brain segmentation image into a\
            left hemisphere segmentation and a right hemisphere segmentation\
            (assuming the X coordinate corresponds to the right-left axis)\
            \
            c3d seg.nii -as SEG -cmv -pop -pop -thresh 50% inf 1 0 -as MASK \\\
            -push SEG -times -o seg_left.nii.gz \\\
            -push MASK -replace 1 0 0 1 \\\
            -push SEG -times -o seg_right.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "coordinate_map_voxel",
        "coordinate_map_voxel": coordinate_map_voxel,
    }
    return params


def c3d_coordinate_map_voxel_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCoordinateMapVoxelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("coordinate_map_voxel", None) is None:
        raise StyxValidationError("`coordinate_map_voxel` must not be None")
    if not isinstance(params["coordinate_map_voxel"], str):
        raise StyxValidationError(f'`coordinate_map_voxel` has the wrong type: Received `{type(params.get("coordinate_map_voxel", None))}` expected `str`')


def c3d_coordinate_map_voxel_cargs(
    params: C3dCoordinateMapVoxelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-coordinate-map-voxel",
        params.get("coordinate_map_voxel", None)
    ])
    return cargs


def c3d_coordinate_map_physical(
    coordinate_map_physical: str,
) -> C3dCoordinateMapPhysicalParamsDictTagged:
    """
    Build parameters.
    
    Args:
        coordinate_map_physical: -cmp, -coordinate-map-physical: Generate voxel\
            coordinate maps (voxel units)\
            \
            Syntax: `-cmp`\
            \
            This command is similar to **-cmv** (**-coordinate-map-voxel**),\
            but the output will contain the physical coordinates of the voxels,\
            in the NIFTI (RAS) coordinate frame.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "coordinate_map_physical",
        "coordinate_map_physical": coordinate_map_physical,
    }
    return params


def c3d_coordinate_map_physical_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCoordinateMapPhysicalParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("coordinate_map_physical", None) is None:
        raise StyxValidationError("`coordinate_map_physical` must not be None")
    if not isinstance(params["coordinate_map_physical"], str):
        raise StyxValidationError(f'`coordinate_map_physical` has the wrong type: Received `{type(params.get("coordinate_map_physical", None))}` expected `str`')


def c3d_coordinate_map_physical_cargs(
    params: C3dCoordinateMapPhysicalParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-coordinate-map-physical",
        params.get("coordinate_map_physical", None)
    ])
    return cargs


def c3d_copy_transform(
    copy_transform: str,
) -> C3dCopyTransformParamsDictTagged:
    """
    Build parameters.
    
    Args:
        copy_transform: -copy-transform: Copy header information\
            \
            Syntax: `-copy-transform`\
            \
            Copies the image header, specifically the image to physical space\
            transform (origin, spacing, direction cosines), from the first\
            image (reference) to the second image (target). This is best done\
            with NIFTI images, which store this information well. In the\
            example below, *out.nii* will have the same header as *first.nii*\
            and the same intensities as *second.nii*.\
            \
            c3d first.nii second.nii -copy-transform -o out.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "copy_transform",
        "copy_transform": copy_transform,
    }
    return params


def c3d_copy_transform_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCopyTransformParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("copy_transform", None) is None:
        raise StyxValidationError("`copy_transform` must not be None")
    if not isinstance(params["copy_transform"], str):
        raise StyxValidationError(f'`copy_transform` has the wrong type: Received `{type(params.get("copy_transform", None))}` expected `str`')


def c3d_copy_transform_cargs(
    params: C3dCopyTransformParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-copy-transform",
        params.get("copy_transform", None)
    ])
    return cargs


def c3d_cos(
    cos: str,
) -> C3dCosParamsDictTagged:
    """
    Build parameters.
    
    Args:
        cos: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "cos",
        "cos": cos,
    }
    return params


def c3d_cos_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCosParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("cos", None) is None:
        raise StyxValidationError("`cos` must not be None")
    if not isinstance(params["cos"], str):
        raise StyxValidationError(f'`cos` has the wrong type: Received `{type(params.get("cos", None))}` expected `str`')


def c3d_cos_cargs(
    params: C3dCosParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-cos",
        params.get("cos", None)
    ])
    return cargs


def c3d_create(
    create: str,
) -> C3dCreateParamsDictTagged:
    """
    Build parameters.
    
    Args:
        create: -create: Generate blank image\
            \
            Syntax: `-create dimensions voxel_size`\
            \
            Creates a new blank image with specified dimensions and voxel size,\
            and places it at the end of the stack. The image is set to the\
            current background value, which is 0 by default but can be\
            overwritten with the **-background** command. The origin of the\
            image can be changed with the **-origin** command.\
            \
            c3d -create 256x256x160 1x1x1mm -o newimage.img\
            c3d -background 128 -create 256x256x160 1x1x1mm -origin\
            128x128x80mm -o newimage.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "create",
        "create": create,
    }
    return params


def c3d_create_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dCreateParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("create", None) is None:
        raise StyxValidationError("`create` must not be None")
    if not isinstance(params["create"], str):
        raise StyxValidationError(f'`create` has the wrong type: Received `{type(params.get("create", None))}` expected `str`')


def c3d_create_cargs(
    params: C3dCreateParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-create",
        params.get("create", None)
    ])
    return cargs


def c3d_dicom_series_list(
    dicom_series_list: str,
) -> C3dDicomSeriesListParamsDictTagged:
    """
    Build parameters.
    
    Args:
        dicom_series_list: -dicom-series-list: List image series in a DICOM\
            directory\
            \
            Syntax: `-dicom-series-list <directory>\
            \
            Prints out a table of DICOM series ids and corresponding image\
            information to standard output.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "dicom_series_list",
        "dicom_series_list": dicom_series_list,
    }
    return params


def c3d_dicom_series_list_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dDicomSeriesListParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dicom_series_list", None) is None:
        raise StyxValidationError("`dicom_series_list` must not be None")
    if not isinstance(params["dicom_series_list"], str):
        raise StyxValidationError(f'`dicom_series_list` has the wrong type: Received `{type(params.get("dicom_series_list", None))}` expected `str`')


def c3d_dicom_series_list_cargs(
    params: C3dDicomSeriesListParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-dicom-series-list",
        params.get("dicom_series_list", None)
    ])
    return cargs


def c3d_dicom_series_read(
    dicom_series_read: str,
) -> C3dDicomSeriesReadParamsDictTagged:
    """
    Build parameters.
    
    Args:
        dicom_series_read: -dicom-series-read: Read a DICOM image series\
            \
            Syntax: `-dicom-series-read <directory> <series_id>`\
            \
            Imports a specific DICOM image series from a directory containing\
            DICOM files. The **directory** parameter may also point to one of\
            the DICOM files in the directory.\
            The **seried_id** is a string identifier for the series that can be\
            obtained by calling **-dicom-series-list**.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "dicom_series_read",
        "dicom_series_read": dicom_series_read,
    }
    return params


def c3d_dicom_series_read_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dDicomSeriesReadParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dicom_series_read", None) is None:
        raise StyxValidationError("`dicom_series_read` must not be None")
    if not isinstance(params["dicom_series_read"], str):
        raise StyxValidationError(f'`dicom_series_read` has the wrong type: Received `{type(params.get("dicom_series_read", None))}` expected `str`')


def c3d_dicom_series_read_cargs(
    params: C3dDicomSeriesReadParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-dicom-series-read",
        params.get("dicom_series_read", None)
    ])
    return cargs


def c3d_dilate(
    dilate: str,
) -> C3dDilateParamsDictTagged:
    """
    Build parameters.
    
    Args:
        dilate: -dilate: Binary dilation\
            \
            Syntax: `-dilate <label> <radius_vector>`\
            \
            Applies the dilation [mathematical morphology][5] operation to a\
            binary image. The first parameter is the intensity value of the\
            object that is to be dilated. The second is the radius of the\
            dilation structuring element in 3D.\
            \
            c3d binary.img -dilate 255 3x3x3vox -o newimage.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "dilate",
        "dilate": dilate,
    }
    return params


def c3d_dilate_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dDilateParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dilate", None) is None:
        raise StyxValidationError("`dilate` must not be None")
    if not isinstance(params["dilate"], str):
        raise StyxValidationError(f'`dilate` has the wrong type: Received `{type(params.get("dilate", None))}` expected `str`')


def c3d_dilate_cargs(
    params: C3dDilateParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-dilate",
        params.get("dilate", None)
    ])
    return cargs


def c3d_divide(
    divide: str,
) -> C3dDivideParamsDictTagged:
    """
    Build parameters.
    
    Args:
        divide: -divide: Voxelwise image division\
            \
            Syntax: `-divide`\
            \
            Divides one image by another. For instance to compute C = A / B,\
            use the command\
            \
            c3d A.img B.img -divide -o C.img\
            \
            Divison may generate infinite and not-a-number (NaN) values if B\
            contains zeros. You can use **-replace** to get rid of these values\
            \
            c3d A.img B.img -divide -replace inf 1000 -inf -1000 NaN 0 -o\
            C2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "divide",
        "divide": divide,
    }
    return params


def c3d_divide_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dDivideParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("divide", None) is None:
        raise StyxValidationError("`divide` must not be None")
    if not isinstance(params["divide"], str):
        raise StyxValidationError(f'`divide` has the wrong type: Received `{type(params.get("divide", None))}` expected `str`')


def c3d_divide_cargs(
    params: C3dDivideParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-divide",
        params.get("divide", None)
    ])
    return cargs


def c3d_duplicate(
    duplicate: str,
) -> C3dDuplicateParamsDictTagged:
    """
    Build parameters.
    
    Args:
        duplicate: -dup: Duplicate the last image on the stack\
            \
            Syntax: `-dup`\
            \
            Duplicates the image at the end of the stack. This is equivalent to\
            **-as var -push var**, but shorter. An example is when you want to\
            pass an image as both arguments to a binary operator, e.g.,\
            computing the square of the image intensity:\
            \
            c3d input.img -dup -times -o square.img\
            \
            ### Commands: Voxelwise Calculations.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "duplicate",
        "duplicate": duplicate,
    }
    return params


def c3d_duplicate_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dDuplicateParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("duplicate", None) is None:
        raise StyxValidationError("`duplicate` must not be None")
    if not isinstance(params["duplicate"], str):
        raise StyxValidationError(f'`duplicate` has the wrong type: Received `{type(params.get("duplicate", None))}` expected `str`')


def c3d_duplicate_cargs(
    params: C3dDuplicateParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-dup",
        params.get("duplicate", None)
    ])
    return cargs


def c3d_endaccum(
    endaccum: str,
) -> C3dEndaccumParamsDictTagged:
    """
    Build parameters.
    
    Args:
        endaccum: -accum, -endaccum: Accumulate operations over all images\
            \
            Syntax: `-accum command-list -endaccum`\
            \
            Apply a binary operation (such as addition or multiplication) to\
            all the images on the stack in a cumulative fashion. The command(s)\
            will be applied to the last and second-to-last images on the stack,\
            then to the result of this operation and the third-to-last image on\
            the stack and so on. Below is the example of using the command to\
            add multiple images.\
            \
            c3d image*.nii -accum -add -endaccum -o sum.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "endaccum",
        "endaccum": endaccum,
    }
    return params


def c3d_endaccum_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dEndaccumParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("endaccum", None) is None:
        raise StyxValidationError("`endaccum` must not be None")
    if not isinstance(params["endaccum"], str):
        raise StyxValidationError(f'`endaccum` has the wrong type: Received `{type(params.get("endaccum", None))}` expected `str`')


def c3d_endaccum_cargs(
    params: C3dEndaccumParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-endaccum",
        params.get("endaccum", None)
    ])
    return cargs


def c3d_endfor(
    endfor: str,
) -> C3dEndforParamsDictTagged:
    """
    Build parameters.
    
    Args:
        endfor: -foreach, -endfor: Loop commands over all images on the stack\
            \
            Syntax: `-foreach commands-list -endfor`\
            \
            This command forces the commands between **-foreach** and\
            **-endfor** to be applied to every image on the stack. The main use\
            of this command is to automate processing of multiple datasets. For\
            example,\
            \
            c3d epi*.nii -foreach -smooth 3mm -endfor -oo epism%03d.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "endfor",
        "endfor": endfor,
    }
    return params


def c3d_endfor_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dEndforParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("endfor", None) is None:
        raise StyxValidationError("`endfor` must not be None")
    if not isinstance(params["endfor"], str):
        raise StyxValidationError(f'`endfor` has the wrong type: Received `{type(params.get("endfor", None))}` expected `str`')


def c3d_endfor_cargs(
    params: C3dEndforParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-endfor",
        params.get("endfor", None)
    ])
    return cargs


def c3d_erode(
    erode: str,
) -> C3dErodeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        erode: -erode: Binary erosion\
            \
            Syntax: `-erode <label> <radius_vector>`\
            \
            Applies erosion [mathematical morphology][5] operation to a binary\
            image. The first parameter is the intensity value of the object\
            that is to be eroded. The second is the radius of the erosion\
            structuring element in 3D.\
            \
            c3d binary.img -erode 255 3x3x3vox -o newimage.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "erode",
        "erode": erode,
    }
    return params


def c3d_erode_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dErodeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("erode", None) is None:
        raise StyxValidationError("`erode` must not be None")
    if not isinstance(params["erode"], str):
        raise StyxValidationError(f'`erode` has the wrong type: Received `{type(params.get("erode", None))}` expected `str`')


def c3d_erode_cargs(
    params: C3dErodeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-erode",
        params.get("erode", None)
    ])
    return cargs


def c3d_erf(
    erf: str,
) -> C3dErfParamsDictTagged:
    """
    Build parameters.
    
    Args:
        erf: -erf: Standard error function\
            \
            Syntax: `-erf mu sigma`\
            \
            Computes the standard error function. This is useful for applying\
            soft thresholds. The function computes y = erf((x - mu)/sigma).\
            \
            c3d input.img -erf 5 2 -o erf.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "erf",
        "erf": erf,
    }
    return params


def c3d_erf_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dErfParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("erf", None) is None:
        raise StyxValidationError("`erf` must not be None")
    if not isinstance(params["erf"], str):
        raise StyxValidationError(f'`erf` has the wrong type: Received `{type(params.get("erf", None))}` expected `str`')


def c3d_erf_cargs(
    params: C3dErfParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-erf",
        params.get("erf", None)
    ])
    return cargs


def c3d_exp(
    exp: str,
) -> C3dExpParamsDictTagged:
    """
    Build parameters.
    
    Args:
        exp: -exp: Voxelwise natural exponent\
            \
            Syntax: `-exp`\
            \
            Computes exponent of each voxel in the last image on the stack.\
            \
            c3d input.img -exp -o output.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "exp",
        "exp": exp,
    }
    return params


def c3d_exp_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dExpParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("exp", None) is None:
        raise StyxValidationError("`exp` must not be None")
    if not isinstance(params["exp"], str):
        raise StyxValidationError(f'`exp` has the wrong type: Received `{type(params.get("exp", None))}` expected `str`')


def c3d_exp_cargs(
    params: C3dExpParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-exp",
        params.get("exp", None)
    ])
    return cargs


def c3d_export_patches(
    export_patches: str,
) -> C3dExportPatchesParamsDictTagged:
    """
    Build parameters.
    
    Args:
        export_patches: -export-patches, -xp: Fixed size patch sampling from\
            masked regions\
            \
            Syntax: `-export-patches <outfile> <radius_vector> <frequency>`\
            \
            See also: **-export-patches-aug (-xpa)** command, which provides\
            data augmentation for deep learning.\
            \
            This command samples patches from a region of a ND image and stores\
            them into a data file that can be read easily in other software,\
            for example, NumPy. This is useful for generating training data for\
            machine learning projects. Multiple "channels" can be sampled.\
            \
            c3d chan1.nii chan2.nii chan3.nii mask.nii -xp samples.dat 4x4x4\
            100\
            \
            This command will sample the three images chan1, chan2, chan3 at\
            foreground voxels in the mask. Voxels in the mask foreground region\
            are sampled randomly, following a uniform distribution. The value\
            of 100 means that every 100-th voxel, on average, is sampled. The\
            radius 4x4x4 means that patches of size 9x9x9 will be generated.\
            For each sampled voxel, the sampled intensity data is represented\
            as a 3x9x9x9 array in this example.\
            \
            To read these samples in NumPy use the following code\
            \
            dims = (9,9,9) # Patch dimensions\
            k = 3 # Number of channels\
            bps = (4 * k * reduce(mul, dims, 1)) # Bytes per sample\
            np = os.path.getsize(fname) // bps # Number of samples\
            arr = numpy.memmap(fname,'float32','r',shape=(np,k) + dims)\
            \
            It is also possible to visualize the extracted samples in ITK-SNAP\
            by reading them as a raw image, with dimensions equal to the\
            dimensions of the patch, and the z-dimension multiplied by the\
            number of samples.\
            \
            The command can also be used to extract entire structures. For\
            example, if we have a binary segmentation of a lesion of an\
            approximately known size in an MRI scan, we can extract a patch of\
            given size centered on this lesion, as follows:\
            \
            c3d mri.nii lesion_seg.nii -centroid-mark 1 -xp single_sample.dat\
            50x50x20 1\
            \
            In the above example, **-centroid-mark** transforms the lesion\
            segmentation into a single-voxel mask, from which the sample from\
            the MRI is taken.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "export_patches",
        "export_patches": export_patches,
    }
    return params


def c3d_export_patches_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dExportPatchesParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("export_patches", None) is None:
        raise StyxValidationError("`export_patches` must not be None")
    if not isinstance(params["export_patches"], str):
        raise StyxValidationError(f'`export_patches` has the wrong type: Received `{type(params.get("export_patches", None))}` expected `str`')


def c3d_export_patches_cargs(
    params: C3dExportPatchesParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-export-patches",
        params.get("export_patches", None)
    ])
    return cargs


def c3d_export_patches_aug(
    export_patches_aug: str,
) -> C3dExportPatchesAugParamsDictTagged:
    """
    Build parameters.
    
    Args:
        export_patches_aug: -export-patches-aug, -xpa: data augmentation for\
            deep learning\
            \
            Syntax `-export-patches-aug <N> <sigma_angle>`\
            \
            This command must precede the `-export-patches (-xp)` command and\
            instructs this command to not only sample patches along the image\
            axes but to also sample **N** randomly rotated patches. Rotation is\
            around a uniformly distributed axis with a rotation angle\
            distributed normally with teh standard deviation **sigma_angle**,\
            specified in degrees. This kind of sampling is useful for data\
            augmentation for machine learning algorithms.\
            \
            c3d chan1.nii chan2.nii chan3.nii mask.nii -xpa 5 10 -xp\
            samples.dat 4x4x4 100.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "export_patches_aug",
        "export_patches_aug": export_patches_aug,
    }
    return params


def c3d_export_patches_aug_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dExportPatchesAugParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("export_patches_aug", None) is None:
        raise StyxValidationError("`export_patches_aug` must not be None")
    if not isinstance(params["export_patches_aug"], str):
        raise StyxValidationError(f'`export_patches_aug` has the wrong type: Received `{type(params.get("export_patches_aug", None))}` expected `str`')


def c3d_export_patches_aug_cargs(
    params: C3dExportPatchesAugParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-export-patches-aug",
        params.get("export_patches_aug", None)
    ])
    return cargs


def c3d_extrude_seg(
    extrude_seg: str,
) -> C3dExtrudeSegParamsDictTagged:
    """
    Build parameters.
    
    Args:
        extrude_seg: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "extrude_seg",
        "extrude_seg": extrude_seg,
    }
    return params


def c3d_extrude_seg_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dExtrudeSegParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("extrude_seg", None) is None:
        raise StyxValidationError("`extrude_seg` must not be None")
    if not isinstance(params["extrude_seg"], str):
        raise StyxValidationError(f'`extrude_seg` has the wrong type: Received `{type(params.get("extrude_seg", None))}` expected `str`')


def c3d_extrude_seg_cargs(
    params: C3dExtrudeSegParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-extrude-seg",
        params.get("extrude_seg", None)
    ])
    return cargs


def c3d_fill_background_with_noise(
    fill_background_with_noise: str,
) -> C3dFillBackgroundWithNoiseParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fill_background_with_noise: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fill_background_with_noise",
        "fill_background_with_noise": fill_background_with_noise,
    }
    return params


def c3d_fill_background_with_noise_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dFillBackgroundWithNoiseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fill_background_with_noise", None) is None:
        raise StyxValidationError("`fill_background_with_noise` must not be None")
    if not isinstance(params["fill_background_with_noise"], str):
        raise StyxValidationError(f'`fill_background_with_noise` has the wrong type: Received `{type(params.get("fill_background_with_noise", None))}` expected `str`')


def c3d_fill_background_with_noise_cargs(
    params: C3dFillBackgroundWithNoiseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-fill-background-with-noise",
        params.get("fill_background_with_noise", None)
    ])
    return cargs


def c3d_fft(
    fft: str,
) -> C3dFftParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fft: -fft: Fast Fourier transform\
            \
            Syntax `-fft`\
            \
            Computes the Fourier transform of a real-valued image at the end of\
            the stack. The image is replaced by the real and imaginary\
            components of the FFT. This command is only available if\
            **convert3d** is compiled with the FFTW library support.\
            \
            c3d image.nii -fft -oo real.nii imag.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fft",
        "fft": fft,
    }
    return params


def c3d_fft_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dFftParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fft", None) is None:
        raise StyxValidationError("`fft` must not be None")
    if not isinstance(params["fft"], str):
        raise StyxValidationError(f'`fft` has the wrong type: Received `{type(params.get("fft", None))}` expected `str`')


def c3d_fft_cargs(
    params: C3dFftParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-fft",
        params.get("fft", None)
    ])
    return cargs


def c3d_flip(
    flip: str,
) -> C3dFlipParamsDictTagged:
    """
    Build parameters.
    
    Args:
        flip: -flip: Flip image around an axis\
            \
            Syntax: `-flip axes`\
            \
            Flips the image around specified axes. The parameter 'axes' may be\
            any combination of characters 'x', 'y', and 'z'; the order does not\
            matter.\
            \
            c3d input.img -flip xy -o output.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "flip",
        "flip": flip,
    }
    return params


def c3d_flip_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dFlipParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("flip", None) is None:
        raise StyxValidationError("`flip` must not be None")
    if not isinstance(params["flip"], str):
        raise StyxValidationError(f'`flip` has the wrong type: Received `{type(params.get("flip", None))}` expected `str`')


def c3d_flip_cargs(
    params: C3dFlipParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-flip",
        params.get("flip", None)
    ])
    return cargs


def c3d_floor(
    floor: str,
) -> C3dFloorParamsDictTagged:
    """
    Build parameters.
    
    Args:
        floor: -floor: Round down image intensities\
            \
            Syntax: `-floor `\
            \
            Each image intensity is replaced by the largest integer smaller or\
            equal to it.\
            \
            c3d input.img -floor -o output.img\
            \
            To round each intensity to the closest integer, use\
            \
            c3d input.img -shift 0.5 -floor.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "floor",
        "floor": floor,
    }
    return params


def c3d_floor_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dFloorParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("floor", None) is None:
        raise StyxValidationError("`floor` must not be None")
    if not isinstance(params["floor"], str):
        raise StyxValidationError(f'`floor` has the wrong type: Received `{type(params.get("floor", None))}` expected `str`')


def c3d_floor_cargs(
    params: C3dFloorParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-floor",
        params.get("floor", None)
    ])
    return cargs


def c3d_foreach(
    foreach: str,
) -> C3dForeachParamsDictTagged:
    """
    Build parameters.
    
    Args:
        foreach: -foreach, -endfor: Loop commands over all images on the stack\
            \
            Syntax: `-foreach commands-list -endfor`\
            \
            This command forces the commands between **-foreach** and\
            **-endfor** to be applied to every image on the stack. The main use\
            of this command is to automate processing of multiple datasets. For\
            example,\
            \
            c3d epi*.nii -foreach -smooth 3mm -endfor -oo epism%03d.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "foreach",
        "foreach": foreach,
    }
    return params


def c3d_foreach_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dForeachParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("foreach", None) is None:
        raise StyxValidationError("`foreach` must not be None")
    if not isinstance(params["foreach"], str):
        raise StyxValidationError(f'`foreach` has the wrong type: Received `{type(params.get("foreach", None))}` expected `str`')


def c3d_foreach_cargs(
    params: C3dForeachParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-foreach",
        params.get("foreach", None)
    ])
    return cargs


def c3d_foreach_comp(
    foreach_comp: str,
) -> C3dForeachCompParamsDictTagged:
    """
    Build parameters.
    
    Args:
        foreach_comp: -foreach-comp, -endfor: Loop commands over components of\
            a multi-component image\
            \
            Syntax `-foreach-comp <N> commands-list -endfor`\
            \
            This command runs the list of commands separately for each\
            component of a set of multi-component images loaded with -mcs. This\
            makes it possible to perform component-wise operations on\
            multi-component images. For example, it can be used to average\
            several multi-component images. If the image stack contains images\
            *x1* *y1* *z1* *x2* *y2* *z2*, then the operations will be run on\
            *[x1,x2]*, *[y1,y2]*, *[z1,z2]*. For example, if multi_1.nii to\
            multi_10.nii are three-component images, then the mean\
            three-component image is given by\
            \
            c2d -mcs multi_*.nii -foreach-comp -mean -endfor -omc\
            multi_mean.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "foreach_comp",
        "foreach_comp": foreach_comp,
    }
    return params


def c3d_foreach_comp_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dForeachCompParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("foreach_comp", None) is None:
        raise StyxValidationError("`foreach_comp` must not be None")
    if not isinstance(params["foreach_comp"], str):
        raise StyxValidationError(f'`foreach_comp` has the wrong type: Received `{type(params.get("foreach_comp", None))}` expected `str`')


def c3d_foreach_comp_cargs(
    params: C3dForeachCompParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-foreach-comp",
        params.get("foreach_comp", None)
    ])
    return cargs


def c3d_glm(
    glm: str,
) -> C3dGlmParamsDictTagged:
    """
    Build parameters.
    
    Args:
        glm: -glm: General linear model\
            \
            Syntax: `-glm design_matrix_file contrast_vector_file`\
            \
            Applies voxel-wise general linear model to a set of images. More\
            precisely, the general linear model solves the following system: $Y\
            = X \\beta + \\epsilon$, where Y are the observations (a list of n\
            images, where each voxel is treated as an independent observation);\
            X is the $n x k$ design matrix, where $k$ is the number of factors;\
            $\\beta$ is a set of $k$ unknown images (factors) and $\\epsilon$\
            is the error term. The command will compute the $\\beta$ images and\
            return a weighted sum of them, where the weights are specified in\
            the contrast vector. The design matrix and the contrast vector are\
            passed in as files. The file format is just a space-separated list\
            of numbers. For a good explanation of the general linear model, see\
            [S. Kiebel and A. Holmes, General Linear Model, in Ashburner,\
            Friston, Holmes eds., *Human Brain Function, 2nd Edition*][6]. The\
            example below computes the regression coefficient between a set of\
            longitudinal images and subject's age:\
            \
            echo "1 67.00" > design_mat.txt\
            echo "1 75.00" >> design_mat.txt\
            echo "1 80.00" >> design_mat.txt\
            echo "1 83.00" >> design_mat.txt\
            echo "0 1" >> contrast_vec.txt\
            c3d time1.img time2.img time3.img time4.img -glm design_mat.txt\
            contrast_vec.txt -o regress.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "glm",
        "glm": glm,
    }
    return params


def c3d_glm_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dGlmParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("glm", None) is None:
        raise StyxValidationError("`glm` must not be None")
    if not isinstance(params["glm"], str):
        raise StyxValidationError(f'`glm` has the wrong type: Received `{type(params.get("glm", None))}` expected `str`')


def c3d_glm_cargs(
    params: C3dGlmParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-glm",
        params.get("glm", None)
    ])
    return cargs


def c3d_gradient(
    gradient: str,
) -> C3dGradientParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient: -grad, -gradient: Image gradient\
            \
            Syntax `-grad`\
            \
            Computes the gradient of the image. Each component of the gradient\
            is placed on the stack in order (x,y,z). The gradient is computed\
            in physical RAS coordinates, taking into account image spacing and\
            orientation. In other words, the gradient is the vector in physical\
            space orthogonal to the isocontours of the image. No smoothing is\
            performed, so it is a good idea to smooth the image first before\
            computing the gradient.\
            \
            c3d myimage.nii -smooth 1.2vox -grad -oo grad_comp_%02d.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "gradient",
        "gradient": gradient,
    }
    return params


def c3d_gradient_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dGradientParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient", None) is None:
        raise StyxValidationError("`gradient` must not be None")
    if not isinstance(params["gradient"], str):
        raise StyxValidationError(f'`gradient` has the wrong type: Received `{type(params.get("gradient", None))}` expected `str`')


def c3d_gradient_cargs(
    params: C3dGradientParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-grad",
        params.get("gradient", None)
    ])
    return cargs


def c3d__help(
    v__help: str,
) -> C3dHelpParamsDictTagged:
    """
    Build parameters.
    
    Args:
        v__help: -hesseig, -hessian-eigenvalues: Compute eigenvalues of the\
            Hessian matrix\
            \
            Syntax `-hesseig <scale>`\
            \
            Computes the Hessian matrix at every pixel of an image and the\
            eigenvalues of the Hessian. Images of the eigenvalues (sorted by\
            value) are placed on the stack. These images are useful as texture\
            features. See also the '''-steig''' command. The scale determines\
            the amount of Gaussian smoothing applied for computing the partial\
            derivatives in the Hessian, and is in physical (mm) units.\
            \
            c3d myimage.nii -hesseig 2.0 -oo eig%02d.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "_help",
        "_help": v__help,
    }
    return params


def c3d__help_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dHelpParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("_help", None) is None:
        raise StyxValidationError("`_help` must not be None")
    if not isinstance(params["_help"], str):
        raise StyxValidationError(f'`_help` has the wrong type: Received `{type(params.get("_help", None))}` expected `str`')


def c3d__help_cargs(
    params: C3dHelpParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-h",
        params.get("_help", None)
    ])
    return cargs


def c3d_holefill(
    holefill: str,
) -> C3dHolefillParamsDictTagged:
    """
    Build parameters.
    
    Args:
        holefill: -holefill: Fill holes in binary image\
            \
            Syntax: `-holefill intensity_value [0|1] `\
            \
            Apply the binary hole filling algorithm to a particular intensity\
            value in the image. The input image is typically a binary image or\
            a multi-label segmentation image. Holes (voxels not matching the\
            specified intensity value that are completely contained by voxels\
            matching this value) are filled. The second parameter specifies\
            what type of topological connectivity is used to determine holes.\
            The value 0 uses the default algorithm in ITK (face connectivity)\
            and 1 uses the full connectivity variant (face, edge and vertex\
            connectivity). For more details see the [ITK page for this\
            algorithm][7].\
            \
            c3d segmentation.nii.gz -holefill 5 0 -type uchar -o\
            filledlabel5.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "holefill",
        "holefill": holefill,
    }
    return params


def c3d_holefill_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dHolefillParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("holefill", None) is None:
        raise StyxValidationError("`holefill` must not be None")
    if not isinstance(params["holefill"], str):
        raise StyxValidationError(f'`holefill` has the wrong type: Received `{type(params.get("holefill", None))}` expected `str`')


def c3d_holefill_cargs(
    params: C3dHolefillParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-hf",
        params.get("holefill", None)
    ])
    return cargs


def c3d_hessian_eigenvalues(
    hessian_eigenvalues: str,
) -> C3dHessianEigenvaluesParamsDictTagged:
    """
    Build parameters.
    
    Args:
        hessian_eigenvalues: -hesseig, -hessian-eigenvalues: Compute\
            eigenvalues of the Hessian matrix\
            \
            Syntax `-hesseig <scale>`\
            \
            Computes the Hessian matrix at every pixel of an image and the\
            eigenvalues of the Hessian. Images of the eigenvalues (sorted by\
            value) are placed on the stack. These images are useful as texture\
            features. See also the '''-steig''' command. The scale determines\
            the amount of Gaussian smoothing applied for computing the partial\
            derivatives in the Hessian, and is in physical (mm) units.\
            \
            c3d myimage.nii -hesseig 2.0 -oo eig%02d.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "hessian_eigenvalues",
        "hessian_eigenvalues": hessian_eigenvalues,
    }
    return params


def c3d_hessian_eigenvalues_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dHessianEigenvaluesParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("hessian_eigenvalues", None) is None:
        raise StyxValidationError("`hessian_eigenvalues` must not be None")
    if not isinstance(params["hessian_eigenvalues"], str):
        raise StyxValidationError(f'`hessian_eigenvalues` has the wrong type: Received `{type(params.get("hessian_eigenvalues", None))}` expected `str`')


def c3d_hessian_eigenvalues_cargs(
    params: C3dHessianEigenvaluesParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-hesseig",
        params.get("hessian_eigenvalues", None)
    ])
    return cargs


def c3d_hessian_objectness(
    hessian_objectness: str,
) -> C3dHessianObjectnessParamsDictTagged:
    """
    Build parameters.
    
    Args:
        hessian_objectness: -hessobj, -hessian-objectness: Hessian objectness\
            filter\
            \
            Syntax: `-hessobj <dimension> <min_scale> <max_scale>`\
            \
            Also known as the Frangi vesselness filter, this filter can be used\
            to highlight tube-like, sheet-like and blob-like objects in the\
            image. For details, see documentation to the [corresponging ITK\
            class][HTOMIF].\
            \
            Parameter `dimension` is an integer that determines the kind of\
            features that are highlighed. Use 0 for blobs, 1 for tubes, 2 for\
            pancakes, etc. The min and max scale parameters are floating point\
            values, giving the scale of the features highlighted, in physical\
            units. Typically, just one scale is used.\
            \
            # Detect vessel-like structures at scale 0.5mm\
            c3d image.nii.gz -hessobj 1 0.5 0.5\
            \
            [HTOMIF]\
            http://www.itk.org/Doxygen/html/classitk_1_1HessianToObjectnessMeasureImageFilter.html.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "hessian_objectness",
        "hessian_objectness": hessian_objectness,
    }
    return params


def c3d_hessian_objectness_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dHessianObjectnessParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("hessian_objectness", None) is None:
        raise StyxValidationError("`hessian_objectness` must not be None")
    if not isinstance(params["hessian_objectness"], str):
        raise StyxValidationError(f'`hessian_objectness` has the wrong type: Received `{type(params.get("hessian_objectness", None))}` expected `str`')


def c3d_hessian_objectness_cargs(
    params: C3dHessianObjectnessParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-hessobj",
        params.get("hessian_objectness", None)
    ])
    return cargs


def c3d_histogram_match(
    histogram_match: str,
) -> C3dHistogramMatchParamsDictTagged:
    """
    Build parameters.
    
    Args:
        histogram_match: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "histogram_match",
        "histogram_match": histogram_match,
    }
    return params


def c3d_histogram_match_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dHistogramMatchParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("histogram_match", None) is None:
        raise StyxValidationError("`histogram_match` must not be None")
    if not isinstance(params["histogram_match"], str):
        raise StyxValidationError(f'`histogram_match` has the wrong type: Received `{type(params.get("histogram_match", None))}` expected `str`')


def c3d_histogram_match_cargs(
    params: C3dHistogramMatchParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-histmatch",
        params.get("histogram_match", None)
    ])
    return cargs


def c3d_info(
    info: str,
) -> C3dInfoParamsDictTagged:
    """
    Build parameters.
    
    Args:
        info: -info: Display brief image information\
            \
            Syntax: `-info`\
            \
            Prints brief information about the last image on the stack. Does\
            not affect the stack.\
            \
            c3d image.hdr -info\
            \
            Use with the **-foreach** command to get information on multiple\
            images\
            \
            c3d images*.nii -foreach -info -endfor.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "info",
        "info": info,
    }
    return params


def c3d_info_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dInfoParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("info", None) is None:
        raise StyxValidationError("`info` must not be None")
    if not isinstance(params["info"], str):
        raise StyxValidationError(f'`info` has the wrong type: Received `{type(params.get("info", None))}` expected `str`')


def c3d_info_cargs(
    params: C3dInfoParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-info",
        params.get("info", None)
    ])
    return cargs


def c3d_info_full(
    info_full: str,
) -> C3dInfoFullParamsDictTagged:
    """
    Build parameters.
    
    Args:
        info_full: -info-full: Display verbose image information\
            \
            Syntax: `-info-full`\
            \
            Prints extended information about the last image on the stack, such\
            as the metadata dictionary. For example,\
            \
            c3d image.hdr -info-full.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "info_full",
        "info_full": info_full,
    }
    return params


def c3d_info_full_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dInfoFullParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("info_full", None) is None:
        raise StyxValidationError("`info_full` must not be None")
    if not isinstance(params["info_full"], str):
        raise StyxValidationError(f'`info_full` has the wrong type: Received `{type(params.get("info_full", None))}` expected `str`')


def c3d_info_full_cargs(
    params: C3dInfoFullParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-info-full",
        params.get("info_full", None)
    ])
    return cargs


def c3d_insert(
    insert: str,
) -> C3dInsertParamsDictTagged:
    """
    Build parameters.
    
    Args:
        insert: -insert: Insert image anywhere in the stack\
            \
            Syntax: `-insert var pos`\
            \
            This command is similar to **-push**, but allows you to insert the\
            image associated with 'var' at any position in the stack, counting\
            from the end. When 'pos' is 0, the image is placed at the end of\
            the stack (same as **-push**). When pos is one, the image is placed\
            at the next-to-end position, and so on.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "insert",
        "insert": insert,
    }
    return params


def c3d_insert_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dInsertParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("insert", None) is None:
        raise StyxValidationError("`insert` must not be None")
    if not isinstance(params["insert"], str):
        raise StyxValidationError(f'`insert` has the wrong type: Received `{type(params.get("insert", None))}` expected `str`')


def c3d_insert_cargs(
    params: C3dInsertParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-insert",
        params.get("insert", None)
    ])
    return cargs


def c3d_interpolation(
    interpolation: str,
) -> C3dInterpolationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        interpolation: -interpolation: Set interpolation mode\
            \
            Syntax: `-interpolation\
            <NearestNeighbor|Linear|Cubic|Sinc|Gaussian> [param]`\
            \
            Specifies the interpolation used with **-resample** and other\
            commands. Default is **Linear**. Gaussian interpolation takes as\
            the parameter the standard deviation of the Gaussian filter (e.g,\
            1mm). Gaussian interpolation is very similar in result to first\
            smoothing an image with a Gaussian filter and then reslicing it\
            with linear interpolation, but is more accurate and has less\
            aliasing artifacts. It is also slower, and should only be used with\
            small sigmas (a few voxels across).\
            \
            Shorthand 0 can be used for *NearestNeighbor*, 1 for *Linear* and 3\
            for *Cubic*. For example:\
            \
            c3d -int 3 test.nii -resample 200x200x200% -o cubic_supersample.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "interpolation",
        "interpolation": interpolation,
    }
    return params


def c3d_interpolation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dInterpolationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("interpolation", None) is None:
        raise StyxValidationError("`interpolation` must not be None")
    if not isinstance(params["interpolation"], str):
        raise StyxValidationError(f'`interpolation` has the wrong type: Received `{type(params.get("interpolation", None))}` expected `str`')


def c3d_interpolation_cargs(
    params: C3dInterpolationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-interpolation",
        params.get("interpolation", None)
    ])
    return cargs


def c3d_iterations(
    iterations: str,
) -> C3dIterationsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        iterations: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "iterations",
        "iterations": iterations,
    }
    return params


def c3d_iterations_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dIterationsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("iterations", None) is None:
        raise StyxValidationError("`iterations` must not be None")
    if not isinstance(params["iterations"], str):
        raise StyxValidationError(f'`iterations` has the wrong type: Received `{type(params.get("iterations", None))}` expected `str`')


def c3d_iterations_cargs(
    params: C3dIterationsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-iterations",
        params.get("iterations", None)
    ])
    return cargs


def c3d_label_overlap(
    label_overlap: str,
) -> C3dLabelOverlapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        label_overlap: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "label_overlap",
        "label_overlap": label_overlap,
    }
    return params


def c3d_label_overlap_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLabelOverlapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("label_overlap", None) is None:
        raise StyxValidationError("`label_overlap` must not be None")
    if not isinstance(params["label_overlap"], str):
        raise StyxValidationError(f'`label_overlap` has the wrong type: Received `{type(params.get("label_overlap", None))}` expected `str`')


def c3d_label_overlap_cargs(
    params: C3dLabelOverlapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-label-overlap",
        params.get("label_overlap", None)
    ])
    return cargs


def c3d_label_statistics(
    label_statistics: str,
) -> C3dLabelStatisticsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        label_statistics: -lstat, -label-statistics: Display segmentation\
            volumes and intensity statistics\
            \
            Syntax: `-lstat`\
            \
            Given a grayscale image and a multilabel (or binary) image, this\
            command computes the statistics for every label in the latter,\
            including volumes, average grayscale intensity, etc. For instance,\
            if image *mri.nii* is a medical image and *seg.nii* is a multilabel\
            segmentation of the image with labels 0, 1 and 4, the following\
            command can be used to print the statistics of the intensity of\
            *mri.nii* for each of the labels\
            \
            c3d mri.nii seg.nii -lstat\
            \
            The output contains the mean, standard deviation, maximum intensity\
            and minimum intensity for each label. If you just need volumes from\
            a multi-label image, use **-dup** command as follows:\
            \
            c3d seg.nii -dup -lstat.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "label_statistics",
        "label_statistics": label_statistics,
    }
    return params


def c3d_label_statistics_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLabelStatisticsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("label_statistics", None) is None:
        raise StyxValidationError("`label_statistics` must not be None")
    if not isinstance(params["label_statistics"], str):
        raise StyxValidationError(f'`label_statistics` has the wrong type: Received `{type(params.get("label_statistics", None))}` expected `str`')


def c3d_label_statistics_cargs(
    params: C3dLabelStatisticsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-label-statistics",
        params.get("label_statistics", None)
    ])
    return cargs


def c3d_landmarks_to_spheres(
    landmarks_to_spheres: str,
) -> C3dLandmarksToSpheresParamsDictTagged:
    """
    Build parameters.
    
    Args:
        landmarks_to_spheres: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "landmarks_to_spheres",
        "landmarks_to_spheres": landmarks_to_spheres,
    }
    return params


def c3d_landmarks_to_spheres_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLandmarksToSpheresParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("landmarks_to_spheres", None) is None:
        raise StyxValidationError("`landmarks_to_spheres` must not be None")
    if not isinstance(params["landmarks_to_spheres"], str):
        raise StyxValidationError(f'`landmarks_to_spheres` has the wrong type: Received `{type(params.get("landmarks_to_spheres", None))}` expected `str`')


def c3d_landmarks_to_spheres_cargs(
    params: C3dLandmarksToSpheresParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-landmarks-to-spheres",
        params.get("landmarks_to_spheres", None)
    ])
    return cargs


def c3d_laplacian(
    laplacian: str,
) -> C3dLaplacianParamsDictTagged:
    """
    Build parameters.
    
    Args:
        laplacian: -laplacian, -laplace: Laplacian filter\
            \
            Syntax: `-laplacian`\
            \
            Applies the Laplacian filter to the image. Used to detect ridges of\
            intensity. Typically, used with the **-smooth** option to obtain\
            the equivalent of convolving the image with the *Laplacian of the\
            Gaussian (LoG)* kernel:\
            \
            c3d input.img -smooth 1.2vox -laplacian -o output.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "laplacian",
        "laplacian": laplacian,
    }
    return params


def c3d_laplacian_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLaplacianParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("laplacian", None) is None:
        raise StyxValidationError("`laplacian` must not be None")
    if not isinstance(params["laplacian"], str):
        raise StyxValidationError(f'`laplacian` has the wrong type: Received `{type(params.get("laplacian", None))}` expected `str`')


def c3d_laplacian_cargs(
    params: C3dLaplacianParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-laplacian",
        params.get("laplacian", None)
    ])
    return cargs


def c3d_levelset(
    levelset: str,
) -> C3dLevelsetParamsDictTagged:
    """
    Build parameters.
    
    Args:
        levelset: -levelset: Level set segmentation\
            \
            Syntax: `-levelset n_iter `\
            \
            Perform level set segmentation for *n\\_iter* iterations, like in\
            ITK-SNAP. The last image on the stack is treated as the\
            initialization image and the next-to-last image on the stack is the\
            speed image. Both images should be in the range between -1 and 1.\
            Here is how the signs of the different images are interpreted\
            \
            | | Speed Image | Initialization Image | Output Image |\
            | -- | ------------- | -------------------- | ------------ |\
            | +1 | Foreground | Outside | Outside |\
            | -1 | Background | Inside | Inside |\
            \
            Here is an example where you have the speed and the initialization\
            given:\
            \
            c3d speed.img initial.img -levelset-curvature 0.5 -levelset 100 -o\
            seg.img\
            \
            Here is an example of segmenting the ventricles in an MRI image,\
            where the ventricles and other CSF have intensity below 715. The\
            image seg_bubbles.nii.gz in this example is a binary image of the\
            initialization seeds (1 inside the seeds, 0 outside).\
            \
            c3d brain.nii.gz -erf 715 100 -scale -1 seg_bubbles.nii.gz \\\
            -replace 0 1 1 -1 -levelset-curvature 0.2 -levelset 500 \\\
            -thresh -inf 0 1 0 -o segmentation.nii.gz\
            \
            Another example of smoothing a binary image that is useful for\
            cleaning up manual segmentations. Here the speed image is positive\
            inside the binary object, and the initialization is negative inside\
            the object. The command writes out both the level set image (whose\
            0-level set is the smoothed boundary of the binary object) and the\
            smoothed binary object\
            \
            c3d binary.img -threshold 1 inf 1 -1 -binary.img 1 inf 1 -1 \\\
            -levelset-curvature 1.5 -levelset 100 -o levelset.img \\\
            -thresh -inf 0 1 0 -o smoothed_binary.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "levelset",
        "levelset": levelset,
    }
    return params


def c3d_levelset_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLevelsetParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("levelset", None) is None:
        raise StyxValidationError("`levelset` must not be None")
    if not isinstance(params["levelset"], str):
        raise StyxValidationError(f'`levelset` has the wrong type: Received `{type(params.get("levelset", None))}` expected `str`')


def c3d_levelset_cargs(
    params: C3dLevelsetParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-levelset",
        params.get("levelset", None)
    ])
    return cargs


def c3d_levelset_curvature(
    levelset_curvature: str,
) -> C3dLevelsetCurvatureParamsDictTagged:
    """
    Build parameters.
    
    Args:
        levelset_curvature: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "levelset_curvature",
        "levelset_curvature": levelset_curvature,
    }
    return params


def c3d_levelset_curvature_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLevelsetCurvatureParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("levelset_curvature", None) is None:
        raise StyxValidationError("`levelset_curvature` must not be None")
    if not isinstance(params["levelset_curvature"], str):
        raise StyxValidationError(f'`levelset_curvature` has the wrong type: Received `{type(params.get("levelset_curvature", None))}` expected `str`')


def c3d_levelset_curvature_cargs(
    params: C3dLevelsetCurvatureParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-levelset-curvature",
        params.get("levelset_curvature", None)
    ])
    return cargs


def c3d_levelset_advection(
    levelset_advection: str,
) -> C3dLevelsetAdvectionParamsDictTagged:
    """
    Build parameters.
    
    Args:
        levelset_advection: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "levelset_advection",
        "levelset_advection": levelset_advection,
    }
    return params


def c3d_levelset_advection_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLevelsetAdvectionParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("levelset_advection", None) is None:
        raise StyxValidationError("`levelset_advection` must not be None")
    if not isinstance(params["levelset_advection"], str):
        raise StyxValidationError(f'`levelset_advection` has the wrong type: Received `{type(params.get("levelset_advection", None))}` expected `str`')


def c3d_levelset_advection_cargs(
    params: C3dLevelsetAdvectionParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-levelset-advection",
        params.get("levelset_advection", None)
    ])
    return cargs


def c3d_log(
    log: str,
) -> C3dLogParamsDictTagged:
    """
    Build parameters.
    
    Args:
        log: -log, -ln: Voxelwise natural logarithm\
            \
            Syntax: `-log`\
            \
            Computes natural logarithm of each voxel in the last image on the\
            stack.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "log",
        "log": log,
    }
    return params


def c3d_log_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLogParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("log", None) is None:
        raise StyxValidationError("`log` must not be None")
    if not isinstance(params["log"], str):
        raise StyxValidationError(f'`log` has the wrong type: Received `{type(params.get("log", None))}` expected `str`')


def c3d_log_cargs(
    params: C3dLogParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-ln",
        params.get("log", None)
    ])
    return cargs


def c3d_log10(
    log10: str,
) -> C3dLog10ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        log10: -log10: Voxelwise base 10 logarithm\
            \
            Syntax: `-log10`\
            \
            Computes base 10 logarithm of each voxel in the last image on the\
            stack.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "log10",
        "log10": log10,
    }
    return params


def c3d_log10_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dLog10ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("log10", None) is None:
        raise StyxValidationError("`log10` must not be None")
    if not isinstance(params["log10"], str):
        raise StyxValidationError(f'`log10` has the wrong type: Received `{type(params.get("log10", None))}` expected `str`')


def c3d_log10_cargs(
    params: C3dLog10ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-log10",
        params.get("log10", None)
    ])
    return cargs


def c3d_manual(
    manual: str,
) -> C3dManualParamsDictTagged:
    """
    Build parameters.
    
    Args:
        manual: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "manual",
        "manual": manual,
    }
    return params


def c3d_manual_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dManualParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("manual", None) is None:
        raise StyxValidationError("`manual` must not be None")
    if not isinstance(params["manual"], str):
        raise StyxValidationError(f'`manual` has the wrong type: Received `{type(params.get("manual", None))}` expected `str`')


def c3d_manual_cargs(
    params: C3dManualParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-manual",
        params.get("manual", None)
    ])
    return cargs


def c3d_match_bounding_box(
    match_bounding_box: str,
) -> C3dMatchBoundingBoxParamsDictTagged:
    """
    Build parameters.
    
    Args:
        match_bounding_box: -mbb, -match-bounding-box: Match bounding box of\
            one image to another\
            \
            Syntax: `-mbb`\
            \
            Given two images on the stack (reference and target), sets the\
            header of the target image so that the two images occupy the same\
            physical space. The direction cosines of the target image are set\
            to match the reference image. This command is related to\
            '-copy-transform' but supports images of different size.\
            \
            c3d reference.nii target.nii -mbb -o out.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "match_bounding_box",
        "match_bounding_box": match_bounding_box,
    }
    return params


def c3d_match_bounding_box_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMatchBoundingBoxParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("match_bounding_box", None) is None:
        raise StyxValidationError("`match_bounding_box` must not be None")
    if not isinstance(params["match_bounding_box"], str):
        raise StyxValidationError(f'`match_bounding_box` has the wrong type: Received `{type(params.get("match_bounding_box", None))}` expected `str`')


def c3d_match_bounding_box_cargs(
    params: C3dMatchBoundingBoxParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-match-bounding-box",
        params.get("match_bounding_box", None)
    ])
    return cargs


def c3d_maximum(
    maximum: str,
) -> C3dMaximumParamsDictTagged:
    """
    Build parameters.
    
    Args:
        maximum: -max: Voxel-wise maximum of two images\
            \
            Syntax: `-max`\
            \
            Computes the voxel-wise maximum of two images. Can be used with the\
            **-accum** command to compute maximum of all images.\
            \
            c3d i1.nii i2.nii -max -o max12.nii\
            c3d i1.nii i2.nii i3.nii i4.nii -accum -max -endaccum -o\
            max1234.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "maximum",
        "maximum": maximum,
    }
    return params


def c3d_maximum_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMaximumParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("maximum", None) is None:
        raise StyxValidationError("`maximum` must not be None")
    if not isinstance(params["maximum"], str):
        raise StyxValidationError(f'`maximum` has the wrong type: Received `{type(params.get("maximum", None))}` expected `str`')


def c3d_maximum_cargs(
    params: C3dMaximumParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-maximum",
        params.get("maximum", None)
    ])
    return cargs


def c3d_multicomponent_split(
    multicomponent_split: str,
) -> C3dMulticomponentSplitParamsDictTagged:
    """
    Build parameters.
    
    Args:
        multicomponent_split: -mcs, -multicomponent-split: Enable splitting of\
            multi-component images on read\
            \
            Syntax: `-mcs`\
            \
            Enable reading of multi-component images. By default, when a\
            multi-component image is encountered, the components are combined\
            into a single image. Setting the **-mcs** flag changes this\
            behavior, and each of the components is loaded sequentially. See\
            the section below on multi-component image support.\
            \
            $ c3d -mcs rgb.mha -foreach -probe 110x110x80mm -endfor\
            Interpolated image value at 110 110 80 is 1\
            Interpolated image value at 110 110 80 is 66\
            Interpolated image value at 110 110 80 is 29\
            \
            $ c3d rgb.mha -foreach -probe 110x110x80mm -endfor\
            Interpolated image value at 110 110 80 is 49.5198.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "multicomponent_split",
        "multicomponent_split": multicomponent_split,
    }
    return params


def c3d_multicomponent_split_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMulticomponentSplitParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("multicomponent_split", None) is None:
        raise StyxValidationError("`multicomponent_split` must not be None")
    if not isinstance(params["multicomponent_split"], str):
        raise StyxValidationError(f'`multicomponent_split` has the wrong type: Received `{type(params.get("multicomponent_split", None))}` expected `str`')


def c3d_multicomponent_split_cargs(
    params: C3dMulticomponentSplitParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-mcs",
        params.get("multicomponent_split", None)
    ])
    return cargs


def c3d_mean(
    mean: str,
) -> C3dMeanParamsDictTagged:
    """
    Build parameters.
    
    Args:
        mean: -mean: Mean of all images on the stack\
            \
            Syntax: `-mean `\
            \
            Computes the mean of all the images on the stack. All images on the\
            stack are replaced with the mean image.\
            \
            c3d image_*.nii -mean -o mean.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mean",
        "mean": mean,
    }
    return params


def c3d_mean_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMeanParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("mean", None) is None:
        raise StyxValidationError("`mean` must not be None")
    if not isinstance(params["mean"], str):
        raise StyxValidationError(f'`mean` has the wrong type: Received `{type(params.get("mean", None))}` expected `str`')


def c3d_mean_cargs(
    params: C3dMeanParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-mean",
        params.get("mean", None)
    ])
    return cargs


def c3d_median_filter(
    median_filter: str,
) -> C3dMedianFilterParamsDictTagged:
    """
    Build parameters.
    
    Args:
        median_filter: -median, -median-filter: Median filter\
            \
            Syntax: `-median <radius_vector>`\
            \
            Applies the median filter: the intensity of each voxel is replaced\
            by the median of the intensities in the neighborhood of size\
            specified by the radius parameter. For example, the following code\
            will apply the median filter with the 5x5x5 neighborhood.\
            \
            c3d in.nii -median 2x2x2 -o median.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "median_filter",
        "median_filter": median_filter,
    }
    return params


def c3d_median_filter_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMedianFilterParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("median_filter", None) is None:
        raise StyxValidationError("`median_filter` must not be None")
    if not isinstance(params["median_filter"], str):
        raise StyxValidationError(f'`median_filter` has the wrong type: Received `{type(params.get("median_filter", None))}` expected `str`')


def c3d_median_filter_cargs(
    params: C3dMedianFilterParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-median",
        params.get("median_filter", None)
    ])
    return cargs


def c3d_merge(
    merge: str,
) -> C3dMergeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        merge: -merge: Merge images from previous split command\
            \
            Syntax: `-merge`\
            \
            Works in conjunction with the **-split** command. Has similar\
            behavior to **-vote**, except that label values are carried from\
            the input to the **-split** command.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "merge",
        "merge": merge,
    }
    return params


def c3d_merge_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMergeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("merge", None) is None:
        raise StyxValidationError("`merge` must not be None")
    if not isinstance(params["merge"], str):
        raise StyxValidationError(f'`merge` has the wrong type: Received `{type(params.get("merge", None))}` expected `str`')


def c3d_merge_cargs(
    params: C3dMergeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-merge",
        params.get("merge", None)
    ])
    return cargs


def c3d_mean_filter(
    mean_filter: str,
) -> C3dMeanFilterParamsDictTagged:
    """
    Build parameters.
    
    Args:
        mean_filter: -mf, -mean-filter: Mean filter\
            \
            Syntax: `-mf <radius_vector>`\
            \
            Applies the mean filter: the intensity of each voxel is replaced by\
            the mean of the intensities in the neighborhood of size specified\
            by the radius parameter. For example, the following code will apply\
            the mean filter with the 5x5x5 neighborhood.\
            \
            c3d in.nii -mf 2x2x2 -o filtered.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mean_filter",
        "mean_filter": mean_filter,
    }
    return params


def c3d_mean_filter_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMeanFilterParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("mean_filter", None) is None:
        raise StyxValidationError("`mean_filter` must not be None")
    if not isinstance(params["mean_filter"], str):
        raise StyxValidationError(f'`mean_filter` has the wrong type: Received `{type(params.get("mean_filter", None))}` expected `str`')


def c3d_mean_filter_cargs(
    params: C3dMeanFilterParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-mf",
        params.get("mean_filter", None)
    ])
    return cargs


def c3d_mutual_info(
    mutual_info: str,
) -> C3dMutualInfoParamsDictTagged:
    """
    Build parameters.
    
    Args:
        mutual_info: -min: Voxel-wise minimum of two images\
            \
            Syntax: `-min`\
            \
            Computes the voxel-wise minimum of two images. Can be used with the\
            **-accum** command to compute minimum of all images.\
            \
            c3d i1.nii i2.nii -min -o min12.nii\
            c3d i1.nii i2.nii i3.nii i4.nii -accum -min -endaccum -o\
            min1234.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mutual_info",
        "mutual_info": mutual_info,
    }
    return params


def c3d_mutual_info_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMutualInfoParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("mutual_info", None) is None:
        raise StyxValidationError("`mutual_info` must not be None")
    if not isinstance(params["mutual_info"], str):
        raise StyxValidationError(f'`mutual_info` has the wrong type: Received `{type(params.get("mutual_info", None))}` expected `str`')


def c3d_mutual_info_cargs(
    params: C3dMutualInfoParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-mi",
        params.get("mutual_info", None)
    ])
    return cargs


def c3d_minimum(
    minimum: str,
) -> C3dMinimumParamsDictTagged:
    """
    Build parameters.
    
    Args:
        minimum: -min: Voxel-wise minimum of two images\
            \
            Syntax: `-min`\
            \
            Computes the voxel-wise minimum of two images. Can be used with the\
            **-accum** command to compute minimum of all images.\
            \
            c3d i1.nii i2.nii -min -o min12.nii\
            c3d i1.nii i2.nii i3.nii i4.nii -accum -min -endaccum -o\
            min1234.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "minimum",
        "minimum": minimum,
    }
    return params


def c3d_minimum_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMinimumParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("minimum", None) is None:
        raise StyxValidationError("`minimum` must not be None")
    if not isinstance(params["minimum"], str):
        raise StyxValidationError(f'`minimum` has the wrong type: Received `{type(params.get("minimum", None))}` expected `str`')


def c3d_minimum_cargs(
    params: C3dMinimumParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-minimum",
        params.get("minimum", None)
    ])
    return cargs


def c3d_mixture_model(
    mixture_model: str,
) -> C3dMixtureModelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        mixture_model: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mixture_model",
        "mixture_model": mixture_model,
    }
    return params


def c3d_mixture_model_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMixtureModelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("mixture_model", None) is None:
        raise StyxValidationError("`mixture_model` must not be None")
    if not isinstance(params["mixture_model"], str):
        raise StyxValidationError(f'`mixture_model` has the wrong type: Received `{type(params.get("mixture_model", None))}` expected `str`')


def c3d_mixture_model_cargs(
    params: C3dMixtureModelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-mixture",
        params.get("mixture_model", None)
    ])
    return cargs


def c3d_moments(
    moments: str,
) -> C3dMomentsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        moments: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "moments",
        "moments": moments,
    }
    return params


def c3d_moments_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMomentsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("moments", None) is None:
        raise StyxValidationError("`moments` must not be None")
    if not isinstance(params["moments"], str):
        raise StyxValidationError(f'`moments` has the wrong type: Received `{type(params.get("moments", None))}` expected `str`')


def c3d_moments_cargs(
    params: C3dMomentsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-moments",
        params.get("moments", None)
    ])
    return cargs


def c3d_mattes_mutual_info(
    mattes_mutual_info: str,
) -> C3dMattesMutualInfoParamsDictTagged:
    """
    Build parameters.
    
    Args:
        mattes_mutual_info: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mattes_mutual_info",
        "mattes_mutual_info": mattes_mutual_info,
    }
    return params


def c3d_mattes_mutual_info_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMattesMutualInfoParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("mattes_mutual_info", None) is None:
        raise StyxValidationError("`mattes_mutual_info` must not be None")
    if not isinstance(params["mattes_mutual_info"], str):
        raise StyxValidationError(f'`mattes_mutual_info` has the wrong type: Received `{type(params.get("mattes_mutual_info", None))}` expected `str`')


def c3d_mattes_mutual_info_cargs(
    params: C3dMattesMutualInfoParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-mmi",
        params.get("mattes_mutual_info", None)
    ])
    return cargs


def c3d_mean_square(
    mean_square: str,
) -> C3dMeanSquareParamsDictTagged:
    """
    Build parameters.
    
    Args:
        mean_square: -msq, -mean-square: Compute mean square difference metric\
            \
            Syntax: `-msq [movtransform.mat] [reftransform.mat]`\
            \
            Compute the mean square difference metric between the last two\
            images on the stack. If an optional *movtransform.mat* file is\
            provided, the metric is computed by applying the transform to the\
            moving image. If, in addition to *movtransform.mat*, the optional\
            *reftransform.mat* file is also provided -- the moving transform is\
            applied to the moving image, the ref transform is applied to the\
            reference image, and the metric is computed in an image space that\
            is physically halfway between the reference and moving images. This\
            may be useful for unbiased metric computation if the two transforms\
            are inverse of each other as both images undergo similar amount of\
            interpolation. The definitions of reference and moving images and\
            the transform file format are similar to the **-reslice-matrix**\
            command.\
            \
            # Compute metric between ref.nii and mov.nii\
            c3d ref.nii mov.nii -msq\
            \
            # Compute metric between ref.nii and mov.nii after applying\
            transform to mov.nii\
            c3d ref.nii mov.nii -msq tmov.mat\
            \
            # Compute metric between ref.nii and mov.nii in a neutral space\
            after applying transforms to both\
            c3d ref.nii mov.nii -msq tmov.mat tref.mat.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mean_square",
        "mean_square": mean_square,
    }
    return params


def c3d_mean_square_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMeanSquareParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("mean_square", None) is None:
        raise StyxValidationError("`mean_square` must not be None")
    if not isinstance(params["mean_square"], str):
        raise StyxValidationError(f'`mean_square` has the wrong type: Received `{type(params.get("mean_square", None))}` expected `str`')


def c3d_mean_square_cargs(
    params: C3dMeanSquareParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-msq",
        params.get("mean_square", None)
    ])
    return cargs


def c3d_multiply(
    multiply: str,
) -> C3dMultiplyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        multiply: -multiply, -times: Multiply two images\
            \
            Syntax: `-multiply`\
            \
            Multiply two images voxel-by-voxel. The operation is applied to the\
            last two images on the stack.\
            \
            # Compute x = a * b\
            c3d a.img b.img -multiply -o x.img\
            \
            # Compute x = a * (b + c) using add and -multiply\
            c3d a.img b.img c.img -multiply -add -o x.img\
            \
            Combine with the **-dup** command to compute voxelwise square of\
            the image\
            \
            # Compute x = a^2\
            c3d a.img -dup -multiply -o x.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "multiply",
        "multiply": multiply,
    }
    return params


def c3d_multiply_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dMultiplyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("multiply", None) is None:
        raise StyxValidationError("`multiply` must not be None")
    if not isinstance(params["multiply"], str):
        raise StyxValidationError(f'`multiply` has the wrong type: Received `{type(params.get("multiply", None))}` expected `str`')


def c3d_multiply_cargs(
    params: C3dMultiplyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-multiply",
        params.get("multiply", None)
    ])
    return cargs


def c3d_normalized_cross_correlation(
    normalized_cross_correlation: str,
) -> C3dNormalizedCrossCorrelationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        normalized_cross_correlation: -ncc, -normalized-cross-correlation:\
            Compute normalized cross-correlation image\
            \
            Syntax: `-ncc <radius_vector>`\
            \
            Computes normalized cross-correlation between two images that\
            occupy the same physical space. Each voxel in the resulting image\
            is the cross-correlation of patches of given radius surrounding the\
            voxel in the two input images. This is different from **-ncor**,\
            which computes a global cross-correlation metric value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "normalized_cross_correlation",
        "normalized_cross_correlation": normalized_cross_correlation,
    }
    return params


def c3d_normalized_cross_correlation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNormalizedCrossCorrelationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("normalized_cross_correlation", None) is None:
        raise StyxValidationError("`normalized_cross_correlation` must not be None")
    if not isinstance(params["normalized_cross_correlation"], str):
        raise StyxValidationError(f'`normalized_cross_correlation` has the wrong type: Received `{type(params.get("normalized_cross_correlation", None))}` expected `str`')


def c3d_normalized_cross_correlation_cargs(
    params: C3dNormalizedCrossCorrelationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-ncc",
        params.get("normalized_cross_correlation", None)
    ])
    return cargs


def c3d_normalized_correlation(
    normalized_correlation: str,
) -> C3dNormalizedCorrelationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        normalized_correlation: -ncor, -normalized-correlation: Compute\
            normalized correlation metric\
            \
            Syntax: `-ncor [movtransform.mat] [reftransform.mat]`\
            \
            : Compute the normalized correlation metric between the last two\
            images on the stack. See documentation for **-msq***.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "normalized_correlation",
        "normalized_correlation": normalized_correlation,
    }
    return params


def c3d_normalized_correlation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNormalizedCorrelationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("normalized_correlation", None) is None:
        raise StyxValidationError("`normalized_correlation` must not be None")
    if not isinstance(params["normalized_correlation"], str):
        raise StyxValidationError(f'`normalized_correlation` has the wrong type: Received `{type(params.get("normalized_correlation", None))}` expected `str`')


def c3d_normalized_correlation_cargs(
    params: C3dNormalizedCorrelationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-ncor",
        params.get("normalized_correlation", None)
    ])
    return cargs


def c3d_normalized_mutual_info(
    normalized_mutual_info: str,
) -> C3dNormalizedMutualInfoParamsDictTagged:
    """
    Build parameters.
    
    Args:
        normalized_mutual_info: -mmi, -mattes-mutual-info: Compute mutual\
            informaiton metric\
            \
            Syntax: `-nmi [movtransform.mat] [reftransform.mat]`\
            \
            Compute the Mattes mutual information metric between the last two\
            images on the stack. See documentation for **-msq**.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "normalized_mutual_info",
        "normalized_mutual_info": normalized_mutual_info,
    }
    return params


def c3d_normalized_mutual_info_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNormalizedMutualInfoParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("normalized_mutual_info", None) is None:
        raise StyxValidationError("`normalized_mutual_info` must not be None")
    if not isinstance(params["normalized_mutual_info"], str):
        raise StyxValidationError(f'`normalized_mutual_info` has the wrong type: Received `{type(params.get("normalized_mutual_info", None))}` expected `str`')


def c3d_normalized_mutual_info_cargs(
    params: C3dNormalizedMutualInfoParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-nmi",
        params.get("normalized_mutual_info", None)
    ])
    return cargs


def c3d_noise_gaussian(
    noise_gaussian: str,
) -> C3dNoiseGaussianParamsDictTagged:
    """
    Build parameters.
    
    Args:
        noise_gaussian: -noise-gaussian, -noise: Apply additive Gaussian noise\
            \
            Syntax: `-noise-gaussian <sigma>`\
            \
            Adds Gaussian noise to an image with zero mean and standard\
            deviation sigma. Please see [Noise simulation article][15] by G.\
            Lehmann for details.\
            \
            c3d image.nii -noise-gaussian 5 -o noisy.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "noise_gaussian",
        "noise_gaussian": noise_gaussian,
    }
    return params


def c3d_noise_gaussian_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoiseGaussianParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("noise_gaussian", None) is None:
        raise StyxValidationError("`noise_gaussian` must not be None")
    if not isinstance(params["noise_gaussian"], str):
        raise StyxValidationError(f'`noise_gaussian` has the wrong type: Received `{type(params.get("noise_gaussian", None))}` expected `str`')


def c3d_noise_gaussian_cargs(
    params: C3dNoiseGaussianParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-noise-gaussian",
        params.get("noise_gaussian", None)
    ])
    return cargs


def c3d_noise_poisson(
    noise_poisson: str,
) -> C3dNoisePoissonParamsDictTagged:
    """
    Build parameters.
    
    Args:
        noise_poisson: -noise-poisson: Apply Poisson noise\
            Syntax: `-noise-poisson <scale>`\
            \
            Applies Poisson (shot) noise to an image with given scale. Please\
            see [Noise simulation article][15] by G. Lehmann for details.\
            \
            c3d image.nii -noise-poisson 5 -o noisy.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "noise_poisson",
        "noise_poisson": noise_poisson,
    }
    return params


def c3d_noise_poisson_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoisePoissonParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("noise_poisson", None) is None:
        raise StyxValidationError("`noise_poisson` must not be None")
    if not isinstance(params["noise_poisson"], str):
        raise StyxValidationError(f'`noise_poisson` has the wrong type: Received `{type(params.get("noise_poisson", None))}` expected `str`')


def c3d_noise_poisson_cargs(
    params: C3dNoisePoissonParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-noise-poisson",
        params.get("noise_poisson", None)
    ])
    return cargs


def c3d_noise_speckle(
    noise_speckle: str,
) -> C3dNoiseSpeckleParamsDictTagged:
    """
    Build parameters.
    
    Args:
        noise_speckle: -noise-speckle: Apply Poisson noise\
            Syntax: `-noise-speckle <sigma>`\
            \
            Applies Speckle noise to an image with given standard deviation.\
            Please see [Noise simulation article][15] by G. Lehmann for\
            details.\
            \
            c3d image.nii -noise-speckle 5 -o noisy.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "noise_speckle",
        "noise_speckle": noise_speckle,
    }
    return params


def c3d_noise_speckle_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoiseSpeckleParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("noise_speckle", None) is None:
        raise StyxValidationError("`noise_speckle` must not be None")
    if not isinstance(params["noise_speckle"], str):
        raise StyxValidationError(f'`noise_speckle` has the wrong type: Received `{type(params.get("noise_speckle", None))}` expected `str`')


def c3d_noise_speckle_cargs(
    params: C3dNoiseSpeckleParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-noise-speckle",
        params.get("noise_speckle", None)
    ])
    return cargs


def c3d_noise_salt_pepper(
    noise_salt_pepper: str,
) -> C3dNoiseSaltPepperParamsDictTagged:
    """
    Build parameters.
    
    Args:
        noise_salt_pepper: -noise-salt-pepper: Apply salt and pepper noise\
            Syntax: `-noise-salt-pepper <probability>`\
            \
            Applies salt and pepper noise to an image with given probability.\
            Please see [Noise simulation article][15] by G. Lehmann for\
            details.\
            \
            c3d image.nii -noise-salt-pepper 0.1 -o noisy.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "noise_salt_pepper",
        "noise_salt_pepper": noise_salt_pepper,
    }
    return params


def c3d_noise_salt_pepper_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoiseSaltPepperParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("noise_salt_pepper", None) is None:
        raise StyxValidationError("`noise_salt_pepper` must not be None")
    if not isinstance(params["noise_salt_pepper"], str):
        raise StyxValidationError(f'`noise_salt_pepper` has the wrong type: Received `{type(params.get("noise_salt_pepper", None))}` expected `str`')


def c3d_noise_salt_pepper_cargs(
    params: C3dNoiseSaltPepperParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-noise-salt-pepper",
        params.get("noise_salt_pepper", None)
    ])
    return cargs


def c3d_no_multicomponent_split(
    no_multicomponent_split: str,
) -> C3dNoMulticomponentSplitParamsDictTagged:
    """
    Build parameters.
    
    Args:
        no_multicomponent_split: -nomcs, -no-multicomponent-split: Disable\
            splitting of multi-component images on read\
            \
            Syntax: `-nomcs`\
            \
            Used to reverse the effect of previous **-mcs** command.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "no_multicomponent_split",
        "no_multicomponent_split": no_multicomponent_split,
    }
    return params


def c3d_no_multicomponent_split_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoMulticomponentSplitParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("no_multicomponent_split", None) is None:
        raise StyxValidationError("`no_multicomponent_split` must not be None")
    if not isinstance(params["no_multicomponent_split"], str):
        raise StyxValidationError(f'`no_multicomponent_split` has the wrong type: Received `{type(params.get("no_multicomponent_split", None))}` expected `str`')


def c3d_no_multicomponent_split_cargs(
    params: C3dNoMulticomponentSplitParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-nomcs",
        params.get("no_multicomponent_split", None)
    ])
    return cargs


def c3d_normalize_local_window(
    normalize_local_window: str,
) -> C3dNormalizeLocalWindowParamsDictTagged:
    """
    Build parameters.
    
    Args:
        normalize_local_window: -nlw, -normalize-local-window: Standardize\
            image intensity using local neighborhood\
            \
            Syntax: `-nlw <radius>`\
            \
            This command takes as inputs an image and a mask image. At each\
            voxel, the mean of the local neighborhood is subtracted, and the\
            result is divided by the standard deviation of the neighborhood.\
            The mean and standard deviation are computed only over the masked\
            region. You might also want to multiply by the mask.\
            \
            c3d gray.nii.gz mask.nii.gz -nlw 10x10x10 -o residual.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "normalize_local_window",
        "normalize_local_window": normalize_local_window,
    }
    return params


def c3d_normalize_local_window_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNormalizeLocalWindowParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("normalize_local_window", None) is None:
        raise StyxValidationError("`normalize_local_window` must not be None")
    if not isinstance(params["normalize_local_window"], str):
        raise StyxValidationError(f'`normalize_local_window` has the wrong type: Received `{type(params.get("normalize_local_window", None))}` expected `str`')


def c3d_normalize_local_window_cargs(
    params: C3dNormalizeLocalWindowParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-nlw",
        params.get("normalize_local_window", None)
    ])
    return cargs


def c3d_normpdf(
    normpdf: str,
) -> C3dNormpdfParamsDictTagged:
    """
    Build parameters.
    
    Args:
        normpdf: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "normpdf",
        "normpdf": normpdf,
    }
    return params


def c3d_normpdf_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNormpdfParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("normpdf", None) is None:
        raise StyxValidationError("`normpdf` must not be None")
    if not isinstance(params["normpdf"], str):
        raise StyxValidationError(f'`normpdf` has the wrong type: Received `{type(params.get("normpdf", None))}` expected `str`')


def c3d_normpdf_cargs(
    params: C3dNormpdfParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-normpdf",
        params.get("normpdf", None)
    ])
    return cargs


def c3d_noround(
    noround: str,
) -> C3dNoroundParamsDictTagged:
    """
    Build parameters.
    
    Args:
        noround: -noround, -round: Floating point rounding behavior\
            \
            Syntax: `-noround` or `-round `\
            \
            By default, **convert3d** will round floating point values when\
            converting to an integer, short or byte image. This command\
            specifies that rounding should not be used. Rounding is used to\
            avoid numerical errors stemming from the internal floating point\
            representation.\
            \
            c3d image1.img -type short -noround image2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "noround",
        "noround": noround,
    }
    return params


def c3d_noround_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoroundParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("noround", None) is None:
        raise StyxValidationError("`noround` must not be None")
    if not isinstance(params["noround"], str):
        raise StyxValidationError(f'`noround` has the wrong type: Received `{type(params.get("noround", None))}` expected `str`')


def c3d_noround_cargs(
    params: C3dNoroundParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-noround",
        params.get("noround", None)
    ])
    return cargs


def c3d_nospm(
    nospm: str,
) -> C3dNospmParamsDictTagged:
    """
    Build parameters.
    
    Args:
        nospm: -spm, -nospm: SPM compatibility in Analyze output\
            \
            Syntax: `-spm` or `-nospm `\
            \
            These options specify whether use the SPM extension to the Analyze\
            (.hdr,.img) format. When this option is on, the origin field stored\
            by SPM in the Analyze header will be correctly interpreted. When\
            saving analyze files, the origin will be set correctly. The default\
            is equivalent to the **-nospm** option. Best to avoid this issue\
            altogether by using NIFTI and SPM5 or later.\
            \
            c3d -spm in.hdr out.img.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "nospm",
        "nospm": nospm,
    }
    return params


def c3d_nospm_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNospmParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("nospm", None) is None:
        raise StyxValidationError("`nospm` must not be None")
    if not isinstance(params["nospm"], str):
        raise StyxValidationError(f'`nospm` has the wrong type: Received `{type(params.get("nospm", None))}` expected `str`')


def c3d_nospm_cargs(
    params: C3dNospmParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-nospm",
        params.get("nospm", None)
    ])
    return cargs


class C3dOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `C3dOutputParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output: OutputPathType
    """The output"""


def c3d_output(
    output: str,
) -> C3dOutputParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output: -o: Output (write) last image on the stack to image file\
            \
            Syntax: `-o filename`\
            \
            Write image, overriding an existing image. Without the **-o**\
            option, **convert3d** will write an image only if it does not\
            exist. The **-o** options protects input images from being\
            accidentally deleted. Here we copy an image, changing format:\
            \
            c3d image1.mha -o image2.nii\
            \
            The **-o** option can also be used to save an intermediate image in\
            the stack:\
            \
            c3d image1.img -threshold 1 10 1 0 -o thresh.img -resample 50% -o\
            final.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "output",
        "output": output,
    }
    return params


def c3d_output_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOutputParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')


def c3d_output_cargs(
    params: C3dOutputParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-o",
        params.get("output", None)
    ])
    return cargs


def c3d_output_outputs(
    params: C3dOutputParamsDict,
    execution: Execution,
) -> C3dOutputOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = C3dOutputOutputs(
        root=execution.output_file("."),
        output=execution.output_file(params.get("output", None)),
    )
    return ret


def c3d_output_multicomponent(
    output_multicomponent: str,
) -> C3dOutputMulticomponentParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output_multicomponent: -omc, -output-multicomponent: Output multiple\
            images to single file\
            \
            Syntax: `-omc [number] filename`\
            \
            Write multiple images on the **Convert3d** stack as a single\
            multi-component image file. If the optional number *n* is\
            specified, only the last *n* images on the stack will be used. Not\
            all file formats support multi-component output. NIFTI is the\
            safest bet.\
            \
            c3d red.nii green.nii blue.nii -omc rgb.mha\
            \
            For 2D images, this command can be used to generate color PNG\
            files:\
            \
            c3d image.nii -slice z 50% -colormap jet -type uchar -omc\
            colorslice.png.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "output_multicomponent",
        "output_multicomponent": output_multicomponent,
    }
    return params


def c3d_output_multicomponent_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOutputMulticomponentParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output_multicomponent", None) is None:
        raise StyxValidationError("`output_multicomponent` must not be None")
    if not isinstance(params["output_multicomponent"], str):
        raise StyxValidationError(f'`output_multicomponent` has the wrong type: Received `{type(params.get("output_multicomponent", None))}` expected `str`')


def c3d_output_multicomponent_cargs(
    params: C3dOutputMulticomponentParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-omc",
        params.get("output_multicomponent", None)
    ])
    return cargs


def c3d_output_multiple_multicomponent(
    output_multiple_multicomponent: str,
) -> C3dOutputMultipleMulticomponentParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output_multiple_multicomponent: -oomc: Output multiple multi-component\
            images to multiple files\
            \
            Syntax: `-oomc n_comp image_list` or `-oomc n_comp image_spec`\
            \
            Write all images on the **convert3d** stack as multiple\
            multi-component image files. The command is a mixture of the\
            **-omc** and **-oo** commands. There must be a multiple of 'n_comp'\
            images on the stack. Every consecutive 'n_comp' images on the stack\
            will be written to a separate multi-component image.\
            \
            ### Commands: Stack Manipulation and Flow Control\
            \
            These commands are used to manipulate the **convert3d** stack. The\
            stack is a linear array of images. Every time an image is specified\
            on the command line, it is loaded and placed at the end of the\
            stack. Most operations take one image from the end of the stack,\
            apply some operation to it, and place the result on the end of the\
            stack. Certain commands like **-levelset** and **-reslice-matrix**\
            take two images from the end of the stack as the input and replace\
            them with a single output. Some other commands, like **-mean** and\
            **-vote** take all images on the stack and replace them with a\
            single output.\
            \
            Sometimes, for complex operations, it is useful to change the order\
            of the images on the stack, to duplicate images, or to execute the\
            same command multiple times. The stack manipulation and flow\
            control commands allow you to complete complex tasks without saving\
            intermediate images to the disk.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "output_multiple_multicomponent",
        "output_multiple_multicomponent": output_multiple_multicomponent,
    }
    return params


def c3d_output_multiple_multicomponent_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOutputMultipleMulticomponentParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output_multiple_multicomponent", None) is None:
        raise StyxValidationError("`output_multiple_multicomponent` must not be None")
    if not isinstance(params["output_multiple_multicomponent"], str):
        raise StyxValidationError(f'`output_multiple_multicomponent` has the wrong type: Received `{type(params.get("output_multiple_multicomponent", None))}` expected `str`')


def c3d_output_multiple_multicomponent_cargs(
    params: C3dOutputMultipleMulticomponentParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-oomc",
        params.get("output_multiple_multicomponent", None)
    ])
    return cargs


def c3d_orient(
    orient: str,
) -> C3dOrientParamsDictTagged:
    """
    Build parameters.
    
    Args:
        orient: -orient: Change image orientation\
            \
            Syntax: `-orient CODE`\
            \
            Set the orientation of the image using one of 48 canonical\
            orientations. The orientation describes the mapping from the voxel\
            coordinate system (i,j,k) to the physical coordinate system\
            (x,y,z). In the voxel coordinate system, i runs along columns of\
            voxels, j runs along rows of voxels, and k runs along slices of\
            voxels. It is assumed (by the NIFTI convention) that the axes of\
            the physical coordinate system run as follows: x from (L)eft to\
            (R)ight, y from (P)osterior to (A)nterior, z from (I)nferior to\
            (S)uperior.\
            \
            The CODE passed in is a three-letter code consisting of letters\
            RLAPSI. Each letter describes the anatomical direction\
            corresponding to the voxel coordinates (i,j,k). For example, code\
            RAI means that i runs from Right to Left, j from Anterior to\
            Posterior, and k from Inferior to Superior.\
            \
            c3d input.img -orient RAI -o output.img\
            c3d input.img -orient SAL -o output.img\
            \
            This command has the same behavior as the 'Reorient Image' menu\
            option in ITK-SNAP.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "orient",
        "orient": orient,
    }
    return params


def c3d_orient_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOrientParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("orient", None) is None:
        raise StyxValidationError("`orient` must not be None")
    if not isinstance(params["orient"], str):
        raise StyxValidationError(f'`orient` has the wrong type: Received `{type(params.get("orient", None))}` expected `str`')


def c3d_orient_cargs(
    params: C3dOrientParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-orient",
        params.get("orient", None)
    ])
    return cargs


def c3d_output_multiple(
    output_multiple: str,
) -> C3dOutputMultipleParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output_multiple: -oo: Output multiple images to multiple files\
            \
            Syntax: `-oo image_list` or `-oo image_spec`\
            \
            Write all images on the **convert3d** stack as multiple files.\
            There are two ways to use this command. The first is to supply a\
            list of file names, separated by spaces:\
            \
            c3d labelimage.nii -split -oo labelA.nii labelB.nii labelC.nii\
            \
            In the above example, the image at the end of the stack will be\
            saved as *labelC.nii*, the image next to the end of the stack will\
            be saved as *labelB.nii* and so on.\
            \
            The second way to use the **-oo** command is to supply a pattern\
            for the output filenames. In this case, all the images on the stack\
            will be written. The format for the pattern is the same as for the\
            [C++ printf command][8]. For example, the following command\
            \
            c3d labelimage.nii -split -oo label%02d.nii\
            \
            will generate images *label00.nii*, *label01.nii*, *label02.nii*\
            and so on. The image at the end of the stack will have the highest\
            number, and the image at the beginning of the stack will have\
            number 00.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "output_multiple",
        "output_multiple": output_multiple,
    }
    return params


def c3d_output_multiple_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOutputMultipleParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output_multiple", None) is None:
        raise StyxValidationError("`output_multiple` must not be None")
    if not isinstance(params["output_multiple"], str):
        raise StyxValidationError(f'`output_multiple` has the wrong type: Received `{type(params.get("output_multiple", None))}` expected `str`')


def c3d_output_multiple_cargs(
    params: C3dOutputMultipleParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-oo",
        params.get("output_multiple", None)
    ])
    return cargs


def c3d_orient_1(
    orient: str,
) -> C3dOrient1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        orient: -orient: Change image orientation\
            \
            Syntax: `-orient CODE`\
            \
            Set the orientation of the image using one of 48 canonical\
            orientations. The orientation describes the mapping from the voxel\
            coordinate system (i,j,k) to the physical coordinate system\
            (x,y,z). In the voxel coordinate system, i runs along columns of\
            voxels, j runs along rows of voxels, and k runs along slices of\
            voxels. It is assumed (by the NIFTI convention) that the axes of\
            the physical coordinate system run as follows: x from (L)eft to\
            (R)ight, y from (P)osterior to (A)nterior, z from (I)nferior to\
            (S)uperior.\
            \
            The CODE passed in is a three-letter code consisting of letters\
            RLAPSI. Each letter describes the anatomical direction\
            corresponding to the voxel coordinates (i,j,k). For example, code\
            RAI means that i runs from Right to Left, j from Anterior to\
            Posterior, and k from Inferior to Superior.\
            \
            c3d input.img -orient RAI -o output.img\
            c3d input.img -orient SAL -o output.img\
            \
            This command has the same behavior as the 'Reorient Image' menu\
            option in ITK-SNAP.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "orient_1",
        "orient": orient,
    }
    return params


def c3d_orient_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOrient1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("orient", None) is None:
        raise StyxValidationError("`orient` must not be None")
    if not isinstance(params["orient"], str):
        raise StyxValidationError(f'`orient` has the wrong type: Received `{type(params.get("orient", None))}` expected `str`')


def c3d_orient_1_cargs(
    params: C3dOrient1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-orient",
        params.get("orient", None)
    ])
    return cargs


def c3d_origin(
    origin: str,
) -> C3dOriginParamsDictTagged:
    """
    Build parameters.
    
    Args:
        origin: -origin: Set image origin\
            \
            Syntax: `-origin vector `\
            \
            Set the origin of the image. The origin is the world coordinate (in\
            NIfTI coordinate space) of the center of the voxel (0,0,0) in the\
            image. The origin should be specified in millimeters.\
            \
            c3d input.img -origin 100x100x100mm -o output.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "origin",
        "origin": origin,
    }
    return params


def c3d_origin_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOriginParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("origin", None) is None:
        raise StyxValidationError("`origin` must not be None")
    if not isinstance(params["origin"], str):
        raise StyxValidationError(f'`origin` has the wrong type: Received `{type(params.get("origin", None))}` expected `str`')


def c3d_origin_cargs(
    params: C3dOriginParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-origin",
        params.get("origin", None)
    ])
    return cargs


def c3d_origin_voxel(
    origin_voxel: str,
) -> C3dOriginVoxelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        origin_voxel: -origin-voxel: Assign image origin to a voxel\
            \
            Syntax: `-origin-voxel vector `\
            \
            Set the origin of the image by specifying the voxel coordinates of\
            the center of the patient (RAS) coordinate system. The vector\
            should be specified in voxel units.\
            \
            c3d input.img -origin-voxel 60x70x35 -o output.img\
            c3d input.img -origin-voxel 50% -o output.img # image centered\
            around origin.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "origin_voxel",
        "origin_voxel": origin_voxel,
    }
    return params


def c3d_origin_voxel_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOriginVoxelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("origin_voxel", None) is None:
        raise StyxValidationError("`origin_voxel` must not be None")
    if not isinstance(params["origin_voxel"], str):
        raise StyxValidationError(f'`origin_voxel` has the wrong type: Received `{type(params.get("origin_voxel", None))}` expected `str`')


def c3d_origin_voxel_cargs(
    params: C3dOriginVoxelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-origin-voxel",
        params.get("origin_voxel", None)
    ])
    return cargs


def c3d_origin_voxel_coord(
    origin_voxel_coord: str,
) -> C3dOriginVoxelCoordParamsDictTagged:
    """
    Build parameters.
    
    Args:
        origin_voxel_coord: -origin-voxel-coord: Set coordinate of specified\
            voxel\
            \
            Syntax: `-origin-voxel-coord: <index> <vector>`\
            \
            This command updates the origin of the image such that the specifed\
            voxel has the specified coordinate. For example, you can use the\
            command to set the world coordinate (in NIFTI coordinate space) of\
            the center voxel of the image, as follows:\
            \
            c3d input.nii -origin-voxel-coord: 50% 10x10x5mm -o output.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "origin_voxel_coord",
        "origin_voxel_coord": origin_voxel_coord,
    }
    return params


def c3d_origin_voxel_coord_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOriginVoxelCoordParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("origin_voxel_coord", None) is None:
        raise StyxValidationError("`origin_voxel_coord` must not be None")
    if not isinstance(params["origin_voxel_coord"], str):
        raise StyxValidationError(f'`origin_voxel_coord` has the wrong type: Received `{type(params.get("origin_voxel_coord", None))}` expected `str`')


def c3d_origin_voxel_coord_cargs(
    params: C3dOriginVoxelCoordParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-origin-voxel-coord",
        params.get("origin_voxel_coord", None)
    ])
    return cargs


def c3d_overlap(
    overlap: str,
) -> C3dOverlapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        overlap: -overlap: Compute relative overlap between binary images\
            \
            Syntax: `-overlap Z`\
            \
            Compute relative overlap between labels in the last two images on\
            the stack. Overlap is computed for a given label **Z**, i.e., the\
            number of voxels that are equal to **Z** in both images is computed\
            and divided by either the average number of voxels equal to **Z**\
            in both images (to get Dice coefficient) or by the size of the\
            region where at least one of the images is equal to **Z** (Jaccard\
            coefficient).\
            \
            The command below computes overlap for label 255.\
            \
            c3d -verbose seg1.img seg2.img -overlap 255\
            \
            The output of the command is in the following terse format, with\
            the last two values giving Dice and Jaccard coefficients,\
            respectively.\
            \
            OVL: 1, 2383, 2474, 1807, 0.744081, 0.592459\
            \
            Use the flag **-verbose** to get full information.\
            \
            Matching voxels in first image: 2383\
            Matching voxels in second image: 2474\
            Size of overlap region: 1807\
            Dice similarity coefficient: 0.744081\
            Intersection / ratio: 0.592459\
            \
            This command does not alter the stack.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "overlap",
        "overlap": overlap,
    }
    return params


def c3d_overlap_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOverlapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("overlap", None) is None:
        raise StyxValidationError("`overlap` must not be None")
    if not isinstance(params["overlap"], str):
        raise StyxValidationError(f'`overlap` has the wrong type: Received `{type(params.get("overlap", None))}` expected `str`')


def c3d_overlap_cargs(
    params: C3dOverlapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-overlap",
        params.get("overlap", None)
    ])
    return cargs


def c3d_overlay_label_image(
    overlay_label_image: str,
) -> C3dOverlayLabelImageParamsDictTagged:
    """
    Build parameters.
    
    Args:
        overlay_label_image: -oli, -overlay-label-image: Overlay segmentation\
            image on grayscale image\
            \
            Syntax: `-oli lookup_table_file opacity`\
            \
            This command takes a grayscale image and a label image (i.e. image\
            with a set of discrete values) and produces red, green and blue\
            components of a color image. The resulting color image is an\
            overlay of the labels over the grey image. The first parameter\
            (*lookup\\_table*) is a text file with entries in the format\
            \
            label_value red green blue alpha\
            \
            Alpha values must be between 0 and 1. Red, green and blue values\
            should be on the same order as the intensity of the grey image\
            (typically 0-255). The text file is compatible with ITK-SNAP and\
            can be generated using the ITK-SNAP `Segmentation->Save Label\
            Descriptions` command. The second parameter (*opacity*) is between\
            0 and 1 and sets the overall opacity of the overlay. The output of\
            this command is similar to the way ITK-SNAP presents segmentation\
            data on top of grayscale images.\
            \
            c3d gray.nii.gz -stretch 2% 98% 0 255 -clip 0 255 seg.nii.gz -oli\
            labels.txt 0.5 -omc rgb.nii.gz\
            \
            Note: this command does not interpolate between entries in the\
            lookup table. It should not be used for images with a continuous\
            intensity spectrum.\
            \
            Here is a more complex example, used to visualize a segmentation\
            result. We do a few things in this command: trim grayscale and\
            segmentation images to an ROI around the object of interest; map\
            intensity range of the grayscale image to 0-255; extract slices\
            through the middle of the cropped images; overlay segmentation on\
            the grayscale image; and save as a color PNG file.\
            \
            c3d seg.nii.gz -trim 20x20x0vox -as S gray.nii.gz -stretch 2% 98% 0\
            255 -clip 0 255 \\\\\
            -reslice-identity -push S -foreach -slice z 50% -flip xy -endfor\
            \\\\\
            -oli labels.txt 0.5 -type uchar -omc ovl.png.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "overlay_label_image",
        "overlay_label_image": overlay_label_image,
    }
    return params


def c3d_overlay_label_image_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dOverlayLabelImageParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("overlay_label_image", None) is None:
        raise StyxValidationError("`overlay_label_image` must not be None")
    if not isinstance(params["overlay_label_image"], str):
        raise StyxValidationError(f'`overlay_label_image` has the wrong type: Received `{type(params.get("overlay_label_image", None))}` expected `str`')


def c3d_overlay_label_image_cargs(
    params: C3dOverlayLabelImageParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-overlay-label-image",
        params.get("overlay_label_image", None)
    ])
    return cargs


def c3d_pad(
    pad: str,
) -> C3dPadParamsDictTagged:
    """
    Build parameters.
    
    Args:
        pad: -pad: Pad image with constant value\
            \
            Syntax: `-pad <padlower> <padupper> <value> `\
            \
            Pads the image by a given percentage or number of voxels. The\
            *padlower* dimension pads along the zero faces of the image, and\
            the *padupper* dimension pads along the upper faces of the image.\
            For example to add 1 voxel to the left side of an image, do\
            \
            c3d img1.nii -pad 1x0x0vox 0x0x0vox 0 -o padded.nii\
            \
            while\
            \
            c3d img1.nii -pad 2x2x4vox 0% 0 -o padded.nii\
            \
            adds two voxels padding to the left and posterior sides, and four\
            slices to the bottom of the image. Note that the first argument\
            changes the location of voxel (0,0,0) and thus the origin of the\
            output image will be changed to maintain anatomical alignment\
            between the padded and original images.\
            \
            Normally you will want to pad with zeros, but you can pad with any\
            constant value, eg :\
            \
            c3d img1.nii -pad 10% 10% 1 -o padded.nii\
            \
            Adds 10% to all sides of the image, and fills the new voxels with\
            the value 1.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "pad",
        "pad": pad,
    }
    return params


def c3d_pad_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPadParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("pad", None) is None:
        raise StyxValidationError("`pad` must not be None")
    if not isinstance(params["pad"], str):
        raise StyxValidationError(f'`pad` has the wrong type: Received `{type(params.get("pad", None))}` expected `str`')


def c3d_pad_cargs(
    params: C3dPadParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-pad",
        params.get("pad", None)
    ])
    return cargs


def c3d_pad_to(
    pad_to: str,
) -> C3dPadToParamsDictTagged:
    """
    Build parameters.
    
    Args:
        pad_to: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "pad_to",
        "pad_to": pad_to,
    }
    return params


def c3d_pad_to_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPadToParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("pad_to", None) is None:
        raise StyxValidationError("`pad_to` must not be None")
    if not isinstance(params["pad_to"], str):
        raise StyxValidationError(f'`pad_to` has the wrong type: Received `{type(params.get("pad_to", None))}` expected `str`')


def c3d_pad_to_cargs(
    params: C3dPadToParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-padto",
        params.get("pad_to", None)
    ])
    return cargs


def c3d_pca(
    pca: str,
) -> C3dPcaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        pca: -pca: Principal components analysis of foreground voxels\
            \
            Syntax: `-pca`\
            \
            Similar to the *-centroid* command, computes the centroid and\
            prinicipal components of the foregrond voxels in the image. For\
            example if the image is a binary image of an ellipsoid, this will\
            report the center and the principal axes of the ellipsoid, in\
            physical NIFTI coordinates.\
            \
            c3d binaryimage.img -pca // centroid of all non-0 voxels\
            c3d labelimage.img -thresh 5 5 1 0 -pca // centroid of all voxels\
            with label 5\
            c3d labelimage.img -split -foreach -pca -endfor // centroids of all\
            labels (including 0).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "pca",
        "pca": pca,
    }
    return params


def c3d_pca_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPcaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("pca", None) is None:
        raise StyxValidationError("`pca` must not be None")
    if not isinstance(params["pca"], str):
        raise StyxValidationError(f'`pca` has the wrong type: Received `{type(params.get("pca", None))}` expected `str`')


def c3d_pca_cargs(
    params: C3dPcaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-pca",
        params.get("pca", None)
    ])
    return cargs


def c3d_percent_intensity_mode(
    percent_intensity_mode: str,
) -> C3dPercentIntensityModeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        percent_intensity_mode: -pim, -percent-intensity-mode: Set behavior of\
            % specifier\
            \
            Syntax: `-pim Quantile | q | ForegroundQuantile | fq | Range | r`\
            \
            This options changes how the percent sign (%) is interpreted when\
            specifying intensity values. **Quantile (q)** means that `10%`\
            describes the 10th percentile of all intensity values in the image\
            (i.e., 10% of the voxels have lower intensity).\
            **ForegroundQuantile (fq)** is similar, but voxels with background\
            intensity (see **-background** option) are excluded from the\
            percentile computation. **Range (r)** changes the meaning of\
            percent sign from percentile to the range between the minimum and\
            maximum of the image, and `0.1%` becomes equal to MIN + 0.1 (MAX -\
            MIN). The default is **Quantile**.\
            \
            $ c3d comp01.png -verbose -pim Quantile -verbose -threshold 75% inf\
            1 0\
            Quantile 0.75 maps to 18\
            \
            $ c3d comp01.png -verbose -pim ForegroundQuantile -verbose\
            -threshold 75% inf 1 0\
            Foreground quantile 0.75 (over 37467 voxels) maps to 58\
            \
            $ c3d comp01.png -verbose -pim Range -verbose -threshold 75% inf 1\
            0\
            Intensity range spec 0.75 maps to 191.25.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "percent_intensity_mode",
        "percent_intensity_mode": percent_intensity_mode,
    }
    return params


def c3d_percent_intensity_mode_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPercentIntensityModeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("percent_intensity_mode", None) is None:
        raise StyxValidationError("`percent_intensity_mode` must not be None")
    if not isinstance(params["percent_intensity_mode"], str):
        raise StyxValidationError(f'`percent_intensity_mode` has the wrong type: Received `{type(params.get("percent_intensity_mode", None))}` expected `str`')


def c3d_percent_intensity_mode_cargs(
    params: C3dPercentIntensityModeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-percent-intensity-mode",
        params.get("percent_intensity_mode", None)
    ])
    return cargs


def c3d_pixel(
    pixel: str,
) -> C3dPixelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        pixel: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "pixel",
        "pixel": pixel,
    }
    return params


def c3d_pixel_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPixelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("pixel", None) is None:
        raise StyxValidationError("`pixel` must not be None")
    if not isinstance(params["pixel"], str):
        raise StyxValidationError(f'`pixel` has the wrong type: Received `{type(params.get("pixel", None))}` expected `str`')


def c3d_pixel_cargs(
    params: C3dPixelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-pixel",
        params.get("pixel", None)
    ])
    return cargs


def c3d_pop(
    pop_: str,
) -> C3dPopParamsDictTagged:
    """
    Build parameters.
    
    Args:
        pop_: -pop: Remove last image from the stack\
            \
            Syntax: `-pop`\
            \
            Removes the last image from the image stack. Images assigned a name\
            with the **-as** command will remain in memory.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "pop",
        "pop": pop_,
    }
    return params


def c3d_pop_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPopParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("pop", None) is None:
        raise StyxValidationError("`pop` must not be None")
    if not isinstance(params["pop"], str):
        raise StyxValidationError(f'`pop` has the wrong type: Received `{type(params.get("pop", None))}` expected `str`')


def c3d_pop_cargs(
    params: C3dPopParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-pop",
        params.get("pop", None)
    ])
    return cargs


def c3d_popas(
    popas: str,
) -> C3dPopasParamsDictTagged:
    """
    Build parameters.
    
    Args:
        popas: -popas: Remove last image from the stack and assign to variable\
            \
            Syntax: `-popas var`\
            \
            Removes the last image from the stack, but also assigns it the name\
            'var', keeping the image in memory. Same as calling **-as** *var*\
            followed by **-pop**.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "popas",
        "popas": popas,
    }
    return params


def c3d_popas_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPopasParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("popas", None) is None:
        raise StyxValidationError("`popas` must not be None")
    if not isinstance(params["popas"], str):
        raise StyxValidationError(f'`popas` has the wrong type: Received `{type(params.get("popas", None))}` expected `str`')


def c3d_popas_cargs(
    params: C3dPopasParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-popas",
        params.get("popas", None)
    ])
    return cargs


def c3d_probe(
    probe: str,
) -> C3dProbeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        probe: -probe: Report image intensity at a voxel\
            \
            Syntax: `-probe <point_spec>`\
            \
            Prints the value of the image at the position specified by the\
            parameter `point_spec`, which may be in physical units or voxel\
            units:\
            \
            c3d img1.img -probe 128x120x160vox\
            c3d img1.img -interpolation NearestNeighbor -probe 60x60x60mm\
            c3d img1.img -probe 50%.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "probe",
        "probe": probe,
    }
    return params


def c3d_probe_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dProbeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("probe", None) is None:
        raise StyxValidationError("`probe` must not be None")
    if not isinstance(params["probe"], str):
        raise StyxValidationError(f'`probe` has the wrong type: Received `{type(params.get("probe", None))}` expected `str`')


def c3d_probe_cargs(
    params: C3dProbeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-probe",
        params.get("probe", None)
    ])
    return cargs


def c3d_push(
    push: str,
) -> C3dPushParamsDictTagged:
    """
    Build parameters.
    
    Args:
        push: -push: Place variable at the end of the stack\
            \
            Syntax: `-push var`\
            \
            Places the image associated with variable name 'var' on end of the\
            image stack. Variable names are assigned using the **-as** command.\
            The **-as** and **-push** commands are useful when you need to use\
            a certain image more than once during a convert3d operation. For\
            example, if you want to compute the distance transform of a binary\
            image and mask it so that the values outside of the binary image\
            region have value 0, you would use the following command:\
            \
            c3d binary.img -as A -sdt -push A -times -o masked_distance.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "push",
        "push": push,
    }
    return params


def c3d_push_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dPushParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("push", None) is None:
        raise StyxValidationError("`push` must not be None")
    if not isinstance(params["push"], str):
        raise StyxValidationError(f'`push` has the wrong type: Received `{type(params.get("push", None))}` expected `str`')


def c3d_push_cargs(
    params: C3dPushParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-push",
        params.get("push", None)
    ])
    return cargs


def c3d_rank(
    rank: str,
) -> C3dRankParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rank: -rank: Voxelwise ranking of intensity values\
            \
            Syntax: `-rank `\
            \
            This command takes N images as the input (all the images on the\
            stack are used). It also generates N images as the output. For\
            voxel k in image j, it assigns it a label based on its rank among\
            the values of voxel k in all N images. If the voxel has highest\
            intensity in image j, then the j'th output will have value 1.\
            \
            c3d img1.img img2.img ... imgN.img -rank -oo rank%d.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rank",
        "rank": rank,
    }
    return params


def c3d_rank_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRankParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rank", None) is None:
        raise StyxValidationError("`rank` must not be None")
    if not isinstance(params["rank"], str):
        raise StyxValidationError(f'`rank` has the wrong type: Received `{type(params.get("rank", None))}` expected `str`')


def c3d_rank_cargs(
    params: C3dRankParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rank",
        params.get("rank", None)
    ])
    return cargs


def c3d_reciprocal(
    reciprocal: str,
) -> C3dReciprocalParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reciprocal: -reciprocal: Image voxelwise reciprocal\
            \
            Syntax: `-reciprocal `\
            \
            Computes the reciprocal of an image. For instance to compute B = 1\
            / A, use the command\
            \
            c3d A.img -reciprocal -o B.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "reciprocal",
        "reciprocal": reciprocal,
    }
    return params


def c3d_reciprocal_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dReciprocalParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("reciprocal", None) is None:
        raise StyxValidationError("`reciprocal` must not be None")
    if not isinstance(params["reciprocal"], str):
        raise StyxValidationError(f'`reciprocal` has the wrong type: Received `{type(params.get("reciprocal", None))}` expected `str`')


def c3d_reciprocal_cargs(
    params: C3dReciprocalParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-reciprocal",
        params.get("reciprocal", None)
    ])
    return cargs


def c3d_region(
    region: str,
) -> C3dRegionParamsDictTagged:
    """
    Build parameters.
    
    Args:
        region: -region: Extract region from image\
            \
            Syntax: `-region vOrigin vSize `\
            \
            Extract a rectangular region from the image. The first parameter is\
            the position of the corner of the region, and the second is the\
            size of the region.\
            \
            c3d img1.img -region 20x20x20vox 50x60x70vox -o img2.img\
            c3d img1.img -region 25% 50% -o img3.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "region",
        "region": region,
    }
    return params


def c3d_region_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRegionParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("region", None) is None:
        raise StyxValidationError("`region` must not be None")
    if not isinstance(params["region"], str):
        raise StyxValidationError(f'`region` has the wrong type: Received `{type(params.get("region", None))}` expected `str`')


def c3d_region_cargs(
    params: C3dRegionParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-region",
        params.get("region", None)
    ])
    return cargs


def c3d_reorder(
    reorder: str,
) -> C3dReorderParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reorder: -reorder: Rearrange images on the stack\
            \
            Syntax: `-reorder k` or `-reorder fraction`\
            \
            Rearranges images in the stack, such that images that are k\
            positions apart become next to each other on the stack. In other\
            words, if the original order of the images is 1, 2, ..., n, the new\
            order of the images becomes 1, 1+k, 1+2k, ..., 2, 2+k, 2+2k, ...,\
            k, 2k, ... n. Of course, n must be divisible by k. As an\
            alternative to specifying k, you can specify a floating point\
            number (i.e., **-reorder** 0.5), in which case k is obtained by\
            multiplying n by the floating point number and rounding to the\
            nearest integer.\
            \
            The following three commands are equivalent:\
            \
            c3d a1.nii a2.nii a3.nii a4.nii b1.nii b2.nii b3.nii b4.nii\
            -reorder 4 ...\
            c3d a1.nii a2.nii a3.nii a4.nii b1.nii b2.nii b3.nii b4.nii\
            -reorder 0.5 ...\
            c3d a1.nii b1.nii a2.nii b2.nii a3.nii b3.nii a4.nii b4.nii ...\
            \
            The **-reorder** command us useful when you specify two sets of\
            images using wildcards and then want to perform pairwise operations\
            on the images. For example\
            \
            c3d weight*.nii gray*.nii -reorder 0.5 -weighted-sum-voxelwise -o\
            wsum.nii\
            \
            is equivalent to the command\
            \
            c3d weight1.nii gray1.nii weight2.nii gray2.nii ...\
            -weighted-sum-voxelwise -o wsum.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "reorder",
        "reorder": reorder,
    }
    return params


def c3d_reorder_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dReorderParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("reorder", None) is None:
        raise StyxValidationError("`reorder` must not be None")
    if not isinstance(params["reorder"], str):
        raise StyxValidationError(f'`reorder` has the wrong type: Received `{type(params.get("reorder", None))}` expected `str`')


def c3d_reorder_cargs(
    params: C3dReorderParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-reorder",
        params.get("reorder", None)
    ])
    return cargs


def c3d_retain_labels(
    retain_labels: str,
) -> C3dRetainLabelsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        retain_labels: -retain-labels: Retain labels in a label image\
            \
            Syntax: `-retain-labels I1 I2 ... IN`\
            \
            Assuming that the input is a multi-label segmentation image, this\
            command keeps all labels specifed in the list and replaces the\
            remaining labels with the background value.\
            \
            c3d seg.nii -retain-labels 2 3 4 8 -o subseg.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "retain_labels",
        "retain_labels": retain_labels,
    }
    return params


def c3d_retain_labels_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRetainLabelsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("retain_labels", None) is None:
        raise StyxValidationError("`retain_labels` must not be None")
    if not isinstance(params["retain_labels"], str):
        raise StyxValidationError(f'`retain_labels` has the wrong type: Received `{type(params.get("retain_labels", None))}` expected `str`')


def c3d_retain_labels_cargs(
    params: C3dRetainLabelsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-retain-labels",
        params.get("retain_labels", None)
    ])
    return cargs


def c3d_rf_apply(
    rf_apply: str,
) -> C3dRfApplyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rf_apply: -rf-apply: Apply Random Forest classifier\
            \
            Syntax: `-rf-apply <classifier_file>`\
            \
            This command applies a classifier trained previously by\
            **-rf-train**. The stack must contain the same number of feature\
            images as when training. The images will be removed from the stack\
            and replaced with a set of K probability images, where K is the\
            number of classes during training. See examples under **-rf-train**\
            for usage.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rf_apply",
        "rf_apply": rf_apply,
    }
    return params


def c3d_rf_apply_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRfApplyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rf_apply", None) is None:
        raise StyxValidationError("`rf_apply` must not be None")
    if not isinstance(params["rf_apply"], str):
        raise StyxValidationError(f'`rf_apply` has the wrong type: Received `{type(params.get("rf_apply", None))}` expected `str`')


def c3d_rf_apply_cargs(
    params: C3dRfApplyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rf-apply",
        params.get("rf_apply", None)
    ])
    return cargs


def c3d_rf_train(
    rf_train: str,
) -> C3dRfTrainParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rf_train: -rf-train: Train Random Forest classifier\
            \
            Syntax: `-rf-train <classifier_file>`\
            \
            This command trains a classifier using an implementation of the\
            [Breyman et al. Random Forest Algorithm][Br2001], with\
            modifications proposed by [Criminisi and Shotton][Cr2004]. The\
            stack must contain one or more images of features (e.g., grayscale\
            images), followed by a multi-label image. The latter must have at\
            least two non-zero labels corresponding to different classes. The\
            classifier is trained on a voxel by voxel basis. All voxels with\
            label *L* are treated as the examples of class *L*. The classifier\
            is output to a binary file that can later be used by the\
            **-rf-apply** command. Multiple parameters can be specified with\
            the **-rf-param-xxx** options before calling **-rf-train**. The\
            stack is not modified by this command.\
            \
            # Training with two MRI modalities as features and default\
            parameters\
            c3d t1_mri.nii t2_mri.nii segmentation.nii -rf-train myforest1.rf\
            \
            # Training with patches as features (see docs for -rf-param-patch)\
            c3d ultrasound.nii seg.nii -rf-param-patch 2x2x2 -rf-train\
            myforest2.rf\
            \
            # Applying the classifier\
            c3d ultrasound.nii -rf-apply myforest2.rf -omc class_prob.nii.gz\
            \
            The commands are meant to replicate the "classification"\
            pre-segmentation mode in ITK-SNAP, i.e., extending a rough example\
            segmentation to the entire image domain. It is possible to also use\
            the commands to train classifiers jointly on data from multiple\
            subjects, each with its own segmentation, as long as the images\
            from the different subjects occupy the same image space and can be\
            stacked into a 4-dimensional image. For example:\
            \
            # Train using MRI and segmentations from N subjects\
            c4d mri_subj*.nii -tile w -popas ALLMRI \\\
            seg_subj*.nii -tile w -popas ALLSEG \\\
            -rf-param-patch 2x2x2x0 \\\
            -push ALLMRI -push ALLSEG -rf-train myforest.rf\
            \
            # Apply using single MRI\
            c4d mri_new.nii -rf-apply myforest.rf -omc classprob.nii\
            \
            [Br2001] Breiman, L. (2001). Random forests. Machine learning,\
            45(1), 5-32.\
            [Cr2004] Criminisi, A., & Shotton, J. (2013). Decision forests for\
            computer vision and medical image analysis. Springer Science &\
            Business Media.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rf_train",
        "rf_train": rf_train,
    }
    return params


def c3d_rf_train_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRfTrainParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rf_train", None) is None:
        raise StyxValidationError("`rf_train` must not be None")
    if not isinstance(params["rf_train"], str):
        raise StyxValidationError(f'`rf_train` has the wrong type: Received `{type(params.get("rf_train", None))}` expected `str`')


def c3d_rf_train_cargs(
    params: C3dRfTrainParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rf-train",
        params.get("rf_train", None)
    ])
    return cargs


def c3d_rf_param_patch(
    rf_param_patch: str,
) -> C3dRfParamPatchParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rf_param_patch: -rf-param-patch: Random Forest training patch size\
            \
            Syntax: `-rf-param-patch <size_spec>`\
            \
            Set the radius of the patch used to generate features for the RF\
            classifier. By default this is zero, which means that just the\
            intensity of each voxel is used as a feature. Setting this to\
            non-zero values will result in neighboring intensities also being\
            used as features, and can improve classification in presence of\
            complex image texture. The patch size in each dimension is (2 *\
            radius + 1). See **-rf-train** command for details.\
            \
            # Set patch size to 5x5x5\
            c3d ... -rf-param-patch 2x2x2 ... -rf-train myforest.rf.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rf_param_patch",
        "rf_param_patch": rf_param_patch,
    }
    return params


def c3d_rf_param_patch_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRfParamPatchParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rf_param_patch", None) is None:
        raise StyxValidationError("`rf_param_patch` must not be None")
    if not isinstance(params["rf_param_patch"], str):
        raise StyxValidationError(f'`rf_param_patch` has the wrong type: Received `{type(params.get("rf_param_patch", None))}` expected `str`')


def c3d_rf_param_patch_cargs(
    params: C3dRfParamPatchParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rf-param-patch",
        params.get("rf_param_patch", None)
    ])
    return cargs


def c3d_rf_param_usexyz(
    rf_param_usexyz: str,
) -> C3dRfParamUsexyzParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rf_param_usexyz: -rf-param-usexyz: Random Forest coordinate features\
            \
            Syntax: `-rf-param-usexyz`\
            \
            Use the coordinates of voxels as additional features. This allows\
            some geometric relations between different labels to be learned.\
            Equivalent to the corresponding ITK-SNAP option.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rf_param_usexyz",
        "rf_param_usexyz": rf_param_usexyz,
    }
    return params


def c3d_rf_param_usexyz_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRfParamUsexyzParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rf_param_usexyz", None) is None:
        raise StyxValidationError("`rf_param_usexyz` must not be None")
    if not isinstance(params["rf_param_usexyz"], str):
        raise StyxValidationError(f'`rf_param_usexyz` has the wrong type: Received `{type(params.get("rf_param_usexyz", None))}` expected `str`')


def c3d_rf_param_usexyz_cargs(
    params: C3dRfParamUsexyzParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rf-param-usexyz",
        params.get("rf_param_usexyz", None)
    ])
    return cargs


def c3d_rf_param_nousexyz(
    rf_param_nousexyz: str,
) -> C3dRfParamNousexyzParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rf_param_nousexyz: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rf_param_nousexyz",
        "rf_param_nousexyz": rf_param_nousexyz,
    }
    return params


def c3d_rf_param_nousexyz_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRfParamNousexyzParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rf_param_nousexyz", None) is None:
        raise StyxValidationError("`rf_param_nousexyz` must not be None")
    if not isinstance(params["rf_param_nousexyz"], str):
        raise StyxValidationError(f'`rf_param_nousexyz` has the wrong type: Received `{type(params.get("rf_param_nousexyz", None))}` expected `str`')


def c3d_rf_param_nousexyz_cargs(
    params: C3dRfParamNousexyzParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rf-param-nousexyz",
        params.get("rf_param_nousexyz", None)
    ])
    return cargs


def c3d_rf_param_ntrees(
    rf_param_ntrees: str,
) -> C3dRfParamNtreesParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rf_param_ntrees: -rf-param-ntrees: Random Forest forest size\
            \
            Syntax: `-rf-param-ntrees <integer>`\
            \
            Sets the number of trees in the forest. Default value is 50. Larger\
            forests are more robust but more time to train and apply.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rf_param_ntrees",
        "rf_param_ntrees": rf_param_ntrees,
    }
    return params


def c3d_rf_param_ntrees_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRfParamNtreesParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rf_param_ntrees", None) is None:
        raise StyxValidationError("`rf_param_ntrees` must not be None")
    if not isinstance(params["rf_param_ntrees"], str):
        raise StyxValidationError(f'`rf_param_ntrees` has the wrong type: Received `{type(params.get("rf_param_ntrees", None))}` expected `str`')


def c3d_rf_param_ntrees_cargs(
    params: C3dRfParamNtreesParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rf-param-ntrees",
        params.get("rf_param_ntrees", None)
    ])
    return cargs


def c3d_rf_param_treedepth(
    rf_param_treedepth: str,
) -> C3dRfParamTreedepthParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rf_param_treedepth: -rf-param-treedepth: Random Forest tree depth\
            \
            Syntax: `-rf-param-treedepth <integer>`\
            \
            Sets the depth of the trees in the classifier. Default value is 30.\
            Deeper trees can learn on more complex data but require more time.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rf_param_treedepth",
        "rf_param_treedepth": rf_param_treedepth,
    }
    return params


def c3d_rf_param_treedepth_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRfParamTreedepthParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rf_param_treedepth", None) is None:
        raise StyxValidationError("`rf_param_treedepth` must not be None")
    if not isinstance(params["rf_param_treedepth"], str):
        raise StyxValidationError(f'`rf_param_treedepth` has the wrong type: Received `{type(params.get("rf_param_treedepth", None))}` expected `str`')


def c3d_rf_param_treedepth_cargs(
    params: C3dRfParamTreedepthParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rf-param-treedepth",
        params.get("rf_param_treedepth", None)
    ])
    return cargs


def c3d_set_sform(
    set_sform: str,
) -> C3dSetSformParamsDictTagged:
    """
    Build parameters.
    
    Args:
        set_sform: -set-sform: Set the transform to physical space\
            \
            Syntax: `-set-sform <sform.mat> `\
            \
            Sets the Nifti sform of the last image on the stack to the 4x4\
            matrix provided.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "set_sform",
        "set_sform": set_sform,
    }
    return params


def c3d_set_sform_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSetSformParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("set_sform", None) is None:
        raise StyxValidationError("`set_sform` must not be None")
    if not isinstance(params["set_sform"], str):
        raise StyxValidationError(f'`set_sform` has the wrong type: Received `{type(params.get("set_sform", None))}` expected `str`')


def c3d_set_sform_cargs(
    params: C3dSetSformParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-set-sform",
        params.get("set_sform", None)
    ])
    return cargs


def c3d_replace(
    replace: str,
) -> C3dReplaceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        replace: -replace: Replace intensities in image\
            \
            Syntax: `-replace I1 J1 I2 J2 ... `\
            \
            Replace intensity I1 by J1, I2 by J2 and so on. Allowed values of\
            intensity include **nan**, **inf** and **-inf**.\
            \
            c3d img1.img -replace 1 128 nan 0.0 -o img2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "replace",
        "replace": replace,
    }
    return params


def c3d_replace_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dReplaceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("replace", None) is None:
        raise StyxValidationError("`replace` must not be None")
    if not isinstance(params["replace"], str):
        raise StyxValidationError(f'`replace` has the wrong type: Received `{type(params.get("replace", None))}` expected `str`')


def c3d_replace_cargs(
    params: C3dReplaceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-replace",
        params.get("replace", None)
    ])
    return cargs


def c3d_resample(
    resample: str,
) -> C3dResampleParamsDictTagged:
    """
    Build parameters.
    
    Args:
        resample: -resample: Resample image to new dimensions\
            \
            Syntax: `-resample <dimensions> `\
            \
            Resamples the image, keeping the bounding box the same, but\
            changing the number of voxels in the image. The dimensions can be\
            specified as a percentage, for example to double the number of\
            voxels in each direction. The **-interpolation** flag affects how\
            sampling is performed.\
            \
            c3d img1.img -resample 123x142x200 -o img2.img\
            c3d img1.img -resample 200% -o img2.img\
            c3d img1.img -resample 100x100x200% -o img2.img\
            c3d img1.img -background 4.0 -interpolation Cubic -resample\
            123x142x200 -o img2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "resample",
        "resample": resample,
    }
    return params


def c3d_resample_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dResampleParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("resample", None) is None:
        raise StyxValidationError("`resample` must not be None")
    if not isinstance(params["resample"], str):
        raise StyxValidationError(f'`resample` has the wrong type: Received `{type(params.get("resample", None))}` expected `str`')


def c3d_resample_cargs(
    params: C3dResampleParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-resample",
        params.get("resample", None)
    ])
    return cargs


def c3d_resample_iso(
    resample_iso: str,
) -> C3dResampleIsoParamsDictTagged:
    """
    Build parameters.
    
    Args:
        resample_iso: -resample-iso: Resample image to (approximately)\
            isotropic resolution\
            \
            Syntax: `-resample-iso <min|max>`\
            \
            Resamples the image to have approximately isotropic resolution,\
            either based on the smallest voxel dimension ('min' mode) or\
            largest voxel dimension ('max' mode). This command calls\
            **-resample** with appropriately calculated new image dimensions.\
            The bounding box of the image in physical space is preserved.\
            Therefore, since the image dimensions must be integer, the actual\
            voxel dimensions after resampling may not be precisely isotropic.\
            \
            c3d img1.img -resample-iso min -o img2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "resample_iso",
        "resample_iso": resample_iso,
    }
    return params


def c3d_resample_iso_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dResampleIsoParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("resample_iso", None) is None:
        raise StyxValidationError("`resample_iso` must not be None")
    if not isinstance(params["resample_iso"], str):
        raise StyxValidationError(f'`resample_iso` has the wrong type: Received `{type(params.get("resample_iso", None))}` expected `str`')


def c3d_resample_iso_cargs(
    params: C3dResampleIsoParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-resample-iso",
        params.get("resample_iso", None)
    ])
    return cargs


def c3d_resample_mm(
    resample_mm: str,
) -> C3dResampleMmParamsDictTagged:
    """
    Build parameters.
    
    Args:
        resample_mm: -resample-mm: Resample image to new resolution\
            \
            Syntax: `-resample-mm <voxel_size> `\
            \
            Resamples the image as in **-resample**, but the user specifies the\
            new voxel size rather than dimensions. This may not be precise, so\
            the bounding box of the image may change. A warning will be\
            generated in that case.\
            \
            c3d img1.img -resample-mm 1.0x1.5x1.5mm -o img2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "resample_mm",
        "resample_mm": resample_mm,
    }
    return params


def c3d_resample_mm_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dResampleMmParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("resample_mm", None) is None:
        raise StyxValidationError("`resample_mm` must not be None")
    if not isinstance(params["resample_mm"], str):
        raise StyxValidationError(f'`resample_mm` has the wrong type: Received `{type(params.get("resample_mm", None))}` expected `str`')


def c3d_resample_mm_cargs(
    params: C3dResampleMmParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-resample-mm",
        params.get("resample_mm", None)
    ])
    return cargs


def c3d_reslice_itk(
    reslice_itk: str,
) -> C3dResliceItkParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reslice_itk: -reslice-itk: Resample image using affine transform\
            \
            Syntax: `-reslice-itk <transform_file> `\
            \
            Applies affine (or other) transform in ITK (ANTs) format to an\
            image. See notes to **-reslice-matrix** for usage.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "reslice_itk",
        "reslice_itk": reslice_itk,
    }
    return params


def c3d_reslice_itk_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dResliceItkParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("reslice_itk", None) is None:
        raise StyxValidationError("`reslice_itk` must not be None")
    if not isinstance(params["reslice_itk"], str):
        raise StyxValidationError(f'`reslice_itk` has the wrong type: Received `{type(params.get("reslice_itk", None))}` expected `str`')


def c3d_reslice_itk_cargs(
    params: C3dResliceItkParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-reslice-itk",
        params.get("reslice_itk", None)
    ])
    return cargs


def c3d_reslice_matrix(
    reslice_matrix: str,
) -> C3dResliceMatrixParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reslice_matrix: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "reslice_matrix",
        "reslice_matrix": reslice_matrix,
    }
    return params


def c3d_reslice_matrix_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dResliceMatrixParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("reslice_matrix", None) is None:
        raise StyxValidationError("`reslice_matrix` must not be None")
    if not isinstance(params["reslice_matrix"], str):
        raise StyxValidationError(f'`reslice_matrix` has the wrong type: Received `{type(params.get("reslice_matrix", None))}` expected `str`')


def c3d_reslice_matrix_cargs(
    params: C3dResliceMatrixParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-reslice-matrix",
        params.get("reslice_matrix", None)
    ])
    return cargs


def c3d_reslice_identity(
    reslice_identity: str,
) -> C3dResliceIdentityParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reslice_identity: -reslice-identity: Resample image using identity\
            transform\
            \
            Syntax: `-reslice-identity `\
            \
            Applies the **-reslice-matrix** command with the identity\
            transform. This is useful when you have two scans of the same\
            subject with different coordinate transformations to patient space\
            and you want to resample one scan in the space of another scan. For\
            example, if you have T1 and T2 images in different coordinate\
            frames, and want to reslice the T2 image into the space of the T1\
            \
            c3d t1.nii t2.nii -reslice-identity -o t2_in_t1_space.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "reslice_identity",
        "reslice_identity": reslice_identity,
    }
    return params


def c3d_reslice_identity_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dResliceIdentityParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("reslice_identity", None) is None:
        raise StyxValidationError("`reslice_identity` must not be None")
    if not isinstance(params["reslice_identity"], str):
        raise StyxValidationError(f'`reslice_identity` has the wrong type: Received `{type(params.get("reslice_identity", None))}` expected `str`')


def c3d_reslice_identity_cargs(
    params: C3dResliceIdentityParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-reslice-identity",
        params.get("reslice_identity", None)
    ])
    return cargs


def c3d_rgb2hsv(
    rgb2hsv: str,
) -> C3dRgb2hsvParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rgb2hsv: -rgb2hsv: Convert RGB image to HSV image\
            \
            Syntax `-rgb2hsv`\
            \
            Takes the last three images on the stack and treats them as red,\
            green, and blue channels. Outputs three images corresponding to\
            hue, saturation, value. To read color images you need the\
            ***-msc*** command.\
            \
            c3d -mcs color.png -rgb2hsv -omc hsv.png.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rgb2hsv",
        "rgb2hsv": rgb2hsv,
    }
    return params


def c3d_rgb2hsv_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRgb2hsvParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rgb2hsv", None) is None:
        raise StyxValidationError("`rgb2hsv` must not be None")
    if not isinstance(params["rgb2hsv"], str):
        raise StyxValidationError(f'`rgb2hsv` has the wrong type: Received `{type(params.get("rgb2hsv", None))}` expected `str`')


def c3d_rgb2hsv_cargs(
    params: C3dRgb2hsvParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rgb2hsv",
        params.get("rgb2hsv", None)
    ])
    return cargs


def c3d_rms(
    rms: str,
) -> C3dRmsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        rms: -rms: Voxelwise vector norm\
            \
            Syntax: `-rms`\
            \
            Computes RMS (root mean square) of all images on the stack. The\
            command takes the square of each image on the stack, adds all the\
            squared images and takes the square root of the result. This is\
            very useful for statistical operations. Images must have the same\
            size.\
            \
            c3d img1.img img2.img img3.img img4.img -rms -o rms.img\
            \
            The equivalent of this command is\
            \
            c3d img1.img img2.img img3.img img4.img -foreach -dup -times\
            -endfor \\\
            -accum -add -endaccum -sqrt -o rms.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "rms",
        "rms": rms,
    }
    return params


def c3d_rms_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRmsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("rms", None) is None:
        raise StyxValidationError("`rms` must not be None")
    if not isinstance(params["rms"], str):
        raise StyxValidationError(f'`rms` has the wrong type: Received `{type(params.get("rms", None))}` expected `str`')


def c3d_rms_cargs(
    params: C3dRmsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-rms",
        params.get("rms", None)
    ])
    return cargs


def c3d_round(
    round_: str,
) -> C3dRoundParamsDictTagged:
    """
    Build parameters.
    
    Args:
        round_: -noround, -round: Floating point rounding behavior\
            \
            Syntax: `-noround` or `-round `\
            \
            By default, **convert3d** will round floating point values when\
            converting to an integer, short or byte image. This command\
            specifies that rounding should not be used. Rounding is used to\
            avoid numerical errors stemming from the internal floating point\
            representation.\
            \
            c3d image1.img -type short -noround image2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "round",
        "round": round_,
    }
    return params


def c3d_round_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dRoundParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("round", None) is None:
        raise StyxValidationError("`round` must not be None")
    if not isinstance(params["round"], str):
        raise StyxValidationError(f'`round` has the wrong type: Received `{type(params.get("round", None))}` expected `str`')


def c3d_round_cargs(
    params: C3dRoundParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-round",
        params.get("round", None)
    ])
    return cargs


def c3d_scale(
    scale: str,
) -> C3dScaleParamsDictTagged:
    """
    Build parameters.
    
    Args:
        scale: -scale: Scale intensity by constant factor\
            \
            Syntax: `-scale <factor>`\
            \
            Multiplies the intensity of each voxel in the last image on the\
            stack by the given factor.\
            \
            c3d img1.img -scale 0.5 -o img2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "scale",
        "scale": scale,
    }
    return params


def c3d_scale_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dScaleParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("scale", None) is None:
        raise StyxValidationError("`scale` must not be None")
    if not isinstance(params["scale"], str):
        raise StyxValidationError(f'`scale` has the wrong type: Received `{type(params.get("scale", None))}` expected `str`')


def c3d_scale_cargs(
    params: C3dScaleParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-scale",
        params.get("scale", None)
    ])
    return cargs


def c3d_set_sform_1(
    set_sform: str,
) -> C3dSetSform1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        set_sform: -set-sform: Set the transform to physical space\
            \
            Syntax: `-set-sform <sform.mat> `\
            \
            Sets the Nifti sform of the last image on the stack to the 4x4\
            matrix provided.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "set_sform_1",
        "set_sform": set_sform,
    }
    return params


def c3d_set_sform_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSetSform1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("set_sform", None) is None:
        raise StyxValidationError("`set_sform` must not be None")
    if not isinstance(params["set_sform"], str):
        raise StyxValidationError(f'`set_sform` has the wrong type: Received `{type(params.get("set_sform", None))}` expected `str`')


def c3d_set_sform_1_cargs(
    params: C3dSetSform1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-set-sform",
        params.get("set_sform", None)
    ])
    return cargs


def c3d_sin(
    sin: str,
) -> C3dSinParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sin: -cos: Voxelwise cosine\
            \
            Syntax: `-sin`\
            \
            Replaces the last image on the stack with the cosine trigonometric\
            operation applied to all voxels. Input must be in radians.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sin",
        "sin": sin,
    }
    return params


def c3d_sin_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSinParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sin", None) is None:
        raise StyxValidationError("`sin` must not be None")
    if not isinstance(params["sin"], str):
        raise StyxValidationError(f'`sin` has the wrong type: Received `{type(params.get("sin", None))}` expected `str`')


def c3d_sin_cargs(
    params: C3dSinParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-sin",
        params.get("sin", None)
    ])
    return cargs


def c3d_slice(
    slice_: str,
) -> C3dSliceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        slice_: -slice: Extract slices from an image\
            \
            Syntax: `-slice axis position_spec`\
            \
            Extracts a slice along the specified axis (x,y or z). The position\
            specifier **position_spec** can be a single slice or a range of\
            slices. For a single slice, it can be specified as a number or a\
            percentage. Numbering is zero-based, i.e, the first slice is slice\
            0, the last slice is N-1, where N is the number of slices. For a\
            range, use MATLAB notation first:step:last. The slice is placed on\
            the stack as an image with size 1 in the last dimension. You can\
            save the slice as a 2D PNG image.\
            \
            c3d input.img -slice x 128 -o myslice.nii.gz\
            c3d input.img -slice y 50% myslice.nii.gz\
            c3d input.img -slice z 25% -type uchar -stretch 0 2000 0 255 -o\
            myslice.png\
            c3d input.img -slice z 0:-1 -oo slice%0d.nii.gz\
            c3d input.img -slice z 20%:10%:80% -oo slice%0d.nii.gz\
            \
            With the new command **c4d**, the **-slice** command can be used to\
            extract volumes from a 4D image. This can be useful to reformat a\
            4D NIFTI image as a 3D multi-component NIFTI image, using the\
            command\
            \
            c4d input4d.nii.gz -slice w 0:-1 -omc output3d_multicomp.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "slice",
        "slice": slice_,
    }
    return params


def c3d_slice_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSliceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("slice", None) is None:
        raise StyxValidationError("`slice` must not be None")
    if not isinstance(params["slice"], str):
        raise StyxValidationError(f'`slice` has the wrong type: Received `{type(params.get("slice", None))}` expected `str`')


def c3d_slice_cargs(
    params: C3dSliceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-slice",
        params.get("slice", None)
    ])
    return cargs


def c3d_slice_all(
    slice_all: str,
) -> C3dSliceAllParamsDictTagged:
    """
    Build parameters.
    
    Args:
        slice_all: -slice-all: Extract slices from all images on the stack\
            \
            Syntax `-slice-all axis position_spec`\
            \
            This command behaves identical to the **-slice** command, but all\
            images on the stack are sliced, and the slices are interleaved.\
            This is useful for slicing multi-component images. For example, if\
            you read a four-component image 'test4.nii.gz', you can extract and\
            save the slices as follows:\
            \
            c3d test4.nii.gz -slice-all 20%:10%:80% -oomc 4 slice4_%03d.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "slice_all",
        "slice_all": slice_all,
    }
    return params


def c3d_slice_all_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSliceAllParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("slice_all", None) is None:
        raise StyxValidationError("`slice_all` must not be None")
    if not isinstance(params["slice_all"], str):
        raise StyxValidationError(f'`slice_all` has the wrong type: Received `{type(params.get("slice_all", None))}` expected `str`')


def c3d_slice_all_cargs(
    params: C3dSliceAllParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-slice-all",
        params.get("slice_all", None)
    ])
    return cargs


def c3d_sharpen(
    sharpen: str,
) -> C3dSharpenParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sharpen: -sharpen: Sharpen edges in the image\
            \
            Syntax: `-sharpen`\
            \
            Applies the Laplacian sharpening filter from ITK, which accentuates\
            the edges in the image.\
            \
            c3d input.nii.gz -sharpen -o output.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sharpen",
        "sharpen": sharpen,
    }
    return params


def c3d_sharpen_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSharpenParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sharpen", None) is None:
        raise StyxValidationError("`sharpen` must not be None")
    if not isinstance(params["sharpen"], str):
        raise StyxValidationError(f'`sharpen` has the wrong type: Received `{type(params.get("sharpen", None))}` expected `str`')


def c3d_sharpen_cargs(
    params: C3dSharpenParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-sharpen",
        params.get("sharpen", None)
    ])
    return cargs


def c3d_shift(
    shift: str,
) -> C3dShiftParamsDictTagged:
    """
    Build parameters.
    
    Args:
        shift: -shift: Shift image intensity by constant\
            \
            Syntax: `-shift <constant>`\
            \
            Adds the given constant to every voxel.\
            \
            c3d img1.img -shift 100 -o img2.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "shift",
        "shift": shift,
    }
    return params


def c3d_shift_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dShiftParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("shift", None) is None:
        raise StyxValidationError("`shift` must not be None")
    if not isinstance(params["shift"], str):
        raise StyxValidationError(f'`shift` has the wrong type: Received `{type(params.get("shift", None))}` expected `str`')


def c3d_shift_cargs(
    params: C3dShiftParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-shift",
        params.get("shift", None)
    ])
    return cargs


def c3d_signed_distance_transform(
    signed_distance_transform: str,
) -> C3dSignedDistanceTransformParamsDictTagged:
    """
    Build parameters.
    
    Args:
        signed_distance_transform: -sdt, -signed-distance-transform: Signed\
            distance transform of a binary image\
            \
            Syntax: `-sdt`\
            \
            Computes the signed distance transform of a binary image. Voxels\
            where the binary image is non-zero will have negative values and\
            voxels where the binary image is zero will have negative values.\
            The magnitude of the value will be the approximate Euclidean\
            distance to the boundary of the object represented by the binary\
            image.\
            \
            c3d binary.img -sdt -o dist.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "signed_distance_transform",
        "signed_distance_transform": signed_distance_transform,
    }
    return params


def c3d_signed_distance_transform_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSignedDistanceTransformParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("signed_distance_transform", None) is None:
        raise StyxValidationError("`signed_distance_transform` must not be None")
    if not isinstance(params["signed_distance_transform"], str):
        raise StyxValidationError(f'`signed_distance_transform` has the wrong type: Received `{type(params.get("signed_distance_transform", None))}` expected `str`')


def c3d_signed_distance_transform_cargs(
    params: C3dSignedDistanceTransformParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-signed-distance-transform",
        params.get("signed_distance_transform", None)
    ])
    return cargs


def c3d_smooth(
    smooth: str,
) -> C3dSmoothParamsDictTagged:
    """
    Build parameters.
    
    Args:
        smooth: -smooth: Gaussian smoothing\
            \
            Syntax: `-smooth <sigma_vector> `\
            \
            Applies Gaussian smoothing to the image. The parameter vector\
            specifies the standard deviation of the Gaussian kernel. Also see\
            [Vector Format Specification][10] below.\
            \
            c3d img1.img -smooth 2x1x1vox -o out.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "smooth",
        "smooth": smooth,
    }
    return params


def c3d_smooth_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSmoothParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("smooth", None) is None:
        raise StyxValidationError("`smooth` must not be None")
    if not isinstance(params["smooth"], str):
        raise StyxValidationError(f'`smooth` has the wrong type: Received `{type(params.get("smooth", None))}` expected `str`')


def c3d_smooth_cargs(
    params: C3dSmoothParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-smooth",
        params.get("smooth", None)
    ])
    return cargs


def c3d_smooth_fast(
    smooth_fast: str,
) -> C3dSmoothFastParamsDictTagged:
    """
    Build parameters.
    
    Args:
        smooth_fast: -smooth-fast: Fast approximate Gaussian smoothing\
            \
            Syntax: `-smooth-fast <sigma_vector> `\
            \
            Applies Gaussian smoothing to the image using the fast [Deriche\
            recursive smoothing algorithm][15]. The parameter vector specifies\
            the standard deviation of the Gaussian kernel. Also see [Vector\
            Format Specification][10] below.\
            \
            c3d img1.img -smooth-fast 20x10x10vox -o out.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "smooth_fast",
        "smooth_fast": smooth_fast,
    }
    return params


def c3d_smooth_fast_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSmoothFastParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("smooth_fast", None) is None:
        raise StyxValidationError("`smooth_fast` must not be None")
    if not isinstance(params["smooth_fast"], str):
        raise StyxValidationError(f'`smooth_fast` has the wrong type: Received `{type(params.get("smooth_fast", None))}` expected `str`')


def c3d_smooth_fast_cargs(
    params: C3dSmoothFastParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-smooth-fast",
        params.get("smooth_fast", None)
    ])
    return cargs


def c3d_spacing(
    spacing: str,
) -> C3dSpacingParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spacing: -spacing: Set voxel spacing\
            \
            Syntax: `-spacing <vector> `\
            \
            Sets the voxel spacing of the image. This should always be a vector\
            with positive components. For example, to set the spacing of the\
            image to 1mm isotropic, use the command below. This command only\
            changes the header of the image, not its contents.\
            \
            c3d img.nii -spacing 1x1x1mm -o out.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "spacing",
        "spacing": spacing,
    }
    return params


def c3d_spacing_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSpacingParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spacing", None) is None:
        raise StyxValidationError("`spacing` must not be None")
    if not isinstance(params["spacing"], str):
        raise StyxValidationError(f'`spacing` has the wrong type: Received `{type(params.get("spacing", None))}` expected `str`')


def c3d_spacing_cargs(
    params: C3dSpacingParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-spacing",
        params.get("spacing", None)
    ])
    return cargs


def c3d_split(
    split: str,
) -> C3dSplitParamsDictTagged:
    """
    Build parameters.
    
    Args:
        split: -split: Split multi-label image into binary images\
            \
            Syntax: `-split`\
            \
            This command takes a multilabel image (one with a small number of\
            discrete intensity levels), and replaces it with a set of binary\
            images, one for each of the levels. The images can later be\
            recombined using the **-merge** command. The labels corresponding\
            to each binary image are remembered by **convert3d** so that when\
            **-merge** is called, the labels are faithfully reassigned. The\
            **-merge** command treats each input as a probability image, and\
            selects at each voxel the label that has highest probability. The\
            example below smooths each label independently, then recombines\
            using **-merge**\
            \
            c3d multilabel.nii -split -foreach -smooth 3mm -endfor -merge -o\
            ml_smooth.nii\
            \
            Also of note is that the **-split** command will disregard infinite\
            intensity values. So if you want to apply voting to a subset of the\
            labels, you can replace labels you do not care about with *inf*,\
            for example, using the **-thresh** command.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "split",
        "split": split,
    }
    return params


def c3d_split_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSplitParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("split", None) is None:
        raise StyxValidationError("`split` must not be None")
    if not isinstance(params["split"], str):
        raise StyxValidationError(f'`split` has the wrong type: Received `{type(params.get("split", None))}` expected `str`')


def c3d_split_cargs(
    params: C3dSplitParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-split",
        params.get("split", None)
    ])
    return cargs


def c3d_sqrt(
    sqrt: str,
) -> C3dSqrtParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sqrt: -sqrt: Take square root of image\
            \
            Syntax: `-sqrt `\
            \
            Computes square root of each voxel in the image.\
            \
            c3d input.img -sqrt -o output.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sqrt",
        "sqrt": sqrt,
    }
    return params


def c3d_sqrt_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSqrtParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sqrt", None) is None:
        raise StyxValidationError("`sqrt` must not be None")
    if not isinstance(params["sqrt"], str):
        raise StyxValidationError(f'`sqrt` has the wrong type: Received `{type(params.get("sqrt", None))}` expected `str`')


def c3d_sqrt_cargs(
    params: C3dSqrtParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-sqrt",
        params.get("sqrt", None)
    ])
    return cargs


def c3d_staple(
    staple: str,
) -> C3dStapleParamsDictTagged:
    """
    Build parameters.
    
    Args:
        staple: -staple: STAPLE algorithm to combine segmentations\
            \
            Syntax: `-staple <intensity_value> `\
            \
            Runs the ITK implementation of the STAPLE algorithm ([See\
            Paper][11]). STAPLE generates an estimate of the 'true'\
            segmentation of a structure given a set of segmentations by\
            different raters. This command treats all images on the stack as\
            inputs. Each image is considered to be a segmentation by a\
            different rater. The parameter *intensity_value* specifies the\
            label in the segmentation images corresponding to the structure of\
            interest (e.g., the segmentation image may have value 1\
            corresponding to the caudate and value 2 corresponding to the\
            hippocampus. To run STAPLE on the hippocampus, pass in 2 as the\
            *intensity_value*). The output of STAPLE is a real-valued image\
            with voxels between 0 and 1, representing the probability of each\
            voxel being in the 'true' segmentation. This image can be\
            thresholded to get a binary consensus segmentation. Additional\
            outputs (estimates of the sensitivity and specificity of each\
            rater) are printed out if the **-verbose** command is used before\
            the **-staple** command.\
            \
            c3d -verbose rater1.img rater2.img rater3.img -staple 1 -o\
            probmap.img\
            c3d -verbose rater*.img -staple 1 -threshold 0.5 inf 1 0 -o\
            bin_segm.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "staple",
        "staple": staple,
    }
    return params


def c3d_staple_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dStapleParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("staple", None) is None:
        raise StyxValidationError("`staple` must not be None")
    if not isinstance(params["staple"], str):
        raise StyxValidationError(f'`staple` has the wrong type: Received `{type(params.get("staple", None))}` expected `str`')


def c3d_staple_cargs(
    params: C3dStapleParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-staple",
        params.get("staple", None)
    ])
    return cargs


def c3d_structure_tensor_eigenvalues(
    structure_tensor_eigenvalues: str,
) -> C3dStructureTensorEigenvaluesParamsDictTagged:
    """
    Build parameters.
    
    Args:
        structure_tensor_eigenvalues: -steig, -structure-tensor-eigenvalues:\
            Compute eigenvalues of the structure tensor\
            \
            Syntax `-steig <scale> <radius>`\
            \
            Computes the Hessian matrix at every pixel of an image and the\
            eigenvalues of the Hessian. Images of the eigenvalues (sorted by\
            value) are placed on the stack. These images are useful as texture\
            features. See also the '''-steig''' command. The scale determines\
            the amount of Gaussian smoothing applied for computing the partial\
            derivatives in the Hessian, and is in physical (mm) units.\
            \
            c3d myimage.nii -hesseig 2.0 -oo eig%02d.nii.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "structure_tensor_eigenvalues",
        "structure_tensor_eigenvalues": structure_tensor_eigenvalues,
    }
    return params


def c3d_structure_tensor_eigenvalues_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dStructureTensorEigenvaluesParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("structure_tensor_eigenvalues", None) is None:
        raise StyxValidationError("`structure_tensor_eigenvalues` must not be None")
    if not isinstance(params["structure_tensor_eigenvalues"], str):
        raise StyxValidationError(f'`structure_tensor_eigenvalues` has the wrong type: Received `{type(params.get("structure_tensor_eigenvalues", None))}` expected `str`')


def c3d_structure_tensor_eigenvalues_cargs(
    params: C3dStructureTensorEigenvaluesParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-steig",
        params.get("structure_tensor_eigenvalues", None)
    ])
    return cargs


def c3d_spm(
    spm: str,
) -> C3dSpmParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spm: -spm, -nospm: SPM compatibility in Analyze output\
            \
            Syntax: `-spm` or `-nospm `\
            \
            These options specify whether use the SPM extension to the Analyze\
            (.hdr,.img) format. When this option is on, the origin field stored\
            by SPM in the Analyze header will be correctly interpreted. When\
            saving analyze files, the origin will be set correctly. The default\
            is equivalent to the **-nospm** option. Best to avoid this issue\
            altogether by using NIFTI and SPM5 or later.\
            \
            c3d -spm in.hdr out.img.gz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "spm",
        "spm": spm,
    }
    return params


def c3d_spm_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSpmParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spm", None) is None:
        raise StyxValidationError("`spm` must not be None")
    if not isinstance(params["spm"], str):
        raise StyxValidationError(f'`spm` has the wrong type: Received `{type(params.get("spm", None))}` expected `str`')


def c3d_spm_cargs(
    params: C3dSpmParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-spm",
        params.get("spm", None)
    ])
    return cargs


def c3d_subtract(
    subtract: str,
) -> C3dSubtractParamsDictTagged:
    """
    Build parameters.
    
    Args:
        subtract: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "subtract",
        "subtract": subtract,
    }
    return params


def c3d_subtract_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSubtractParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("subtract", None) is None:
        raise StyxValidationError("`subtract` must not be None")
    if not isinstance(params["subtract"], str):
        raise StyxValidationError(f'`subtract` has the wrong type: Received `{type(params.get("subtract", None))}` expected `str`')


def c3d_subtract_cargs(
    params: C3dSubtractParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-subtract",
        params.get("subtract", None)
    ])
    return cargs


def c3d_supervoxel(
    supervoxel: str,
) -> C3dSupervoxelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        supervoxel: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "supervoxel",
        "supervoxel": supervoxel,
    }
    return params


def c3d_supervoxel_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSupervoxelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("supervoxel", None) is None:
        raise StyxValidationError("`supervoxel` must not be None")
    if not isinstance(params["supervoxel"], str):
        raise StyxValidationError(f'`supervoxel` has the wrong type: Received `{type(params.get("supervoxel", None))}` expected `str`')


def c3d_supervoxel_cargs(
    params: C3dSupervoxelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-supervoxel",
        params.get("supervoxel", None)
    ])
    return cargs


def c3d_stretch(
    stretch: str,
) -> C3dStretchParamsDictTagged:
    """
    Build parameters.
    
    Args:
        stretch: -stretch: Stretch image intensities linearly\
            \
            Syntax: `-stretch <u1 u2 v1 v2> `\
            \
            Stretches the intensities in the image linearly, such that u1 maps\
            to v1 and u2 maps to v2. The linear transformation is applied to\
            all intensities in the image, whether inside the range or not. For\
            example, to map a floating point image with intensities in interval\
            (0,1) to the full range of an unsigned short image, use\
            \
            c3d input.img -stretch 0.0 1.0 0 65535 -type ushort -o output.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "stretch",
        "stretch": stretch,
    }
    return params


def c3d_stretch_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dStretchParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("stretch", None) is None:
        raise StyxValidationError("`stretch` must not be None")
    if not isinstance(params["stretch"], str):
        raise StyxValidationError(f'`stretch` has the wrong type: Received `{type(params.get("stretch", None))}` expected `str`')


def c3d_stretch_cargs(
    params: C3dStretchParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-stretch",
        params.get("stretch", None)
    ])
    return cargs


def c3d_swapdim(
    swapdim: str,
) -> C3dSwapdimParamsDictTagged:
    """
    Build parameters.
    
    Args:
        swapdim: -swapdim: Reorder the coordinate axes of an image\
            \
            Syntax `-swapdim <code>`\
            \
            This command reorders the image axes (columns, rows, slices) to\
            achieve a desired transformation between voxel space and physical\
            space. The image remains exactly the same in physical space, but\
            the encoding of the voxels in memory and on disk is changed to\
            obtain the desired transformation. The transformation is specified\
            as a three-letter 'RAI' code, as in the '''-orient''' command.\
            \
            c3d img.nii -swapdim ASL -info -o out.nii\
            \
            \
            ### Commands: Image Processing\
            \
            The following commands invoke an action that is applied to images.\
            Unary commands apply the action to the last image on the stack,\
            binary commands apply to the last two images and so on. Commands\
            are affected by options, which are listed separately.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "swapdim",
        "swapdim": swapdim,
    }
    return params


def c3d_swapdim_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dSwapdimParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("swapdim", None) is None:
        raise StyxValidationError("`swapdim` must not be None")
    if not isinstance(params["swapdim"], str):
        raise StyxValidationError(f'`swapdim` has the wrong type: Received `{type(params.get("swapdim", None))}` expected `str`')


def c3d_swapdim_cargs(
    params: C3dSwapdimParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-swapdim",
        params.get("swapdim", None)
    ])
    return cargs


def c3d_test_image(
    test_image: str,
) -> C3dTestImageParamsDictTagged:
    """
    Build parameters.
    
    Args:
        test_image: -test-image, -test-probe: Test condition\
            \
            Syntax: `-test-image [tolerance]` and `-test-probe <vector> <value>\
            [tolerance]`\
            \
            These advanced commands (with more to come in the future) are\
            primarily meant to allow testing of **c3d**. However, they can also\
            be used for flow control in shell scripts (e.g., **bash** shell).\
            The commands check a certain aspect of the **c3d** state and cause\
            the program to exit with either return code 0 if the test succeeded\
            or a non-zero return code if the test failed.\
            \
            **-test-image** tests if the last two images on the stack are\
            identical (both in terms of data and header). Returns 0 if the\
            images are identical. The optional tolerance parameter has default\
            value 1e-8.\
            \
            c3d input1.img input2.img -test-image\
            \
            **-test-probe** is similar to the **-probe** command. It tests if\
            the value of the last image on the stack at the position given by\
            **vector** is equal to the **test_value**. An optional tolerance\
            value may be specified, the default is 1e-8.\
            \
            c3d input1.img -test-probe 40x40x20vox 1.0 1e-6.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "test_image",
        "test_image": test_image,
    }
    return params


def c3d_test_image_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dTestImageParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("test_image", None) is None:
        raise StyxValidationError("`test_image` must not be None")
    if not isinstance(params["test_image"], str):
        raise StyxValidationError(f'`test_image` has the wrong type: Received `{type(params.get("test_image", None))}` expected `str`')


def c3d_test_image_cargs(
    params: C3dTestImageParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-test-image",
        params.get("test_image", None)
    ])
    return cargs


def c3d_test_probe(
    test_probe: str,
) -> C3dTestProbeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        test_probe: -test-image, -test-probe: Test condition\
            \
            Syntax: `-test-image [tolerance]` and `-test-probe <vector> <value>\
            [tolerance]`\
            \
            These advanced commands (with more to come in the future) are\
            primarily meant to allow testing of **c3d**. However, they can also\
            be used for flow control in shell scripts (e.g., **bash** shell).\
            The commands check a certain aspect of the **c3d** state and cause\
            the program to exit with either return code 0 if the test succeeded\
            or a non-zero return code if the test failed.\
            \
            **-test-image** tests if the last two images on the stack are\
            identical (both in terms of data and header). Returns 0 if the\
            images are identical. The optional tolerance parameter has default\
            value 1e-8.\
            \
            c3d input1.img input2.img -test-image\
            \
            **-test-probe** is similar to the **-probe** command. It tests if\
            the value of the last image on the stack at the position given by\
            **vector** is equal to the **test_value**. An optional tolerance\
            value may be specified, the default is 1e-8.\
            \
            c3d input1.img -test-probe 40x40x20vox 1.0 1e-6.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "test_probe",
        "test_probe": test_probe,
    }
    return params


def c3d_test_probe_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dTestProbeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("test_probe", None) is None:
        raise StyxValidationError("`test_probe` must not be None")
    if not isinstance(params["test_probe"], str):
        raise StyxValidationError(f'`test_probe` has the wrong type: Received `{type(params.get("test_probe", None))}` expected `str`')


def c3d_test_probe_cargs(
    params: C3dTestProbeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-test-probe",
        params.get("test_probe", None)
    ])
    return cargs


def c3d_threshold(
    threshold: str,
) -> C3dThresholdParamsDictTagged:
    """
    Build parameters.
    
    Args:
        threshold: -thresh, -threshold: Binary thresholding\
            \
            Syntax: `-thresh <u1 u2 vIn vOut> `\
            \
            Thresholds the image, setting voxels whose intensity is in the\
            range [u1,u2] to vIn and all other voxels to vOut. Values *u1* and\
            *u2* are intensity specifications (see below). This means that you\
            can supply values **inf** and **-inf** for u1 and u2 to construct a\
            one-sided threshold. You can also specify *u1* and *u2* as\
            percentiles.\
            c3d in.img -threshold -inf 128 1 0 -o out.img\
            c3d in.img -threshold 64 128 1 0 -o out.img\
            c3d in.img -threshold 20% 40% 1 0 -o out.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "threshold",
        "threshold": threshold,
    }
    return params


def c3d_threshold_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dThresholdParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("threshold", None) is None:
        raise StyxValidationError("`threshold` must not be None")
    if not isinstance(params["threshold"], str):
        raise StyxValidationError(f'`threshold` has the wrong type: Received `{type(params.get("threshold", None))}` expected `str`')


def c3d_threshold_cargs(
    params: C3dThresholdParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-threshold",
        params.get("threshold", None)
    ])
    return cargs


def c3d_tile(
    tile: str,
) -> C3dTileParamsDictTagged:
    """
    Build parameters.
    
    Args:
        tile: -tile: Tile and stack multiple images into one\
            \
            Syntax: `-tile <tile_spec>`\
            \
            Tiles multiple images into a single image -- including stacking\
            slices into a 3D volume. The command takes all images on the stack\
            and produces a single tiled image. The **tile_spec** parameter can\
            either specify a coordinate axis (x, y, or z) along which to tile\
            the images, or a layout vector (e.g., **4x4**) which specifies the\
            tiling along each coordinate. Passing 0 for the last value in the\
            layout vector determines the value based on the number of images\
            currently loaded. For example, to create a 3D volume from a set of\
            slices, we use\
            \
            c3d slices*.png -tile z -o volume.nii.gz\
            \
            And to arrange the same 2D slices into a 2D montage of 4 images per\
            row, we would use the **c2d** command as follows:\
            \
            c2d slices*.png -tile 4x0 -type uchar -o montage.png.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "tile",
        "tile": tile,
    }
    return params


def c3d_tile_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dTileParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("tile", None) is None:
        raise StyxValidationError("`tile` must not be None")
    if not isinstance(params["tile"], str):
        raise StyxValidationError(f'`tile` has the wrong type: Received `{type(params.get("tile", None))}` expected `str`')


def c3d_tile_cargs(
    params: C3dTileParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-tile",
        params.get("tile", None)
    ])
    return cargs


def c3d_trim(
    trim: str,
) -> C3dTrimParamsDictTagged:
    """
    Build parameters.
    
    Args:
        trim: -trim: Trim background region of image\
            \
            Syntax: `-trim <margin_vector>`\
            \
            Use this command to trim background in an image. When most of the\
            image is filled by background, this command will find the smallest\
            rectangular region that contains all of the non-background voxels\
            in the image. I will then expand this region by the margin of the\
            size specified, and return the resulting region as the new image.\
            For example, this command will trim an image, leaving a 5-voxel\
            margin of background values on all sides\
            \
            c3d in.img -trim 5vox -o out.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "trim",
        "trim": trim,
    }
    return params


def c3d_trim_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dTrimParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("trim", None) is None:
        raise StyxValidationError("`trim` must not be None")
    if not isinstance(params["trim"], str):
        raise StyxValidationError(f'`trim` has the wrong type: Received `{type(params.get("trim", None))}` expected `str`')


def c3d_trim_cargs(
    params: C3dTrimParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-trim",
        params.get("trim", None)
    ])
    return cargs


def c3d_trim_to_size(
    trim_to_size: str,
) -> C3dTrimToSizeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        trim_to_size: -trim-to-size: Trim image to given size\
            \
            Syntax: `-trim-to-size <size_vector>`\
            \
            Like **-trim**, this command trims the background in an image.\
            However, instead of **-trim**, you specify the target size of the\
            output region. The actual region may be smaller if the specified\
            region falls outside the boundaries of the input image. For\
            example, if you want a 64x64x128 image containing all the\
            foreground pixels in your image, call\
            \
            c3d in.img -trim-to-size 64x64x128vox -o out.img.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "trim_to_size",
        "trim_to_size": trim_to_size,
    }
    return params


def c3d_trim_to_size_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dTrimToSizeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("trim_to_size", None) is None:
        raise StyxValidationError("`trim_to_size` must not be None")
    if not isinstance(params["trim_to_size"], str):
        raise StyxValidationError(f'`trim_to_size` has the wrong type: Received `{type(params.get("trim_to_size", None))}` expected `str`')


def c3d_trim_to_size_cargs(
    params: C3dTrimToSizeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-trim-to-size",
        params.get("trim_to_size", None)
    ])
    return cargs


def c3d_type(
    type_: str,
) -> C3dTypeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        type_: -type: Specify pixel type for image output\
            \
            Syntax: `-type < char | uchar | short | ushort | int | uint | float\
            | double > `\
            \
            Specifies the pixel type for the output image. By default, images\
            are written in floating point (**float**) format. The type does not\
            affect how images are processed, only how they are saved.\
            \
            c3d image1.img -type short image2.img\
            \
            Some images require data in certain types. For example, to save PNG\
            images, uchar or ushort type must be specified.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "type",
        "type": type_,
    }
    return params


def c3d_type_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dTypeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("type", None) is None:
        raise StyxValidationError("`type` must not be None")
    if not isinstance(params["type"], str):
        raise StyxValidationError(f'`type` has the wrong type: Received `{type(params.get("type", None))}` expected `str`')


def c3d_type_cargs(
    params: C3dTypeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-type",
        params.get("type", None)
    ])
    return cargs


def c3d_verbose(
    verbose: str,
) -> C3dVerboseParamsDictTagged:
    """
    Build parameters.
    
    Args:
        verbose: -verbose: Enable verbose output of commands\
            \
            Syntax: `-verbose`\
            \
            Commands entered after the **-verbose** command will print\
            debugging information. This can be turned off with **-noverbose**.\
            \
            ### Parameter Specifications.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "verbose",
        "verbose": verbose,
    }
    return params


def c3d_verbose_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVerboseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("verbose", None) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], str):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", None))}` expected `str`')


def c3d_verbose_cargs(
    params: C3dVerboseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-verbose",
        params.get("verbose", None)
    ])
    return cargs


def c3d_noverbose(
    noverbose: str,
) -> C3dNoverboseParamsDictTagged:
    """
    Build parameters.
    
    Args:
        noverbose: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "noverbose",
        "noverbose": noverbose,
    }
    return params


def c3d_noverbose_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dNoverboseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("noverbose", None) is None:
        raise StyxValidationError("`noverbose` must not be None")
    if not isinstance(params["noverbose"], str):
        raise StyxValidationError(f'`noverbose` has the wrong type: Received `{type(params.get("noverbose", None))}` expected `str`')


def c3d_noverbose_cargs(
    params: C3dNoverboseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-noverbose",
        params.get("noverbose", None)
    ])
    return cargs


def c3d_version(
    version: str,
) -> C3dVersionParamsDictTagged:
    """
    Build parameters.
    
    Args:
        version: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "version",
        "version": version,
    }
    return params


def c3d_version_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVersionParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("version", None) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], str):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", None))}` expected `str`')


def c3d_version_cargs(
    params: C3dVersionParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-version",
        params.get("version", None)
    ])
    return cargs


def c3d_vote(
    vote: str,
) -> C3dVoteParamsDictTagged:
    """
    Build parameters.
    
    Args:
        vote: -vote: Vote among images on the stack\
            \
            Syntax: `-vote `\
            \
            This command takes all images on the stack as arguments and at each\
            voxel *(i,j,k)* returns the index of the image for which the image\
            value at *(i,j,k)* is the greatest. This is most useful when\
            combining probability maps into a single label image. If images\
            prob1.img, prob2.img, etc. give the probability of label 1, 2, etc.\
            over the image domain, the **-vote** command will return the most\
            probable label at each voxel.\
            \
            c3d prob1.img prob2.img prob3.img -vote -type uchar -o label.img\
            \
            The value assigned to each image is based on its position from the\
            bottom of the stack, with zero indicating bottom-most image. In the\
            example above, the output image has values 0 for voxels where\
            prob1.img is highest, 1 for prob2.img and 2 for prob3.img. Also see\
            the related commands **-split** and **-merge**.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "vote",
        "vote": vote,
    }
    return params


def c3d_vote_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVoteParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("vote", None) is None:
        raise StyxValidationError("`vote` must not be None")
    if not isinstance(params["vote"], str):
        raise StyxValidationError(f'`vote` has the wrong type: Received `{type(params.get("vote", None))}` expected `str`')


def c3d_vote_cargs(
    params: C3dVoteParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-vote",
        params.get("vote", None)
    ])
    return cargs


def c3d_vote_mrf(
    vote_mrf: str,
) -> C3dVoteMrfParamsDictTagged:
    """
    Build parameters.
    
    Args:
        vote_mrf: -vote-mrf: Vote with Markov Random Field regularlization\
            \
            Syntax: `-vote-mrf <mode> <lambda>`\
            \
            This command is similar to **-vote** but it performs\
            regularlization using the Markov Random Field (MRF). This form of\
            regularization penalizes the total surface area of the segments in\
            the output. It results in more contiguous segments.\
            \
            The command takes all the images on the stack and assumes that they\
            are likelihood images corresponding to labels 1, 2, ... N. This\
            means that voxel **x** in image **k** holds the probability that\
            voxel **x** has label **k**. Likelihood images must be between 0\
            and 1. Any values outside of the range are interpreted as the voxel\
            being excluded from the voting. These voxels will be assigned label\
            0 in the output.\
            \
            The problem is encoded in the form of energy minimization,\
            consisting of a data term and a regularization term. The data term\
            encodes the cost (penalty) associated with assigning the voxel\
            **x** the label **k**. The parameter **mode** describes how\
            likelihood images are mapped to the cost.\
            \
            * `VOTES_AGAINST` or `VA`. This mode is useful when the command is\
            being used to combine several multi-label segmentations into a\
            single one. Each likelihood image is assumed to be the proportion\
            of segmentations that assign label *k* to voxel *x*. The data term\
            equals to the error associated to assining the voxel *k* label *x*.\
            This error is calculated as the sum of the likelihoods for all\
            labels at *x* minus the likelihood for *k* at *x*. Note that the\
            likelihoods do not have to add up to one, which may be interpreted\
            as missing data for some voxels.\
            \
            * `LOG_LIKELIHOOD` or `LL`. The cost for label *k* at voxel *x* is\
            the logarithm of the k-th likelihood image at *x*. This will assign\
            infinite cost when the likelihood is zero.\
            \
            The regularlization term is encoded as **lambda** times the total\
            number of neighboring voxels inside the mask (non-excluded region\
            of the image) that have different labels.\
            \
            The optmization problem is solved using the Alpha-Expansion graph\
            cut algorithm. Users of this functionality should cite the\
            following papers.\
            \
            1. Yuri Boykov, Olga Veksler, Ramin Zabih, *Efficient Approximate\
            Energy Minimization via Graph Cuts*, IEEE transactions on PAMI,\
            vol. 20, no. 12, p. 1222-1239, 2001.\
            \
            2. Vladimir Kolmogorov and Ramin Zabih, *What Energy Functions can\
            be Minimized via Graph Cuts?*, IEEE transactions on PAMI, vol. 26,\
            no. 2, p. 147-159, 2004.\
            \
            3. Yuri Boykov and Vladimir Kolmogorov, *An Experimental Comparison\
            of Min-Cut/Max-Flow Algorithms for Energy Minimization in Vision*,\
            IEEE transactions on PAMI, vol. 26, no. 9, p. 1124-1137, 2004.\
            \
            As noted in the open source implementation of the graph cuts\
            algorithms distributed under the General Public License, "This\
            software can be used only for research purposes, you should cite\
            the aforementioned paper in any resulting publication. If you wish\
            to use this software (or the algorithms described in the\
            aforementioned paper) for commercial purposes, you should be aware\
            that there is a US patent: R. Zabih, Y. Boykov, O. Veksler, *System\
            and method for fast approximate energy minimization via graph\
            cuts*, United Stated Patent 6,744,923, June 1, 2004.\
            \
            The example below illustrates applying **-vote-mrf** with a\
            user-specified mask. Voxels outside of the mask are first remapped\
            to NaN (not a number) and thus excluded from the MRF optimization\
            and given 0 label.\
            \
            c3d lhood01.nii lhood02.nii lhood03.nii mask.nii -popas M \\\
            -foreach -push M -replace 0 NaN -times -endfor \\\
            -vote-mrf VA 0.2 -o result.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "vote_mrf",
        "vote_mrf": vote_mrf,
    }
    return params


def c3d_vote_mrf_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVoteMrfParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("vote_mrf", None) is None:
        raise StyxValidationError("`vote_mrf` must not be None")
    if not isinstance(params["vote_mrf"], str):
        raise StyxValidationError(f'`vote_mrf` has the wrong type: Received `{type(params.get("vote_mrf", None))}` expected `str`')


def c3d_vote_mrf_cargs(
    params: C3dVoteMrfParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-vote-mrf",
        params.get("vote_mrf", None)
    ])
    return cargs


def c3d_vote_label(
    vote_label: str,
) -> C3dVoteLabelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        vote_label: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "vote_label",
        "vote_label": vote_label,
    }
    return params


def c3d_vote_label_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVoteLabelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("vote_label", None) is None:
        raise StyxValidationError("`vote_label` must not be None")
    if not isinstance(params["vote_label"], str):
        raise StyxValidationError(f'`vote_label` has the wrong type: Received `{type(params.get("vote_label", None))}` expected `str`')


def c3d_vote_label_cargs(
    params: C3dVoteLabelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-vote-label",
        params.get("vote_label", None)
    ])
    return cargs


def c3d_voxel_sum(
    voxel_sum: str,
) -> C3dVoxelSumParamsDictTagged:
    """
    Build parameters.
    
    Args:
        voxel_sum: -voxel-sum: Print sum of all voxel intensities\
            \
            Syntax: `-voxel-sum `\
            \
            Print the sum of all voxels in the image.\
            \
            $ c3d image.img -voxel-sum\
            Voxel Sum: 200923123.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "voxel_sum",
        "voxel_sum": voxel_sum,
    }
    return params


def c3d_voxel_sum_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVoxelSumParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("voxel_sum", None) is None:
        raise StyxValidationError("`voxel_sum` must not be None")
    if not isinstance(params["voxel_sum"], str):
        raise StyxValidationError(f'`voxel_sum` has the wrong type: Received `{type(params.get("voxel_sum", None))}` expected `str`')


def c3d_voxel_sum_cargs(
    params: C3dVoxelSumParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-voxel-sum",
        params.get("voxel_sum", None)
    ])
    return cargs


def c3d_voxel_integral(
    voxel_integral: str,
) -> C3dVoxelIntegralParamsDictTagged:
    """
    Build parameters.
    
    Args:
        voxel_integral: -voxel-integral: Print volume integral of all voxel\
            intensities\
            \
            Syntax: `-voxel-integral`\
            \
            Like **-voxel-sum**, but multiplies the sum of voxel intensities by\
            voxel volume. This is useful for computing volumes of objects\
            represented by binary images. The result is in 'ml'.\
            \
            $ c3d image.img -voxel-integral\
            Voxel Integral: 2341.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "voxel_integral",
        "voxel_integral": voxel_integral,
    }
    return params


def c3d_voxel_integral_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVoxelIntegralParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("voxel_integral", None) is None:
        raise StyxValidationError("`voxel_integral` must not be None")
    if not isinstance(params["voxel_integral"], str):
        raise StyxValidationError(f'`voxel_integral` has the wrong type: Received `{type(params.get("voxel_integral", None))}` expected `str`')


def c3d_voxel_integral_cargs(
    params: C3dVoxelIntegralParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-voxel-integral",
        params.get("voxel_integral", None)
    ])
    return cargs


def c3d_voxelwise_regression(
    voxelwise_regression: str,
) -> C3dVoxelwiseRegressionParamsDictTagged:
    """
    Build parameters.
    
    Args:
        voxelwise_regression: -voxreg, -voxelwise-regression: Regression\
            between two images\
            \
            Syntax: `-voxreg regression_order `\
            \
            Perform regression between corresponding voxels in two images. This\
            command takes two images as input, X and Y. This command finds\
            parameters b\\_0, b\\_1, ..., b\\_k, such that Y is best\
            approximated by b\\_0 + b\\_1 * X + b\\_2 * X^2 + ... + b_k * X^k.\
            Here is an example of linear regression.\
            \
            $ c3d Y.nii X.nii -voxreg 2\
            REGCOEFF[0] = 5.56935\
            REGCOEFF[1] = 0.844024\
            \
            $ c3d Y.nii X.nii -scale 0.844024 -shift 5.56935 -voxreg 2\
            REGCOEFF[0] = 0\
            REGCOEFF[1] = 1.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "voxelwise_regression",
        "voxelwise_regression": voxelwise_regression,
    }
    return params


def c3d_voxelwise_regression_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dVoxelwiseRegressionParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("voxelwise_regression", None) is None:
        raise StyxValidationError("`voxelwise_regression` must not be None")
    if not isinstance(params["voxelwise_regression"], str):
        raise StyxValidationError(f'`voxelwise_regression` has the wrong type: Received `{type(params.get("voxelwise_regression", None))}` expected `str`')


def c3d_voxelwise_regression_cargs(
    params: C3dVoxelwiseRegressionParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-voxelwise-regression",
        params.get("voxelwise_regression", None)
    ])
    return cargs


def c3d_warp(
    warp: str,
) -> C3dWarpParamsDictTagged:
    """
    Build parameters.
    
    Args:
        warp: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "warp",
        "warp": warp,
    }
    return params


def c3d_warp_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dWarpParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("warp", None) is None:
        raise StyxValidationError("`warp` must not be None")
    if not isinstance(params["warp"], str):
        raise StyxValidationError(f'`warp` has the wrong type: Received `{type(params.get("warp", None))}` expected `str`')


def c3d_warp_cargs(
    params: C3dWarpParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-warp",
        params.get("warp", None)
    ])
    return cargs


def c3d_warp_label(
    warp_label: str,
) -> C3dWarpLabelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        warp_label: No description found.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "warp_label",
        "warp_label": warp_label,
    }
    return params


def c3d_warp_label_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dWarpLabelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("warp_label", None) is None:
        raise StyxValidationError("`warp_label` must not be None")
    if not isinstance(params["warp_label"], str):
        raise StyxValidationError(f'`warp_label` has the wrong type: Received `{type(params.get("warp_label", None))}` expected `str`')


def c3d_warp_label_cargs(
    params: C3dWarpLabelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-warp-label",
        params.get("warp_label", None)
    ])
    return cargs


def c3d_wrap(
    wrap: str,
) -> C3dWrapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        wrap: -wrap: Wrap (rotate) image\
            \
            Syntax: `-wrap <vector> `\
            \
            Wrap image around one or more voxel dimensions. Wrapping is\
            typically used to correct for MRI wrap-around artifacts. The vector\
            must have integer components, possibly negative. For example,\
            \
            c3d badmri.nii.gz -wrap 0x20x0 -o fixedmri.nii.gz\
            \
            will wrap the image in the second voxel dimension by 20 voxels\
            (i.e., voxel at 10x40x20 will me moved to the position 10x20x20).\
            \
            \
            ### Commands: Options and Parameters\
            \
            Options change the behavior of commands that *appear later on the\
            command line*. This is very important. Specifying options after the\
            command will have no effect.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "wrap",
        "wrap": wrap,
    }
    return params


def c3d_wrap_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dWrapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("wrap", None) is None:
        raise StyxValidationError("`wrap` must not be None")
    if not isinstance(params["wrap"], str):
        raise StyxValidationError(f'`wrap` has the wrong type: Received `{type(params.get("wrap", None))}` expected `str`')


def c3d_wrap_cargs(
    params: C3dWrapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-wrap",
        params.get("wrap", None)
    ])
    return cargs


def c3d_weighted_sum(
    weighted_sum: str,
) -> C3dWeightedSumParamsDictTagged:
    """
    Build parameters.
    
    Args:
        weighted_sum: -wsum, -weighted-sum: Weighed sum of images with constant\
            weights\
            \
            Syntax: `-wsum weight1 weight2 ... weightN `\
            \
            Computes weighted sum of the last N images on the stack.\
            \
            c3d image1.nii image2.nii image3.nii -wsum 0.2 0.7 0.1 -o wsum.nii\
            \
            This command is particularly useful for combining components in a\
            multicomponent image. For example, for an RGB image, we can convert\
            it to grayscale (using [ImageMagick][13] formula) as follows:\
            \
            c3d -mcs rgb.nii -wsum 0.29900 0.58700 0.11400 -o gray.nii.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "weighted_sum",
        "weighted_sum": weighted_sum,
    }
    return params


def c3d_weighted_sum_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dWeightedSumParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("weighted_sum", None) is None:
        raise StyxValidationError("`weighted_sum` must not be None")
    if not isinstance(params["weighted_sum"], str):
        raise StyxValidationError(f'`weighted_sum` has the wrong type: Received `{type(params.get("weighted_sum", None))}` expected `str`')


def c3d_weighted_sum_cargs(
    params: C3dWeightedSumParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-weighted-sum",
        params.get("weighted_sum", None)
    ])
    return cargs


def c3d_weighted_sum_voxelwise(
    weighted_sum_voxelwise: str,
) -> C3dWeightedSumVoxelwiseParamsDictTagged:
    """
    Build parameters.
    
    Args:
        weighted_sum_voxelwise: -wsv, -weighed-sum-voxelwise: Weighed sum of\
            images with spatially varying weights\
            \
            Syntax: `-wsv `\
            \
            Computes weighted sum of N weight images and N scalar images. The\
            images must be interleaved on the stack. All images on the stack\
            are used.\
            \
            c3d weight1.nii image1.nii weight2.nii image2.nii weight3.nii\
            image3.nii -wsv -o mysum.nii.gz\
            \
            The **-reorder** command can simplify loading the images:\
            \
            c3d weight*.nii image*.nii -reorder 0.5 -wsv -o mysum.nii.gz\
            \
            ### Commands: Image Header Manipulation.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "weighted_sum_voxelwise",
        "weighted_sum_voxelwise": weighted_sum_voxelwise,
    }
    return params


def c3d_weighted_sum_voxelwise_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `C3dWeightedSumVoxelwiseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("weighted_sum_voxelwise", None) is None:
        raise StyxValidationError("`weighted_sum_voxelwise` must not be None")
    if not isinstance(params["weighted_sum_voxelwise"], str):
        raise StyxValidationError(f'`weighted_sum_voxelwise` has the wrong type: Received `{type(params.get("weighted_sum_voxelwise", None))}` expected `str`')


def c3d_weighted_sum_voxelwise_cargs(
    params: C3dWeightedSumVoxelwiseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "-weighted-sum-voxelwise",
        params.get("weighted_sum_voxelwise", None)
    ])
    return cargs


class C3dOutputs(typing.NamedTuple):
    """
    Output object returned when calling `C3dParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    operations: list[typing.Union[C3dOutputOutputs]]
    """Outputs from `C3dOutputParamsDict`.This is a list of outputs with the
    same length and order as the inputs."""


def c3d_params(
    input_: list[InputPathType],
    operations: list[typing.Union[C3dAccumParamsDictTagged, C3dAcosParamsDictTagged, C3dAddParamsDictTagged, C3dAlignLandmarksParamsDictTagged, C3dAnisotropicDiffusionParamsDictTagged, C3dAntialiasParamsDictTagged, C3dSetParamsDictTagged, C3dAsinParamsDictTagged, C3dAtan2ParamsDictTagged, C3dBackgroundParamsDictTagged, C3dN4BiasCorrectionParamsDictTagged, C3dBinarizeParamsDictTagged, C3dCannyParamsDictTagged, C3dCeilParamsDictTagged, C3dCentroidParamsDictTagged, C3dCentroidMarkParamsDictTagged, C3dConnectedComponentsParamsDictTagged, C3dClearParamsDictTagged, C3dClipParamsDictTagged, C3dColorMapParamsDictTagged, C3dCompressParamsDictTagged, C3dNoCompressParamsDictTagged, C3dConvParamsDictTagged, C3dCoordinateMapVoxelParamsDictTagged, C3dCoordinateMapPhysicalParamsDictTagged, C3dCopyTransformParamsDictTagged, C3dCosParamsDictTagged, C3dCreateParamsDictTagged, C3dDicomSeriesListParamsDictTagged, C3dDicomSeriesReadParamsDictTagged, C3dDilateParamsDictTagged, C3dDivideParamsDictTagged, C3dDuplicateParamsDictTagged, C3dEndaccumParamsDictTagged, C3dEndforParamsDictTagged, C3dErodeParamsDictTagged, C3dErfParamsDictTagged, C3dExpParamsDictTagged, C3dExportPatchesParamsDictTagged, C3dExportPatchesAugParamsDictTagged, C3dExtrudeSegParamsDictTagged, C3dFillBackgroundWithNoiseParamsDictTagged, C3dFftParamsDictTagged, C3dFlipParamsDictTagged, C3dFloorParamsDictTagged, C3dForeachParamsDictTagged, C3dForeachCompParamsDictTagged, C3dGlmParamsDictTagged, C3dGradientParamsDictTagged, C3dHelpParamsDictTagged, C3dHolefillParamsDictTagged, C3dHessianEigenvaluesParamsDictTagged, C3dHessianObjectnessParamsDictTagged, C3dHistogramMatchParamsDictTagged, C3dInfoParamsDictTagged, C3dInfoFullParamsDictTagged, C3dInsertParamsDictTagged, C3dInterpolationParamsDictTagged, C3dIterationsParamsDictTagged, C3dLabelOverlapParamsDictTagged, C3dLabelStatisticsParamsDictTagged, C3dLandmarksToSpheresParamsDictTagged, C3dLaplacianParamsDictTagged, C3dLevelsetParamsDictTagged, C3dLevelsetCurvatureParamsDictTagged, C3dLevelsetAdvectionParamsDictTagged, C3dLogParamsDictTagged, C3dLog10ParamsDictTagged, C3dManualParamsDictTagged, C3dMatchBoundingBoxParamsDictTagged, C3dMaximumParamsDictTagged, C3dMulticomponentSplitParamsDictTagged, C3dMeanParamsDictTagged, C3dMedianFilterParamsDictTagged, C3dMergeParamsDictTagged, C3dMeanFilterParamsDictTagged, C3dMutualInfoParamsDictTagged, C3dMinimumParamsDictTagged, C3dMixtureModelParamsDictTagged, C3dMomentsParamsDictTagged, C3dMattesMutualInfoParamsDictTagged, C3dMeanSquareParamsDictTagged, C3dMultiplyParamsDictTagged, C3dNormalizedCrossCorrelationParamsDictTagged, C3dNormalizedCorrelationParamsDictTagged, C3dNormalizedMutualInfoParamsDictTagged, C3dNoiseGaussianParamsDictTagged, C3dNoisePoissonParamsDictTagged, C3dNoiseSpeckleParamsDictTagged, C3dNoiseSaltPepperParamsDictTagged, C3dNoMulticomponentSplitParamsDictTagged, C3dNormalizeLocalWindowParamsDictTagged, C3dNormpdfParamsDictTagged, C3dNoroundParamsDictTagged, C3dNospmParamsDictTagged, C3dOutputParamsDictTagged, C3dOutputMulticomponentParamsDictTagged, C3dOutputMultipleMulticomponentParamsDictTagged, C3dOrientParamsDictTagged, C3dOutputMultipleParamsDictTagged, C3dOrient1ParamsDictTagged, C3dOriginParamsDictTagged, C3dOriginVoxelParamsDictTagged, C3dOriginVoxelCoordParamsDictTagged, C3dOverlapParamsDictTagged, C3dOverlayLabelImageParamsDictTagged, C3dPadParamsDictTagged, C3dPadToParamsDictTagged, C3dPcaParamsDictTagged, C3dPercentIntensityModeParamsDictTagged, C3dPixelParamsDictTagged, C3dPopParamsDictTagged, C3dPopasParamsDictTagged, C3dProbeParamsDictTagged, C3dPushParamsDictTagged, C3dRankParamsDictTagged, C3dReciprocalParamsDictTagged, C3dRegionParamsDictTagged, C3dReorderParamsDictTagged, C3dRetainLabelsParamsDictTagged, C3dRfApplyParamsDictTagged, C3dRfTrainParamsDictTagged, C3dRfParamPatchParamsDictTagged, C3dRfParamUsexyzParamsDictTagged, C3dRfParamNousexyzParamsDictTagged, C3dRfParamNtreesParamsDictTagged, C3dRfParamTreedepthParamsDictTagged, C3dSetSformParamsDictTagged, C3dReplaceParamsDictTagged, C3dResampleParamsDictTagged, C3dResampleIsoParamsDictTagged, C3dResampleMmParamsDictTagged, C3dResliceItkParamsDictTagged, C3dResliceMatrixParamsDictTagged, C3dResliceIdentityParamsDictTagged, C3dRgb2hsvParamsDictTagged, C3dRmsParamsDictTagged, C3dRoundParamsDictTagged, C3dScaleParamsDictTagged, C3dSetSform1ParamsDictTagged, C3dSinParamsDictTagged, C3dSliceParamsDictTagged, C3dSliceAllParamsDictTagged, C3dSharpenParamsDictTagged, C3dShiftParamsDictTagged, C3dSignedDistanceTransformParamsDictTagged, C3dSmoothParamsDictTagged, C3dSmoothFastParamsDictTagged, C3dSpacingParamsDictTagged, C3dSplitParamsDictTagged, C3dSqrtParamsDictTagged, C3dStapleParamsDictTagged, C3dStructureTensorEigenvaluesParamsDictTagged, C3dSpmParamsDictTagged, C3dSubtractParamsDictTagged, C3dSupervoxelParamsDictTagged, C3dStretchParamsDictTagged, C3dSwapdimParamsDictTagged, C3dTestImageParamsDictTagged, C3dTestProbeParamsDictTagged, C3dThresholdParamsDictTagged, C3dTileParamsDictTagged, C3dTrimParamsDictTagged, C3dTrimToSizeParamsDictTagged, C3dTypeParamsDictTagged, C3dVerboseParamsDictTagged, C3dNoverboseParamsDictTagged, C3dVersionParamsDictTagged, C3dVoteParamsDictTagged, C3dVoteMrfParamsDictTagged, C3dVoteLabelParamsDictTagged, C3dVoxelSumParamsDictTagged, C3dVoxelIntegralParamsDictTagged, C3dVoxelwiseRegressionParamsDictTagged, C3dWarpParamsDictTagged, C3dWarpLabelParamsDictTagged, C3dWrapParamsDictTagged, C3dWeightedSumParamsDictTagged, C3dWeightedSumVoxelwiseParamsDictTagged]],
    output: str,
) -> C3dParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_: The input image to process.
        operations: The operations to perform.
        output: The output image.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "c3d/c3d",
        "input": input_,
        "operations": operations,
        "output": output,
    }
    return params


def c3d_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid `C3dParamsDict`
    object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input", None) is None:
        raise StyxValidationError("`input` must not be None")
    if not isinstance(params["input"], list):
        raise StyxValidationError(f'`input` has the wrong type: Received `{type(params.get("input", None))}` expected `list[InputPathType]`')
    for e in params["input"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`input` has the wrong type: Received `{type(params.get("input", None))}` expected `list[InputPathType]`')
    if params.get("operations", None) is None:
        raise StyxValidationError("`operations` must not be None")
    if not isinstance(params["operations"], list):
        raise StyxValidationError(f'`operations` has the wrong type: Received `{type(params.get("operations", None))}` expected `list[typing.Union[C3dAccumParamsDictTagged, C3dAcosParamsDictTagged, C3dAddParamsDictTagged, C3dAlignLandmarksParamsDictTagged, C3dAnisotropicDiffusionParamsDictTagged, C3dAntialiasParamsDictTagged, C3dSetParamsDictTagged, C3dAsinParamsDictTagged, C3dAtan2ParamsDictTagged, C3dBackgroundParamsDictTagged, C3dN4BiasCorrectionParamsDictTagged, C3dBinarizeParamsDictTagged, C3dCannyParamsDictTagged, C3dCeilParamsDictTagged, C3dCentroidParamsDictTagged, C3dCentroidMarkParamsDictTagged, C3dConnectedComponentsParamsDictTagged, C3dClearParamsDictTagged, C3dClipParamsDictTagged, C3dColorMapParamsDictTagged, C3dCompressParamsDictTagged, C3dNoCompressParamsDictTagged, C3dConvParamsDictTagged, C3dCoordinateMapVoxelParamsDictTagged, C3dCoordinateMapPhysicalParamsDictTagged, C3dCopyTransformParamsDictTagged, C3dCosParamsDictTagged, C3dCreateParamsDictTagged, C3dDicomSeriesListParamsDictTagged, C3dDicomSeriesReadParamsDictTagged, C3dDilateParamsDictTagged, C3dDivideParamsDictTagged, C3dDuplicateParamsDictTagged, C3dEndaccumParamsDictTagged, C3dEndforParamsDictTagged, C3dErodeParamsDictTagged, C3dErfParamsDictTagged, C3dExpParamsDictTagged, C3dExportPatchesParamsDictTagged, C3dExportPatchesAugParamsDictTagged, C3dExtrudeSegParamsDictTagged, C3dFillBackgroundWithNoiseParamsDictTagged, C3dFftParamsDictTagged, C3dFlipParamsDictTagged, C3dFloorParamsDictTagged, C3dForeachParamsDictTagged, C3dForeachCompParamsDictTagged, C3dGlmParamsDictTagged, C3dGradientParamsDictTagged, C3dHelpParamsDictTagged, C3dHolefillParamsDictTagged, C3dHessianEigenvaluesParamsDictTagged, C3dHessianObjectnessParamsDictTagged, C3dHistogramMatchParamsDictTagged, C3dInfoParamsDictTagged, C3dInfoFullParamsDictTagged, C3dInsertParamsDictTagged, C3dInterpolationParamsDictTagged, C3dIterationsParamsDictTagged, C3dLabelOverlapParamsDictTagged, C3dLabelStatisticsParamsDictTagged, C3dLandmarksToSpheresParamsDictTagged, C3dLaplacianParamsDictTagged, C3dLevelsetParamsDictTagged, C3dLevelsetCurvatureParamsDictTagged, C3dLevelsetAdvectionParamsDictTagged, C3dLogParamsDictTagged, C3dLog10ParamsDictTagged, C3dManualParamsDictTagged, C3dMatchBoundingBoxParamsDictTagged, C3dMaximumParamsDictTagged, C3dMulticomponentSplitParamsDictTagged, C3dMeanParamsDictTagged, C3dMedianFilterParamsDictTagged, C3dMergeParamsDictTagged, C3dMeanFilterParamsDictTagged, C3dMutualInfoParamsDictTagged, C3dMinimumParamsDictTagged, C3dMixtureModelParamsDictTagged, C3dMomentsParamsDictTagged, C3dMattesMutualInfoParamsDictTagged, C3dMeanSquareParamsDictTagged, C3dMultiplyParamsDictTagged, C3dNormalizedCrossCorrelationParamsDictTagged, C3dNormalizedCorrelationParamsDictTagged, C3dNormalizedMutualInfoParamsDictTagged, C3dNoiseGaussianParamsDictTagged, C3dNoisePoissonParamsDictTagged, C3dNoiseSpeckleParamsDictTagged, C3dNoiseSaltPepperParamsDictTagged, C3dNoMulticomponentSplitParamsDictTagged, C3dNormalizeLocalWindowParamsDictTagged, C3dNormpdfParamsDictTagged, C3dNoroundParamsDictTagged, C3dNospmParamsDictTagged, C3dOutputParamsDictTagged, C3dOutputMulticomponentParamsDictTagged, C3dOutputMultipleMulticomponentParamsDictTagged, C3dOrientParamsDictTagged, C3dOutputMultipleParamsDictTagged, C3dOrient1ParamsDictTagged, C3dOriginParamsDictTagged, C3dOriginVoxelParamsDictTagged, C3dOriginVoxelCoordParamsDictTagged, C3dOverlapParamsDictTagged, C3dOverlayLabelImageParamsDictTagged, C3dPadParamsDictTagged, C3dPadToParamsDictTagged, C3dPcaParamsDictTagged, C3dPercentIntensityModeParamsDictTagged, C3dPixelParamsDictTagged, C3dPopParamsDictTagged, C3dPopasParamsDictTagged, C3dProbeParamsDictTagged, C3dPushParamsDictTagged, C3dRankParamsDictTagged, C3dReciprocalParamsDictTagged, C3dRegionParamsDictTagged, C3dReorderParamsDictTagged, C3dRetainLabelsParamsDictTagged, C3dRfApplyParamsDictTagged, C3dRfTrainParamsDictTagged, C3dRfParamPatchParamsDictTagged, C3dRfParamUsexyzParamsDictTagged, C3dRfParamNousexyzParamsDictTagged, C3dRfParamNtreesParamsDictTagged, C3dRfParamTreedepthParamsDictTagged, C3dSetSformParamsDictTagged, C3dReplaceParamsDictTagged, C3dResampleParamsDictTagged, C3dResampleIsoParamsDictTagged, C3dResampleMmParamsDictTagged, C3dResliceItkParamsDictTagged, C3dResliceMatrixParamsDictTagged, C3dResliceIdentityParamsDictTagged, C3dRgb2hsvParamsDictTagged, C3dRmsParamsDictTagged, C3dRoundParamsDictTagged, C3dScaleParamsDictTagged, C3dSetSform1ParamsDictTagged, C3dSinParamsDictTagged, C3dSliceParamsDictTagged, C3dSliceAllParamsDictTagged, C3dSharpenParamsDictTagged, C3dShiftParamsDictTagged, C3dSignedDistanceTransformParamsDictTagged, C3dSmoothParamsDictTagged, C3dSmoothFastParamsDictTagged, C3dSpacingParamsDictTagged, C3dSplitParamsDictTagged, C3dSqrtParamsDictTagged, C3dStapleParamsDictTagged, C3dStructureTensorEigenvaluesParamsDictTagged, C3dSpmParamsDictTagged, C3dSubtractParamsDictTagged, C3dSupervoxelParamsDictTagged, C3dStretchParamsDictTagged, C3dSwapdimParamsDictTagged, C3dTestImageParamsDictTagged, C3dTestProbeParamsDictTagged, C3dThresholdParamsDictTagged, C3dTileParamsDictTagged, C3dTrimParamsDictTagged, C3dTrimToSizeParamsDictTagged, C3dTypeParamsDictTagged, C3dVerboseParamsDictTagged, C3dNoverboseParamsDictTagged, C3dVersionParamsDictTagged, C3dVoteParamsDictTagged, C3dVoteMrfParamsDictTagged, C3dVoteLabelParamsDictTagged, C3dVoxelSumParamsDictTagged, C3dVoxelIntegralParamsDictTagged, C3dVoxelwiseRegressionParamsDictTagged, C3dWarpParamsDictTagged, C3dWarpLabelParamsDictTagged, C3dWrapParamsDictTagged, C3dWeightedSumParamsDictTagged, C3dWeightedSumVoxelwiseParamsDictTagged]]`')
    for e in params["operations"]:
        if not isinstance(e, dict):
            raise StyxValidationError(f'Params object has the wrong type \'{type(e)}\'')
        if "@type" not in e:
            raise StyxValidationError("Params object is missing `@type`")
        if e["@type"] not in ["accum", "acos", "add", "align_landmarks", "anisotropic_diffusion", "antialias", "set", "asin", "atan2", "background", "n4_bias_correction", "binarize", "canny", "ceil", "centroid", "centroid_mark", "connected_components", "clear", "clip", "color_map", "compress", "no_compress", "conv", "coordinate_map_voxel", "coordinate_map_physical", "copy_transform", "cos", "create", "dicom_series_list", "dicom_series_read", "dilate", "divide", "duplicate", "endaccum", "endfor", "erode", "erf", "exp", "export_patches", "export_patches_aug", "extrude_seg", "fill_background_with_noise", "fft", "flip", "floor", "foreach", "foreach_comp", "glm", "gradient", "_help", "holefill", "hessian_eigenvalues", "hessian_objectness", "histogram_match", "info", "info_full", "insert", "interpolation", "iterations", "label_overlap", "label_statistics", "landmarks_to_spheres", "laplacian", "levelset", "levelset_curvature", "levelset_advection", "log", "log10", "manual", "match_bounding_box", "maximum", "multicomponent_split", "mean", "median_filter", "merge", "mean_filter", "mutual_info", "minimum", "mixture_model", "moments", "mattes_mutual_info", "mean_square", "multiply", "normalized_cross_correlation", "normalized_correlation", "normalized_mutual_info", "noise_gaussian", "noise_poisson", "noise_speckle", "noise_salt_pepper", "no_multicomponent_split", "normalize_local_window", "normpdf", "noround", "nospm", "output", "output_multicomponent", "output_multiple_multicomponent", "orient", "output_multiple", "orient_1", "origin", "origin_voxel", "origin_voxel_coord", "overlap", "overlay_label_image", "pad", "pad_to", "pca", "percent_intensity_mode", "pixel", "pop", "popas", "probe", "push", "rank", "reciprocal", "region", "reorder", "retain_labels", "rf_apply", "rf_train", "rf_param_patch", "rf_param_usexyz", "rf_param_nousexyz", "rf_param_ntrees", "rf_param_treedepth", "set_sform", "replace", "resample", "resample_iso", "resample_mm", "reslice_itk", "reslice_matrix", "reslice_identity", "rgb2hsv", "rms", "round", "scale", "set_sform_1", "sin", "slice", "slice_all", "sharpen", "shift", "signed_distance_transform", "smooth", "smooth_fast", "spacing", "split", "sqrt", "staple", "structure_tensor_eigenvalues", "spm", "subtract", "supervoxel", "stretch", "swapdim", "test_image", "test_probe", "threshold", "tile", "trim", "trim_to_size", "type", "verbose", "noverbose", "version", "vote", "vote_mrf", "vote_label", "voxel_sum", "voxel_integral", "voxelwise_regression", "warp", "warp_label", "wrap", "weighted_sum", "weighted_sum_voxelwise"]:
            raise StyxValidationError("Parameter `operations`s `@type` must be one of [\"accum\", \"acos\", \"add\", \"align_landmarks\", \"anisotropic_diffusion\", \"antialias\", \"set\", \"asin\", \"atan2\", \"background\", \"n4_bias_correction\", \"binarize\", \"canny\", \"ceil\", \"centroid\", \"centroid_mark\", \"connected_components\", \"clear\", \"clip\", \"color_map\", \"compress\", \"no_compress\", \"conv\", \"coordinate_map_voxel\", \"coordinate_map_physical\", \"copy_transform\", \"cos\", \"create\", \"dicom_series_list\", \"dicom_series_read\", \"dilate\", \"divide\", \"duplicate\", \"endaccum\", \"endfor\", \"erode\", \"erf\", \"exp\", \"export_patches\", \"export_patches_aug\", \"extrude_seg\", \"fill_background_with_noise\", \"fft\", \"flip\", \"floor\", \"foreach\", \"foreach_comp\", \"glm\", \"gradient\", \"_help\", \"holefill\", \"hessian_eigenvalues\", \"hessian_objectness\", \"histogram_match\", \"info\", \"info_full\", \"insert\", \"interpolation\", \"iterations\", \"label_overlap\", \"label_statistics\", \"landmarks_to_spheres\", \"laplacian\", \"levelset\", \"levelset_curvature\", \"levelset_advection\", \"log\", \"log10\", \"manual\", \"match_bounding_box\", \"maximum\", \"multicomponent_split\", \"mean\", \"median_filter\", \"merge\", \"mean_filter\", \"mutual_info\", \"minimum\", \"mixture_model\", \"moments\", \"mattes_mutual_info\", \"mean_square\", \"multiply\", \"normalized_cross_correlation\", \"normalized_correlation\", \"normalized_mutual_info\", \"noise_gaussian\", \"noise_poisson\", \"noise_speckle\", \"noise_salt_pepper\", \"no_multicomponent_split\", \"normalize_local_window\", \"normpdf\", \"noround\", \"nospm\", \"output\", \"output_multicomponent\", \"output_multiple_multicomponent\", \"orient\", \"output_multiple\", \"orient_1\", \"origin\", \"origin_voxel\", \"origin_voxel_coord\", \"overlap\", \"overlay_label_image\", \"pad\", \"pad_to\", \"pca\", \"percent_intensity_mode\", \"pixel\", \"pop\", \"popas\", \"probe\", \"push\", \"rank\", \"reciprocal\", \"region\", \"reorder\", \"retain_labels\", \"rf_apply\", \"rf_train\", \"rf_param_patch\", \"rf_param_usexyz\", \"rf_param_nousexyz\", \"rf_param_ntrees\", \"rf_param_treedepth\", \"set_sform\", \"replace\", \"resample\", \"resample_iso\", \"resample_mm\", \"reslice_itk\", \"reslice_matrix\", \"reslice_identity\", \"rgb2hsv\", \"rms\", \"round\", \"scale\", \"set_sform_1\", \"sin\", \"slice\", \"slice_all\", \"sharpen\", \"shift\", \"signed_distance_transform\", \"smooth\", \"smooth_fast\", \"spacing\", \"split\", \"sqrt\", \"staple\", \"structure_tensor_eigenvalues\", \"spm\", \"subtract\", \"supervoxel\", \"stretch\", \"swapdim\", \"test_image\", \"test_probe\", \"threshold\", \"tile\", \"trim\", \"trim_to_size\", \"type\", \"verbose\", \"noverbose\", \"version\", \"vote\", \"vote_mrf\", \"vote_label\", \"voxel_sum\", \"voxel_integral\", \"voxelwise_regression\", \"warp\", \"warp_label\", \"wrap\", \"weighted_sum\", \"weighted_sum_voxelwise\"]")
        c3d_operations_validate_dyn_fn(e["@type"])(e)
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')


def c3d_cargs(
    params: C3dParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("c3d")
    cargs.append(" ".join([execution.input_file(f) for f in params.get("input", None)]))
    cargs.extend([a for c in [c3d_operations_cargs_dyn_fn(s["@type"])(s, execution) for s in params.get("operations", None)] for a in c])
    cargs.extend([
        "-o",
        params.get("output", None)
    ])
    return cargs


def c3d_outputs(
    params: C3dParamsDict,
    execution: Execution,
) -> C3dOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = C3dOutputs(
        root=execution.output_file("."),
        operations=[c3d_operations_outputs_dyn_fn(i["@type"])(i, execution) if c3d_operations_outputs_dyn_fn(i["@type"]) else None for i in params.get("operations")],
    )
    return ret


def c3d_execute(
    params: C3dParamsDict,
    runner: Runner | None = None,
) -> C3dOutputs:
    """
    c3d
    
    C3D is a command-line tool for medical image processing.
    
    Author: Convert3D Developers
    
    URL: http://www.itksnap.org/pmwiki/pmwiki.php?n=Convert3D.Convert3D
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `C3dOutputs`).
    """
    c3d_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(C3D_METADATA)
    params = execution.params(params)
    cargs = c3d_cargs(params, execution)
    ret = c3d_outputs(params, execution)
    execution.run(cargs)
    return ret


def c3d_(
    input_: list[InputPathType],
    operations: list[typing.Union[C3dAccumParamsDictTagged, C3dAcosParamsDictTagged, C3dAddParamsDictTagged, C3dAlignLandmarksParamsDictTagged, C3dAnisotropicDiffusionParamsDictTagged, C3dAntialiasParamsDictTagged, C3dSetParamsDictTagged, C3dAsinParamsDictTagged, C3dAtan2ParamsDictTagged, C3dBackgroundParamsDictTagged, C3dN4BiasCorrectionParamsDictTagged, C3dBinarizeParamsDictTagged, C3dCannyParamsDictTagged, C3dCeilParamsDictTagged, C3dCentroidParamsDictTagged, C3dCentroidMarkParamsDictTagged, C3dConnectedComponentsParamsDictTagged, C3dClearParamsDictTagged, C3dClipParamsDictTagged, C3dColorMapParamsDictTagged, C3dCompressParamsDictTagged, C3dNoCompressParamsDictTagged, C3dConvParamsDictTagged, C3dCoordinateMapVoxelParamsDictTagged, C3dCoordinateMapPhysicalParamsDictTagged, C3dCopyTransformParamsDictTagged, C3dCosParamsDictTagged, C3dCreateParamsDictTagged, C3dDicomSeriesListParamsDictTagged, C3dDicomSeriesReadParamsDictTagged, C3dDilateParamsDictTagged, C3dDivideParamsDictTagged, C3dDuplicateParamsDictTagged, C3dEndaccumParamsDictTagged, C3dEndforParamsDictTagged, C3dErodeParamsDictTagged, C3dErfParamsDictTagged, C3dExpParamsDictTagged, C3dExportPatchesParamsDictTagged, C3dExportPatchesAugParamsDictTagged, C3dExtrudeSegParamsDictTagged, C3dFillBackgroundWithNoiseParamsDictTagged, C3dFftParamsDictTagged, C3dFlipParamsDictTagged, C3dFloorParamsDictTagged, C3dForeachParamsDictTagged, C3dForeachCompParamsDictTagged, C3dGlmParamsDictTagged, C3dGradientParamsDictTagged, C3dHelpParamsDictTagged, C3dHolefillParamsDictTagged, C3dHessianEigenvaluesParamsDictTagged, C3dHessianObjectnessParamsDictTagged, C3dHistogramMatchParamsDictTagged, C3dInfoParamsDictTagged, C3dInfoFullParamsDictTagged, C3dInsertParamsDictTagged, C3dInterpolationParamsDictTagged, C3dIterationsParamsDictTagged, C3dLabelOverlapParamsDictTagged, C3dLabelStatisticsParamsDictTagged, C3dLandmarksToSpheresParamsDictTagged, C3dLaplacianParamsDictTagged, C3dLevelsetParamsDictTagged, C3dLevelsetCurvatureParamsDictTagged, C3dLevelsetAdvectionParamsDictTagged, C3dLogParamsDictTagged, C3dLog10ParamsDictTagged, C3dManualParamsDictTagged, C3dMatchBoundingBoxParamsDictTagged, C3dMaximumParamsDictTagged, C3dMulticomponentSplitParamsDictTagged, C3dMeanParamsDictTagged, C3dMedianFilterParamsDictTagged, C3dMergeParamsDictTagged, C3dMeanFilterParamsDictTagged, C3dMutualInfoParamsDictTagged, C3dMinimumParamsDictTagged, C3dMixtureModelParamsDictTagged, C3dMomentsParamsDictTagged, C3dMattesMutualInfoParamsDictTagged, C3dMeanSquareParamsDictTagged, C3dMultiplyParamsDictTagged, C3dNormalizedCrossCorrelationParamsDictTagged, C3dNormalizedCorrelationParamsDictTagged, C3dNormalizedMutualInfoParamsDictTagged, C3dNoiseGaussianParamsDictTagged, C3dNoisePoissonParamsDictTagged, C3dNoiseSpeckleParamsDictTagged, C3dNoiseSaltPepperParamsDictTagged, C3dNoMulticomponentSplitParamsDictTagged, C3dNormalizeLocalWindowParamsDictTagged, C3dNormpdfParamsDictTagged, C3dNoroundParamsDictTagged, C3dNospmParamsDictTagged, C3dOutputParamsDictTagged, C3dOutputMulticomponentParamsDictTagged, C3dOutputMultipleMulticomponentParamsDictTagged, C3dOrientParamsDictTagged, C3dOutputMultipleParamsDictTagged, C3dOrient1ParamsDictTagged, C3dOriginParamsDictTagged, C3dOriginVoxelParamsDictTagged, C3dOriginVoxelCoordParamsDictTagged, C3dOverlapParamsDictTagged, C3dOverlayLabelImageParamsDictTagged, C3dPadParamsDictTagged, C3dPadToParamsDictTagged, C3dPcaParamsDictTagged, C3dPercentIntensityModeParamsDictTagged, C3dPixelParamsDictTagged, C3dPopParamsDictTagged, C3dPopasParamsDictTagged, C3dProbeParamsDictTagged, C3dPushParamsDictTagged, C3dRankParamsDictTagged, C3dReciprocalParamsDictTagged, C3dRegionParamsDictTagged, C3dReorderParamsDictTagged, C3dRetainLabelsParamsDictTagged, C3dRfApplyParamsDictTagged, C3dRfTrainParamsDictTagged, C3dRfParamPatchParamsDictTagged, C3dRfParamUsexyzParamsDictTagged, C3dRfParamNousexyzParamsDictTagged, C3dRfParamNtreesParamsDictTagged, C3dRfParamTreedepthParamsDictTagged, C3dSetSformParamsDictTagged, C3dReplaceParamsDictTagged, C3dResampleParamsDictTagged, C3dResampleIsoParamsDictTagged, C3dResampleMmParamsDictTagged, C3dResliceItkParamsDictTagged, C3dResliceMatrixParamsDictTagged, C3dResliceIdentityParamsDictTagged, C3dRgb2hsvParamsDictTagged, C3dRmsParamsDictTagged, C3dRoundParamsDictTagged, C3dScaleParamsDictTagged, C3dSetSform1ParamsDictTagged, C3dSinParamsDictTagged, C3dSliceParamsDictTagged, C3dSliceAllParamsDictTagged, C3dSharpenParamsDictTagged, C3dShiftParamsDictTagged, C3dSignedDistanceTransformParamsDictTagged, C3dSmoothParamsDictTagged, C3dSmoothFastParamsDictTagged, C3dSpacingParamsDictTagged, C3dSplitParamsDictTagged, C3dSqrtParamsDictTagged, C3dStapleParamsDictTagged, C3dStructureTensorEigenvaluesParamsDictTagged, C3dSpmParamsDictTagged, C3dSubtractParamsDictTagged, C3dSupervoxelParamsDictTagged, C3dStretchParamsDictTagged, C3dSwapdimParamsDictTagged, C3dTestImageParamsDictTagged, C3dTestProbeParamsDictTagged, C3dThresholdParamsDictTagged, C3dTileParamsDictTagged, C3dTrimParamsDictTagged, C3dTrimToSizeParamsDictTagged, C3dTypeParamsDictTagged, C3dVerboseParamsDictTagged, C3dNoverboseParamsDictTagged, C3dVersionParamsDictTagged, C3dVoteParamsDictTagged, C3dVoteMrfParamsDictTagged, C3dVoteLabelParamsDictTagged, C3dVoxelSumParamsDictTagged, C3dVoxelIntegralParamsDictTagged, C3dVoxelwiseRegressionParamsDictTagged, C3dWarpParamsDictTagged, C3dWarpLabelParamsDictTagged, C3dWrapParamsDictTagged, C3dWeightedSumParamsDictTagged, C3dWeightedSumVoxelwiseParamsDictTagged]],
    output: str,
    runner: Runner | None = None,
) -> C3dOutputs:
    """
    c3d
    
    C3D is a command-line tool for medical image processing.
    
    Author: Convert3D Developers
    
    URL: http://www.itksnap.org/pmwiki/pmwiki.php?n=Convert3D.Convert3D
    
    Args:
        input_: The input image to process.
        operations: The operations to perform.
        output: The output image.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `C3dOutputs`).
    """
    params = c3d_params(
        input_=input_,
        operations=operations,
        output=output,
    )
    return c3d_execute(params, runner)


__all__ = [
    "C3D_METADATA",
    "C3dAccumParamsDict",
    "C3dAccumParamsDictTagged",
    "C3dAcosParamsDict",
    "C3dAcosParamsDictTagged",
    "C3dAddParamsDict",
    "C3dAddParamsDictTagged",
    "C3dAlignLandmarksParamsDict",
    "C3dAlignLandmarksParamsDictTagged",
    "C3dAnisotropicDiffusionParamsDict",
    "C3dAnisotropicDiffusionParamsDictTagged",
    "C3dAntialiasParamsDict",
    "C3dAntialiasParamsDictTagged",
    "C3dAsinParamsDict",
    "C3dAsinParamsDictTagged",
    "C3dAtan2ParamsDict",
    "C3dAtan2ParamsDictTagged",
    "C3dBackgroundParamsDict",
    "C3dBackgroundParamsDictTagged",
    "C3dBinarizeParamsDict",
    "C3dBinarizeParamsDictTagged",
    "C3dCannyParamsDict",
    "C3dCannyParamsDictTagged",
    "C3dCeilParamsDict",
    "C3dCeilParamsDictTagged",
    "C3dCentroidMarkParamsDict",
    "C3dCentroidMarkParamsDictTagged",
    "C3dCentroidParamsDict",
    "C3dCentroidParamsDictTagged",
    "C3dClearParamsDict",
    "C3dClearParamsDictTagged",
    "C3dClipParamsDict",
    "C3dClipParamsDictTagged",
    "C3dColorMapParamsDict",
    "C3dColorMapParamsDictTagged",
    "C3dCompressParamsDict",
    "C3dCompressParamsDictTagged",
    "C3dConnectedComponentsParamsDict",
    "C3dConnectedComponentsParamsDictTagged",
    "C3dConvParamsDict",
    "C3dConvParamsDictTagged",
    "C3dCoordinateMapPhysicalParamsDict",
    "C3dCoordinateMapPhysicalParamsDictTagged",
    "C3dCoordinateMapVoxelParamsDict",
    "C3dCoordinateMapVoxelParamsDictTagged",
    "C3dCopyTransformParamsDict",
    "C3dCopyTransformParamsDictTagged",
    "C3dCosParamsDict",
    "C3dCosParamsDictTagged",
    "C3dCreateParamsDict",
    "C3dCreateParamsDictTagged",
    "C3dDicomSeriesListParamsDict",
    "C3dDicomSeriesListParamsDictTagged",
    "C3dDicomSeriesReadParamsDict",
    "C3dDicomSeriesReadParamsDictTagged",
    "C3dDilateParamsDict",
    "C3dDilateParamsDictTagged",
    "C3dDivideParamsDict",
    "C3dDivideParamsDictTagged",
    "C3dDuplicateParamsDict",
    "C3dDuplicateParamsDictTagged",
    "C3dEndaccumParamsDict",
    "C3dEndaccumParamsDictTagged",
    "C3dEndforParamsDict",
    "C3dEndforParamsDictTagged",
    "C3dErfParamsDict",
    "C3dErfParamsDictTagged",
    "C3dErodeParamsDict",
    "C3dErodeParamsDictTagged",
    "C3dExpParamsDict",
    "C3dExpParamsDictTagged",
    "C3dExportPatchesAugParamsDict",
    "C3dExportPatchesAugParamsDictTagged",
    "C3dExportPatchesParamsDict",
    "C3dExportPatchesParamsDictTagged",
    "C3dExtrudeSegParamsDict",
    "C3dExtrudeSegParamsDictTagged",
    "C3dFftParamsDict",
    "C3dFftParamsDictTagged",
    "C3dFillBackgroundWithNoiseParamsDict",
    "C3dFillBackgroundWithNoiseParamsDictTagged",
    "C3dFlipParamsDict",
    "C3dFlipParamsDictTagged",
    "C3dFloorParamsDict",
    "C3dFloorParamsDictTagged",
    "C3dForeachCompParamsDict",
    "C3dForeachCompParamsDictTagged",
    "C3dForeachParamsDict",
    "C3dForeachParamsDictTagged",
    "C3dGlmParamsDict",
    "C3dGlmParamsDictTagged",
    "C3dGradientParamsDict",
    "C3dGradientParamsDictTagged",
    "C3dHelpParamsDict",
    "C3dHelpParamsDictTagged",
    "C3dHessianEigenvaluesParamsDict",
    "C3dHessianEigenvaluesParamsDictTagged",
    "C3dHessianObjectnessParamsDict",
    "C3dHessianObjectnessParamsDictTagged",
    "C3dHistogramMatchParamsDict",
    "C3dHistogramMatchParamsDictTagged",
    "C3dHolefillParamsDict",
    "C3dHolefillParamsDictTagged",
    "C3dInfoFullParamsDict",
    "C3dInfoFullParamsDictTagged",
    "C3dInfoParamsDict",
    "C3dInfoParamsDictTagged",
    "C3dInsertParamsDict",
    "C3dInsertParamsDictTagged",
    "C3dInterpolationParamsDict",
    "C3dInterpolationParamsDictTagged",
    "C3dIterationsParamsDict",
    "C3dIterationsParamsDictTagged",
    "C3dLabelOverlapParamsDict",
    "C3dLabelOverlapParamsDictTagged",
    "C3dLabelStatisticsParamsDict",
    "C3dLabelStatisticsParamsDictTagged",
    "C3dLandmarksToSpheresParamsDict",
    "C3dLandmarksToSpheresParamsDictTagged",
    "C3dLaplacianParamsDict",
    "C3dLaplacianParamsDictTagged",
    "C3dLevelsetAdvectionParamsDict",
    "C3dLevelsetAdvectionParamsDictTagged",
    "C3dLevelsetCurvatureParamsDict",
    "C3dLevelsetCurvatureParamsDictTagged",
    "C3dLevelsetParamsDict",
    "C3dLevelsetParamsDictTagged",
    "C3dLog10ParamsDict",
    "C3dLog10ParamsDictTagged",
    "C3dLogParamsDict",
    "C3dLogParamsDictTagged",
    "C3dManualParamsDict",
    "C3dManualParamsDictTagged",
    "C3dMatchBoundingBoxParamsDict",
    "C3dMatchBoundingBoxParamsDictTagged",
    "C3dMattesMutualInfoParamsDict",
    "C3dMattesMutualInfoParamsDictTagged",
    "C3dMaximumParamsDict",
    "C3dMaximumParamsDictTagged",
    "C3dMeanFilterParamsDict",
    "C3dMeanFilterParamsDictTagged",
    "C3dMeanParamsDict",
    "C3dMeanParamsDictTagged",
    "C3dMeanSquareParamsDict",
    "C3dMeanSquareParamsDictTagged",
    "C3dMedianFilterParamsDict",
    "C3dMedianFilterParamsDictTagged",
    "C3dMergeParamsDict",
    "C3dMergeParamsDictTagged",
    "C3dMinimumParamsDict",
    "C3dMinimumParamsDictTagged",
    "C3dMixtureModelParamsDict",
    "C3dMixtureModelParamsDictTagged",
    "C3dMomentsParamsDict",
    "C3dMomentsParamsDictTagged",
    "C3dMulticomponentSplitParamsDict",
    "C3dMulticomponentSplitParamsDictTagged",
    "C3dMultiplyParamsDict",
    "C3dMultiplyParamsDictTagged",
    "C3dMutualInfoParamsDict",
    "C3dMutualInfoParamsDictTagged",
    "C3dN4BiasCorrectionParamsDict",
    "C3dN4BiasCorrectionParamsDictTagged",
    "C3dNoCompressParamsDict",
    "C3dNoCompressParamsDictTagged",
    "C3dNoMulticomponentSplitParamsDict",
    "C3dNoMulticomponentSplitParamsDictTagged",
    "C3dNoiseGaussianParamsDict",
    "C3dNoiseGaussianParamsDictTagged",
    "C3dNoisePoissonParamsDict",
    "C3dNoisePoissonParamsDictTagged",
    "C3dNoiseSaltPepperParamsDict",
    "C3dNoiseSaltPepperParamsDictTagged",
    "C3dNoiseSpeckleParamsDict",
    "C3dNoiseSpeckleParamsDictTagged",
    "C3dNormalizeLocalWindowParamsDict",
    "C3dNormalizeLocalWindowParamsDictTagged",
    "C3dNormalizedCorrelationParamsDict",
    "C3dNormalizedCorrelationParamsDictTagged",
    "C3dNormalizedCrossCorrelationParamsDict",
    "C3dNormalizedCrossCorrelationParamsDictTagged",
    "C3dNormalizedMutualInfoParamsDict",
    "C3dNormalizedMutualInfoParamsDictTagged",
    "C3dNormpdfParamsDict",
    "C3dNormpdfParamsDictTagged",
    "C3dNoroundParamsDict",
    "C3dNoroundParamsDictTagged",
    "C3dNospmParamsDict",
    "C3dNospmParamsDictTagged",
    "C3dNoverboseParamsDict",
    "C3dNoverboseParamsDictTagged",
    "C3dOrient1ParamsDict",
    "C3dOrient1ParamsDictTagged",
    "C3dOrientParamsDict",
    "C3dOrientParamsDictTagged",
    "C3dOriginParamsDict",
    "C3dOriginParamsDictTagged",
    "C3dOriginVoxelCoordParamsDict",
    "C3dOriginVoxelCoordParamsDictTagged",
    "C3dOriginVoxelParamsDict",
    "C3dOriginVoxelParamsDictTagged",
    "C3dOutputMulticomponentParamsDict",
    "C3dOutputMulticomponentParamsDictTagged",
    "C3dOutputMultipleMulticomponentParamsDict",
    "C3dOutputMultipleMulticomponentParamsDictTagged",
    "C3dOutputMultipleParamsDict",
    "C3dOutputMultipleParamsDictTagged",
    "C3dOutputOutputs",
    "C3dOutputParamsDict",
    "C3dOutputParamsDictTagged",
    "C3dOutputs",
    "C3dOverlapParamsDict",
    "C3dOverlapParamsDictTagged",
    "C3dOverlayLabelImageParamsDict",
    "C3dOverlayLabelImageParamsDictTagged",
    "C3dPadParamsDict",
    "C3dPadParamsDictTagged",
    "C3dPadToParamsDict",
    "C3dPadToParamsDictTagged",
    "C3dParamsDict",
    "C3dParamsDictTagged",
    "C3dPcaParamsDict",
    "C3dPcaParamsDictTagged",
    "C3dPercentIntensityModeParamsDict",
    "C3dPercentIntensityModeParamsDictTagged",
    "C3dPixelParamsDict",
    "C3dPixelParamsDictTagged",
    "C3dPopParamsDict",
    "C3dPopParamsDictTagged",
    "C3dPopasParamsDict",
    "C3dPopasParamsDictTagged",
    "C3dProbeParamsDict",
    "C3dProbeParamsDictTagged",
    "C3dPushParamsDict",
    "C3dPushParamsDictTagged",
    "C3dRankParamsDict",
    "C3dRankParamsDictTagged",
    "C3dReciprocalParamsDict",
    "C3dReciprocalParamsDictTagged",
    "C3dRegionParamsDict",
    "C3dRegionParamsDictTagged",
    "C3dReorderParamsDict",
    "C3dReorderParamsDictTagged",
    "C3dReplaceParamsDict",
    "C3dReplaceParamsDictTagged",
    "C3dResampleIsoParamsDict",
    "C3dResampleIsoParamsDictTagged",
    "C3dResampleMmParamsDict",
    "C3dResampleMmParamsDictTagged",
    "C3dResampleParamsDict",
    "C3dResampleParamsDictTagged",
    "C3dResliceIdentityParamsDict",
    "C3dResliceIdentityParamsDictTagged",
    "C3dResliceItkParamsDict",
    "C3dResliceItkParamsDictTagged",
    "C3dResliceMatrixParamsDict",
    "C3dResliceMatrixParamsDictTagged",
    "C3dRetainLabelsParamsDict",
    "C3dRetainLabelsParamsDictTagged",
    "C3dRfApplyParamsDict",
    "C3dRfApplyParamsDictTagged",
    "C3dRfParamNousexyzParamsDict",
    "C3dRfParamNousexyzParamsDictTagged",
    "C3dRfParamNtreesParamsDict",
    "C3dRfParamNtreesParamsDictTagged",
    "C3dRfParamPatchParamsDict",
    "C3dRfParamPatchParamsDictTagged",
    "C3dRfParamTreedepthParamsDict",
    "C3dRfParamTreedepthParamsDictTagged",
    "C3dRfParamUsexyzParamsDict",
    "C3dRfParamUsexyzParamsDictTagged",
    "C3dRfTrainParamsDict",
    "C3dRfTrainParamsDictTagged",
    "C3dRgb2hsvParamsDict",
    "C3dRgb2hsvParamsDictTagged",
    "C3dRmsParamsDict",
    "C3dRmsParamsDictTagged",
    "C3dRoundParamsDict",
    "C3dRoundParamsDictTagged",
    "C3dScaleParamsDict",
    "C3dScaleParamsDictTagged",
    "C3dSetParamsDict",
    "C3dSetParamsDictTagged",
    "C3dSetSform1ParamsDict",
    "C3dSetSform1ParamsDictTagged",
    "C3dSetSformParamsDict",
    "C3dSetSformParamsDictTagged",
    "C3dSharpenParamsDict",
    "C3dSharpenParamsDictTagged",
    "C3dShiftParamsDict",
    "C3dShiftParamsDictTagged",
    "C3dSignedDistanceTransformParamsDict",
    "C3dSignedDistanceTransformParamsDictTagged",
    "C3dSinParamsDict",
    "C3dSinParamsDictTagged",
    "C3dSliceAllParamsDict",
    "C3dSliceAllParamsDictTagged",
    "C3dSliceParamsDict",
    "C3dSliceParamsDictTagged",
    "C3dSmoothFastParamsDict",
    "C3dSmoothFastParamsDictTagged",
    "C3dSmoothParamsDict",
    "C3dSmoothParamsDictTagged",
    "C3dSpacingParamsDict",
    "C3dSpacingParamsDictTagged",
    "C3dSplitParamsDict",
    "C3dSplitParamsDictTagged",
    "C3dSpmParamsDict",
    "C3dSpmParamsDictTagged",
    "C3dSqrtParamsDict",
    "C3dSqrtParamsDictTagged",
    "C3dStapleParamsDict",
    "C3dStapleParamsDictTagged",
    "C3dStretchParamsDict",
    "C3dStretchParamsDictTagged",
    "C3dStructureTensorEigenvaluesParamsDict",
    "C3dStructureTensorEigenvaluesParamsDictTagged",
    "C3dSubtractParamsDict",
    "C3dSubtractParamsDictTagged",
    "C3dSupervoxelParamsDict",
    "C3dSupervoxelParamsDictTagged",
    "C3dSwapdimParamsDict",
    "C3dSwapdimParamsDictTagged",
    "C3dTestImageParamsDict",
    "C3dTestImageParamsDictTagged",
    "C3dTestProbeParamsDict",
    "C3dTestProbeParamsDictTagged",
    "C3dThresholdParamsDict",
    "C3dThresholdParamsDictTagged",
    "C3dTileParamsDict",
    "C3dTileParamsDictTagged",
    "C3dTrimParamsDict",
    "C3dTrimParamsDictTagged",
    "C3dTrimToSizeParamsDict",
    "C3dTrimToSizeParamsDictTagged",
    "C3dTypeParamsDict",
    "C3dTypeParamsDictTagged",
    "C3dVerboseParamsDict",
    "C3dVerboseParamsDictTagged",
    "C3dVersionParamsDict",
    "C3dVersionParamsDictTagged",
    "C3dVoteLabelParamsDict",
    "C3dVoteLabelParamsDictTagged",
    "C3dVoteMrfParamsDict",
    "C3dVoteMrfParamsDictTagged",
    "C3dVoteParamsDict",
    "C3dVoteParamsDictTagged",
    "C3dVoxelIntegralParamsDict",
    "C3dVoxelIntegralParamsDictTagged",
    "C3dVoxelSumParamsDict",
    "C3dVoxelSumParamsDictTagged",
    "C3dVoxelwiseRegressionParamsDict",
    "C3dVoxelwiseRegressionParamsDictTagged",
    "C3dWarpLabelParamsDict",
    "C3dWarpLabelParamsDictTagged",
    "C3dWarpParamsDict",
    "C3dWarpParamsDictTagged",
    "C3dWeightedSumParamsDict",
    "C3dWeightedSumParamsDictTagged",
    "C3dWeightedSumVoxelwiseParamsDict",
    "C3dWeightedSumVoxelwiseParamsDictTagged",
    "C3dWrapParamsDict",
    "C3dWrapParamsDictTagged",
    "c3d_",
    "c3d__help",
    "c3d_accum",
    "c3d_acos",
    "c3d_add",
    "c3d_align_landmarks",
    "c3d_anisotropic_diffusion",
    "c3d_antialias",
    "c3d_asin",
    "c3d_atan2",
    "c3d_background",
    "c3d_binarize",
    "c3d_canny",
    "c3d_ceil",
    "c3d_centroid",
    "c3d_centroid_mark",
    "c3d_clear",
    "c3d_clip",
    "c3d_color_map",
    "c3d_compress",
    "c3d_connected_components",
    "c3d_conv",
    "c3d_coordinate_map_physical",
    "c3d_coordinate_map_voxel",
    "c3d_copy_transform",
    "c3d_cos",
    "c3d_create",
    "c3d_dicom_series_list",
    "c3d_dicom_series_read",
    "c3d_dilate",
    "c3d_divide",
    "c3d_duplicate",
    "c3d_endaccum",
    "c3d_endfor",
    "c3d_erf",
    "c3d_erode",
    "c3d_execute",
    "c3d_exp",
    "c3d_export_patches",
    "c3d_export_patches_aug",
    "c3d_extrude_seg",
    "c3d_fft",
    "c3d_fill_background_with_noise",
    "c3d_flip",
    "c3d_floor",
    "c3d_foreach",
    "c3d_foreach_comp",
    "c3d_glm",
    "c3d_gradient",
    "c3d_hessian_eigenvalues",
    "c3d_hessian_objectness",
    "c3d_histogram_match",
    "c3d_holefill",
    "c3d_info",
    "c3d_info_full",
    "c3d_insert",
    "c3d_interpolation",
    "c3d_iterations",
    "c3d_label_overlap",
    "c3d_label_statistics",
    "c3d_landmarks_to_spheres",
    "c3d_laplacian",
    "c3d_levelset",
    "c3d_levelset_advection",
    "c3d_levelset_curvature",
    "c3d_log",
    "c3d_log10",
    "c3d_manual",
    "c3d_match_bounding_box",
    "c3d_mattes_mutual_info",
    "c3d_maximum",
    "c3d_mean",
    "c3d_mean_filter",
    "c3d_mean_square",
    "c3d_median_filter",
    "c3d_merge",
    "c3d_minimum",
    "c3d_mixture_model",
    "c3d_moments",
    "c3d_multicomponent_split",
    "c3d_multiply",
    "c3d_mutual_info",
    "c3d_n4_bias_correction",
    "c3d_no_compress",
    "c3d_no_multicomponent_split",
    "c3d_noise_gaussian",
    "c3d_noise_poisson",
    "c3d_noise_salt_pepper",
    "c3d_noise_speckle",
    "c3d_normalize_local_window",
    "c3d_normalized_correlation",
    "c3d_normalized_cross_correlation",
    "c3d_normalized_mutual_info",
    "c3d_normpdf",
    "c3d_noround",
    "c3d_nospm",
    "c3d_noverbose",
    "c3d_orient",
    "c3d_orient_1",
    "c3d_origin",
    "c3d_origin_voxel",
    "c3d_origin_voxel_coord",
    "c3d_output",
    "c3d_output_multicomponent",
    "c3d_output_multiple",
    "c3d_output_multiple_multicomponent",
    "c3d_overlap",
    "c3d_overlay_label_image",
    "c3d_pad",
    "c3d_pad_to",
    "c3d_params",
    "c3d_pca",
    "c3d_percent_intensity_mode",
    "c3d_pixel",
    "c3d_pop",
    "c3d_popas",
    "c3d_probe",
    "c3d_push",
    "c3d_rank",
    "c3d_reciprocal",
    "c3d_region",
    "c3d_reorder",
    "c3d_replace",
    "c3d_resample",
    "c3d_resample_iso",
    "c3d_resample_mm",
    "c3d_reslice_identity",
    "c3d_reslice_itk",
    "c3d_reslice_matrix",
    "c3d_retain_labels",
    "c3d_rf_apply",
    "c3d_rf_param_nousexyz",
    "c3d_rf_param_ntrees",
    "c3d_rf_param_patch",
    "c3d_rf_param_treedepth",
    "c3d_rf_param_usexyz",
    "c3d_rf_train",
    "c3d_rgb2hsv",
    "c3d_rms",
    "c3d_round",
    "c3d_scale",
    "c3d_set",
    "c3d_set_sform",
    "c3d_set_sform_1",
    "c3d_sharpen",
    "c3d_shift",
    "c3d_signed_distance_transform",
    "c3d_sin",
    "c3d_slice",
    "c3d_slice_all",
    "c3d_smooth",
    "c3d_smooth_fast",
    "c3d_spacing",
    "c3d_split",
    "c3d_spm",
    "c3d_sqrt",
    "c3d_staple",
    "c3d_stretch",
    "c3d_structure_tensor_eigenvalues",
    "c3d_subtract",
    "c3d_supervoxel",
    "c3d_swapdim",
    "c3d_test_image",
    "c3d_test_probe",
    "c3d_threshold",
    "c3d_tile",
    "c3d_trim",
    "c3d_trim_to_size",
    "c3d_type",
    "c3d_verbose",
    "c3d_version",
    "c3d_vote",
    "c3d_vote_label",
    "c3d_vote_mrf",
    "c3d_voxel_integral",
    "c3d_voxel_sum",
    "c3d_voxelwise_regression",
    "c3d_warp",
    "c3d_warp_label",
    "c3d_weighted_sum",
    "c3d_weighted_sum_voxelwise",
    "c3d_wrap",
]
