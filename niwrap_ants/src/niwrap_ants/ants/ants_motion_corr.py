# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

ANTS_MOTION_CORR_METADATA = Metadata(
    id="bad4ed9033e4ea6d613468b01cddbf59baf994a6.boutiques",
    name="antsMotionCorr",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


_AntsMotionCorrParamsDictNoTag = typing.TypedDict('_AntsMotionCorrParamsDictNoTag', {
    "dimensionality": typing.NotRequired[typing.Literal[2, 3] | None],
    "n_images": typing.NotRequired[int | None],
    "metric": typing.NotRequired[str | None],
    "use_fixed_reference_image": typing.NotRequired[bool | None],
    "use_scales_estimator": bool,
    "transform": typing.NotRequired[str | None],
    "iterations": typing.NotRequired[str | None],
    "smoothing_sigmas": typing.NotRequired[str | None],
    "shrink_factors": typing.NotRequired[str | None],
    "output": typing.NotRequired[str | None],
    "average_image": bool,
    "write_displacement": bool,
    "use_histogram_matching": typing.NotRequired[bool | None],
    "random_seed": typing.NotRequired[int | None],
    "interpolation": typing.NotRequired[typing.Literal["Linear", "NearestNeighbor", "BSpline", "BlackmanWindowedSinc", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc"] | None],
    "verbose": typing.NotRequired[bool | None],
})
AntsMotionCorrParamsDictTagged = typing.TypedDict('AntsMotionCorrParamsDictTagged', {
    "@type": typing.Literal["ants/antsMotionCorr"],
    "dimensionality": typing.NotRequired[typing.Literal[2, 3] | None],
    "n_images": typing.NotRequired[int | None],
    "metric": typing.NotRequired[str | None],
    "use_fixed_reference_image": typing.NotRequired[bool | None],
    "use_scales_estimator": bool,
    "transform": typing.NotRequired[str | None],
    "iterations": typing.NotRequired[str | None],
    "smoothing_sigmas": typing.NotRequired[str | None],
    "shrink_factors": typing.NotRequired[str | None],
    "output": typing.NotRequired[str | None],
    "average_image": bool,
    "write_displacement": bool,
    "use_histogram_matching": typing.NotRequired[bool | None],
    "random_seed": typing.NotRequired[int | None],
    "interpolation": typing.NotRequired[typing.Literal["Linear", "NearestNeighbor", "BSpline", "BlackmanWindowedSinc", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc"] | None],
    "verbose": typing.NotRequired[bool | None],
})
AntsMotionCorrParamsDict = _AntsMotionCorrParamsDictNoTag | AntsMotionCorrParamsDictTagged


class AntsMotionCorrOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsMotionCorrParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_transform_prefix: OutputPathType
    """The output is the transformation matrix."""
    warped_image: OutputPathType
    """The output is the warped moving image."""
    average_image_output: OutputPathType
    """The output is the averaged image of the input time series."""


def ants_motion_corr_params(
    dimensionality: typing.Literal[2, 3] | None = None,
    n_images: int | None = None,
    metric: str | None = None,
    use_fixed_reference_image: bool | None = None,
    use_scales_estimator: bool = False,
    transform: str | None = None,
    iterations: str | None = None,
    smoothing_sigmas: str | None = None,
    shrink_factors: str | None = None,
    output: str | None = None,
    average_image: bool = False,
    write_displacement: bool = False,
    use_histogram_matching: bool | None = None,
    random_seed: int | None = None,
    interpolation: typing.Literal["Linear", "NearestNeighbor", "BSpline", "BlackmanWindowedSinc", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc"] | None = None,
    verbose: bool | None = None,
) -> AntsMotionCorrParamsDictTagged:
    """
    Build parameters.
    
    Args:
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. If not specified, the program tries to\
            infer the dimensionality from the input image.
        n_images: This option sets the number of images to use to construct the\
            template image.
        metric: Metrics for registration: GC (global correlation), CC (ANTS\
            neighborhood cross correlation), MI (Mutual information), and Demons.
        use_fixed_reference_image: Use a fixed reference image to correct all\
            volumes, instead of correcting each image to the prior volume in the\
            time series.
        use_scales_estimator: Use the scale estimator to control optimization.
        transform: Several transform options are available: Affine, Rigid,\
            GaussianDisplacementField, SyN.
        iterations: Specify the number of iterations at each level.
        smoothing_sigmas: Specify the sigma for smoothing at each level.\
            Smoothing may be specified in mm units or voxels with 'AxBxCmm' or\
            'AxBxCvox'. No units implies voxels.
        shrink_factors: Specify the shrink factor for the virtual domain\
            (typically the fixed image) at each level.
        output: Specify the output transform prefix (output format is .nii.gz\
            ). Optionally, one can choose to warp the moving image to the fixed\
            space and, if the inverse transform exists, one can also output the\
            warped fixed image.
        average_image: Average the input time series image.
        write_displacement: Write the low-dimensional 3D transforms to a 4D\
            displacement field.
        use_histogram_matching: Histogram match the moving images to the\
            reference image.
        random_seed: Use a fixed seed for random number generation.
        interpolation: Several interpolation options are available in ITK. The\
            above are available (default Linear).
        verbose: Verbose output.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants/antsMotionCorr",
        "use_scales_estimator": use_scales_estimator,
        "average_image": average_image,
        "write_displacement": write_displacement,
    }
    if dimensionality is not None:
        params["dimensionality"] = dimensionality
    if n_images is not None:
        params["n_images"] = n_images
    if metric is not None:
        params["metric"] = metric
    if use_fixed_reference_image is not None:
        params["use_fixed_reference_image"] = use_fixed_reference_image
    if transform is not None:
        params["transform"] = transform
    if iterations is not None:
        params["iterations"] = iterations
    if smoothing_sigmas is not None:
        params["smoothing_sigmas"] = smoothing_sigmas
    if shrink_factors is not None:
        params["shrink_factors"] = shrink_factors
    if output is not None:
        params["output"] = output
    if use_histogram_matching is not None:
        params["use_histogram_matching"] = use_histogram_matching
    if random_seed is not None:
        params["random_seed"] = random_seed
    if interpolation is not None:
        params["interpolation"] = interpolation
    if verbose is not None:
        params["verbose"] = verbose
    return params


def ants_motion_corr_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsMotionCorrParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dimensionality", None) is not None:
        if not isinstance(params["dimensionality"], int):
            raise StyxValidationError(f'`dimensionality` has the wrong type: Received `{type(params.get("dimensionality", None))}` expected `typing.Literal[2, 3] | None`')
        if params["dimensionality"] not in [2, 3]:
            raise StyxValidationError("Parameter `dimensionality` must be one of [2, 3]")
    if params.get("n_images", None) is not None:
        if not isinstance(params["n_images"], int):
            raise StyxValidationError(f'`n_images` has the wrong type: Received `{type(params.get("n_images", None))}` expected `int | None`')
    if params.get("metric", None) is not None:
        if not isinstance(params["metric"], str):
            raise StyxValidationError(f'`metric` has the wrong type: Received `{type(params.get("metric", None))}` expected `str | None`')
    if params.get("use_fixed_reference_image", None) is not None:
        if not isinstance(params["use_fixed_reference_image"], bool):
            raise StyxValidationError(f'`use_fixed_reference_image` has the wrong type: Received `{type(params.get("use_fixed_reference_image", None))}` expected `bool | None`')
    if params.get("use_scales_estimator", False) is None:
        raise StyxValidationError("`use_scales_estimator` must not be None")
    if not isinstance(params["use_scales_estimator"], bool):
        raise StyxValidationError(f'`use_scales_estimator` has the wrong type: Received `{type(params.get("use_scales_estimator", False))}` expected `bool`')
    if params.get("transform", None) is not None:
        if not isinstance(params["transform"], str):
            raise StyxValidationError(f'`transform` has the wrong type: Received `{type(params.get("transform", None))}` expected `str | None`')
    if params.get("iterations", None) is not None:
        if not isinstance(params["iterations"], str):
            raise StyxValidationError(f'`iterations` has the wrong type: Received `{type(params.get("iterations", None))}` expected `str | None`')
    if params.get("smoothing_sigmas", None) is not None:
        if not isinstance(params["smoothing_sigmas"], str):
            raise StyxValidationError(f'`smoothing_sigmas` has the wrong type: Received `{type(params.get("smoothing_sigmas", None))}` expected `str | None`')
    if params.get("shrink_factors", None) is not None:
        if not isinstance(params["shrink_factors"], str):
            raise StyxValidationError(f'`shrink_factors` has the wrong type: Received `{type(params.get("shrink_factors", None))}` expected `str | None`')
    if params.get("output", None) is not None:
        if not isinstance(params["output"], str):
            raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str | None`')
    if params.get("average_image", False) is None:
        raise StyxValidationError("`average_image` must not be None")
    if not isinstance(params["average_image"], bool):
        raise StyxValidationError(f'`average_image` has the wrong type: Received `{type(params.get("average_image", False))}` expected `bool`')
    if params.get("write_displacement", False) is None:
        raise StyxValidationError("`write_displacement` must not be None")
    if not isinstance(params["write_displacement"], bool):
        raise StyxValidationError(f'`write_displacement` has the wrong type: Received `{type(params.get("write_displacement", False))}` expected `bool`')
    if params.get("use_histogram_matching", None) is not None:
        if not isinstance(params["use_histogram_matching"], bool):
            raise StyxValidationError(f'`use_histogram_matching` has the wrong type: Received `{type(params.get("use_histogram_matching", None))}` expected `bool | None`')
    if params.get("random_seed", None) is not None:
        if not isinstance(params["random_seed"], int):
            raise StyxValidationError(f'`random_seed` has the wrong type: Received `{type(params.get("random_seed", None))}` expected `int | None`')
        if params["random_seed"] < 1:
            raise StyxValidationError("Parameter `random_seed` must be at least 1")
    if params.get("interpolation", None) is not None:
        if not isinstance(params["interpolation"], str):
            raise StyxValidationError(f'`interpolation` has the wrong type: Received `{type(params.get("interpolation", None))}` expected `typing.Literal["Linear", "NearestNeighbor", "BSpline", "BlackmanWindowedSinc", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc"] | None`')
        if params["interpolation"] not in ["Linear", "NearestNeighbor", "BSpline", "BlackmanWindowedSinc", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc"]:
            raise StyxValidationError("Parameter `interpolation` must be one of [\"Linear\", \"NearestNeighbor\", \"BSpline\", \"BlackmanWindowedSinc\", \"CosineWindowedSinc\", \"WelchWindowedSinc\", \"HammingWindowedSinc\", \"LanczosWindowedSinc\"]")
    if params.get("verbose", None) is not None:
        if not isinstance(params["verbose"], bool):
            raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", None))}` expected `bool | None`')


def ants_motion_corr_cargs(
    params: AntsMotionCorrParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("antsMotionCorr")
    if params.get("dimensionality", None) is not None:
        cargs.extend([
            "--dimensionality",
            str(params.get("dimensionality", None))
        ])
    if params.get("n_images", None) is not None:
        cargs.extend([
            "--n-images",
            str(params.get("n_images", None))
        ])
    if params.get("metric", None) is not None:
        cargs.extend([
            "--metric",
            params.get("metric", None)
        ])
    if params.get("use_fixed_reference_image", None) is not None:
        cargs.extend([
            "--useFixedReferenceImage",
            ("1" if params.get("use_fixed_reference_image", None) else "0")
        ])
    if params.get("use_scales_estimator", False):
        cargs.append("--useScalesEstimator")
    if params.get("transform", None) is not None:
        cargs.extend([
            "--transform",
            params.get("transform", None)
        ])
    if params.get("iterations", None) is not None:
        cargs.extend([
            "--iterations",
            params.get("iterations", None)
        ])
    if params.get("smoothing_sigmas", None) is not None:
        cargs.extend([
            "--smoothingSigmas",
            params.get("smoothing_sigmas", None)
        ])
    if params.get("shrink_factors", None) is not None:
        cargs.extend([
            "--shrinkFactors",
            params.get("shrink_factors", None)
        ])
    if params.get("output", None) is not None:
        cargs.extend([
            "--output",
            params.get("output", None)
        ])
    if params.get("average_image", False):
        cargs.append("--average-image")
    if params.get("write_displacement", False):
        cargs.append("--write-displacement")
    if params.get("use_histogram_matching", None) is not None:
        cargs.extend([
            "--use-histogram-matching",
            ("1" if params.get("use_histogram_matching", None) else "0")
        ])
    if params.get("random_seed", None) is not None:
        cargs.extend([
            "--random-seed",
            str(params.get("random_seed", None))
        ])
    if params.get("interpolation", None) is not None:
        cargs.extend([
            "--interpolation",
            params.get("interpolation", None)
        ])
    if params.get("verbose", None) is not None:
        cargs.extend([
            "--verbose",
            ("1" if params.get("verbose", None) else "0")
        ])
    return cargs


def ants_motion_corr_outputs(
    params: AntsMotionCorrParamsDict,
    execution: Execution,
) -> AntsMotionCorrOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsMotionCorrOutputs(
        root=execution.output_file("."),
        output_transform_prefix=execution.output_file("[OUTPUT_TRANSFORM_PREFIX]Affine.mat"),
        warped_image=execution.output_file("[OUTPUT_TRANSFORM_PREFIX]Warped.nii.gz"),
        average_image_output=execution.output_file("[OUTPUT_TRANSFORM_PREFIX]Average.nii.gz"),
    )
    return ret


def ants_motion_corr_execute(
    params: AntsMotionCorrParamsDict,
    runner: Runner | None = None,
) -> AntsMotionCorrOutputs:
    """
    antsMotionCorr
    
    ANTS Motion Correction application to perform motion correction on 4D time
    series data.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsMotionCorrOutputs`).
    """
    ants_motion_corr_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(ANTS_MOTION_CORR_METADATA)
    params = execution.params(params)
    cargs = ants_motion_corr_cargs(params, execution)
    ret = ants_motion_corr_outputs(params, execution)
    execution.run(cargs)
    return ret


def ants_motion_corr(
    dimensionality: typing.Literal[2, 3] | None = None,
    n_images: int | None = None,
    metric: str | None = None,
    use_fixed_reference_image: bool | None = None,
    use_scales_estimator: bool = False,
    transform: str | None = None,
    iterations: str | None = None,
    smoothing_sigmas: str | None = None,
    shrink_factors: str | None = None,
    output: str | None = None,
    average_image: bool = False,
    write_displacement: bool = False,
    use_histogram_matching: bool | None = None,
    random_seed: int | None = None,
    interpolation: typing.Literal["Linear", "NearestNeighbor", "BSpline", "BlackmanWindowedSinc", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc"] | None = None,
    verbose: bool | None = None,
    runner: Runner | None = None,
) -> AntsMotionCorrOutputs:
    """
    antsMotionCorr
    
    ANTS Motion Correction application to perform motion correction on 4D time
    series data.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. If not specified, the program tries to\
            infer the dimensionality from the input image.
        n_images: This option sets the number of images to use to construct the\
            template image.
        metric: Metrics for registration: GC (global correlation), CC (ANTS\
            neighborhood cross correlation), MI (Mutual information), and Demons.
        use_fixed_reference_image: Use a fixed reference image to correct all\
            volumes, instead of correcting each image to the prior volume in the\
            time series.
        use_scales_estimator: Use the scale estimator to control optimization.
        transform: Several transform options are available: Affine, Rigid,\
            GaussianDisplacementField, SyN.
        iterations: Specify the number of iterations at each level.
        smoothing_sigmas: Specify the sigma for smoothing at each level.\
            Smoothing may be specified in mm units or voxels with 'AxBxCmm' or\
            'AxBxCvox'. No units implies voxels.
        shrink_factors: Specify the shrink factor for the virtual domain\
            (typically the fixed image) at each level.
        output: Specify the output transform prefix (output format is .nii.gz\
            ). Optionally, one can choose to warp the moving image to the fixed\
            space and, if the inverse transform exists, one can also output the\
            warped fixed image.
        average_image: Average the input time series image.
        write_displacement: Write the low-dimensional 3D transforms to a 4D\
            displacement field.
        use_histogram_matching: Histogram match the moving images to the\
            reference image.
        random_seed: Use a fixed seed for random number generation.
        interpolation: Several interpolation options are available in ITK. The\
            above are available (default Linear).
        verbose: Verbose output.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsMotionCorrOutputs`).
    """
    params = ants_motion_corr_params(
        dimensionality=dimensionality,
        n_images=n_images,
        metric=metric,
        use_fixed_reference_image=use_fixed_reference_image,
        use_scales_estimator=use_scales_estimator,
        transform=transform,
        iterations=iterations,
        smoothing_sigmas=smoothing_sigmas,
        shrink_factors=shrink_factors,
        output=output,
        average_image=average_image,
        write_displacement=write_displacement,
        use_histogram_matching=use_histogram_matching,
        random_seed=random_seed,
        interpolation=interpolation,
        verbose=verbose,
    )
    return ants_motion_corr_execute(params, runner)


__all__ = [
    "ANTS_MOTION_CORR_METADATA",
    "AntsMotionCorrOutputs",
    "AntsMotionCorrParamsDict",
    "AntsMotionCorrParamsDictTagged",
    "ants_motion_corr",
    "ants_motion_corr_execute",
    "ants_motion_corr_params",
]
