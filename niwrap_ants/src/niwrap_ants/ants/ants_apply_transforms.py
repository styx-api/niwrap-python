# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

ANTS_APPLY_TRANSFORMS_METADATA = Metadata(
    id="5bae5c4751160f7ccaa07fc3078825fcfbfea774.boutiques",
    name="antsApplyTransforms",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


AntsApplyTransformsWarpedOutputParameters = typing.TypedDict('AntsApplyTransformsWarpedOutputParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.warpedOutput"],
    "warpedOutputFileName": str,
})


AntsApplyTransformsCompositeDisplacementFieldOutputParameters = typing.TypedDict('AntsApplyTransformsCompositeDisplacementFieldOutputParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.compositeDisplacementFieldOutput"],
    "compositeDisplacementField": str,
    "printOutCompositeWarpFile": typing.NotRequired[typing.Literal[0, 1] | None],
})


AntsApplyTransformsGenericAffineTransformOutputParameters = typing.TypedDict('AntsApplyTransformsGenericAffineTransformOutputParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.genericAffineTransformOutput"],
    "genericAffineTransformFile": str,
    "calculateInverse": typing.NotRequired[typing.Literal[0, 1] | None],
})


AntsApplyTransformsLinearParameters = typing.TypedDict('AntsApplyTransformsLinearParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.linear"],
})


AntsApplyTransformsNearestNeighborParameters = typing.TypedDict('AntsApplyTransformsNearestNeighborParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.nearestNeighbor"],
})


AntsApplyTransformsMultiLabelnoparamsParameters = typing.TypedDict('AntsApplyTransformsMultiLabelnoparamsParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.multiLabelnoparams"],
})


AntsApplyTransformsSigmaParameters = typing.TypedDict('AntsApplyTransformsSigmaParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.multiLabel.params.sigma"],
    "sigma": float,
})


AntsApplyTransformsAlphaParameters = typing.TypedDict('AntsApplyTransformsAlphaParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.multiLabel.params.alpha"],
    "alpha": float,
})


AntsApplyTransformsParamParameters = typing.TypedDict('AntsApplyTransformsParamParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.multiLabel.params"],
    "params": list[typing.Union[AntsApplyTransformsSigmaParameters, AntsApplyTransformsAlphaParameters]],
})


AntsApplyTransformsMultiLabelParameters = typing.TypedDict('AntsApplyTransformsMultiLabelParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.multiLabel"],
    "params": AntsApplyTransformsParamParameters,
})


AntsApplyTransformsGaussianParameters = typing.TypedDict('AntsApplyTransformsGaussianParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.gaussian"],
    "sigma": typing.NotRequired[float | None],
    "alpha": typing.NotRequired[float | None],
})


AntsApplyTransformsBsplineParameters = typing.TypedDict('AntsApplyTransformsBsplineParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.bspline"],
    "order": typing.NotRequired[int | None],
})


AntsApplyTransformsCosineWindowedSincParameters = typing.TypedDict('AntsApplyTransformsCosineWindowedSincParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.cosineWindowedSinc"],
})


AntsApplyTransformsWelchWindowedSincParameters = typing.TypedDict('AntsApplyTransformsWelchWindowedSincParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.welchWindowedSinc"],
})


AntsApplyTransformsHammingWindowedSincParameters = typing.TypedDict('AntsApplyTransformsHammingWindowedSincParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.hammingWindowedSinc"],
})


AntsApplyTransformsLanczosWindowedSincParameters = typing.TypedDict('AntsApplyTransformsLanczosWindowedSincParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.lanczosWindowedSinc"],
})


AntsApplyTransformsGenericLabelParameters = typing.TypedDict('AntsApplyTransformsGenericLabelParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.genericLabel"],
    "interpolator": typing.NotRequired[str | None],
})


AntsApplyTransformsTransformFileNameParameters = typing.TypedDict('AntsApplyTransformsTransformFileNameParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.transformFileName"],
    "transformFileName": InputPathType,
})


AntsApplyTransformsUseInverseParameters = typing.TypedDict('AntsApplyTransformsUseInverseParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms.useInverse"],
    "transformFileName": InputPathType,
})


AntsApplyTransformsParameters = typing.TypedDict('AntsApplyTransformsParameters', {
    "@type": typing.Literal["ants.antsApplyTransforms"],
    "dimensionality": typing.NotRequired[typing.Literal[2, 3, 4] | None],
    "input_image_type": typing.NotRequired[typing.Literal[0, 1, 2, 3, 4, 5] | None],
    "input_image": typing.NotRequired[InputPathType | None],
    "reference_image": InputPathType,
    "output": typing.Union[AntsApplyTransformsWarpedOutputParameters, AntsApplyTransformsCompositeDisplacementFieldOutputParameters, AntsApplyTransformsGenericAffineTransformOutputParameters],
    "interpolation": typing.NotRequired[typing.Union[AntsApplyTransformsLinearParameters, AntsApplyTransformsNearestNeighborParameters, AntsApplyTransformsMultiLabelnoparamsParameters, AntsApplyTransformsMultiLabelParameters, AntsApplyTransformsGaussianParameters, AntsApplyTransformsBsplineParameters, AntsApplyTransformsCosineWindowedSincParameters, AntsApplyTransformsWelchWindowedSincParameters, AntsApplyTransformsHammingWindowedSincParameters, AntsApplyTransformsLanczosWindowedSincParameters, AntsApplyTransformsGenericLabelParameters] | None],
    "output_data_type": typing.NotRequired[typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None],
    "transform": typing.NotRequired[list[typing.Union[AntsApplyTransformsTransformFileNameParameters, AntsApplyTransformsUseInverseParameters]] | None],
    "default_value": typing.NotRequired[float | None],
    "static_cast_for_R": typing.NotRequired[str | None],
    "float": typing.NotRequired[typing.Literal[0, 1] | None],
    "verbose": typing.NotRequired[typing.Literal[0, 1] | None],
})


def dyn_cargs(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "ants.antsApplyTransforms": ants_apply_transforms_cargs,
        "ants.antsApplyTransforms.warpedOutput": ants_apply_transforms_warped_output_cargs,
        "ants.antsApplyTransforms.compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_cargs,
        "ants.antsApplyTransforms.genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_cargs,
        "ants.antsApplyTransforms.linear": ants_apply_transforms_linear_cargs,
        "ants.antsApplyTransforms.nearestNeighbor": ants_apply_transforms_nearest_neighbor_cargs,
        "ants.antsApplyTransforms.multiLabelnoparams": ants_apply_transforms_multi_labelnoparams_cargs,
        "ants.antsApplyTransforms.multiLabel": ants_apply_transforms_multi_label_cargs,
        "ants.antsApplyTransforms.multiLabel.params": ants_apply_transforms_param_cargs,
        "ants.antsApplyTransforms.multiLabel.params.sigma": ants_apply_transforms_sigma_cargs,
        "ants.antsApplyTransforms.multiLabel.params.alpha": ants_apply_transforms_alpha_cargs,
        "ants.antsApplyTransforms.gaussian": ants_apply_transforms_gaussian_cargs,
        "ants.antsApplyTransforms.bspline": ants_apply_transforms_bspline_cargs,
        "ants.antsApplyTransforms.cosineWindowedSinc": ants_apply_transforms_cosine_windowed_sinc_cargs,
        "ants.antsApplyTransforms.welchWindowedSinc": ants_apply_transforms_welch_windowed_sinc_cargs,
        "ants.antsApplyTransforms.hammingWindowedSinc": ants_apply_transforms_hamming_windowed_sinc_cargs,
        "ants.antsApplyTransforms.lanczosWindowedSinc": ants_apply_transforms_lanczos_windowed_sinc_cargs,
        "ants.antsApplyTransforms.genericLabel": ants_apply_transforms_generic_label_cargs,
        "ants.antsApplyTransforms.transformFileName": ants_apply_transforms_transform_file_name_cargs,
        "ants.antsApplyTransforms.useInverse": ants_apply_transforms_use_inverse_cargs,
    }.get(t)


def dyn_outputs(
    t: str,
) -> typing.Any:
    """
    Get build outputs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build outputs function.
    """
    return {
        "ants.antsApplyTransforms": ants_apply_transforms_outputs,
        "ants.antsApplyTransforms.warpedOutput": ants_apply_transforms_warped_output_outputs,
        "ants.antsApplyTransforms.compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_outputs,
        "ants.antsApplyTransforms.genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_outputs,
    }.get(t)


class AntsApplyTransformsWarpedOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsApplyTransformsWarpedOutputParameters(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


def ants_apply_transforms_warped_output_params(
    warped_output_file_name: str,
) -> AntsApplyTransformsWarpedOutputParameters:
    """
    Build parameters.
    
    Args:
        warped_output_file_name: Output file name.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.warpedOutput",
        "warpedOutputFileName": warped_output_file_name,
    }
    return params


def ants_apply_transforms_warped_output_cargs(
    params: AntsApplyTransformsWarpedOutputParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("warpedOutputFileName"))
    return cargs


def ants_apply_transforms_warped_output_outputs(
    params: AntsApplyTransformsWarpedOutputParameters,
    execution: Execution,
) -> AntsApplyTransformsWarpedOutputOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsWarpedOutputOutputs(
        root=execution.output_file("."),
        output_image_outfile=execution.output_file(params.get("warpedOutputFileName")),
    )
    return ret


class AntsApplyTransformsCompositeDisplacementFieldOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsApplyTransformsCompositeDisplacementFieldOutputParameters(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


def ants_apply_transforms_composite_displacement_field_output_params(
    composite_displacement_field: str,
    print_out_composite_warp_file: typing.Literal[0, 1] | None = None,
) -> AntsApplyTransformsCompositeDisplacementFieldOutputParameters:
    """
    Build parameters.
    
    Args:
        composite_displacement_field: Output file name.
        print_out_composite_warp_file: Output a composite warp file instead of\
            a transformed image.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.compositeDisplacementFieldOutput",
        "compositeDisplacementField": composite_displacement_field,
    }
    if print_out_composite_warp_file is not None:
        params["printOutCompositeWarpFile"] = print_out_composite_warp_file
    return params


def ants_apply_transforms_composite_displacement_field_output_cargs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("printOutCompositeWarpFile") is not None:
        cargs.append("[" + params.get("compositeDisplacementField") + ",printOutCompositeWarpFile=" + str(params.get("printOutCompositeWarpFile")) + "]")
    return cargs


def ants_apply_transforms_composite_displacement_field_output_outputs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
    execution: Execution,
) -> AntsApplyTransformsCompositeDisplacementFieldOutputOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsCompositeDisplacementFieldOutputOutputs(
        root=execution.output_file("."),
        output_image_outfile=execution.output_file(params.get("compositeDisplacementField")),
    )
    return ret


class AntsApplyTransformsGenericAffineTransformOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsApplyTransformsGenericAffineTransformOutputParameters(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


def ants_apply_transforms_generic_affine_transform_output_params(
    generic_affine_transform_file: str,
    calculate_inverse: typing.Literal[0, 1] | None = None,
) -> AntsApplyTransformsGenericAffineTransformOutputParameters:
    """
    Build parameters.
    
    Args:
        generic_affine_transform_file: Output file name.
        calculate_inverse: Calculate the inverse of the affine transform.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.genericAffineTransformOutput",
        "genericAffineTransformFile": generic_affine_transform_file,
    }
    if calculate_inverse is not None:
        params["calculateInverse"] = calculate_inverse
    return params


def ants_apply_transforms_generic_affine_transform_output_cargs(
    params: AntsApplyTransformsGenericAffineTransformOutputParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("calculateInverse") is not None:
        cargs.append("Linear[" + params.get("genericAffineTransformFile") + ",calculateInverse=" + str(params.get("calculateInverse")) + "]")
    return cargs


def ants_apply_transforms_generic_affine_transform_output_outputs(
    params: AntsApplyTransformsGenericAffineTransformOutputParameters,
    execution: Execution,
) -> AntsApplyTransformsGenericAffineTransformOutputOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsGenericAffineTransformOutputOutputs(
        root=execution.output_file("."),
        output_image_outfile=execution.output_file(params.get("genericAffineTransformFile")),
    )
    return ret


def ants_apply_transforms_linear_params(
) -> AntsApplyTransformsLinearParameters:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.linear",
    }
    return params


def ants_apply_transforms_linear_cargs(
    params: AntsApplyTransformsLinearParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Linear")
    return cargs


def ants_apply_transforms_nearest_neighbor_params(
) -> AntsApplyTransformsNearestNeighborParameters:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.nearestNeighbor",
    }
    return params


def ants_apply_transforms_nearest_neighbor_cargs(
    params: AntsApplyTransformsNearestNeighborParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("NearestNeighbor")
    return cargs


def ants_apply_transforms_multi_labelnoparams_params(
) -> AntsApplyTransformsMultiLabelnoparamsParameters:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.multiLabelnoparams",
    }
    return params


def ants_apply_transforms_multi_labelnoparams_cargs(
    params: AntsApplyTransformsMultiLabelnoparamsParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("MultiLabel")
    return cargs


def ants_apply_transforms_sigma_params(
    sigma: float,
) -> AntsApplyTransformsSigmaParameters:
    """
    Build parameters.
    
    Args:
        sigma: Sigma value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.multiLabel.params.sigma",
        "sigma": sigma,
    }
    return params


def ants_apply_transforms_sigma_cargs(
    params: AntsApplyTransformsSigmaParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("sigma=" + str(params.get("sigma")))
    return cargs


def ants_apply_transforms_alpha_params(
    alpha: float,
) -> AntsApplyTransformsAlphaParameters:
    """
    Build parameters.
    
    Args:
        alpha: Alpha value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.multiLabel.params.alpha",
        "alpha": alpha,
    }
    return params


def ants_apply_transforms_alpha_cargs(
    params: AntsApplyTransformsAlphaParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("alpha=" + str(params.get("alpha")))
    return cargs


def ants_apply_transforms_param_params(
    params_: list[typing.Union[AntsApplyTransformsSigmaParameters, AntsApplyTransformsAlphaParameters]],
) -> AntsApplyTransformsParamParameters:
    """
    Build parameters.
    
    Args:
        params_:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.multiLabel.params",
        "params": params_,
    }
    return params


def ants_apply_transforms_param_cargs(
    params: AntsApplyTransformsParamParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + ",".join([a for c in [dyn_cargs(s["@type"])(s, execution) for s in params.get("params")] for a in c]) + "]")
    return cargs


def ants_apply_transforms_multi_label_params(
    params_: AntsApplyTransformsParamParameters,
) -> AntsApplyTransformsMultiLabelParameters:
    """
    Build parameters.
    
    Args:
        params_:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.multiLabel",
        "params": params_,
    }
    return params


def ants_apply_transforms_multi_label_cargs(
    params: AntsApplyTransformsMultiLabelParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("MultiLabel" + "".join(dyn_cargs(params.get("params")["@type"])(params.get("params"), execution)))
    return cargs


def ants_apply_transforms_gaussian_params(
    sigma: float | None = None,
    alpha: float | None = None,
) -> AntsApplyTransformsGaussianParameters:
    """
    Build parameters.
    
    Args:
        sigma: Sigma value.
        alpha: Alpha value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.gaussian",
    }
    if sigma is not None:
        params["sigma"] = sigma
    if alpha is not None:
        params["alpha"] = alpha
    return params


def ants_apply_transforms_gaussian_cargs(
    params: AntsApplyTransformsGaussianParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("sigma") is not None or params.get("alpha") is not None:
        cargs.append("Gaussian[sigma=" + (str(params.get("sigma")) if (params.get("sigma") is not None) else "") + ",alpha=" + (str(params.get("alpha")) if (params.get("alpha") is not None) else "") + "]")
    return cargs


def ants_apply_transforms_bspline_params(
    order: int | None = None,
) -> AntsApplyTransformsBsplineParameters:
    """
    Build parameters.
    
    Args:
        order: Order value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.bspline",
    }
    if order is not None:
        params["order"] = order
    return params


def ants_apply_transforms_bspline_cargs(
    params: AntsApplyTransformsBsplineParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("order") is not None:
        cargs.append("BSpline[order=" + str(params.get("order")) + "]")
    return cargs


def ants_apply_transforms_cosine_windowed_sinc_params(
) -> AntsApplyTransformsCosineWindowedSincParameters:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.cosineWindowedSinc",
    }
    return params


def ants_apply_transforms_cosine_windowed_sinc_cargs(
    params: AntsApplyTransformsCosineWindowedSincParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("CosineWindowedSinc")
    return cargs


def ants_apply_transforms_welch_windowed_sinc_params(
) -> AntsApplyTransformsWelchWindowedSincParameters:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.welchWindowedSinc",
    }
    return params


def ants_apply_transforms_welch_windowed_sinc_cargs(
    params: AntsApplyTransformsWelchWindowedSincParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("WelchWindowedSinc")
    return cargs


def ants_apply_transforms_hamming_windowed_sinc_params(
) -> AntsApplyTransformsHammingWindowedSincParameters:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.hammingWindowedSinc",
    }
    return params


def ants_apply_transforms_hamming_windowed_sinc_cargs(
    params: AntsApplyTransformsHammingWindowedSincParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("HammingWindowedSinc")
    return cargs


def ants_apply_transforms_lanczos_windowed_sinc_params(
) -> AntsApplyTransformsLanczosWindowedSincParameters:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.lanczosWindowedSinc",
    }
    return params


def ants_apply_transforms_lanczos_windowed_sinc_cargs(
    params: AntsApplyTransformsLanczosWindowedSincParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("LanczosWindowedSinc")
    return cargs


def ants_apply_transforms_generic_label_params(
    interpolator: str | None = None,
) -> AntsApplyTransformsGenericLabelParameters:
    """
    Build parameters.
    
    Args:
        interpolator: Interpolator value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.genericLabel",
    }
    if interpolator is not None:
        params["interpolator"] = interpolator
    return params


def ants_apply_transforms_generic_label_cargs(
    params: AntsApplyTransformsGenericLabelParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("interpolator") is not None:
        cargs.append("GenericLabel[interpolator=" + params.get("interpolator") + "]")
    return cargs


def ants_apply_transforms_transform_file_name_params(
    transform_file_name: InputPathType,
) -> AntsApplyTransformsTransformFileNameParameters:
    """
    Build parameters.
    
    Args:
        transform_file_name: Transform file name.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.transformFileName",
        "transformFileName": transform_file_name,
    }
    return params


def ants_apply_transforms_transform_file_name_cargs(
    params: AntsApplyTransformsTransformFileNameParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("transformFileName")))
    return cargs


def ants_apply_transforms_use_inverse_params(
    transform_file_name: InputPathType,
) -> AntsApplyTransformsUseInverseParameters:
    """
    Build parameters.
    
    Args:
        transform_file_name: Transform file name.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms.useInverse",
        "transformFileName": transform_file_name,
    }
    return params


def ants_apply_transforms_use_inverse_cargs(
    params: AntsApplyTransformsUseInverseParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + execution.input_file(params.get("transformFileName")) + ",useInverse]")
    return cargs


class AntsApplyTransformsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `ants_apply_transforms(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output: typing.Union[AntsApplyTransformsWarpedOutputOutputs, AntsApplyTransformsCompositeDisplacementFieldOutputOutputs, AntsApplyTransformsGenericAffineTransformOutputOutputs]
    """Outputs from `AntsApplyTransformsWarpedOutputParameters` or
    `AntsApplyTransformsCompositeDisplacementFieldOutputParameters` or
    `AntsApplyTransformsGenericAffineTransformOutputParameters`."""


def ants_apply_transforms_params(
    reference_image: InputPathType,
    output: typing.Union[AntsApplyTransformsWarpedOutputParameters, AntsApplyTransformsCompositeDisplacementFieldOutputParameters, AntsApplyTransformsGenericAffineTransformOutputParameters],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    input_image_type: typing.Literal[0, 1, 2, 3, 4, 5] | None = None,
    input_image: InputPathType | None = None,
    interpolation: typing.Union[AntsApplyTransformsLinearParameters, AntsApplyTransformsNearestNeighborParameters, AntsApplyTransformsMultiLabelnoparamsParameters, AntsApplyTransformsMultiLabelParameters, AntsApplyTransformsGaussianParameters, AntsApplyTransformsBsplineParameters, AntsApplyTransformsCosineWindowedSincParameters, AntsApplyTransformsWelchWindowedSincParameters, AntsApplyTransformsHammingWindowedSincParameters, AntsApplyTransformsLanczosWindowedSincParameters, AntsApplyTransformsGenericLabelParameters] | None = None,
    output_data_type: typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None = None,
    transform: list[typing.Union[AntsApplyTransformsTransformFileNameParameters, AntsApplyTransformsUseInverseParameters]] | None = None,
    default_value: float | None = None,
    static_cast_for_r: str | None = None,
    float_: typing.Literal[0, 1] | None = None,
    verbose: typing.Literal[0, 1] | None = None,
) -> AntsApplyTransformsParameters:
    """
    Build parameters.
    
    Args:
        reference_image: For warping input images, the reference image defines\
            the spacing, origin, size, and direction of the output warped image.
        output: One can either output the warped image or, if the boolean is\
            set, one can print out the displacement field based on the composite\
            transform and the reference image. A third option is to compose all\
            affine transforms and (if boolean is set) calculate its inverse which\
            is then written to an ITK file.
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. if not specified, antswarp tries to infer\
            the dimensionality from the input image.
        input_image_type: Option specifying the input image type of scalar\
            (default), vector, tensor, time series, or multi-channel. A time series\
            image is a scalar image defined by an additional dimension for the time\
            component whereas a multi-channel image is a vector image with only\
            spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
        input_image: Currently, the only input objects supported are image\
            objects. However, the current framework allows for warping of other\
            objects such as meshes and point sets.
        interpolation: Several interpolation options are available in ITK.\
            These have all been made available.
        output_data_type: Output image data type. This is a direct typecast;\
            output values are not rescaled. Default is to use the internal data\
            type (float or double). uchar is unsigned char; others are signed.\
            WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values\
            exceed the range allowed by your choice. Note that some pixel types are\
            not supported by some image formats. e.g. int is not supported by jpg.
        transform: Several transform options are supported including all those\
            defined in the ITK library in addition to a deformation field\
            transform. The ordering of the transformations follows the ordering\
            specified on the command line. An identity transform is pushed onto the\
            transformation stack. Each new transform encountered on the command\
            line is also pushed onto the transformation stack. Then, to warp the\
            input object, each point comprising the input object is warped first\
            according to the last transform pushed onto the stack followed by the\
            second to last transform, etc. until the last transform encountered\
            which is the identity transform. Also, it should be noted that the\
            inverse transform can be accommodated with the usual caveat that such\
            an inverse must be defined by the specified transform class.
        default_value: Default voxel value to be used with input images only.\
            Specifies the voxel value when the input point maps outside the output\
            domain. With tensor input images, specifies the default voxel\
            eigenvalues.
        static_cast_for_r: Forces static cast in ReadTransform (for R).
        float_: Use float instead of double for computations.
        verbose: Verbose output.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants.antsApplyTransforms",
        "reference_image": reference_image,
        "output": output,
    }
    if dimensionality is not None:
        params["dimensionality"] = dimensionality
    if input_image_type is not None:
        params["input_image_type"] = input_image_type
    if input_image is not None:
        params["input_image"] = input_image
    if interpolation is not None:
        params["interpolation"] = interpolation
    if output_data_type is not None:
        params["output_data_type"] = output_data_type
    if transform is not None:
        params["transform"] = transform
    if default_value is not None:
        params["default_value"] = default_value
    if static_cast_for_r is not None:
        params["static_cast_for_R"] = static_cast_for_r
    if float_ is not None:
        params["float"] = float_
    if verbose is not None:
        params["verbose"] = verbose
    return params


def ants_apply_transforms_cargs(
    params: AntsApplyTransformsParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("antsApplyTransforms")
    if params.get("dimensionality") is not None:
        cargs.extend([
            "--dimensionality",
            str(params.get("dimensionality"))
        ])
    if params.get("input_image_type") is not None:
        cargs.extend([
            "--input-image-type",
            str(params.get("input_image_type"))
        ])
    if params.get("input_image") is not None:
        cargs.extend([
            "--input",
            execution.input_file(params.get("input_image"))
        ])
    cargs.extend([
        "--reference-image",
        execution.input_file(params.get("reference_image"))
    ])
    cargs.extend([
        "--output",
        *dyn_cargs(params.get("output")["@type"])(params.get("output"), execution)
    ])
    if params.get("interpolation") is not None:
        cargs.extend([
            "--interpolation",
            *dyn_cargs(params.get("interpolation")["@type"])(params.get("interpolation"), execution)
        ])
    if params.get("output_data_type") is not None:
        cargs.extend([
            "--output-data-type",
            params.get("output_data_type")
        ])
    if params.get("transform") is not None:
        cargs.extend([
            "--transform",
            *[a for c in [dyn_cargs(s["@type"])(s, execution) for s in params.get("transform")] for a in c]
        ])
    if params.get("default_value") is not None:
        cargs.extend([
            "--default-value",
            str(params.get("default_value"))
        ])
    if params.get("static_cast_for_R") is not None:
        cargs.extend([
            "--static-cast-for-R",
            params.get("static_cast_for_R")
        ])
    if params.get("float") is not None:
        cargs.extend([
            "--float",
            str(params.get("float"))
        ])
    if params.get("verbose") is not None:
        cargs.extend([
            "--verbose",
            str(params.get("verbose"))
        ])
    return cargs


def ants_apply_transforms_outputs(
    params: AntsApplyTransformsParameters,
    execution: Execution,
) -> AntsApplyTransformsOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsOutputs(
        root=execution.output_file("."),
        output=dyn_outputs(params.get("output")["@type"])(params.get("output"), execution),
    )
    return ret


def ants_apply_transforms_execute(
    params: AntsApplyTransformsParameters,
    execution: Execution,
) -> AntsApplyTransformsOutputs:
    """
    antsApplyTransforms, applied to an input image, transforms it according to a
    reference image and a transform (or a set of transforms).
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        params: The parameters.
        execution: The execution object.
    Returns:
        NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
    """
    params = execution.params(params)
    cargs = ants_apply_transforms_cargs(params, execution)
    ret = ants_apply_transforms_outputs(params, execution)
    execution.run(cargs)
    return ret


def ants_apply_transforms(
    reference_image: InputPathType,
    output: typing.Union[AntsApplyTransformsWarpedOutputParameters, AntsApplyTransformsCompositeDisplacementFieldOutputParameters, AntsApplyTransformsGenericAffineTransformOutputParameters],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    input_image_type: typing.Literal[0, 1, 2, 3, 4, 5] | None = None,
    input_image: InputPathType | None = None,
    interpolation: typing.Union[AntsApplyTransformsLinearParameters, AntsApplyTransformsNearestNeighborParameters, AntsApplyTransformsMultiLabelnoparamsParameters, AntsApplyTransformsMultiLabelParameters, AntsApplyTransformsGaussianParameters, AntsApplyTransformsBsplineParameters, AntsApplyTransformsCosineWindowedSincParameters, AntsApplyTransformsWelchWindowedSincParameters, AntsApplyTransformsHammingWindowedSincParameters, AntsApplyTransformsLanczosWindowedSincParameters, AntsApplyTransformsGenericLabelParameters] | None = None,
    output_data_type: typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None = None,
    transform: list[typing.Union[AntsApplyTransformsTransformFileNameParameters, AntsApplyTransformsUseInverseParameters]] | None = None,
    default_value: float | None = None,
    static_cast_for_r: str | None = None,
    float_: typing.Literal[0, 1] | None = None,
    verbose: typing.Literal[0, 1] | None = None,
    runner: Runner | None = None,
) -> AntsApplyTransformsOutputs:
    """
    antsApplyTransforms, applied to an input image, transforms it according to a
    reference image and a transform (or a set of transforms).
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        reference_image: For warping input images, the reference image defines\
            the spacing, origin, size, and direction of the output warped image.
        output: One can either output the warped image or, if the boolean is\
            set, one can print out the displacement field based on the composite\
            transform and the reference image. A third option is to compose all\
            affine transforms and (if boolean is set) calculate its inverse which\
            is then written to an ITK file.
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. if not specified, antswarp tries to infer\
            the dimensionality from the input image.
        input_image_type: Option specifying the input image type of scalar\
            (default), vector, tensor, time series, or multi-channel. A time series\
            image is a scalar image defined by an additional dimension for the time\
            component whereas a multi-channel image is a vector image with only\
            spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
        input_image: Currently, the only input objects supported are image\
            objects. However, the current framework allows for warping of other\
            objects such as meshes and point sets.
        interpolation: Several interpolation options are available in ITK.\
            These have all been made available.
        output_data_type: Output image data type. This is a direct typecast;\
            output values are not rescaled. Default is to use the internal data\
            type (float or double). uchar is unsigned char; others are signed.\
            WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values\
            exceed the range allowed by your choice. Note that some pixel types are\
            not supported by some image formats. e.g. int is not supported by jpg.
        transform: Several transform options are supported including all those\
            defined in the ITK library in addition to a deformation field\
            transform. The ordering of the transformations follows the ordering\
            specified on the command line. An identity transform is pushed onto the\
            transformation stack. Each new transform encountered on the command\
            line is also pushed onto the transformation stack. Then, to warp the\
            input object, each point comprising the input object is warped first\
            according to the last transform pushed onto the stack followed by the\
            second to last transform, etc. until the last transform encountered\
            which is the identity transform. Also, it should be noted that the\
            inverse transform can be accommodated with the usual caveat that such\
            an inverse must be defined by the specified transform class.
        default_value: Default voxel value to be used with input images only.\
            Specifies the voxel value when the input point maps outside the output\
            domain. With tensor input images, specifies the default voxel\
            eigenvalues.
        static_cast_for_r: Forces static cast in ReadTransform (for R).
        float_: Use float instead of double for computations.
        verbose: Verbose output.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(ANTS_APPLY_TRANSFORMS_METADATA)
    params = ants_apply_transforms_params(
        dimensionality=dimensionality,
        input_image_type=input_image_type,
        input_image=input_image,
        reference_image=reference_image,
        output=output,
        interpolation=interpolation,
        output_data_type=output_data_type,
        transform=transform,
        default_value=default_value,
        static_cast_for_r=static_cast_for_r,
        float_=float_,
        verbose=verbose,
    )
    return ants_apply_transforms_execute(params, execution)


__all__ = [
    "ANTS_APPLY_TRANSFORMS_METADATA",
    "AntsApplyTransformsAlphaParameters",
    "AntsApplyTransformsBsplineParameters",
    "AntsApplyTransformsCompositeDisplacementFieldOutputOutputs",
    "AntsApplyTransformsCompositeDisplacementFieldOutputParameters",
    "AntsApplyTransformsCosineWindowedSincParameters",
    "AntsApplyTransformsGaussianParameters",
    "AntsApplyTransformsGenericAffineTransformOutputOutputs",
    "AntsApplyTransformsGenericAffineTransformOutputParameters",
    "AntsApplyTransformsGenericLabelParameters",
    "AntsApplyTransformsHammingWindowedSincParameters",
    "AntsApplyTransformsLanczosWindowedSincParameters",
    "AntsApplyTransformsLinearParameters",
    "AntsApplyTransformsMultiLabelParameters",
    "AntsApplyTransformsMultiLabelnoparamsParameters",
    "AntsApplyTransformsNearestNeighborParameters",
    "AntsApplyTransformsOutputs",
    "AntsApplyTransformsParamParameters",
    "AntsApplyTransformsParameters",
    "AntsApplyTransformsSigmaParameters",
    "AntsApplyTransformsTransformFileNameParameters",
    "AntsApplyTransformsUseInverseParameters",
    "AntsApplyTransformsWarpedOutputOutputs",
    "AntsApplyTransformsWarpedOutputParameters",
    "AntsApplyTransformsWelchWindowedSincParameters",
    "ants_apply_transforms",
    "ants_apply_transforms_alpha_cargs",
    "ants_apply_transforms_alpha_params",
    "ants_apply_transforms_bspline_cargs",
    "ants_apply_transforms_bspline_params",
    "ants_apply_transforms_cargs",
    "ants_apply_transforms_composite_displacement_field_output_cargs",
    "ants_apply_transforms_composite_displacement_field_output_outputs",
    "ants_apply_transforms_composite_displacement_field_output_params",
    "ants_apply_transforms_cosine_windowed_sinc_cargs",
    "ants_apply_transforms_cosine_windowed_sinc_params",
    "ants_apply_transforms_execute",
    "ants_apply_transforms_gaussian_cargs",
    "ants_apply_transforms_gaussian_params",
    "ants_apply_transforms_generic_affine_transform_output_cargs",
    "ants_apply_transforms_generic_affine_transform_output_outputs",
    "ants_apply_transforms_generic_affine_transform_output_params",
    "ants_apply_transforms_generic_label_cargs",
    "ants_apply_transforms_generic_label_params",
    "ants_apply_transforms_hamming_windowed_sinc_cargs",
    "ants_apply_transforms_hamming_windowed_sinc_params",
    "ants_apply_transforms_lanczos_windowed_sinc_cargs",
    "ants_apply_transforms_lanczos_windowed_sinc_params",
    "ants_apply_transforms_linear_cargs",
    "ants_apply_transforms_linear_params",
    "ants_apply_transforms_multi_label_cargs",
    "ants_apply_transforms_multi_label_params",
    "ants_apply_transforms_multi_labelnoparams_cargs",
    "ants_apply_transforms_multi_labelnoparams_params",
    "ants_apply_transforms_nearest_neighbor_cargs",
    "ants_apply_transforms_nearest_neighbor_params",
    "ants_apply_transforms_outputs",
    "ants_apply_transforms_param_cargs",
    "ants_apply_transforms_param_params",
    "ants_apply_transforms_params",
    "ants_apply_transforms_sigma_cargs",
    "ants_apply_transforms_sigma_params",
    "ants_apply_transforms_transform_file_name_cargs",
    "ants_apply_transforms_transform_file_name_params",
    "ants_apply_transforms_use_inverse_cargs",
    "ants_apply_transforms_use_inverse_params",
    "ants_apply_transforms_warped_output_cargs",
    "ants_apply_transforms_warped_output_outputs",
    "ants_apply_transforms_warped_output_params",
    "ants_apply_transforms_welch_windowed_sinc_cargs",
    "ants_apply_transforms_welch_windowed_sinc_params",
]
