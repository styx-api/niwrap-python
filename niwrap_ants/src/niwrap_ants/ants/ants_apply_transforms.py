# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

ANTS_APPLY_TRANSFORMS_METADATA = Metadata(
    id="b2a458e411cfbc6687dbc4a31f95f2b6ac33d716.boutiques",
    name="antsApplyTransforms",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


_AntsApplyTransformsWarpedOutputParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsWarpedOutputParamsDictNoTag', {
    "warpedOutputFileName": str,
})
AntsApplyTransformsWarpedOutputParamsDictTagged = typing.TypedDict('AntsApplyTransformsWarpedOutputParamsDictTagged', {
    "@type": typing.Literal["warpedOutput"],
    "warpedOutputFileName": str,
})
AntsApplyTransformsWarpedOutputParamsDict = _AntsApplyTransformsWarpedOutputParamsDictNoTag | AntsApplyTransformsWarpedOutputParamsDictTagged


_AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictNoTag', {
    "compositeDisplacementField": str,
    "printOutCompositeWarpFile": typing.NotRequired[bool | None],
})
AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged = typing.TypedDict('AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged', {
    "@type": typing.Literal["compositeDisplacementFieldOutput"],
    "compositeDisplacementField": str,
    "printOutCompositeWarpFile": typing.NotRequired[bool | None],
})
AntsApplyTransformsCompositeDisplacementFieldOutputParamsDict = _AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictNoTag | AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged


_AntsApplyTransformsGenericAffineTransformOutputParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsGenericAffineTransformOutputParamsDictNoTag', {
    "genericAffineTransformFile": str,
    "calculateInverse": typing.NotRequired[bool | None],
})
AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged = typing.TypedDict('AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged', {
    "@type": typing.Literal["genericAffineTransformOutput"],
    "genericAffineTransformFile": str,
    "calculateInverse": typing.NotRequired[bool | None],
})
AntsApplyTransformsGenericAffineTransformOutputParamsDict = _AntsApplyTransformsGenericAffineTransformOutputParamsDictNoTag | AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged


_AntsApplyTransformsLinearParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsLinearParamsDictNoTag', {})
AntsApplyTransformsLinearParamsDictTagged = typing.TypedDict('AntsApplyTransformsLinearParamsDictTagged', {
    "@type": typing.Literal["linear"],
})
AntsApplyTransformsLinearParamsDict = _AntsApplyTransformsLinearParamsDictNoTag | AntsApplyTransformsLinearParamsDictTagged


_AntsApplyTransformsNearestNeighborParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsNearestNeighborParamsDictNoTag', {})
AntsApplyTransformsNearestNeighborParamsDictTagged = typing.TypedDict('AntsApplyTransformsNearestNeighborParamsDictTagged', {
    "@type": typing.Literal["nearestNeighbor"],
})
AntsApplyTransformsNearestNeighborParamsDict = _AntsApplyTransformsNearestNeighborParamsDictNoTag | AntsApplyTransformsNearestNeighborParamsDictTagged


_AntsApplyTransformsMultiLabelnoparamsParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsMultiLabelnoparamsParamsDictNoTag', {})
AntsApplyTransformsMultiLabelnoparamsParamsDictTagged = typing.TypedDict('AntsApplyTransformsMultiLabelnoparamsParamsDictTagged', {
    "@type": typing.Literal["multiLabelnoparams"],
})
AntsApplyTransformsMultiLabelnoparamsParamsDict = _AntsApplyTransformsMultiLabelnoparamsParamsDictNoTag | AntsApplyTransformsMultiLabelnoparamsParamsDictTagged


_AntsApplyTransformsSigmaParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsSigmaParamsDictNoTag', {
    "sigma": float,
})
AntsApplyTransformsSigmaParamsDictTagged = typing.TypedDict('AntsApplyTransformsSigmaParamsDictTagged', {
    "@type": typing.Literal["sigma"],
    "sigma": float,
})
AntsApplyTransformsSigmaParamsDict = _AntsApplyTransformsSigmaParamsDictNoTag | AntsApplyTransformsSigmaParamsDictTagged


_AntsApplyTransformsAlphaParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsAlphaParamsDictNoTag', {
    "alpha": float,
})
AntsApplyTransformsAlphaParamsDictTagged = typing.TypedDict('AntsApplyTransformsAlphaParamsDictTagged', {
    "@type": typing.Literal["alpha"],
    "alpha": float,
})
AntsApplyTransformsAlphaParamsDict = _AntsApplyTransformsAlphaParamsDictNoTag | AntsApplyTransformsAlphaParamsDictTagged


_AntsApplyTransformsParamParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsParamParamsDictNoTag', {
    "params": list[typing.Union[AntsApplyTransformsSigmaParamsDictTagged, AntsApplyTransformsAlphaParamsDictTagged]],
})
AntsApplyTransformsParamParamsDictTagged = typing.TypedDict('AntsApplyTransformsParamParamsDictTagged', {
    "@type": typing.Literal["param"],
    "params": list[typing.Union[AntsApplyTransformsSigmaParamsDictTagged, AntsApplyTransformsAlphaParamsDictTagged]],
})
AntsApplyTransformsParamParamsDict = _AntsApplyTransformsParamParamsDictNoTag | AntsApplyTransformsParamParamsDictTagged


_AntsApplyTransformsMultiLabelParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsMultiLabelParamsDictNoTag', {
    "params": AntsApplyTransformsParamParamsDict,
})
AntsApplyTransformsMultiLabelParamsDictTagged = typing.TypedDict('AntsApplyTransformsMultiLabelParamsDictTagged', {
    "@type": typing.Literal["multiLabel"],
    "params": AntsApplyTransformsParamParamsDict,
})
AntsApplyTransformsMultiLabelParamsDict = _AntsApplyTransformsMultiLabelParamsDictNoTag | AntsApplyTransformsMultiLabelParamsDictTagged


_AntsApplyTransformsGaussianParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsGaussianParamsDictNoTag', {
    "sigma": typing.NotRequired[float | None],
    "alpha": typing.NotRequired[float | None],
})
AntsApplyTransformsGaussianParamsDictTagged = typing.TypedDict('AntsApplyTransformsGaussianParamsDictTagged', {
    "@type": typing.Literal["gaussian"],
    "sigma": typing.NotRequired[float | None],
    "alpha": typing.NotRequired[float | None],
})
AntsApplyTransformsGaussianParamsDict = _AntsApplyTransformsGaussianParamsDictNoTag | AntsApplyTransformsGaussianParamsDictTagged


_AntsApplyTransformsBsplineParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsBsplineParamsDictNoTag', {
    "order": typing.NotRequired[int | None],
})
AntsApplyTransformsBsplineParamsDictTagged = typing.TypedDict('AntsApplyTransformsBsplineParamsDictTagged', {
    "@type": typing.Literal["bspline"],
    "order": typing.NotRequired[int | None],
})
AntsApplyTransformsBsplineParamsDict = _AntsApplyTransformsBsplineParamsDictNoTag | AntsApplyTransformsBsplineParamsDictTagged


_AntsApplyTransformsCosineWindowedSincParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsCosineWindowedSincParamsDictNoTag', {})
AntsApplyTransformsCosineWindowedSincParamsDictTagged = typing.TypedDict('AntsApplyTransformsCosineWindowedSincParamsDictTagged', {
    "@type": typing.Literal["cosineWindowedSinc"],
})
AntsApplyTransformsCosineWindowedSincParamsDict = _AntsApplyTransformsCosineWindowedSincParamsDictNoTag | AntsApplyTransformsCosineWindowedSincParamsDictTagged


_AntsApplyTransformsWelchWindowedSincParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsWelchWindowedSincParamsDictNoTag', {})
AntsApplyTransformsWelchWindowedSincParamsDictTagged = typing.TypedDict('AntsApplyTransformsWelchWindowedSincParamsDictTagged', {
    "@type": typing.Literal["welchWindowedSinc"],
})
AntsApplyTransformsWelchWindowedSincParamsDict = _AntsApplyTransformsWelchWindowedSincParamsDictNoTag | AntsApplyTransformsWelchWindowedSincParamsDictTagged


_AntsApplyTransformsHammingWindowedSincParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsHammingWindowedSincParamsDictNoTag', {})
AntsApplyTransformsHammingWindowedSincParamsDictTagged = typing.TypedDict('AntsApplyTransformsHammingWindowedSincParamsDictTagged', {
    "@type": typing.Literal["hammingWindowedSinc"],
})
AntsApplyTransformsHammingWindowedSincParamsDict = _AntsApplyTransformsHammingWindowedSincParamsDictNoTag | AntsApplyTransformsHammingWindowedSincParamsDictTagged


_AntsApplyTransformsLanczosWindowedSincParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsLanczosWindowedSincParamsDictNoTag', {})
AntsApplyTransformsLanczosWindowedSincParamsDictTagged = typing.TypedDict('AntsApplyTransformsLanczosWindowedSincParamsDictTagged', {
    "@type": typing.Literal["lanczosWindowedSinc"],
})
AntsApplyTransformsLanczosWindowedSincParamsDict = _AntsApplyTransformsLanczosWindowedSincParamsDictNoTag | AntsApplyTransformsLanczosWindowedSincParamsDictTagged


_AntsApplyTransformsGenericLabelParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsGenericLabelParamsDictNoTag', {
    "interpolator": typing.NotRequired[str | None],
})
AntsApplyTransformsGenericLabelParamsDictTagged = typing.TypedDict('AntsApplyTransformsGenericLabelParamsDictTagged', {
    "@type": typing.Literal["genericLabel"],
    "interpolator": typing.NotRequired[str | None],
})
AntsApplyTransformsGenericLabelParamsDict = _AntsApplyTransformsGenericLabelParamsDictNoTag | AntsApplyTransformsGenericLabelParamsDictTagged


_AntsApplyTransformsTransformFileNameParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsTransformFileNameParamsDictNoTag', {
    "transformFileName": InputPathType,
})
AntsApplyTransformsTransformFileNameParamsDictTagged = typing.TypedDict('AntsApplyTransformsTransformFileNameParamsDictTagged', {
    "@type": typing.Literal["transformFileName"],
    "transformFileName": InputPathType,
})
AntsApplyTransformsTransformFileNameParamsDict = _AntsApplyTransformsTransformFileNameParamsDictNoTag | AntsApplyTransformsTransformFileNameParamsDictTagged


_AntsApplyTransformsUseInverseParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsUseInverseParamsDictNoTag', {
    "transformFileName": InputPathType,
})
AntsApplyTransformsUseInverseParamsDictTagged = typing.TypedDict('AntsApplyTransformsUseInverseParamsDictTagged', {
    "@type": typing.Literal["useInverse"],
    "transformFileName": InputPathType,
})
AntsApplyTransformsUseInverseParamsDict = _AntsApplyTransformsUseInverseParamsDictNoTag | AntsApplyTransformsUseInverseParamsDictTagged


_AntsApplyTransformsParamsDictNoTag = typing.TypedDict('_AntsApplyTransformsParamsDictNoTag', {
    "dimensionality": typing.NotRequired[typing.Literal[2, 3, 4] | None],
    "input_image_type": typing.NotRequired[typing.Literal[0, 1, 2, 3, 4, 5] | None],
    "input_image": typing.NotRequired[InputPathType | None],
    "reference_image": InputPathType,
    "output": typing.Union[AntsApplyTransformsWarpedOutputParamsDictTagged, AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged, AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged],
    "interpolation": typing.NotRequired[typing.Union[AntsApplyTransformsLinearParamsDictTagged, AntsApplyTransformsNearestNeighborParamsDictTagged, AntsApplyTransformsMultiLabelnoparamsParamsDictTagged, AntsApplyTransformsMultiLabelParamsDictTagged, AntsApplyTransformsGaussianParamsDictTagged, AntsApplyTransformsBsplineParamsDictTagged, AntsApplyTransformsCosineWindowedSincParamsDictTagged, AntsApplyTransformsWelchWindowedSincParamsDictTagged, AntsApplyTransformsHammingWindowedSincParamsDictTagged, AntsApplyTransformsLanczosWindowedSincParamsDictTagged, AntsApplyTransformsGenericLabelParamsDictTagged] | None],
    "output_data_type": typing.NotRequired[typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None],
    "transform": typing.NotRequired[list[typing.Union[AntsApplyTransformsTransformFileNameParamsDictTagged, AntsApplyTransformsUseInverseParamsDictTagged]] | None],
    "default_value": typing.NotRequired[float | None],
    "static_cast_for_R": typing.NotRequired[str | None],
    "float": typing.NotRequired[bool | None],
    "verbose": typing.NotRequired[bool | None],
})
AntsApplyTransformsParamsDictTagged = typing.TypedDict('AntsApplyTransformsParamsDictTagged', {
    "@type": typing.Literal["ants/antsApplyTransforms"],
    "dimensionality": typing.NotRequired[typing.Literal[2, 3, 4] | None],
    "input_image_type": typing.NotRequired[typing.Literal[0, 1, 2, 3, 4, 5] | None],
    "input_image": typing.NotRequired[InputPathType | None],
    "reference_image": InputPathType,
    "output": typing.Union[AntsApplyTransformsWarpedOutputParamsDictTagged, AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged, AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged],
    "interpolation": typing.NotRequired[typing.Union[AntsApplyTransformsLinearParamsDictTagged, AntsApplyTransformsNearestNeighborParamsDictTagged, AntsApplyTransformsMultiLabelnoparamsParamsDictTagged, AntsApplyTransformsMultiLabelParamsDictTagged, AntsApplyTransformsGaussianParamsDictTagged, AntsApplyTransformsBsplineParamsDictTagged, AntsApplyTransformsCosineWindowedSincParamsDictTagged, AntsApplyTransformsWelchWindowedSincParamsDictTagged, AntsApplyTransformsHammingWindowedSincParamsDictTagged, AntsApplyTransformsLanczosWindowedSincParamsDictTagged, AntsApplyTransformsGenericLabelParamsDictTagged] | None],
    "output_data_type": typing.NotRequired[typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None],
    "transform": typing.NotRequired[list[typing.Union[AntsApplyTransformsTransformFileNameParamsDictTagged, AntsApplyTransformsUseInverseParamsDictTagged]] | None],
    "default_value": typing.NotRequired[float | None],
    "static_cast_for_R": typing.NotRequired[str | None],
    "float": typing.NotRequired[bool | None],
    "verbose": typing.NotRequired[bool | None],
})
AntsApplyTransformsParamsDict = _AntsApplyTransformsParamsDictNoTag | AntsApplyTransformsParamsDictTagged


def ants_apply_transforms_output_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "warpedOutput": ants_apply_transforms_warped_output_cargs,
        "compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_cargs,
        "genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_cargs,
    }.get(t)


def ants_apply_transforms_output_outputs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build outputs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build outputs function.
    """
    return {
        "warpedOutput": ants_apply_transforms_warped_output_outputs,
        "compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_outputs,
        "genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_outputs,
    }.get(t)


def ants_apply_transforms_output_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "warpedOutput": ants_apply_transforms_warped_output_validate,
        "compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_validate,
        "genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_validate,
    }.get(t)


def ants_apply_transforms_interpolation_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "linear": ants_apply_transforms_linear_cargs,
        "nearestNeighbor": ants_apply_transforms_nearest_neighbor_cargs,
        "multiLabelnoparams": ants_apply_transforms_multi_labelnoparams_cargs,
        "multiLabel": ants_apply_transforms_multi_label_cargs,
        "gaussian": ants_apply_transforms_gaussian_cargs,
        "bspline": ants_apply_transforms_bspline_cargs,
        "cosineWindowedSinc": ants_apply_transforms_cosine_windowed_sinc_cargs,
        "welchWindowedSinc": ants_apply_transforms_welch_windowed_sinc_cargs,
        "hammingWindowedSinc": ants_apply_transforms_hamming_windowed_sinc_cargs,
        "lanczosWindowedSinc": ants_apply_transforms_lanczos_windowed_sinc_cargs,
        "genericLabel": ants_apply_transforms_generic_label_cargs,
    }.get(t)


def ants_apply_transforms_interpolation_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "linear": ants_apply_transforms_linear_validate,
        "nearestNeighbor": ants_apply_transforms_nearest_neighbor_validate,
        "multiLabelnoparams": ants_apply_transforms_multi_labelnoparams_validate,
        "multiLabel": ants_apply_transforms_multi_label_validate,
        "gaussian": ants_apply_transforms_gaussian_validate,
        "bspline": ants_apply_transforms_bspline_validate,
        "cosineWindowedSinc": ants_apply_transforms_cosine_windowed_sinc_validate,
        "welchWindowedSinc": ants_apply_transforms_welch_windowed_sinc_validate,
        "hammingWindowedSinc": ants_apply_transforms_hamming_windowed_sinc_validate,
        "lanczosWindowedSinc": ants_apply_transforms_lanczos_windowed_sinc_validate,
        "genericLabel": ants_apply_transforms_generic_label_validate,
    }.get(t)


def ants_apply_transforms_params_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "sigma": ants_apply_transforms_sigma_cargs,
        "alpha": ants_apply_transforms_alpha_cargs,
    }.get(t)


def ants_apply_transforms_params_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "sigma": ants_apply_transforms_sigma_validate,
        "alpha": ants_apply_transforms_alpha_validate,
    }.get(t)


def ants_apply_transforms_transform_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "transformFileName": ants_apply_transforms_transform_file_name_cargs,
        "useInverse": ants_apply_transforms_use_inverse_cargs,
    }.get(t)


def ants_apply_transforms_transform_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "transformFileName": ants_apply_transforms_transform_file_name_validate,
        "useInverse": ants_apply_transforms_use_inverse_validate,
    }.get(t)


class AntsApplyTransformsWarpedOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsApplyTransformsWarpedOutputParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


def ants_apply_transforms_warped_output(
    warped_output_file_name: str,
) -> AntsApplyTransformsWarpedOutputParamsDictTagged:
    """
    Build parameters.
    
    Args:
        warped_output_file_name: Output file name.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "warpedOutput",
        "warpedOutputFileName": warped_output_file_name,
    }
    return params


def ants_apply_transforms_warped_output_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsWarpedOutputParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("warpedOutputFileName", None) is None:
        raise StyxValidationError("`warpedOutputFileName` must not be None")
    if not isinstance(params["warpedOutputFileName"], str):
        raise StyxValidationError(f'`warpedOutputFileName` has the wrong type: Received `{type(params.get("warpedOutputFileName", None))}` expected `str`')


def ants_apply_transforms_warped_output_cargs(
    params: AntsApplyTransformsWarpedOutputParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("warpedOutputFileName", None))
    return cargs


def ants_apply_transforms_warped_output_outputs(
    params: AntsApplyTransformsWarpedOutputParamsDict,
    execution: Execution,
) -> AntsApplyTransformsWarpedOutputOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsWarpedOutputOutputs(
        root=execution.output_file("."),
        output_image_outfile=execution.output_file(params.get("warpedOutputFileName", None)),
    )
    return ret


class AntsApplyTransformsCompositeDisplacementFieldOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsApplyTransformsCompositeDisplacementFieldOutputParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


def ants_apply_transforms_composite_displacement_field_output(
    composite_displacement_field: str,
    print_out_composite_warp_file: bool | None = None,
) -> AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged:
    """
    Build parameters.
    
    Args:
        composite_displacement_field: Output file name.
        print_out_composite_warp_file: Output a composite warp file instead of\
            a transformed image.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "compositeDisplacementFieldOutput",
        "compositeDisplacementField": composite_displacement_field,
    }
    if print_out_composite_warp_file is not None:
        params["printOutCompositeWarpFile"] = print_out_composite_warp_file
    return params


def ants_apply_transforms_composite_displacement_field_output_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsCompositeDisplacementFieldOutputParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("compositeDisplacementField", None) is None:
        raise StyxValidationError("`compositeDisplacementField` must not be None")
    if not isinstance(params["compositeDisplacementField"], str):
        raise StyxValidationError(f'`compositeDisplacementField` has the wrong type: Received `{type(params.get("compositeDisplacementField", None))}` expected `str`')
    if params.get("printOutCompositeWarpFile", None) is not None:
        if not isinstance(params["printOutCompositeWarpFile"], bool):
            raise StyxValidationError(f'`printOutCompositeWarpFile` has the wrong type: Received `{type(params.get("printOutCompositeWarpFile", None))}` expected `bool | None`')


def ants_apply_transforms_composite_displacement_field_output_cargs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + params.get("compositeDisplacementField", None) + ",printOutCompositeWarpFile=" + (("1" if params.get("printOutCompositeWarpFile", None) else "0") if (params.get("printOutCompositeWarpFile", None) is not None) else "") + "]")
    return cargs


def ants_apply_transforms_composite_displacement_field_output_outputs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParamsDict,
    execution: Execution,
) -> AntsApplyTransformsCompositeDisplacementFieldOutputOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsCompositeDisplacementFieldOutputOutputs(
        root=execution.output_file("."),
        output_image_outfile=execution.output_file(params.get("compositeDisplacementField", None)),
    )
    return ret


class AntsApplyTransformsGenericAffineTransformOutputOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsApplyTransformsGenericAffineTransformOutputParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_image_outfile: OutputPathType
    """Warped image."""


def ants_apply_transforms_generic_affine_transform_output(
    generic_affine_transform_file: str,
    calculate_inverse: bool | None = None,
) -> AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged:
    """
    Build parameters.
    
    Args:
        generic_affine_transform_file: Output file name.
        calculate_inverse: Calculate the inverse of the affine transform.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "genericAffineTransformOutput",
        "genericAffineTransformFile": generic_affine_transform_file,
    }
    if calculate_inverse is not None:
        params["calculateInverse"] = calculate_inverse
    return params


def ants_apply_transforms_generic_affine_transform_output_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsGenericAffineTransformOutputParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("genericAffineTransformFile", None) is None:
        raise StyxValidationError("`genericAffineTransformFile` must not be None")
    if not isinstance(params["genericAffineTransformFile"], str):
        raise StyxValidationError(f'`genericAffineTransformFile` has the wrong type: Received `{type(params.get("genericAffineTransformFile", None))}` expected `str`')
    if params.get("calculateInverse", None) is not None:
        if not isinstance(params["calculateInverse"], bool):
            raise StyxValidationError(f'`calculateInverse` has the wrong type: Received `{type(params.get("calculateInverse", None))}` expected `bool | None`')


def ants_apply_transforms_generic_affine_transform_output_cargs(
    params: AntsApplyTransformsGenericAffineTransformOutputParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Linear[" + params.get("genericAffineTransformFile", None) + ",calculateInverse=" + (("1" if params.get("calculateInverse", None) else "0") if (params.get("calculateInverse", None) is not None) else "") + "]")
    return cargs


def ants_apply_transforms_generic_affine_transform_output_outputs(
    params: AntsApplyTransformsGenericAffineTransformOutputParamsDict,
    execution: Execution,
) -> AntsApplyTransformsGenericAffineTransformOutputOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsGenericAffineTransformOutputOutputs(
        root=execution.output_file("."),
        output_image_outfile=execution.output_file(params.get("genericAffineTransformFile", None)),
    )
    return ret


def ants_apply_transforms_linear(
) -> AntsApplyTransformsLinearParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "linear",
    }
    return params


def ants_apply_transforms_linear_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsLinearParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def ants_apply_transforms_linear_cargs(
    params: AntsApplyTransformsLinearParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Linear")
    return cargs


def ants_apply_transforms_nearest_neighbor(
) -> AntsApplyTransformsNearestNeighborParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "nearestNeighbor",
    }
    return params


def ants_apply_transforms_nearest_neighbor_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsNearestNeighborParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def ants_apply_transforms_nearest_neighbor_cargs(
    params: AntsApplyTransformsNearestNeighborParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("NearestNeighbor")
    return cargs


def ants_apply_transforms_multi_labelnoparams(
) -> AntsApplyTransformsMultiLabelnoparamsParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "multiLabelnoparams",
    }
    return params


def ants_apply_transforms_multi_labelnoparams_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsMultiLabelnoparamsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def ants_apply_transforms_multi_labelnoparams_cargs(
    params: AntsApplyTransformsMultiLabelnoparamsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("MultiLabel")
    return cargs


def ants_apply_transforms_sigma(
    sigma: float,
) -> AntsApplyTransformsSigmaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sigma: Sigma value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sigma",
        "sigma": sigma,
    }
    return params


def ants_apply_transforms_sigma_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsSigmaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sigma", None) is None:
        raise StyxValidationError("`sigma` must not be None")
    if not isinstance(params["sigma"], (float, int)):
        raise StyxValidationError(f'`sigma` has the wrong type: Received `{type(params.get("sigma", None))}` expected `float`')


def ants_apply_transforms_sigma_cargs(
    params: AntsApplyTransformsSigmaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("sigma=" + str(params.get("sigma", None)))
    return cargs


def ants_apply_transforms_alpha(
    alpha: float,
) -> AntsApplyTransformsAlphaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        alpha: Alpha value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "alpha",
        "alpha": alpha,
    }
    return params


def ants_apply_transforms_alpha_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsAlphaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("alpha", None) is None:
        raise StyxValidationError("`alpha` must not be None")
    if not isinstance(params["alpha"], (float, int)):
        raise StyxValidationError(f'`alpha` has the wrong type: Received `{type(params.get("alpha", None))}` expected `float`')


def ants_apply_transforms_alpha_cargs(
    params: AntsApplyTransformsAlphaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("alpha=" + str(params.get("alpha", None)))
    return cargs


def ants_apply_transforms_param(
    params_: list[typing.Union[AntsApplyTransformsSigmaParamsDictTagged, AntsApplyTransformsAlphaParamsDictTagged]],
) -> AntsApplyTransformsParamParamsDictTagged:
    """
    Build parameters.
    
    Args:
        params_:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "param",
        "params": params_,
    }
    return params


def ants_apply_transforms_param_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsParamParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("params", None) is None:
        raise StyxValidationError("`params` must not be None")
    if not isinstance(params["params"], list):
        raise StyxValidationError(f'`params` has the wrong type: Received `{type(params.get("params", None))}` expected `list[typing.Union[AntsApplyTransformsSigmaParamsDictTagged, AntsApplyTransformsAlphaParamsDictTagged]]`')
    for e in params["params"]:
        if not isinstance(e, dict):
            raise StyxValidationError(f'Params object has the wrong type \'{type(e)}\'')
        if "@type" not in e:
            raise StyxValidationError("Params object is missing `@type`")
        if e["@type"] not in ["sigma", "alpha"]:
            raise StyxValidationError("Parameter `params`s `@type` must be one of [\"sigma\", \"alpha\"]")
        ants_apply_transforms_params_validate_dyn_fn(e["@type"])(e)


def ants_apply_transforms_param_cargs(
    params: AntsApplyTransformsParamParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + ",".join([a for c in [ants_apply_transforms_params_cargs_dyn_fn(s["@type"])(s, execution) for s in params.get("params", None)] for a in c]) + "]")
    return cargs


def ants_apply_transforms_multi_label(
    params_: AntsApplyTransformsParamParamsDict,
) -> AntsApplyTransformsMultiLabelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        params_:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "multiLabel",
        "params": params_,
    }
    return params


def ants_apply_transforms_multi_label_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsMultiLabelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("params", None) is None:
        raise StyxValidationError("`params` must not be None")
    ants_apply_transforms_param_validate(params["params"])


def ants_apply_transforms_multi_label_cargs(
    params: AntsApplyTransformsMultiLabelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("MultiLabel" + "".join(ants_apply_transforms_param_cargs(params.get("params", None), execution)))
    return cargs


def ants_apply_transforms_gaussian(
    sigma: float | None = None,
    alpha: float | None = None,
) -> AntsApplyTransformsGaussianParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sigma: Sigma value.
        alpha: Alpha value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "gaussian",
    }
    if sigma is not None:
        params["sigma"] = sigma
    if alpha is not None:
        params["alpha"] = alpha
    return params


def ants_apply_transforms_gaussian_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsGaussianParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sigma", None) is not None:
        if not isinstance(params["sigma"], (float, int)):
            raise StyxValidationError(f'`sigma` has the wrong type: Received `{type(params.get("sigma", None))}` expected `float | None`')
    if params.get("alpha", None) is not None:
        if not isinstance(params["alpha"], (float, int)):
            raise StyxValidationError(f'`alpha` has the wrong type: Received `{type(params.get("alpha", None))}` expected `float | None`')


def ants_apply_transforms_gaussian_cargs(
    params: AntsApplyTransformsGaussianParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("sigma", None) is not None or params.get("alpha", None) is not None:
        cargs.append("Gaussian[sigma=" + (str(params.get("sigma", None)) if (params.get("sigma", None) is not None) else "") + ",alpha=" + (str(params.get("alpha", None)) if (params.get("alpha", None) is not None) else "") + "]")
    return cargs


def ants_apply_transforms_bspline(
    order: int | None = None,
) -> AntsApplyTransformsBsplineParamsDictTagged:
    """
    Build parameters.
    
    Args:
        order: Order value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "bspline",
    }
    if order is not None:
        params["order"] = order
    return params


def ants_apply_transforms_bspline_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsBsplineParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("order", None) is not None:
        if not isinstance(params["order"], int):
            raise StyxValidationError(f'`order` has the wrong type: Received `{type(params.get("order", None))}` expected `int | None`')


def ants_apply_transforms_bspline_cargs(
    params: AntsApplyTransformsBsplineParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("order", None) is not None:
        cargs.append("BSpline[" + str(params.get("order", None)) + "]")
    return cargs


def ants_apply_transforms_cosine_windowed_sinc(
) -> AntsApplyTransformsCosineWindowedSincParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "cosineWindowedSinc",
    }
    return params


def ants_apply_transforms_cosine_windowed_sinc_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsCosineWindowedSincParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def ants_apply_transforms_cosine_windowed_sinc_cargs(
    params: AntsApplyTransformsCosineWindowedSincParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("CosineWindowedSinc")
    return cargs


def ants_apply_transforms_welch_windowed_sinc(
) -> AntsApplyTransformsWelchWindowedSincParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "welchWindowedSinc",
    }
    return params


def ants_apply_transforms_welch_windowed_sinc_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsWelchWindowedSincParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def ants_apply_transforms_welch_windowed_sinc_cargs(
    params: AntsApplyTransformsWelchWindowedSincParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("WelchWindowedSinc")
    return cargs


def ants_apply_transforms_hamming_windowed_sinc(
) -> AntsApplyTransformsHammingWindowedSincParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "hammingWindowedSinc",
    }
    return params


def ants_apply_transforms_hamming_windowed_sinc_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsHammingWindowedSincParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def ants_apply_transforms_hamming_windowed_sinc_cargs(
    params: AntsApplyTransformsHammingWindowedSincParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("HammingWindowedSinc")
    return cargs


def ants_apply_transforms_lanczos_windowed_sinc(
) -> AntsApplyTransformsLanczosWindowedSincParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "lanczosWindowedSinc",
    }
    return params


def ants_apply_transforms_lanczos_windowed_sinc_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsLanczosWindowedSincParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def ants_apply_transforms_lanczos_windowed_sinc_cargs(
    params: AntsApplyTransformsLanczosWindowedSincParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("LanczosWindowedSinc")
    return cargs


def ants_apply_transforms_generic_label(
    interpolator: str | None = None,
) -> AntsApplyTransformsGenericLabelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        interpolator: Interpolator value.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "genericLabel",
    }
    if interpolator is not None:
        params["interpolator"] = interpolator
    return params


def ants_apply_transforms_generic_label_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsGenericLabelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("interpolator", None) is not None:
        if not isinstance(params["interpolator"], str):
            raise StyxValidationError(f'`interpolator` has the wrong type: Received `{type(params.get("interpolator", None))}` expected `str | None`')


def ants_apply_transforms_generic_label_cargs(
    params: AntsApplyTransformsGenericLabelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("interpolator", None) is not None:
        cargs.append("GenericLabel[interpolator=" + params.get("interpolator", None) + "]")
    return cargs


def ants_apply_transforms_transform_file_name(
    transform_file_name: InputPathType,
) -> AntsApplyTransformsTransformFileNameParamsDictTagged:
    """
    Build parameters.
    
    Args:
        transform_file_name: Transform file name.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transformFileName",
        "transformFileName": transform_file_name,
    }
    return params


def ants_apply_transforms_transform_file_name_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsTransformFileNameParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("transformFileName", None) is None:
        raise StyxValidationError("`transformFileName` must not be None")
    if not isinstance(params["transformFileName"], (pathlib.Path, str)):
        raise StyxValidationError(f'`transformFileName` has the wrong type: Received `{type(params.get("transformFileName", None))}` expected `InputPathType`')


def ants_apply_transforms_transform_file_name_cargs(
    params: AntsApplyTransformsTransformFileNameParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("transformFileName", None)))
    return cargs


def ants_apply_transforms_use_inverse(
    transform_file_name: InputPathType,
) -> AntsApplyTransformsUseInverseParamsDictTagged:
    """
    Build parameters.
    
    Args:
        transform_file_name: Transform file name.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "useInverse",
        "transformFileName": transform_file_name,
    }
    return params


def ants_apply_transforms_use_inverse_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsUseInverseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("transformFileName", None) is None:
        raise StyxValidationError("`transformFileName` must not be None")
    if not isinstance(params["transformFileName"], (pathlib.Path, str)):
        raise StyxValidationError(f'`transformFileName` has the wrong type: Received `{type(params.get("transformFileName", None))}` expected `InputPathType`')


def ants_apply_transforms_use_inverse_cargs(
    params: AntsApplyTransformsUseInverseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + execution.input_file(params.get("transformFileName", None)) + ",useInverse]")
    return cargs


class AntsApplyTransformsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsApplyTransformsParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output: typing.Union[AntsApplyTransformsWarpedOutputOutputs, AntsApplyTransformsCompositeDisplacementFieldOutputOutputs, AntsApplyTransformsGenericAffineTransformOutputOutputs]
    """Outputs from `AntsApplyTransformsWarpedOutputParamsDict` or
    `AntsApplyTransformsCompositeDisplacementFieldOutputParamsDict` or
    `AntsApplyTransformsGenericAffineTransformOutputParamsDict`."""


def ants_apply_transforms_params(
    reference_image: InputPathType,
    output: typing.Union[AntsApplyTransformsWarpedOutputParamsDictTagged, AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged, AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    input_image_type: typing.Literal[0, 1, 2, 3, 4, 5] | None = None,
    input_image: InputPathType | None = None,
    interpolation: typing.Union[AntsApplyTransformsLinearParamsDictTagged, AntsApplyTransformsNearestNeighborParamsDictTagged, AntsApplyTransformsMultiLabelnoparamsParamsDictTagged, AntsApplyTransformsMultiLabelParamsDictTagged, AntsApplyTransformsGaussianParamsDictTagged, AntsApplyTransformsBsplineParamsDictTagged, AntsApplyTransformsCosineWindowedSincParamsDictTagged, AntsApplyTransformsWelchWindowedSincParamsDictTagged, AntsApplyTransformsHammingWindowedSincParamsDictTagged, AntsApplyTransformsLanczosWindowedSincParamsDictTagged, AntsApplyTransformsGenericLabelParamsDictTagged] | None = None,
    output_data_type: typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None = None,
    transform: list[typing.Union[AntsApplyTransformsTransformFileNameParamsDictTagged, AntsApplyTransformsUseInverseParamsDictTagged]] | None = None,
    default_value: float | None = None,
    static_cast_for_r: str | None = None,
    float_: bool | None = None,
    verbose: bool | None = None,
) -> AntsApplyTransformsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reference_image: For warping input images, the reference image defines\
            the spacing, origin, size, and direction of the output warped image.
        output: One can either output the warped image or, if the boolean is\
            set, one can print out the displacement field based on the composite\
            transform and the reference image. A third option is to compose all\
            affine transforms and (if boolean is set) calculate its inverse which\
            is then written to an ITK file.
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. if not specified, antswarp tries to infer\
            the dimensionality from the input image.
        input_image_type: Option specifying the input image type of scalar\
            (default), vector, tensor, time series, or multi-channel. A time series\
            image is a scalar image defined by an additional dimension for the time\
            component whereas a multi-channel image is a vector image with only\
            spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
        input_image: Currently, the only input objects supported are image\
            objects. However, the current framework allows for warping of other\
            objects such as meshes and point sets.
        interpolation: Several interpolation options are available in ITK.\
            These have all been made available.
        output_data_type: Output image data type. This is a direct typecast;\
            output values are not rescaled. Default is to use the internal data\
            type (float or double). uchar is unsigned char; others are signed.\
            WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values\
            exceed the range allowed by your choice. Note that some pixel types are\
            not supported by some image formats. e.g. int is not supported by jpg.
        transform: Several transform options are supported including all those\
            defined in the ITK library in addition to a deformation field\
            transform. The ordering of the transformations follows the ordering\
            specified on the command line. An identity transform is pushed onto the\
            transformation stack. Each new transform encountered on the command\
            line is also pushed onto the transformation stack. Then, to warp the\
            input object, each point comprising the input object is warped first\
            according to the last transform pushed onto the stack followed by the\
            second to last transform, etc. until the last transform encountered\
            which is the identity transform. Also, it should be noted that the\
            inverse transform can be accommodated with the usual caveat that such\
            an inverse must be defined by the specified transform class.
        default_value: Default voxel value to be used with input images only.\
            Specifies the voxel value when the input point maps outside the output\
            domain. With tensor input images, specifies the default voxel\
            eigenvalues.
        static_cast_for_r: Forces static cast in ReadTransform (for R).
        float_: Use float instead of double for computations.
        verbose: Verbose output.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants/antsApplyTransforms",
        "reference_image": reference_image,
        "output": output,
    }
    if dimensionality is not None:
        params["dimensionality"] = dimensionality
    if input_image_type is not None:
        params["input_image_type"] = input_image_type
    if input_image is not None:
        params["input_image"] = input_image
    if interpolation is not None:
        params["interpolation"] = interpolation
    if output_data_type is not None:
        params["output_data_type"] = output_data_type
    if transform is not None:
        params["transform"] = transform
    if default_value is not None:
        params["default_value"] = default_value
    if static_cast_for_r is not None:
        params["static_cast_for_R"] = static_cast_for_r
    if float_ is not None:
        params["float"] = float_
    if verbose is not None:
        params["verbose"] = verbose
    return params


def ants_apply_transforms_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsApplyTransformsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dimensionality", None) is not None:
        if not isinstance(params["dimensionality"], int):
            raise StyxValidationError(f'`dimensionality` has the wrong type: Received `{type(params.get("dimensionality", None))}` expected `typing.Literal[2, 3, 4] | None`')
        if params["dimensionality"] not in [2, 3, 4]:
            raise StyxValidationError("Parameter `dimensionality` must be one of [2, 3, 4]")
    if params.get("input_image_type", None) is not None:
        if not isinstance(params["input_image_type"], int):
            raise StyxValidationError(f'`input_image_type` has the wrong type: Received `{type(params.get("input_image_type", None))}` expected `typing.Literal[0, 1, 2, 3, 4, 5] | None`')
        if params["input_image_type"] not in [0, 1, 2, 3, 4, 5]:
            raise StyxValidationError("Parameter `input_image_type` must be one of [0, 1, 2, 3, 4, 5]")
    if params.get("input_image", None) is not None:
        if not isinstance(params["input_image"], (pathlib.Path, str)):
            raise StyxValidationError(f'`input_image` has the wrong type: Received `{type(params.get("input_image", None))}` expected `InputPathType | None`')
    if params.get("reference_image", None) is None:
        raise StyxValidationError("`reference_image` must not be None")
    if not isinstance(params["reference_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`reference_image` has the wrong type: Received `{type(params.get("reference_image", None))}` expected `InputPathType`')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["output"])}\'')
    if "@type" not in params["output"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["output"]["@type"] not in ["warpedOutput", "compositeDisplacementFieldOutput", "genericAffineTransformOutput"]:
        raise StyxValidationError("Parameter `output`s `@type` must be one of [\"warpedOutput\", \"compositeDisplacementFieldOutput\", \"genericAffineTransformOutput\"]")
    ants_apply_transforms_output_validate_dyn_fn(params["output"]["@type"])(params["output"])
    if params.get("interpolation", None) is not None:
        if not isinstance(params["interpolation"], dict):
            raise StyxValidationError(f'Params object has the wrong type \'{type(params["interpolation"])}\'')
        if "@type" not in params["interpolation"]:
            raise StyxValidationError("Params object is missing `@type`")
        if params["interpolation"]["@type"] not in ["linear", "nearestNeighbor", "multiLabelnoparams", "multiLabel", "gaussian", "bspline", "cosineWindowedSinc", "welchWindowedSinc", "hammingWindowedSinc", "lanczosWindowedSinc", "genericLabel"]:
            raise StyxValidationError("Parameter `interpolation`s `@type` must be one of [\"linear\", \"nearestNeighbor\", \"multiLabelnoparams\", \"multiLabel\", \"gaussian\", \"bspline\", \"cosineWindowedSinc\", \"welchWindowedSinc\", \"hammingWindowedSinc\", \"lanczosWindowedSinc\", \"genericLabel\"]")
        ants_apply_transforms_interpolation_validate_dyn_fn(params["interpolation"]["@type"])(params["interpolation"])
    if params.get("output_data_type", None) is not None:
        if not isinstance(params["output_data_type"], str):
            raise StyxValidationError(f'`output_data_type` has the wrong type: Received `{type(params.get("output_data_type", None))}` expected `typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None`')
        if params["output_data_type"] not in ["char", "uchar", "short", "int", "float", "double", "default"]:
            raise StyxValidationError("Parameter `output_data_type` must be one of [\"char\", \"uchar\", \"short\", \"int\", \"float\", \"double\", \"default\"]")
    if params.get("transform", None) is not None:
        if not isinstance(params["transform"], list):
            raise StyxValidationError(f'`transform` has the wrong type: Received `{type(params.get("transform", None))}` expected `list[typing.Union[AntsApplyTransformsTransformFileNameParamsDictTagged, AntsApplyTransformsUseInverseParamsDictTagged]] | None`')
        for e in params["transform"]:
            if not isinstance(e, dict):
                raise StyxValidationError(f'Params object has the wrong type \'{type(e)}\'')
            if "@type" not in e:
                raise StyxValidationError("Params object is missing `@type`")
            if e["@type"] not in ["transformFileName", "useInverse"]:
                raise StyxValidationError("Parameter `transform`s `@type` must be one of [\"transformFileName\", \"useInverse\"]")
            ants_apply_transforms_transform_validate_dyn_fn(e["@type"])(e)
    if params.get("default_value", None) is not None:
        if not isinstance(params["default_value"], (float, int)):
            raise StyxValidationError(f'`default_value` has the wrong type: Received `{type(params.get("default_value", None))}` expected `float | None`')
    if params.get("static_cast_for_R", None) is not None:
        if not isinstance(params["static_cast_for_R"], str):
            raise StyxValidationError(f'`static_cast_for_R` has the wrong type: Received `{type(params.get("static_cast_for_R", None))}` expected `str | None`')
    if params.get("float", None) is not None:
        if not isinstance(params["float"], bool):
            raise StyxValidationError(f'`float` has the wrong type: Received `{type(params.get("float", None))}` expected `bool | None`')
    if params.get("verbose", None) is not None:
        if not isinstance(params["verbose"], bool):
            raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", None))}` expected `bool | None`')


def ants_apply_transforms_cargs(
    params: AntsApplyTransformsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("antsApplyTransforms")
    if params.get("dimensionality", None) is not None:
        cargs.extend([
            "--dimensionality",
            str(params.get("dimensionality", None))
        ])
    if params.get("input_image_type", None) is not None:
        cargs.extend([
            "--input-image-type",
            str(params.get("input_image_type", None))
        ])
    if params.get("input_image", None) is not None:
        cargs.extend([
            "--input",
            execution.input_file(params.get("input_image", None))
        ])
    cargs.extend([
        "--reference-image",
        execution.input_file(params.get("reference_image", None))
    ])
    cargs.extend([
        "--output",
        *ants_apply_transforms_output_cargs_dyn_fn(params.get("output", None)["@type"])(params.get("output", None), execution)
    ])
    if params.get("interpolation", None) is not None:
        cargs.extend([
            "--interpolation",
            *ants_apply_transforms_interpolation_cargs_dyn_fn(params.get("interpolation", None)["@type"])(params.get("interpolation", None), execution)
        ])
    if params.get("output_data_type", None) is not None:
        cargs.extend([
            "--output-data-type",
            params.get("output_data_type", None)
        ])
    if params.get("transform", None) is not None:
        cargs.extend([
            "--transform",
            *[a for c in [ants_apply_transforms_transform_cargs_dyn_fn(s["@type"])(s, execution) for s in params.get("transform", None)] for a in c]
        ])
    if params.get("default_value", None) is not None:
        cargs.extend([
            "--default-value",
            str(params.get("default_value", None))
        ])
    if params.get("static_cast_for_R", None) is not None:
        cargs.extend([
            "--static-cast-for-R",
            params.get("static_cast_for_R", None)
        ])
    if params.get("float", None) is not None:
        cargs.extend([
            "--float",
            ("1" if params.get("float", None) else "0")
        ])
    if params.get("verbose", None) is not None:
        cargs.extend([
            "--verbose",
            ("1" if params.get("verbose", None) else "0")
        ])
    return cargs


def ants_apply_transforms_outputs(
    params: AntsApplyTransformsParamsDict,
    execution: Execution,
) -> AntsApplyTransformsOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsApplyTransformsOutputs(
        root=execution.output_file("."),
        output=ants_apply_transforms_output_outputs_dyn_fn(params.get("output")["@type"])(params.get("output"), execution),
    )
    return ret


def ants_apply_transforms_execute(
    params: AntsApplyTransformsParamsDict,
    runner: Runner | None = None,
) -> AntsApplyTransformsOutputs:
    """
    antsApplyTransforms
    
    antsApplyTransforms, applied to an input image, transforms it according to a
    reference image and a transform (or a set of transforms).
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
    """
    ants_apply_transforms_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(ANTS_APPLY_TRANSFORMS_METADATA)
    params = execution.params(params)
    cargs = ants_apply_transforms_cargs(params, execution)
    ret = ants_apply_transforms_outputs(params, execution)
    execution.run(cargs)
    return ret


def ants_apply_transforms(
    reference_image: InputPathType,
    output: typing.Union[AntsApplyTransformsWarpedOutputParamsDictTagged, AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged, AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    input_image_type: typing.Literal[0, 1, 2, 3, 4, 5] | None = None,
    input_image: InputPathType | None = None,
    interpolation: typing.Union[AntsApplyTransformsLinearParamsDictTagged, AntsApplyTransformsNearestNeighborParamsDictTagged, AntsApplyTransformsMultiLabelnoparamsParamsDictTagged, AntsApplyTransformsMultiLabelParamsDictTagged, AntsApplyTransformsGaussianParamsDictTagged, AntsApplyTransformsBsplineParamsDictTagged, AntsApplyTransformsCosineWindowedSincParamsDictTagged, AntsApplyTransformsWelchWindowedSincParamsDictTagged, AntsApplyTransformsHammingWindowedSincParamsDictTagged, AntsApplyTransformsLanczosWindowedSincParamsDictTagged, AntsApplyTransformsGenericLabelParamsDictTagged] | None = None,
    output_data_type: typing.Literal["char", "uchar", "short", "int", "float", "double", "default"] | None = None,
    transform: list[typing.Union[AntsApplyTransformsTransformFileNameParamsDictTagged, AntsApplyTransformsUseInverseParamsDictTagged]] | None = None,
    default_value: float | None = None,
    static_cast_for_r: str | None = None,
    float_: bool | None = None,
    verbose: bool | None = None,
    runner: Runner | None = None,
) -> AntsApplyTransformsOutputs:
    """
    antsApplyTransforms
    
    antsApplyTransforms, applied to an input image, transforms it according to a
    reference image and a transform (or a set of transforms).
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        reference_image: For warping input images, the reference image defines\
            the spacing, origin, size, and direction of the output warped image.
        output: One can either output the warped image or, if the boolean is\
            set, one can print out the displacement field based on the composite\
            transform and the reference image. A third option is to compose all\
            affine transforms and (if boolean is set) calculate its inverse which\
            is then written to an ITK file.
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. if not specified, antswarp tries to infer\
            the dimensionality from the input image.
        input_image_type: Option specifying the input image type of scalar\
            (default), vector, tensor, time series, or multi-channel. A time series\
            image is a scalar image defined by an additional dimension for the time\
            component whereas a multi-channel image is a vector image with only\
            spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
        input_image: Currently, the only input objects supported are image\
            objects. However, the current framework allows for warping of other\
            objects such as meshes and point sets.
        interpolation: Several interpolation options are available in ITK.\
            These have all been made available.
        output_data_type: Output image data type. This is a direct typecast;\
            output values are not rescaled. Default is to use the internal data\
            type (float or double). uchar is unsigned char; others are signed.\
            WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values\
            exceed the range allowed by your choice. Note that some pixel types are\
            not supported by some image formats. e.g. int is not supported by jpg.
        transform: Several transform options are supported including all those\
            defined in the ITK library in addition to a deformation field\
            transform. The ordering of the transformations follows the ordering\
            specified on the command line. An identity transform is pushed onto the\
            transformation stack. Each new transform encountered on the command\
            line is also pushed onto the transformation stack. Then, to warp the\
            input object, each point comprising the input object is warped first\
            according to the last transform pushed onto the stack followed by the\
            second to last transform, etc. until the last transform encountered\
            which is the identity transform. Also, it should be noted that the\
            inverse transform can be accommodated with the usual caveat that such\
            an inverse must be defined by the specified transform class.
        default_value: Default voxel value to be used with input images only.\
            Specifies the voxel value when the input point maps outside the output\
            domain. With tensor input images, specifies the default voxel\
            eigenvalues.
        static_cast_for_r: Forces static cast in ReadTransform (for R).
        float_: Use float instead of double for computations.
        verbose: Verbose output.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
    """
    params = ants_apply_transforms_params(
        dimensionality=dimensionality,
        input_image_type=input_image_type,
        input_image=input_image,
        reference_image=reference_image,
        output=output,
        interpolation=interpolation,
        output_data_type=output_data_type,
        transform=transform,
        default_value=default_value,
        static_cast_for_r=static_cast_for_r,
        float_=float_,
        verbose=verbose,
    )
    return ants_apply_transforms_execute(params, runner)


__all__ = [
    "ANTS_APPLY_TRANSFORMS_METADATA",
    "AntsApplyTransformsAlphaParamsDict",
    "AntsApplyTransformsAlphaParamsDictTagged",
    "AntsApplyTransformsBsplineParamsDict",
    "AntsApplyTransformsBsplineParamsDictTagged",
    "AntsApplyTransformsCompositeDisplacementFieldOutputOutputs",
    "AntsApplyTransformsCompositeDisplacementFieldOutputParamsDict",
    "AntsApplyTransformsCompositeDisplacementFieldOutputParamsDictTagged",
    "AntsApplyTransformsCosineWindowedSincParamsDict",
    "AntsApplyTransformsCosineWindowedSincParamsDictTagged",
    "AntsApplyTransformsGaussianParamsDict",
    "AntsApplyTransformsGaussianParamsDictTagged",
    "AntsApplyTransformsGenericAffineTransformOutputOutputs",
    "AntsApplyTransformsGenericAffineTransformOutputParamsDict",
    "AntsApplyTransformsGenericAffineTransformOutputParamsDictTagged",
    "AntsApplyTransformsGenericLabelParamsDict",
    "AntsApplyTransformsGenericLabelParamsDictTagged",
    "AntsApplyTransformsHammingWindowedSincParamsDict",
    "AntsApplyTransformsHammingWindowedSincParamsDictTagged",
    "AntsApplyTransformsLanczosWindowedSincParamsDict",
    "AntsApplyTransformsLanczosWindowedSincParamsDictTagged",
    "AntsApplyTransformsLinearParamsDict",
    "AntsApplyTransformsLinearParamsDictTagged",
    "AntsApplyTransformsMultiLabelParamsDict",
    "AntsApplyTransformsMultiLabelParamsDictTagged",
    "AntsApplyTransformsMultiLabelnoparamsParamsDict",
    "AntsApplyTransformsMultiLabelnoparamsParamsDictTagged",
    "AntsApplyTransformsNearestNeighborParamsDict",
    "AntsApplyTransformsNearestNeighborParamsDictTagged",
    "AntsApplyTransformsOutputs",
    "AntsApplyTransformsParamParamsDict",
    "AntsApplyTransformsParamParamsDictTagged",
    "AntsApplyTransformsParamsDict",
    "AntsApplyTransformsParamsDictTagged",
    "AntsApplyTransformsSigmaParamsDict",
    "AntsApplyTransformsSigmaParamsDictTagged",
    "AntsApplyTransformsTransformFileNameParamsDict",
    "AntsApplyTransformsTransformFileNameParamsDictTagged",
    "AntsApplyTransformsUseInverseParamsDict",
    "AntsApplyTransformsUseInverseParamsDictTagged",
    "AntsApplyTransformsWarpedOutputOutputs",
    "AntsApplyTransformsWarpedOutputParamsDict",
    "AntsApplyTransformsWarpedOutputParamsDictTagged",
    "AntsApplyTransformsWelchWindowedSincParamsDict",
    "AntsApplyTransformsWelchWindowedSincParamsDictTagged",
    "ants_apply_transforms",
    "ants_apply_transforms_alpha",
    "ants_apply_transforms_bspline",
    "ants_apply_transforms_composite_displacement_field_output",
    "ants_apply_transforms_cosine_windowed_sinc",
    "ants_apply_transforms_execute",
    "ants_apply_transforms_gaussian",
    "ants_apply_transforms_generic_affine_transform_output",
    "ants_apply_transforms_generic_label",
    "ants_apply_transforms_hamming_windowed_sinc",
    "ants_apply_transforms_lanczos_windowed_sinc",
    "ants_apply_transforms_linear",
    "ants_apply_transforms_multi_label",
    "ants_apply_transforms_multi_labelnoparams",
    "ants_apply_transforms_nearest_neighbor",
    "ants_apply_transforms_param",
    "ants_apply_transforms_params",
    "ants_apply_transforms_sigma",
    "ants_apply_transforms_transform_file_name",
    "ants_apply_transforms_use_inverse",
    "ants_apply_transforms_warped_output",
    "ants_apply_transforms_welch_windowed_sinc",
]
