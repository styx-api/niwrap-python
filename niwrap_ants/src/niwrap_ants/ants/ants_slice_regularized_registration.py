# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

ANTS_SLICE_REGULARIZED_REGISTRATION_METADATA = Metadata(
    id="34ad1b0da76f5786fb67baa5172a8cd5bcbbe04d.boutiques",
    name="antsSliceRegularizedRegistration",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


_AntsSliceRegularizedRegistrationParamsDictNoTag = typing.TypedDict('_AntsSliceRegularizedRegistrationParamsDictNoTag', {
    "polydegree": int,
    "output": str,
    "metric": str,
    "transform": str,
    "iterations": str,
    "shrink_factors": str,
    "smoothing_sigmas": str,
    "mask": typing.NotRequired[InputPathType | None],
    "interpolation": typing.NotRequired[typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None],
    "verbose": typing.NotRequired[typing.Literal[0] | None],
})
AntsSliceRegularizedRegistrationParamsDictTagged = typing.TypedDict('AntsSliceRegularizedRegistrationParamsDictTagged', {
    "@type": typing.Literal["ants/antsSliceRegularizedRegistration"],
    "polydegree": int,
    "output": str,
    "metric": str,
    "transform": str,
    "iterations": str,
    "shrink_factors": str,
    "smoothing_sigmas": str,
    "mask": typing.NotRequired[InputPathType | None],
    "interpolation": typing.NotRequired[typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None],
    "verbose": typing.NotRequired[typing.Literal[0] | None],
})
AntsSliceRegularizedRegistrationParamsDict = _AntsSliceRegularizedRegistrationParamsDictNoTag | AntsSliceRegularizedRegistrationParamsDictTagged


class AntsSliceRegularizedRegistrationOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsSliceRegularizedRegistrationParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    polynomial_fit: OutputPathType
    """Output is the polynomial fit to Tx & Ty."""
    transformed_image: OutputPathType
    """Output is the transformed image."""


def ants_slice_regularized_registration_params(
    polydegree: int,
    output: str,
    metric: str,
    transform: str,
    iterations: str,
    shrink_factors: str,
    smoothing_sigmas: str,
    mask: InputPathType | None = None,
    interpolation: typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None = None,
    verbose: typing.Literal[0] | None = None,
) -> AntsSliceRegularizedRegistrationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        polydegree: Degree of polynomial up to zDimension-2. Controls the\
            polynomial degree. 0 means no regularization.
        output: Specify the output transform prefix (output format is .nii.gz).\
            Optionally, one can choose to warp the moving image to the fixed space,\
            and if the inverse transform exists, one can also output the warped\
            fixed image.
        metric: Four image metrics are available: GC: global correlation, CC:\
            ANTS neighborhood cross correlation, MI: Mutual information, and\
            MeanSquares: mean-squares intensity difference.
        transform: Several transform options are available. The gradientStep or\
            learningRate characterizes the gradient descent optimization.
        iterations: Specify the number of iterations at each level.
        shrink_factors: Specify the shrink factor for the virtual domain\
            (typically the fixed image) at each level.
        smoothing_sigmas: Specify the amount of smoothing at each level.
        mask: Fixed image mask to limit voxels considered by the metric.
        interpolation: Several interpolation options are available in ITK.
        verbose: Verbose option.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants/antsSliceRegularizedRegistration",
        "polydegree": polydegree,
        "output": output,
        "metric": metric,
        "transform": transform,
        "iterations": iterations,
        "shrink_factors": shrink_factors,
        "smoothing_sigmas": smoothing_sigmas,
    }
    if mask is not None:
        params["mask"] = mask
    if interpolation is not None:
        params["interpolation"] = interpolation
    if verbose is not None:
        params["verbose"] = verbose
    return params


def ants_slice_regularized_registration_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsSliceRegularizedRegistrationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("polydegree", None) is None:
        raise StyxValidationError("`polydegree` must not be None")
    if not isinstance(params["polydegree"], int):
        raise StyxValidationError(f'`polydegree` has the wrong type: Received `{type(params.get("polydegree", None))}` expected `int`')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')
    if params.get("metric", None) is None:
        raise StyxValidationError("`metric` must not be None")
    if not isinstance(params["metric"], str):
        raise StyxValidationError(f'`metric` has the wrong type: Received `{type(params.get("metric", None))}` expected `str`')
    if params.get("transform", None) is None:
        raise StyxValidationError("`transform` must not be None")
    if not isinstance(params["transform"], str):
        raise StyxValidationError(f'`transform` has the wrong type: Received `{type(params.get("transform", None))}` expected `str`')
    if params.get("iterations", None) is None:
        raise StyxValidationError("`iterations` must not be None")
    if not isinstance(params["iterations"], str):
        raise StyxValidationError(f'`iterations` has the wrong type: Received `{type(params.get("iterations", None))}` expected `str`')
    if params.get("shrink_factors", None) is None:
        raise StyxValidationError("`shrink_factors` must not be None")
    if not isinstance(params["shrink_factors"], str):
        raise StyxValidationError(f'`shrink_factors` has the wrong type: Received `{type(params.get("shrink_factors", None))}` expected `str`')
    if params.get("smoothing_sigmas", None) is None:
        raise StyxValidationError("`smoothing_sigmas` must not be None")
    if not isinstance(params["smoothing_sigmas"], str):
        raise StyxValidationError(f'`smoothing_sigmas` has the wrong type: Received `{type(params.get("smoothing_sigmas", None))}` expected `str`')
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType | None`')
    if params.get("interpolation", None) is not None:
        if not isinstance(params["interpolation"], str):
            raise StyxValidationError(f'`interpolation` has the wrong type: Received `{type(params.get("interpolation", None))}` expected `typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None`')
        if params["interpolation"] not in ["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"]:
            raise StyxValidationError("Parameter `interpolation` must be one of [\"Linear\", \"NearestNeighbor\", \"MultiLabel\", \"Gaussian\", \"BSpline\", \"CosineWindowedSinc\", \"WelchWindowedSinc\", \"HammingWindowedSinc\", \"LanczosWindowedSinc\", \"GenericLabel\"]")
    if params.get("verbose", None) is not None:
        if not isinstance(params["verbose"], int):
            raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", None))}` expected `typing.Literal[0] | None`')
        if params["verbose"] not in [0]:
            raise StyxValidationError("Parameter `verbose` must be one of [0]")


def ants_slice_regularized_registration_cargs(
    params: AntsSliceRegularizedRegistrationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("antsSliceRegularizedRegistration")
    cargs.extend([
        "-p",
        str(params.get("polydegree", None))
    ])
    cargs.extend([
        "-o",
        params.get("output", None)
    ])
    cargs.extend([
        "-m",
        params.get("metric", None)
    ])
    cargs.extend([
        "-t",
        params.get("transform", None)
    ])
    cargs.extend([
        "-i",
        params.get("iterations", None)
    ])
    cargs.extend([
        "-f",
        params.get("shrink_factors", None)
    ])
    cargs.extend([
        "-s",
        params.get("smoothing_sigmas", None)
    ])
    if params.get("mask", None) is not None:
        cargs.extend([
            "-x",
            execution.input_file(params.get("mask", None))
        ])
    if params.get("interpolation", None) is not None:
        cargs.extend([
            "-n",
            params.get("interpolation", None)
        ])
    if params.get("verbose", None) is not None:
        cargs.extend([
            "-v",
            str(params.get("verbose", None))
        ])
    return cargs


def ants_slice_regularized_registration_outputs(
    params: AntsSliceRegularizedRegistrationParamsDict,
    execution: Execution,
) -> AntsSliceRegularizedRegistrationOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsSliceRegularizedRegistrationOutputs(
        root=execution.output_file("."),
        polynomial_fit=execution.output_file("[OUTPUT_PREFIX]TxTy_poly.csv"),
        transformed_image=execution.output_file("[OUTPUT_PREFIX].nii.gz"),
    )
    return ret


def ants_slice_regularized_registration_execute(
    params: AntsSliceRegularizedRegistrationParamsDict,
    runner: Runner | None = None,
) -> AntsSliceRegularizedRegistrationOutputs:
    """
    antsSliceRegularizedRegistration
    
    This program is a user-level application for slice-by-slice translation
    registration. Results are regularized in z using polynomial regression. The
    program is targeted at spinal cord MRI. Only one stage is supported where a
    stage consists of a transform; an image metric; and iterations, shrink
    factors, and smoothing sigmas for each level. Specialized for 3D data: fixed
    image is 3D, moving image is 3D. Registration is performed slice-by-slice
    then regularized in z. The parameter -p controls the polynomial degree. -p 0
    means no regularization.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsSliceRegularizedRegistrationOutputs`).
    """
    ants_slice_regularized_registration_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(ANTS_SLICE_REGULARIZED_REGISTRATION_METADATA)
    params = execution.params(params)
    cargs = ants_slice_regularized_registration_cargs(params, execution)
    ret = ants_slice_regularized_registration_outputs(params, execution)
    execution.run(cargs)
    return ret


def ants_slice_regularized_registration(
    polydegree: int,
    output: str,
    metric: str,
    transform: str,
    iterations: str,
    shrink_factors: str,
    smoothing_sigmas: str,
    mask: InputPathType | None = None,
    interpolation: typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None = None,
    verbose: typing.Literal[0] | None = None,
    runner: Runner | None = None,
) -> AntsSliceRegularizedRegistrationOutputs:
    """
    antsSliceRegularizedRegistration
    
    This program is a user-level application for slice-by-slice translation
    registration. Results are regularized in z using polynomial regression. The
    program is targeted at spinal cord MRI. Only one stage is supported where a
    stage consists of a transform; an image metric; and iterations, shrink
    factors, and smoothing sigmas for each level. Specialized for 3D data: fixed
    image is 3D, moving image is 3D. Registration is performed slice-by-slice
    then regularized in z. The parameter -p controls the polynomial degree. -p 0
    means no regularization.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        polydegree: Degree of polynomial up to zDimension-2. Controls the\
            polynomial degree. 0 means no regularization.
        output: Specify the output transform prefix (output format is .nii.gz).\
            Optionally, one can choose to warp the moving image to the fixed space,\
            and if the inverse transform exists, one can also output the warped\
            fixed image.
        metric: Four image metrics are available: GC: global correlation, CC:\
            ANTS neighborhood cross correlation, MI: Mutual information, and\
            MeanSquares: mean-squares intensity difference.
        transform: Several transform options are available. The gradientStep or\
            learningRate characterizes the gradient descent optimization.
        iterations: Specify the number of iterations at each level.
        shrink_factors: Specify the shrink factor for the virtual domain\
            (typically the fixed image) at each level.
        smoothing_sigmas: Specify the amount of smoothing at each level.
        mask: Fixed image mask to limit voxels considered by the metric.
        interpolation: Several interpolation options are available in ITK.
        verbose: Verbose option.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsSliceRegularizedRegistrationOutputs`).
    """
    params = ants_slice_regularized_registration_params(
        polydegree=polydegree,
        output=output,
        metric=metric,
        transform=transform,
        iterations=iterations,
        shrink_factors=shrink_factors,
        smoothing_sigmas=smoothing_sigmas,
        mask=mask,
        interpolation=interpolation,
        verbose=verbose,
    )
    return ants_slice_regularized_registration_execute(params, runner)


__all__ = [
    "ANTS_SLICE_REGULARIZED_REGISTRATION_METADATA",
    "AntsSliceRegularizedRegistrationOutputs",
    "AntsSliceRegularizedRegistrationParamsDict",
    "AntsSliceRegularizedRegistrationParamsDictTagged",
    "ants_slice_regularized_registration",
    "ants_slice_regularized_registration_execute",
    "ants_slice_regularized_registration_params",
]
