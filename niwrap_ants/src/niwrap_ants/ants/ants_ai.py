# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

ANTS_AI_METADATA = Metadata(
    id="678184c76f859365d010d230b1d56a4b04e420a7.boutiques",
    name="antsAI",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


_AntsAiParamsDictNoTag = typing.TypedDict('_AntsAiParamsDictNoTag', {
    "dimensionality": typing.NotRequired[typing.Literal[2, 3] | None],
    "metric": typing.Literal["Mattes[fixedImage,movingImage]", "GC[fixedImage,movingImage]", "MI[fixedImage,movingImage]"],
    "transform": typing.Literal["Rigid[gradientStep]", "Affine[gradientStep]", "Similarity[gradientStep]", "AlignGeometricCenters", "AlignCentersOfMass"],
    "align_principal_axes": typing.NotRequired[bool | None],
    "align_blobs": typing.NotRequired[typing.Literal["numberOfBlobsToExtract", "[numberOfBlobsToExtract,numberOfBlobsToMatch]"] | None],
    "search_factor": typing.NotRequired[typing.Literal["searchFactor", "[searchFactor,arcFraction]"] | None],
    "translation_search_grid": typing.NotRequired[typing.Literal["[stepSize, AxBxC]"] | None],
    "convergence": typing.NotRequired[typing.Literal["numberOfIterations", "[numberOfIterations,convergenceThreshold,convergenceWindowSize]"] | None],
    "masks": typing.NotRequired[typing.Literal["fixedImageMask", "[fixedImageMask,movingImageMask]"] | None],
    "output": str,
    "random_seed": typing.NotRequired[int | None],
    "verbose": typing.NotRequired[bool | None],
})
AntsAiParamsDictTagged = typing.TypedDict('AntsAiParamsDictTagged', {
    "@type": typing.Literal["ants/antsAI"],
    "dimensionality": typing.NotRequired[typing.Literal[2, 3] | None],
    "metric": typing.Literal["Mattes[fixedImage,movingImage]", "GC[fixedImage,movingImage]", "MI[fixedImage,movingImage]"],
    "transform": typing.Literal["Rigid[gradientStep]", "Affine[gradientStep]", "Similarity[gradientStep]", "AlignGeometricCenters", "AlignCentersOfMass"],
    "align_principal_axes": typing.NotRequired[bool | None],
    "align_blobs": typing.NotRequired[typing.Literal["numberOfBlobsToExtract", "[numberOfBlobsToExtract,numberOfBlobsToMatch]"] | None],
    "search_factor": typing.NotRequired[typing.Literal["searchFactor", "[searchFactor,arcFraction]"] | None],
    "translation_search_grid": typing.NotRequired[typing.Literal["[stepSize, AxBxC]"] | None],
    "convergence": typing.NotRequired[typing.Literal["numberOfIterations", "[numberOfIterations,convergenceThreshold,convergenceWindowSize]"] | None],
    "masks": typing.NotRequired[typing.Literal["fixedImageMask", "[fixedImageMask,movingImageMask]"] | None],
    "output": str,
    "random_seed": typing.NotRequired[int | None],
    "verbose": typing.NotRequired[bool | None],
})
AntsAiParamsDict = _AntsAiParamsDictNoTag | AntsAiParamsDictTagged


class AntsAiOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsAiParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_transform: OutputPathType
    """The output transform (ITK .mat file)."""


def ants_ai_params(
    metric: typing.Literal["Mattes[fixedImage,movingImage]", "GC[fixedImage,movingImage]", "MI[fixedImage,movingImage]"],
    transform: typing.Literal["Rigid[gradientStep]", "Affine[gradientStep]", "Similarity[gradientStep]", "AlignGeometricCenters", "AlignCentersOfMass"],
    output: str,
    dimensionality: typing.Literal[2, 3] | None = None,
    align_principal_axes: bool | None = None,
    align_blobs: typing.Literal["numberOfBlobsToExtract", "[numberOfBlobsToExtract,numberOfBlobsToMatch]"] | None = None,
    search_factor: typing.Literal["searchFactor", "[searchFactor,arcFraction]"] | None = None,
    translation_search_grid: typing.Literal["[stepSize, AxBxC]"] | None = None,
    convergence: typing.Literal["numberOfIterations", "[numberOfIterations,convergenceThreshold,convergenceWindowSize]"] | None = None,
    masks: typing.Literal["fixedImageMask", "[fixedImageMask,movingImageMask]"] | None = None,
    random_seed: int | None = None,
    verbose: bool | None = None,
) -> AntsAiParamsDictTagged:
    """
    Build parameters.
    
    Args:
        metric: These image metrics are available: Mattes: Mattes mutual\
            information (recommended), GC: global correlation, MI: joint histogram\
            mutual information.
        transform: Several transform options are available. For the rigid,\
            affine, and similarity transforms, the gradientStep characterizes the\
            gradient descent optimization. The other two transform types finds the\
            simple translation transform which aligns the specified image feature.
        output: Specify the output transform (output format an ITK .mat file).
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. If not specified, we try to infer the\
            dimensionality from the input image.
        align_principal_axes: Boolean indicating alignment by principal axes.\
            Alternatively, one can align using blobs.
        align_blobs: Boolean indicating alignment by a set of blobs.
        search_factor: Incremental search factor (in degrees) which will sample\
            the arc fraction around the principal axis or default axis.
        translation_search_grid: Translation search grid in mm, which will\
            translate the moving image in each dimension in increments of the step\
            size.
        convergence: Number of iterations.
        masks: Image masks to limit voxels considered by the metric.
        random_seed: Use a fixed seed for random number generation.
        verbose: Verbose output.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants/antsAI",
        "metric": metric,
        "transform": transform,
        "output": output,
    }
    if dimensionality is not None:
        params["dimensionality"] = dimensionality
    if align_principal_axes is not None:
        params["align_principal_axes"] = align_principal_axes
    if align_blobs is not None:
        params["align_blobs"] = align_blobs
    if search_factor is not None:
        params["search_factor"] = search_factor
    if translation_search_grid is not None:
        params["translation_search_grid"] = translation_search_grid
    if convergence is not None:
        params["convergence"] = convergence
    if masks is not None:
        params["masks"] = masks
    if random_seed is not None:
        params["random_seed"] = random_seed
    if verbose is not None:
        params["verbose"] = verbose
    return params


def ants_ai_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsAiParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dimensionality", None) is not None:
        if not isinstance(params["dimensionality"], int):
            raise StyxValidationError(f'`dimensionality` has the wrong type: Received `{type(params.get("dimensionality", None))}` expected `typing.Literal[2, 3] | None`')
        if params["dimensionality"] not in [2, 3]:
            raise StyxValidationError("Parameter `dimensionality` must be one of [2, 3]")
    if params.get("metric", None) is None:
        raise StyxValidationError("`metric` must not be None")
    if not isinstance(params["metric"], str):
        raise StyxValidationError(f'`metric` has the wrong type: Received `{type(params.get("metric", None))}` expected `typing.Literal["Mattes[fixedImage,movingImage]", "GC[fixedImage,movingImage]", "MI[fixedImage,movingImage]"]`')
    if params["metric"] not in ["Mattes[fixedImage,movingImage]", "GC[fixedImage,movingImage]", "MI[fixedImage,movingImage]"]:
        raise StyxValidationError("Parameter `metric` must be one of [\"Mattes[fixedImage,movingImage]\", \"GC[fixedImage,movingImage]\", \"MI[fixedImage,movingImage]\"]")
    if params.get("transform", None) is None:
        raise StyxValidationError("`transform` must not be None")
    if not isinstance(params["transform"], str):
        raise StyxValidationError(f'`transform` has the wrong type: Received `{type(params.get("transform", None))}` expected `typing.Literal["Rigid[gradientStep]", "Affine[gradientStep]", "Similarity[gradientStep]", "AlignGeometricCenters", "AlignCentersOfMass"]`')
    if params["transform"] not in ["Rigid[gradientStep]", "Affine[gradientStep]", "Similarity[gradientStep]", "AlignGeometricCenters", "AlignCentersOfMass"]:
        raise StyxValidationError("Parameter `transform` must be one of [\"Rigid[gradientStep]\", \"Affine[gradientStep]\", \"Similarity[gradientStep]\", \"AlignGeometricCenters\", \"AlignCentersOfMass\"]")
    if params.get("align_principal_axes", None) is not None:
        if not isinstance(params["align_principal_axes"], bool):
            raise StyxValidationError(f'`align_principal_axes` has the wrong type: Received `{type(params.get("align_principal_axes", None))}` expected `bool | None`')
    if params.get("align_blobs", None) is not None:
        if not isinstance(params["align_blobs"], str):
            raise StyxValidationError(f'`align_blobs` has the wrong type: Received `{type(params.get("align_blobs", None))}` expected `typing.Literal["numberOfBlobsToExtract", "[numberOfBlobsToExtract,numberOfBlobsToMatch]"] | None`')
        if params["align_blobs"] not in ["numberOfBlobsToExtract", "[numberOfBlobsToExtract,numberOfBlobsToMatch]"]:
            raise StyxValidationError("Parameter `align_blobs` must be one of [\"numberOfBlobsToExtract\", \"[numberOfBlobsToExtract,numberOfBlobsToMatch]\"]")
    if params.get("search_factor", None) is not None:
        if not isinstance(params["search_factor"], str):
            raise StyxValidationError(f'`search_factor` has the wrong type: Received `{type(params.get("search_factor", None))}` expected `typing.Literal["searchFactor", "[searchFactor,arcFraction]"] | None`')
        if params["search_factor"] not in ["searchFactor", "[searchFactor,arcFraction]"]:
            raise StyxValidationError("Parameter `search_factor` must be one of [\"searchFactor\", \"[searchFactor,arcFraction]\"]")
    if params.get("translation_search_grid", None) is not None:
        if not isinstance(params["translation_search_grid"], str):
            raise StyxValidationError(f'`translation_search_grid` has the wrong type: Received `{type(params.get("translation_search_grid", None))}` expected `typing.Literal["[stepSize, AxBxC]"] | None`')
        if params["translation_search_grid"] not in ["[stepSize, AxBxC]"]:
            raise StyxValidationError("Parameter `translation_search_grid` must be one of [\"[stepSize, AxBxC]\"]")
    if params.get("convergence", None) is not None:
        if not isinstance(params["convergence"], str):
            raise StyxValidationError(f'`convergence` has the wrong type: Received `{type(params.get("convergence", None))}` expected `typing.Literal["numberOfIterations", "[numberOfIterations,convergenceThreshold,convergenceWindowSize]"] | None`')
        if params["convergence"] not in ["numberOfIterations", "[numberOfIterations,convergenceThreshold,convergenceWindowSize]"]:
            raise StyxValidationError("Parameter `convergence` must be one of [\"numberOfIterations\", \"[numberOfIterations,convergenceThreshold,convergenceWindowSize]\"]")
    if params.get("masks", None) is not None:
        if not isinstance(params["masks"], str):
            raise StyxValidationError(f'`masks` has the wrong type: Received `{type(params.get("masks", None))}` expected `typing.Literal["fixedImageMask", "[fixedImageMask,movingImageMask]"] | None`')
        if params["masks"] not in ["fixedImageMask", "[fixedImageMask,movingImageMask]"]:
            raise StyxValidationError("Parameter `masks` must be one of [\"fixedImageMask\", \"[fixedImageMask,movingImageMask]\"]")
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')
    if params.get("random_seed", None) is not None:
        if not isinstance(params["random_seed"], int):
            raise StyxValidationError(f'`random_seed` has the wrong type: Received `{type(params.get("random_seed", None))}` expected `int | None`')
        if params["random_seed"] < 0:
            raise StyxValidationError("Parameter `random_seed` must be at least 0")
    if params.get("verbose", None) is not None:
        if not isinstance(params["verbose"], bool):
            raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", None))}` expected `bool | None`')


def ants_ai_cargs(
    params: AntsAiParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("antsAI")
    if params.get("dimensionality", None) is not None:
        cargs.extend([
            "--dimensionality",
            str(params.get("dimensionality", None))
        ])
    cargs.extend([
        "-m",
        params.get("metric", None)
    ])
    cargs.extend([
        "-t",
        params.get("transform", None)
    ])
    if params.get("align_principal_axes", None) is not None:
        cargs.extend([
            "-p",
            ("1" if params.get("align_principal_axes", None) else "0")
        ])
    if params.get("align_blobs", None) is not None:
        cargs.extend([
            "-b",
            params.get("align_blobs", None)
        ])
    if params.get("search_factor", None) is not None:
        cargs.extend([
            "-s",
            params.get("search_factor", None)
        ])
    if params.get("translation_search_grid", None) is not None:
        cargs.extend([
            "-g",
            params.get("translation_search_grid", None)
        ])
    if params.get("convergence", None) is not None:
        cargs.extend([
            "-c",
            params.get("convergence", None)
        ])
    if params.get("masks", None) is not None:
        cargs.extend([
            "-x",
            params.get("masks", None)
        ])
    cargs.extend([
        "-o",
        params.get("output", None)
    ])
    if params.get("random_seed", None) is not None:
        cargs.extend([
            "--random-seed",
            str(params.get("random_seed", None))
        ])
    if params.get("verbose", None) is not None:
        cargs.extend([
            "-v",
            ("1" if params.get("verbose", None) else "0")
        ])
    return cargs


def ants_ai_outputs(
    params: AntsAiParamsDict,
    execution: Execution,
) -> AntsAiOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsAiOutputs(
        root=execution.output_file("."),
        output_transform=execution.output_file(params.get("output", None) + ".mat"),
    )
    return ret


def ants_ai_execute(
    params: AntsAiParamsDict,
    runner: Runner | None = None,
) -> AntsAiOutputs:
    """
    antsAI
    
    Program to calculate the optimal linear transform parameters for aligning
    two images.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsAiOutputs`).
    """
    ants_ai_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(ANTS_AI_METADATA)
    params = execution.params(params)
    cargs = ants_ai_cargs(params, execution)
    ret = ants_ai_outputs(params, execution)
    execution.run(cargs)
    return ret


def ants_ai(
    metric: typing.Literal["Mattes[fixedImage,movingImage]", "GC[fixedImage,movingImage]", "MI[fixedImage,movingImage]"],
    transform: typing.Literal["Rigid[gradientStep]", "Affine[gradientStep]", "Similarity[gradientStep]", "AlignGeometricCenters", "AlignCentersOfMass"],
    output: str,
    dimensionality: typing.Literal[2, 3] | None = None,
    align_principal_axes: bool | None = None,
    align_blobs: typing.Literal["numberOfBlobsToExtract", "[numberOfBlobsToExtract,numberOfBlobsToMatch]"] | None = None,
    search_factor: typing.Literal["searchFactor", "[searchFactor,arcFraction]"] | None = None,
    translation_search_grid: typing.Literal["[stepSize, AxBxC]"] | None = None,
    convergence: typing.Literal["numberOfIterations", "[numberOfIterations,convergenceThreshold,convergenceWindowSize]"] | None = None,
    masks: typing.Literal["fixedImageMask", "[fixedImageMask,movingImageMask]"] | None = None,
    random_seed: int | None = None,
    verbose: bool | None = None,
    runner: Runner | None = None,
) -> AntsAiOutputs:
    """
    antsAI
    
    Program to calculate the optimal linear transform parameters for aligning
    two images.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        metric: These image metrics are available: Mattes: Mattes mutual\
            information (recommended), GC: global correlation, MI: joint histogram\
            mutual information.
        transform: Several transform options are available. For the rigid,\
            affine, and similarity transforms, the gradientStep characterizes the\
            gradient descent optimization. The other two transform types finds the\
            simple translation transform which aligns the specified image feature.
        output: Specify the output transform (output format an ITK .mat file).
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. If not specified, we try to infer the\
            dimensionality from the input image.
        align_principal_axes: Boolean indicating alignment by principal axes.\
            Alternatively, one can align using blobs.
        align_blobs: Boolean indicating alignment by a set of blobs.
        search_factor: Incremental search factor (in degrees) which will sample\
            the arc fraction around the principal axis or default axis.
        translation_search_grid: Translation search grid in mm, which will\
            translate the moving image in each dimension in increments of the step\
            size.
        convergence: Number of iterations.
        masks: Image masks to limit voxels considered by the metric.
        random_seed: Use a fixed seed for random number generation.
        verbose: Verbose output.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsAiOutputs`).
    """
    params = ants_ai_params(
        dimensionality=dimensionality,
        metric=metric,
        transform=transform,
        align_principal_axes=align_principal_axes,
        align_blobs=align_blobs,
        search_factor=search_factor,
        translation_search_grid=translation_search_grid,
        convergence=convergence,
        masks=masks,
        output=output,
        random_seed=random_seed,
        verbose=verbose,
    )
    return ants_ai_execute(params, runner)


__all__ = [
    "ANTS_AI_METADATA",
    "AntsAiOutputs",
    "AntsAiParamsDict",
    "AntsAiParamsDictTagged",
    "ants_ai",
    "ants_ai_execute",
    "ants_ai_params",
]
