# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

ANTS_REGISTRATION_METADATA = Metadata(
    id="595eeb7ba9023f3ad07e8d85841e09fcc59f9eff.boutiques",
    name="antsRegistration",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


_AntsRegistrationInitialMovingTransformParamsDictNoTag = typing.TypedDict('_AntsRegistrationInitialMovingTransformParamsDictNoTag', {
    "initial_moving_transform": InputPathType,
})
AntsRegistrationInitialMovingTransformParamsDictTagged = typing.TypedDict('AntsRegistrationInitialMovingTransformParamsDictTagged', {
    "@type": typing.Literal["initial_moving_transform"],
    "initial_moving_transform": InputPathType,
})
AntsRegistrationInitialMovingTransformParamsDict = _AntsRegistrationInitialMovingTransformParamsDictNoTag | AntsRegistrationInitialMovingTransformParamsDictTagged


_AntsRegistrationUseInverseParamsDictNoTag = typing.TypedDict('_AntsRegistrationUseInverseParamsDictNoTag', {
    "use_inverse_value": bool,
})
AntsRegistrationUseInverseParamsDictTagged = typing.TypedDict('AntsRegistrationUseInverseParamsDictTagged', {
    "@type": typing.Literal["use_inverse"],
    "use_inverse_value": bool,
})
AntsRegistrationUseInverseParamsDict = _AntsRegistrationUseInverseParamsDictNoTag | AntsRegistrationUseInverseParamsDictTagged


_AntsRegistrationInitialMovingTransformUseInverseParamsDictNoTag = typing.TypedDict('_AntsRegistrationInitialMovingTransformUseInverseParamsDictNoTag', {
    "initial_moving_transform": InputPathType,
    "use_inverse": typing.NotRequired[AntsRegistrationUseInverseParamsDict | None],
})
AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged = typing.TypedDict('AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged', {
    "@type": typing.Literal["initial_moving_transform_use_inverse"],
    "initial_moving_transform": InputPathType,
    "use_inverse": typing.NotRequired[AntsRegistrationUseInverseParamsDict | None],
})
AntsRegistrationInitialMovingTransformUseInverseParamsDict = _AntsRegistrationInitialMovingTransformUseInverseParamsDictNoTag | AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged


_AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictNoTag = typing.TypedDict('_AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "initialization_feature": typing.Literal[0, 1, 2],
})
AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged = typing.TypedDict('AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged', {
    "@type": typing.Literal["initial_moving_transform_initialization_feature"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "initialization_feature": typing.Literal[0, 1, 2],
})
AntsRegistrationInitialMovingTransformInitializationFeatureParamsDict = _AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictNoTag | AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged


_AntsRegistrationTransformRigidParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformRigidParamsDictNoTag', {
    "gradient_step": float,
})
AntsRegistrationTransformRigidParamsDictTagged = typing.TypedDict('AntsRegistrationTransformRigidParamsDictTagged', {
    "@type": typing.Literal["transform_rigid"],
    "gradient_step": float,
})
AntsRegistrationTransformRigidParamsDict = _AntsRegistrationTransformRigidParamsDictNoTag | AntsRegistrationTransformRigidParamsDictTagged


_AntsRegistrationTransformAffineParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformAffineParamsDictNoTag', {
    "gradient_step": float,
})
AntsRegistrationTransformAffineParamsDictTagged = typing.TypedDict('AntsRegistrationTransformAffineParamsDictTagged', {
    "@type": typing.Literal["transform_affine"],
    "gradient_step": float,
})
AntsRegistrationTransformAffineParamsDict = _AntsRegistrationTransformAffineParamsDictNoTag | AntsRegistrationTransformAffineParamsDictTagged


_AntsRegistrationTransformCompositeAffineParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformCompositeAffineParamsDictNoTag', {
    "gradient_step": float,
})
AntsRegistrationTransformCompositeAffineParamsDictTagged = typing.TypedDict('AntsRegistrationTransformCompositeAffineParamsDictTagged', {
    "@type": typing.Literal["transform_composite_affine"],
    "gradient_step": float,
})
AntsRegistrationTransformCompositeAffineParamsDict = _AntsRegistrationTransformCompositeAffineParamsDictNoTag | AntsRegistrationTransformCompositeAffineParamsDictTagged


_AntsRegistrationTransformSimilarityParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformSimilarityParamsDictNoTag', {
    "gradient_step": float,
})
AntsRegistrationTransformSimilarityParamsDictTagged = typing.TypedDict('AntsRegistrationTransformSimilarityParamsDictTagged', {
    "@type": typing.Literal["transform_similarity"],
    "gradient_step": float,
})
AntsRegistrationTransformSimilarityParamsDict = _AntsRegistrationTransformSimilarityParamsDictNoTag | AntsRegistrationTransformSimilarityParamsDictTagged


_AntsRegistrationTransformTranslationParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformTranslationParamsDictNoTag', {
    "gradient_step": float,
})
AntsRegistrationTransformTranslationParamsDictTagged = typing.TypedDict('AntsRegistrationTransformTranslationParamsDictTagged', {
    "@type": typing.Literal["transform_translation"],
    "gradient_step": float,
})
AntsRegistrationTransformTranslationParamsDict = _AntsRegistrationTransformTranslationParamsDictNoTag | AntsRegistrationTransformTranslationParamsDictTagged


_AntsRegistrationTransformBsplineParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformBsplineParamsDictNoTag', {
    "gradient_step": float,
    "mesh_size_at_base_level": float,
})
AntsRegistrationTransformBsplineParamsDictTagged = typing.TypedDict('AntsRegistrationTransformBsplineParamsDictTagged', {
    "@type": typing.Literal["transform_bspline"],
    "gradient_step": float,
    "mesh_size_at_base_level": float,
})
AntsRegistrationTransformBsplineParamsDict = _AntsRegistrationTransformBsplineParamsDictNoTag | AntsRegistrationTransformBsplineParamsDictTagged


_AntsRegistrationTransformGaussianDisplacementFieldParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformGaussianDisplacementFieldParamsDictNoTag', {
    "gradient_step": float,
    "update_field_variance_in_voxel_space": float,
    "total_field_variance_in_voxel_space": float,
})
AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged = typing.TypedDict('AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged', {
    "@type": typing.Literal["transform_gaussian_displacement_field"],
    "gradient_step": float,
    "update_field_variance_in_voxel_space": float,
    "total_field_variance_in_voxel_space": float,
})
AntsRegistrationTransformGaussianDisplacementFieldParamsDict = _AntsRegistrationTransformGaussianDisplacementFieldParamsDictNoTag | AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged


_AntsRegistrationSplineOrderParamsDictNoTag = typing.TypedDict('_AntsRegistrationSplineOrderParamsDictNoTag', {
    "spline_order_value": float,
})
AntsRegistrationSplineOrderParamsDictTagged = typing.TypedDict('AntsRegistrationSplineOrderParamsDictTagged', {
    "@type": typing.Literal["spline_order"],
    "spline_order_value": float,
})
AntsRegistrationSplineOrderParamsDict = _AntsRegistrationSplineOrderParamsDictNoTag | AntsRegistrationSplineOrderParamsDictTagged


_AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictNoTag = typing.TypedDict('_AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictNoTag', {
    "total_field_mesh_size_at_base_level_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrderParamsDict | None],
})
AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictTagged = typing.TypedDict('AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictTagged', {
    "@type": typing.Literal["total_field_mesh_size_at_base_level"],
    "total_field_mesh_size_at_base_level_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrderParamsDict | None],
})
AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDict = _AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictNoTag | AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictTagged


_AntsRegistrationTransformBsplineDisplacementFieldParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformBsplineDisplacementFieldParamsDictNoTag', {
    "gradient_step": float,
    "update_field_mesh_size_at_base_level": float,
    "total_field_mesh_size_at_base_level": typing.NotRequired[AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDict | None],
})
AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged = typing.TypedDict('AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged', {
    "@type": typing.Literal["transform_bspline_displacement_field"],
    "gradient_step": float,
    "update_field_mesh_size_at_base_level": float,
    "total_field_mesh_size_at_base_level": typing.NotRequired[AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDict | None],
})
AntsRegistrationTransformBsplineDisplacementFieldParamsDict = _AntsRegistrationTransformBsplineDisplacementFieldParamsDictNoTag | AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged


_AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictNoTag', {
    "gradient_step": float,
    "number_of_time_indices": float,
    "update_field_variance_in_voxel_space": float,
    "update_field_time_variance": float,
    "total_field_variance_in_voxel_space": float,
    "total_field_time_variance": float,
})
AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged = typing.TypedDict('AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged', {
    "@type": typing.Literal["transform_time_varying_velocity_field"],
    "gradient_step": float,
    "number_of_time_indices": float,
    "update_field_variance_in_voxel_space": float,
    "update_field_time_variance": float,
    "total_field_variance_in_voxel_space": float,
    "total_field_time_variance": float,
})
AntsRegistrationTransformTimeVaryingVelocityFieldParamsDict = _AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictNoTag | AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged


_AntsRegistrationSplineOrder1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSplineOrder1ParamsDictNoTag', {
    "spline_order_value": float,
})
AntsRegistrationSplineOrder1ParamsDictTagged = typing.TypedDict('AntsRegistrationSplineOrder1ParamsDictTagged', {
    "@type": typing.Literal["spline_order_1"],
    "spline_order_value": float,
})
AntsRegistrationSplineOrder1ParamsDict = _AntsRegistrationSplineOrder1ParamsDictNoTag | AntsRegistrationSplineOrder1ParamsDictTagged


_AntsRegistrationNumberOfTimePointSamplesParamsDictNoTag = typing.TypedDict('_AntsRegistrationNumberOfTimePointSamplesParamsDictNoTag', {
    "number_of_time_point_samples_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrder1ParamsDict | None],
})
AntsRegistrationNumberOfTimePointSamplesParamsDictTagged = typing.TypedDict('AntsRegistrationNumberOfTimePointSamplesParamsDictTagged', {
    "@type": typing.Literal["number_of_time_point_samples"],
    "number_of_time_point_samples_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrder1ParamsDict | None],
})
AntsRegistrationNumberOfTimePointSamplesParamsDict = _AntsRegistrationNumberOfTimePointSamplesParamsDictNoTag | AntsRegistrationNumberOfTimePointSamplesParamsDictTagged


_AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictNoTag', {
    "gradient_step": float,
    "velocity_field_mesh_size": float,
    "number_of_time_point_samples": typing.NotRequired[AntsRegistrationNumberOfTimePointSamplesParamsDict | None],
})
AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged = typing.TypedDict('AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged', {
    "@type": typing.Literal["transform_time_varying_bspline_velocity_field"],
    "gradient_step": float,
    "velocity_field_mesh_size": float,
    "number_of_time_point_samples": typing.NotRequired[AntsRegistrationNumberOfTimePointSamplesParamsDict | None],
})
AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDict = _AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictNoTag | AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged


_AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictNoTag = typing.TypedDict('_AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictNoTag', {
    "total_field_variance_in_voxel_space_value": float,
})
AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictTagged = typing.TypedDict('AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictTagged', {
    "@type": typing.Literal["total_field_variance_in_voxel_space"],
    "total_field_variance_in_voxel_space_value": float,
})
AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDict = _AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictNoTag | AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictTagged


_AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictNoTag = typing.TypedDict('_AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictNoTag', {
    "update_field_variance_in_voxel_space_value": float,
    "total_field_variance_in_voxel_space": typing.NotRequired[AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDict | None],
})
AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictTagged = typing.TypedDict('AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictTagged', {
    "@type": typing.Literal["update_field_variance_in_voxel_space"],
    "update_field_variance_in_voxel_space_value": float,
    "total_field_variance_in_voxel_space": typing.NotRequired[AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDict | None],
})
AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDict = _AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictNoTag | AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictTagged


_AntsRegistrationTransformSynParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformSynParamsDictNoTag', {
    "gradient_step": float,
    "update_field_variance_in_voxel_space": typing.NotRequired[AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDict | None],
})
AntsRegistrationTransformSynParamsDictTagged = typing.TypedDict('AntsRegistrationTransformSynParamsDictTagged', {
    "@type": typing.Literal["transform_syn"],
    "gradient_step": float,
    "update_field_variance_in_voxel_space": typing.NotRequired[AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDict | None],
})
AntsRegistrationTransformSynParamsDict = _AntsRegistrationTransformSynParamsDictNoTag | AntsRegistrationTransformSynParamsDictTagged


_AntsRegistrationSplineOrder2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSplineOrder2ParamsDictNoTag', {
    "spline_order_value": float,
})
AntsRegistrationSplineOrder2ParamsDictTagged = typing.TypedDict('AntsRegistrationSplineOrder2ParamsDictTagged', {
    "@type": typing.Literal["spline_order_2"],
    "spline_order_value": float,
})
AntsRegistrationSplineOrder2ParamsDict = _AntsRegistrationSplineOrder2ParamsDictNoTag | AntsRegistrationSplineOrder2ParamsDictTagged


_AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictNoTag', {
    "total_field_mesh_size_at_base_level_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrder2ParamsDict | None],
})
AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictTagged = typing.TypedDict('AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictTagged', {
    "@type": typing.Literal["total_field_mesh_size_at_base_level_1"],
    "total_field_mesh_size_at_base_level_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrder2ParamsDict | None],
})
AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDict = _AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictNoTag | AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictTagged


_AntsRegistrationTransformBsplineSynParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformBsplineSynParamsDictNoTag', {
    "gradient_step": float,
    "update_field_mesh_size_at_base_level": float,
    "total_field_mesh_size_at_base_level": typing.NotRequired[AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDict | None],
})
AntsRegistrationTransformBsplineSynParamsDictTagged = typing.TypedDict('AntsRegistrationTransformBsplineSynParamsDictTagged', {
    "@type": typing.Literal["transform_bspline_syn"],
    "gradient_step": float,
    "update_field_mesh_size_at_base_level": float,
    "total_field_mesh_size_at_base_level": typing.NotRequired[AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDict | None],
})
AntsRegistrationTransformBsplineSynParamsDict = _AntsRegistrationTransformBsplineSynParamsDictNoTag | AntsRegistrationTransformBsplineSynParamsDictTagged


_AntsRegistrationNumberOfIntegrationStepsParamsDictNoTag = typing.TypedDict('_AntsRegistrationNumberOfIntegrationStepsParamsDictNoTag', {
    "number_of_integration_steps_value": float,
})
AntsRegistrationNumberOfIntegrationStepsParamsDictTagged = typing.TypedDict('AntsRegistrationNumberOfIntegrationStepsParamsDictTagged', {
    "@type": typing.Literal["number_of_integration_steps"],
    "number_of_integration_steps_value": float,
})
AntsRegistrationNumberOfIntegrationStepsParamsDict = _AntsRegistrationNumberOfIntegrationStepsParamsDictNoTag | AntsRegistrationNumberOfIntegrationStepsParamsDictTagged


_AntsRegistrationTransformExponentialParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformExponentialParamsDictNoTag', {
    "gradient_step": float,
    "update_field_variance_in_voxel_space": float,
    "velocity_field_variance_in_voxel_space": float,
    "number_of_integration_steps": typing.NotRequired[AntsRegistrationNumberOfIntegrationStepsParamsDict | None],
})
AntsRegistrationTransformExponentialParamsDictTagged = typing.TypedDict('AntsRegistrationTransformExponentialParamsDictTagged', {
    "@type": typing.Literal["transform_exponential"],
    "gradient_step": float,
    "update_field_variance_in_voxel_space": float,
    "velocity_field_variance_in_voxel_space": float,
    "number_of_integration_steps": typing.NotRequired[AntsRegistrationNumberOfIntegrationStepsParamsDict | None],
})
AntsRegistrationTransformExponentialParamsDict = _AntsRegistrationTransformExponentialParamsDictNoTag | AntsRegistrationTransformExponentialParamsDictTagged


_AntsRegistrationSplineOrder3ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSplineOrder3ParamsDictNoTag', {
    "spline_order_value": float,
})
AntsRegistrationSplineOrder3ParamsDictTagged = typing.TypedDict('AntsRegistrationSplineOrder3ParamsDictTagged', {
    "@type": typing.Literal["spline_order_3"],
    "spline_order_value": float,
})
AntsRegistrationSplineOrder3ParamsDict = _AntsRegistrationSplineOrder3ParamsDictNoTag | AntsRegistrationSplineOrder3ParamsDictTagged


_AntsRegistrationNumberOfIntegrationSteps1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationNumberOfIntegrationSteps1ParamsDictNoTag', {
    "number_of_integration_steps_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrder3ParamsDict | None],
})
AntsRegistrationNumberOfIntegrationSteps1ParamsDictTagged = typing.TypedDict('AntsRegistrationNumberOfIntegrationSteps1ParamsDictTagged', {
    "@type": typing.Literal["number_of_integration_steps_1"],
    "number_of_integration_steps_value": float,
    "spline_order": typing.NotRequired[AntsRegistrationSplineOrder3ParamsDict | None],
})
AntsRegistrationNumberOfIntegrationSteps1ParamsDict = _AntsRegistrationNumberOfIntegrationSteps1ParamsDictNoTag | AntsRegistrationNumberOfIntegrationSteps1ParamsDictTagged


_AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictNoTag = typing.TypedDict('_AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictNoTag', {
    "velocity_field_mesh_size_at_base_level_value": float,
    "number_of_integration_steps": typing.NotRequired[AntsRegistrationNumberOfIntegrationSteps1ParamsDict | None],
})
AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictTagged = typing.TypedDict('AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictTagged', {
    "@type": typing.Literal["velocity_field_mesh_size_at_base_level"],
    "velocity_field_mesh_size_at_base_level_value": float,
    "number_of_integration_steps": typing.NotRequired[AntsRegistrationNumberOfIntegrationSteps1ParamsDict | None],
})
AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDict = _AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictNoTag | AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictTagged


_AntsRegistrationTransformBsplineExponentialParamsDictNoTag = typing.TypedDict('_AntsRegistrationTransformBsplineExponentialParamsDictNoTag', {
    "gradient_step": float,
    "update_field_mesh_size_at_base_level": float,
    "velocity_field_mesh_size_at_base_level": typing.NotRequired[AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDict | None],
})
AntsRegistrationTransformBsplineExponentialParamsDictTagged = typing.TypedDict('AntsRegistrationTransformBsplineExponentialParamsDictTagged', {
    "@type": typing.Literal["transform_bspline_exponential"],
    "gradient_step": float,
    "update_field_mesh_size_at_base_level": float,
    "velocity_field_mesh_size_at_base_level": typing.NotRequired[AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDict | None],
})
AntsRegistrationTransformBsplineExponentialParamsDict = _AntsRegistrationTransformBsplineExponentialParamsDictNoTag | AntsRegistrationTransformBsplineExponentialParamsDictTagged


_AntsRegistrationUseGradientFilterParamsDictNoTag = typing.TypedDict('_AntsRegistrationUseGradientFilterParamsDictNoTag', {
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilterParamsDictTagged = typing.TypedDict('AntsRegistrationUseGradientFilterParamsDictTagged', {
    "@type": typing.Literal["use_gradient_filter"],
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilterParamsDict = _AntsRegistrationUseGradientFilterParamsDictNoTag | AntsRegistrationUseGradientFilterParamsDictTagged


_AntsRegistrationSamplingPercentageParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentageParamsDictNoTag', {
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilterParamsDict | None],
})
AntsRegistrationSamplingPercentageParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentageParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage"],
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilterParamsDict | None],
})
AntsRegistrationSamplingPercentageParamsDict = _AntsRegistrationSamplingPercentageParamsDictNoTag | AntsRegistrationSamplingPercentageParamsDictTagged


_AntsRegistrationSamplingStrategyParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingStrategyParamsDictNoTag', {
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentageParamsDict | None],
})
AntsRegistrationSamplingStrategyParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingStrategyParamsDictTagged', {
    "@type": typing.Literal["sampling_strategy"],
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentageParamsDict | None],
})
AntsRegistrationSamplingStrategyParamsDict = _AntsRegistrationSamplingStrategyParamsDictNoTag | AntsRegistrationSamplingStrategyParamsDictTagged


_AntsRegistrationRadiusParamsDictNoTag = typing.TypedDict('_AntsRegistrationRadiusParamsDictNoTag', {
    "radius_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategyParamsDict | None],
})
AntsRegistrationRadiusParamsDictTagged = typing.TypedDict('AntsRegistrationRadiusParamsDictTagged', {
    "@type": typing.Literal["radius"],
    "radius_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategyParamsDict | None],
})
AntsRegistrationRadiusParamsDict = _AntsRegistrationRadiusParamsDictNoTag | AntsRegistrationRadiusParamsDictTagged


_AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "radius": typing.NotRequired[AntsRegistrationRadiusParamsDict | None],
})
AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged = typing.TypedDict('AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged', {
    "@type": typing.Literal["metric_ants_neighbourhood_cross_correlation"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "radius": typing.NotRequired[AntsRegistrationRadiusParamsDict | None],
})
AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDict = _AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictNoTag | AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged


_AntsRegistrationUseGradientFilter1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationUseGradientFilter1ParamsDictNoTag', {
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter1ParamsDictTagged = typing.TypedDict('AntsRegistrationUseGradientFilter1ParamsDictTagged', {
    "@type": typing.Literal["use_gradient_filter_1"],
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter1ParamsDict = _AntsRegistrationUseGradientFilter1ParamsDictNoTag | AntsRegistrationUseGradientFilter1ParamsDictTagged


_AntsRegistrationSamplingPercentage1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage1ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter1ParamsDict | None],
})
AntsRegistrationSamplingPercentage1ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage1ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_1"],
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter1ParamsDict | None],
})
AntsRegistrationSamplingPercentage1ParamsDict = _AntsRegistrationSamplingPercentage1ParamsDictNoTag | AntsRegistrationSamplingPercentage1ParamsDictTagged


_AntsRegistrationSamplingStrategy1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingStrategy1ParamsDictNoTag', {
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage1ParamsDict | None],
})
AntsRegistrationSamplingStrategy1ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingStrategy1ParamsDictTagged', {
    "@type": typing.Literal["sampling_strategy_1"],
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage1ParamsDict | None],
})
AntsRegistrationSamplingStrategy1ParamsDict = _AntsRegistrationSamplingStrategy1ParamsDictNoTag | AntsRegistrationSamplingStrategy1ParamsDictTagged


_AntsRegistrationNumberOfBinsParamsDictNoTag = typing.TypedDict('_AntsRegistrationNumberOfBinsParamsDictNoTag', {
    "number_of_bins_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy1ParamsDict | None],
})
AntsRegistrationNumberOfBinsParamsDictTagged = typing.TypedDict('AntsRegistrationNumberOfBinsParamsDictTagged', {
    "@type": typing.Literal["number_of_bins"],
    "number_of_bins_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy1ParamsDict | None],
})
AntsRegistrationNumberOfBinsParamsDict = _AntsRegistrationNumberOfBinsParamsDictNoTag | AntsRegistrationNumberOfBinsParamsDictTagged


_AntsRegistrationMetricMutualInformationParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricMutualInformationParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "number_of_bins": typing.NotRequired[AntsRegistrationNumberOfBinsParamsDict | None],
})
AntsRegistrationMetricMutualInformationParamsDictTagged = typing.TypedDict('AntsRegistrationMetricMutualInformationParamsDictTagged', {
    "@type": typing.Literal["metric_mutual_information"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "number_of_bins": typing.NotRequired[AntsRegistrationNumberOfBinsParamsDict | None],
})
AntsRegistrationMetricMutualInformationParamsDict = _AntsRegistrationMetricMutualInformationParamsDictNoTag | AntsRegistrationMetricMutualInformationParamsDictTagged


_AntsRegistrationUseGradientFilter2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationUseGradientFilter2ParamsDictNoTag', {
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter2ParamsDictTagged = typing.TypedDict('AntsRegistrationUseGradientFilter2ParamsDictTagged', {
    "@type": typing.Literal["use_gradient_filter_2"],
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter2ParamsDict = _AntsRegistrationUseGradientFilter2ParamsDictNoTag | AntsRegistrationUseGradientFilter2ParamsDictTagged


_AntsRegistrationSamplingPercentage2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage2ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter2ParamsDict | None],
})
AntsRegistrationSamplingPercentage2ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage2ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_2"],
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter2ParamsDict | None],
})
AntsRegistrationSamplingPercentage2ParamsDict = _AntsRegistrationSamplingPercentage2ParamsDictNoTag | AntsRegistrationSamplingPercentage2ParamsDictTagged


_AntsRegistrationSamplingStrategy2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingStrategy2ParamsDictNoTag', {
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage2ParamsDict | None],
})
AntsRegistrationSamplingStrategy2ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingStrategy2ParamsDictTagged', {
    "@type": typing.Literal["sampling_strategy_2"],
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage2ParamsDict | None],
})
AntsRegistrationSamplingStrategy2ParamsDict = _AntsRegistrationSamplingStrategy2ParamsDictNoTag | AntsRegistrationSamplingStrategy2ParamsDictTagged


_AntsRegistrationNumberOfBins1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationNumberOfBins1ParamsDictNoTag', {
    "number_of_bins_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy2ParamsDict | None],
})
AntsRegistrationNumberOfBins1ParamsDictTagged = typing.TypedDict('AntsRegistrationNumberOfBins1ParamsDictTagged', {
    "@type": typing.Literal["number_of_bins_1"],
    "number_of_bins_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy2ParamsDict | None],
})
AntsRegistrationNumberOfBins1ParamsDict = _AntsRegistrationNumberOfBins1ParamsDictNoTag | AntsRegistrationNumberOfBins1ParamsDictTagged


_AntsRegistrationMetricMattesParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricMattesParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "number_of_bins": typing.NotRequired[AntsRegistrationNumberOfBins1ParamsDict | None],
})
AntsRegistrationMetricMattesParamsDictTagged = typing.TypedDict('AntsRegistrationMetricMattesParamsDictTagged', {
    "@type": typing.Literal["metric_mattes"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "number_of_bins": typing.NotRequired[AntsRegistrationNumberOfBins1ParamsDict | None],
})
AntsRegistrationMetricMattesParamsDict = _AntsRegistrationMetricMattesParamsDictNoTag | AntsRegistrationMetricMattesParamsDictTagged


_AntsRegistrationUseGradientFilter3ParamsDictNoTag = typing.TypedDict('_AntsRegistrationUseGradientFilter3ParamsDictNoTag', {
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter3ParamsDictTagged = typing.TypedDict('AntsRegistrationUseGradientFilter3ParamsDictTagged', {
    "@type": typing.Literal["use_gradient_filter_3"],
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter3ParamsDict = _AntsRegistrationUseGradientFilter3ParamsDictNoTag | AntsRegistrationUseGradientFilter3ParamsDictTagged


_AntsRegistrationSamplingPercentage3ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage3ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter3ParamsDict | None],
})
AntsRegistrationSamplingPercentage3ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage3ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_3"],
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter3ParamsDict | None],
})
AntsRegistrationSamplingPercentage3ParamsDict = _AntsRegistrationSamplingPercentage3ParamsDictNoTag | AntsRegistrationSamplingPercentage3ParamsDictTagged


_AntsRegistrationSamplingStrategy3ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingStrategy3ParamsDictNoTag', {
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage3ParamsDict | None],
})
AntsRegistrationSamplingStrategy3ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingStrategy3ParamsDictTagged', {
    "@type": typing.Literal["sampling_strategy_3"],
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage3ParamsDict | None],
})
AntsRegistrationSamplingStrategy3ParamsDict = _AntsRegistrationSamplingStrategy3ParamsDictNoTag | AntsRegistrationSamplingStrategy3ParamsDictTagged


_AntsRegistrationRadius1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationRadius1ParamsDictNoTag', {
    "radius_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy3ParamsDict | None],
})
AntsRegistrationRadius1ParamsDictTagged = typing.TypedDict('AntsRegistrationRadius1ParamsDictTagged', {
    "@type": typing.Literal["radius_1"],
    "radius_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy3ParamsDict | None],
})
AntsRegistrationRadius1ParamsDict = _AntsRegistrationRadius1ParamsDictNoTag | AntsRegistrationRadius1ParamsDictTagged


_AntsRegistrationMetricMeanSquaresParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricMeanSquaresParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "radius": typing.NotRequired[AntsRegistrationRadius1ParamsDict | None],
})
AntsRegistrationMetricMeanSquaresParamsDictTagged = typing.TypedDict('AntsRegistrationMetricMeanSquaresParamsDictTagged', {
    "@type": typing.Literal["metric_mean_squares"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "radius": typing.NotRequired[AntsRegistrationRadius1ParamsDict | None],
})
AntsRegistrationMetricMeanSquaresParamsDict = _AntsRegistrationMetricMeanSquaresParamsDictNoTag | AntsRegistrationMetricMeanSquaresParamsDictTagged


_AntsRegistrationUseGradientFilter4ParamsDictNoTag = typing.TypedDict('_AntsRegistrationUseGradientFilter4ParamsDictNoTag', {
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter4ParamsDictTagged = typing.TypedDict('AntsRegistrationUseGradientFilter4ParamsDictTagged', {
    "@type": typing.Literal["use_gradient_filter_4"],
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter4ParamsDict = _AntsRegistrationUseGradientFilter4ParamsDictNoTag | AntsRegistrationUseGradientFilter4ParamsDictTagged


_AntsRegistrationSamplingPercentage4ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage4ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter4ParamsDict | None],
})
AntsRegistrationSamplingPercentage4ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage4ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_4"],
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter4ParamsDict | None],
})
AntsRegistrationSamplingPercentage4ParamsDict = _AntsRegistrationSamplingPercentage4ParamsDictNoTag | AntsRegistrationSamplingPercentage4ParamsDictTagged


_AntsRegistrationSamplingStrategy4ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingStrategy4ParamsDictNoTag', {
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage4ParamsDict | None],
})
AntsRegistrationSamplingStrategy4ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingStrategy4ParamsDictTagged', {
    "@type": typing.Literal["sampling_strategy_4"],
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage4ParamsDict | None],
})
AntsRegistrationSamplingStrategy4ParamsDict = _AntsRegistrationSamplingStrategy4ParamsDictNoTag | AntsRegistrationSamplingStrategy4ParamsDictTagged


_AntsRegistrationNumberOfBins2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationNumberOfBins2ParamsDictNoTag', {
    "number_of_bins_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy4ParamsDict | None],
})
AntsRegistrationNumberOfBins2ParamsDictTagged = typing.TypedDict('AntsRegistrationNumberOfBins2ParamsDictTagged', {
    "@type": typing.Literal["number_of_bins_2"],
    "number_of_bins_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy4ParamsDict | None],
})
AntsRegistrationNumberOfBins2ParamsDict = _AntsRegistrationNumberOfBins2ParamsDictNoTag | AntsRegistrationNumberOfBins2ParamsDictTagged


_AntsRegistrationMetricDemonsParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricDemonsParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "number_of_bins": typing.NotRequired[AntsRegistrationNumberOfBins2ParamsDict | None],
})
AntsRegistrationMetricDemonsParamsDictTagged = typing.TypedDict('AntsRegistrationMetricDemonsParamsDictTagged', {
    "@type": typing.Literal["metric_demons"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "number_of_bins": typing.NotRequired[AntsRegistrationNumberOfBins2ParamsDict | None],
})
AntsRegistrationMetricDemonsParamsDict = _AntsRegistrationMetricDemonsParamsDictNoTag | AntsRegistrationMetricDemonsParamsDictTagged


_AntsRegistrationUseGradientFilter5ParamsDictNoTag = typing.TypedDict('_AntsRegistrationUseGradientFilter5ParamsDictNoTag', {
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter5ParamsDictTagged = typing.TypedDict('AntsRegistrationUseGradientFilter5ParamsDictTagged', {
    "@type": typing.Literal["use_gradient_filter_5"],
    "use_gradient_filter_value": bool,
})
AntsRegistrationUseGradientFilter5ParamsDict = _AntsRegistrationUseGradientFilter5ParamsDictNoTag | AntsRegistrationUseGradientFilter5ParamsDictTagged


_AntsRegistrationSamplingPercentage5ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage5ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter5ParamsDict | None],
})
AntsRegistrationSamplingPercentage5ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage5ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_5"],
    "sampling_percentage_value": float,
    "use_gradient_filter": typing.NotRequired[AntsRegistrationUseGradientFilter5ParamsDict | None],
})
AntsRegistrationSamplingPercentage5ParamsDict = _AntsRegistrationSamplingPercentage5ParamsDictNoTag | AntsRegistrationSamplingPercentage5ParamsDictTagged


_AntsRegistrationSamplingStrategy5ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingStrategy5ParamsDictNoTag', {
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage5ParamsDict | None],
})
AntsRegistrationSamplingStrategy5ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingStrategy5ParamsDictTagged', {
    "@type": typing.Literal["sampling_strategy_5"],
    "sampling_strategy_value": typing.Literal["None", "Regular", "Random"],
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage5ParamsDict | None],
})
AntsRegistrationSamplingStrategy5ParamsDict = _AntsRegistrationSamplingStrategy5ParamsDictNoTag | AntsRegistrationSamplingStrategy5ParamsDictTagged


_AntsRegistrationRadius2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationRadius2ParamsDictNoTag', {
    "radius_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy5ParamsDict | None],
})
AntsRegistrationRadius2ParamsDictTagged = typing.TypedDict('AntsRegistrationRadius2ParamsDictTagged', {
    "@type": typing.Literal["radius_2"],
    "radius_value": float,
    "sampling_strategy": typing.NotRequired[AntsRegistrationSamplingStrategy5ParamsDict | None],
})
AntsRegistrationRadius2ParamsDict = _AntsRegistrationRadius2ParamsDictNoTag | AntsRegistrationRadius2ParamsDictTagged


_AntsRegistrationMetricGlobalCorrelationParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricGlobalCorrelationParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "radius": typing.NotRequired[AntsRegistrationRadius2ParamsDict | None],
})
AntsRegistrationMetricGlobalCorrelationParamsDictTagged = typing.TypedDict('AntsRegistrationMetricGlobalCorrelationParamsDictTagged', {
    "@type": typing.Literal["metric_global_correlation"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "radius": typing.NotRequired[AntsRegistrationRadius2ParamsDict | None],
})
AntsRegistrationMetricGlobalCorrelationParamsDict = _AntsRegistrationMetricGlobalCorrelationParamsDictNoTag | AntsRegistrationMetricGlobalCorrelationParamsDictTagged


_AntsRegistrationBoundaryPointsOnlyParamsDictNoTag = typing.TypedDict('_AntsRegistrationBoundaryPointsOnlyParamsDictNoTag', {
    "boundary_points_only_value": typing.Literal["0"],
})
AntsRegistrationBoundaryPointsOnlyParamsDictTagged = typing.TypedDict('AntsRegistrationBoundaryPointsOnlyParamsDictTagged', {
    "@type": typing.Literal["boundary_points_only"],
    "boundary_points_only_value": typing.Literal["0"],
})
AntsRegistrationBoundaryPointsOnlyParamsDict = _AntsRegistrationBoundaryPointsOnlyParamsDictNoTag | AntsRegistrationBoundaryPointsOnlyParamsDictTagged


_AntsRegistrationSamplingPercentage6ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage6ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "boundary_points_only": typing.NotRequired[AntsRegistrationBoundaryPointsOnlyParamsDict | None],
})
AntsRegistrationSamplingPercentage6ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage6ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_6"],
    "sampling_percentage_value": float,
    "boundary_points_only": typing.NotRequired[AntsRegistrationBoundaryPointsOnlyParamsDict | None],
})
AntsRegistrationSamplingPercentage6ParamsDict = _AntsRegistrationSamplingPercentage6ParamsDictNoTag | AntsRegistrationSamplingPercentage6ParamsDictTagged


_AntsRegistrationMetricEuclideanIcpParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricEuclideanIcpParamsDictNoTag', {
    "fixed_point_set": str,
    "moving_point_set": str,
    "metric_weight": float,
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage6ParamsDict | None],
})
AntsRegistrationMetricEuclideanIcpParamsDictTagged = typing.TypedDict('AntsRegistrationMetricEuclideanIcpParamsDictTagged', {
    "@type": typing.Literal["metric_euclidean_icp"],
    "fixed_point_set": str,
    "moving_point_set": str,
    "metric_weight": float,
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage6ParamsDict | None],
})
AntsRegistrationMetricEuclideanIcpParamsDict = _AntsRegistrationMetricEuclideanIcpParamsDictNoTag | AntsRegistrationMetricEuclideanIcpParamsDictTagged


_AntsRegistrationKNeighborhoodParamsDictNoTag = typing.TypedDict('_AntsRegistrationKNeighborhoodParamsDictNoTag', {
    "k_neighborhood_value": float,
})
AntsRegistrationKNeighborhoodParamsDictTagged = typing.TypedDict('AntsRegistrationKNeighborhoodParamsDictTagged', {
    "@type": typing.Literal["k_neighborhood"],
    "k_neighborhood_value": float,
})
AntsRegistrationKNeighborhoodParamsDict = _AntsRegistrationKNeighborhoodParamsDictNoTag | AntsRegistrationKNeighborhoodParamsDictTagged


_AntsRegistrationPointSetSigmaParamsDictNoTag = typing.TypedDict('_AntsRegistrationPointSetSigmaParamsDictNoTag', {
    "point_set_sigma_value": float,
    "k_neighborhood": typing.NotRequired[AntsRegistrationKNeighborhoodParamsDict | None],
})
AntsRegistrationPointSetSigmaParamsDictTagged = typing.TypedDict('AntsRegistrationPointSetSigmaParamsDictTagged', {
    "@type": typing.Literal["point_set_sigma"],
    "point_set_sigma_value": float,
    "k_neighborhood": typing.NotRequired[AntsRegistrationKNeighborhoodParamsDict | None],
})
AntsRegistrationPointSetSigmaParamsDict = _AntsRegistrationPointSetSigmaParamsDictNoTag | AntsRegistrationPointSetSigmaParamsDictTagged


_AntsRegistrationBoundaryPointsOnly1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationBoundaryPointsOnly1ParamsDictNoTag', {
    "boundary_points_only_value": typing.Literal["0"],
    "point_set_sigma": typing.NotRequired[AntsRegistrationPointSetSigmaParamsDict | None],
})
AntsRegistrationBoundaryPointsOnly1ParamsDictTagged = typing.TypedDict('AntsRegistrationBoundaryPointsOnly1ParamsDictTagged', {
    "@type": typing.Literal["boundary_points_only_1"],
    "boundary_points_only_value": typing.Literal["0"],
    "point_set_sigma": typing.NotRequired[AntsRegistrationPointSetSigmaParamsDict | None],
})
AntsRegistrationBoundaryPointsOnly1ParamsDict = _AntsRegistrationBoundaryPointsOnly1ParamsDictNoTag | AntsRegistrationBoundaryPointsOnly1ParamsDictTagged


_AntsRegistrationSamplingPercentage7ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage7ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "boundary_points_only": typing.NotRequired[AntsRegistrationBoundaryPointsOnly1ParamsDict | None],
})
AntsRegistrationSamplingPercentage7ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage7ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_7"],
    "sampling_percentage_value": float,
    "boundary_points_only": typing.NotRequired[AntsRegistrationBoundaryPointsOnly1ParamsDict | None],
})
AntsRegistrationSamplingPercentage7ParamsDict = _AntsRegistrationSamplingPercentage7ParamsDictNoTag | AntsRegistrationSamplingPercentage7ParamsDictTagged


_AntsRegistrationMetricPointSetExpectationParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricPointSetExpectationParamsDictNoTag', {
    "fixed_point_set": str,
    "moving_point_set": str,
    "metric_weight": float,
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage7ParamsDict | None],
})
AntsRegistrationMetricPointSetExpectationParamsDictTagged = typing.TypedDict('AntsRegistrationMetricPointSetExpectationParamsDictTagged', {
    "@type": typing.Literal["metric_point_set_expectation"],
    "fixed_point_set": str,
    "moving_point_set": str,
    "metric_weight": float,
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage7ParamsDict | None],
})
AntsRegistrationMetricPointSetExpectationParamsDict = _AntsRegistrationMetricPointSetExpectationParamsDictNoTag | AntsRegistrationMetricPointSetExpectationParamsDictTagged


_AntsRegistrationKNeighborhood1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationKNeighborhood1ParamsDictNoTag', {
    "k_neighborhood_value": float,
})
AntsRegistrationKNeighborhood1ParamsDictTagged = typing.TypedDict('AntsRegistrationKNeighborhood1ParamsDictTagged', {
    "@type": typing.Literal["k_neighborhood_1"],
    "k_neighborhood_value": float,
})
AntsRegistrationKNeighborhood1ParamsDict = _AntsRegistrationKNeighborhood1ParamsDictNoTag | AntsRegistrationKNeighborhood1ParamsDictTagged


_AntsRegistrationPointSetSigma1ParamsDictNoTag = typing.TypedDict('_AntsRegistrationPointSetSigma1ParamsDictNoTag', {
    "point_set_sigma_value": float,
    "k_neighborhood": typing.NotRequired[AntsRegistrationKNeighborhood1ParamsDict | None],
})
AntsRegistrationPointSetSigma1ParamsDictTagged = typing.TypedDict('AntsRegistrationPointSetSigma1ParamsDictTagged', {
    "@type": typing.Literal["point_set_sigma_1"],
    "point_set_sigma_value": float,
    "k_neighborhood": typing.NotRequired[AntsRegistrationKNeighborhood1ParamsDict | None],
})
AntsRegistrationPointSetSigma1ParamsDict = _AntsRegistrationPointSetSigma1ParamsDictNoTag | AntsRegistrationPointSetSigma1ParamsDictTagged


_AntsRegistrationBoundaryPointsOnly2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationBoundaryPointsOnly2ParamsDictNoTag', {
    "boundary_points_only_value": typing.Literal["0"],
    "point_set_sigma": typing.NotRequired[AntsRegistrationPointSetSigma1ParamsDict | None],
})
AntsRegistrationBoundaryPointsOnly2ParamsDictTagged = typing.TypedDict('AntsRegistrationBoundaryPointsOnly2ParamsDictTagged', {
    "@type": typing.Literal["boundary_points_only_2"],
    "boundary_points_only_value": typing.Literal["0"],
    "point_set_sigma": typing.NotRequired[AntsRegistrationPointSetSigma1ParamsDict | None],
})
AntsRegistrationBoundaryPointsOnly2ParamsDict = _AntsRegistrationBoundaryPointsOnly2ParamsDictNoTag | AntsRegistrationBoundaryPointsOnly2ParamsDictTagged


_AntsRegistrationSamplingPercentage8ParamsDictNoTag = typing.TypedDict('_AntsRegistrationSamplingPercentage8ParamsDictNoTag', {
    "sampling_percentage_value": float,
    "boundary_points_only": typing.NotRequired[AntsRegistrationBoundaryPointsOnly2ParamsDict | None],
})
AntsRegistrationSamplingPercentage8ParamsDictTagged = typing.TypedDict('AntsRegistrationSamplingPercentage8ParamsDictTagged', {
    "@type": typing.Literal["sampling_percentage_8"],
    "sampling_percentage_value": float,
    "boundary_points_only": typing.NotRequired[AntsRegistrationBoundaryPointsOnly2ParamsDict | None],
})
AntsRegistrationSamplingPercentage8ParamsDict = _AntsRegistrationSamplingPercentage8ParamsDictNoTag | AntsRegistrationSamplingPercentage8ParamsDictTagged


_AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictNoTag', {
    "fixed_point_set": str,
    "moving_point_set": str,
    "metric_weight": float,
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage8ParamsDict | None],
})
AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged = typing.TypedDict('AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged', {
    "@type": typing.Literal["metric_jensen_havrda_charvet_tsallis"],
    "fixed_point_set": str,
    "moving_point_set": str,
    "metric_weight": float,
    "sampling_percentage": typing.NotRequired[AntsRegistrationSamplingPercentage8ParamsDict | None],
})
AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDict = _AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictNoTag | AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged


_AntsRegistrationGradientSigmaParamsDictNoTag = typing.TypedDict('_AntsRegistrationGradientSigmaParamsDictNoTag', {
    "gradient_sigma_value": float,
})
AntsRegistrationGradientSigmaParamsDictTagged = typing.TypedDict('AntsRegistrationGradientSigmaParamsDictTagged', {
    "@type": typing.Literal["gradient_sigma"],
    "gradient_sigma_value": float,
})
AntsRegistrationGradientSigmaParamsDict = _AntsRegistrationGradientSigmaParamsDictNoTag | AntsRegistrationGradientSigmaParamsDictTagged


_AntsRegistrationKNeighborhood2ParamsDictNoTag = typing.TypedDict('_AntsRegistrationKNeighborhood2ParamsDictNoTag', {
    "k_neighborhood_value": float,
    "gradient_sigma": typing.NotRequired[AntsRegistrationGradientSigmaParamsDict | None],
})
AntsRegistrationKNeighborhood2ParamsDictTagged = typing.TypedDict('AntsRegistrationKNeighborhood2ParamsDictTagged', {
    "@type": typing.Literal["k_neighborhood_2"],
    "k_neighborhood_value": float,
    "gradient_sigma": typing.NotRequired[AntsRegistrationGradientSigmaParamsDict | None],
})
AntsRegistrationKNeighborhood2ParamsDict = _AntsRegistrationKNeighborhood2ParamsDictNoTag | AntsRegistrationKNeighborhood2ParamsDictTagged


_AntsRegistrationDistanceSigmaParamsDictNoTag = typing.TypedDict('_AntsRegistrationDistanceSigmaParamsDictNoTag', {
    "distance_sigma_value": float,
    "k_neighborhood": typing.NotRequired[AntsRegistrationKNeighborhood2ParamsDict | None],
})
AntsRegistrationDistanceSigmaParamsDictTagged = typing.TypedDict('AntsRegistrationDistanceSigmaParamsDictTagged', {
    "@type": typing.Literal["distance_sigma"],
    "distance_sigma_value": float,
    "k_neighborhood": typing.NotRequired[AntsRegistrationKNeighborhood2ParamsDict | None],
})
AntsRegistrationDistanceSigmaParamsDict = _AntsRegistrationDistanceSigmaParamsDictNoTag | AntsRegistrationDistanceSigmaParamsDictTagged


_AntsRegistrationIntensitySigmaParamsDictNoTag = typing.TypedDict('_AntsRegistrationIntensitySigmaParamsDictNoTag', {
    "intensity_sigma_value": float,
    "distance_sigma": typing.NotRequired[AntsRegistrationDistanceSigmaParamsDict | None],
})
AntsRegistrationIntensitySigmaParamsDictTagged = typing.TypedDict('AntsRegistrationIntensitySigmaParamsDictTagged', {
    "@type": typing.Literal["intensity_sigma"],
    "intensity_sigma_value": float,
    "distance_sigma": typing.NotRequired[AntsRegistrationDistanceSigmaParamsDict | None],
})
AntsRegistrationIntensitySigmaParamsDict = _AntsRegistrationIntensitySigmaParamsDictNoTag | AntsRegistrationIntensitySigmaParamsDictTagged


_AntsRegistrationNeighborhoodRadiusParamsDictNoTag = typing.TypedDict('_AntsRegistrationNeighborhoodRadiusParamsDictNoTag', {
    "neighborhood_radius_value": str,
    "intensity_sigma": typing.NotRequired[AntsRegistrationIntensitySigmaParamsDict | None],
})
AntsRegistrationNeighborhoodRadiusParamsDictTagged = typing.TypedDict('AntsRegistrationNeighborhoodRadiusParamsDictTagged', {
    "@type": typing.Literal["neighborhood_radius"],
    "neighborhood_radius_value": str,
    "intensity_sigma": typing.NotRequired[AntsRegistrationIntensitySigmaParamsDict | None],
})
AntsRegistrationNeighborhoodRadiusParamsDict = _AntsRegistrationNeighborhoodRadiusParamsDictNoTag | AntsRegistrationNeighborhoodRadiusParamsDictTagged


_AntsRegistrationMetricIgdmParamsDictNoTag = typing.TypedDict('_AntsRegistrationMetricIgdmParamsDictNoTag', {
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "fixed_mask": str,
    "moving_mask": str,
    "neighborhood_radius": typing.NotRequired[AntsRegistrationNeighborhoodRadiusParamsDict | None],
})
AntsRegistrationMetricIgdmParamsDictTagged = typing.TypedDict('AntsRegistrationMetricIgdmParamsDictTagged', {
    "@type": typing.Literal["metric_igdm"],
    "fixed_image": InputPathType,
    "moving_image": InputPathType,
    "metric_weight": float,
    "fixed_mask": str,
    "moving_mask": str,
    "neighborhood_radius": typing.NotRequired[AntsRegistrationNeighborhoodRadiusParamsDict | None],
})
AntsRegistrationMetricIgdmParamsDict = _AntsRegistrationMetricIgdmParamsDictNoTag | AntsRegistrationMetricIgdmParamsDictTagged


_AntsRegistrationConvergenceParamsDictNoTag = typing.TypedDict('_AntsRegistrationConvergenceParamsDictNoTag', {
    "convergence": str,
    "convergence_threshold": float,
    "convergence_window_size": int,
})
AntsRegistrationConvergenceParamsDictTagged = typing.TypedDict('AntsRegistrationConvergenceParamsDictTagged', {
    "@type": typing.Literal["convergence"],
    "convergence": str,
    "convergence_threshold": float,
    "convergence_window_size": int,
})
AntsRegistrationConvergenceParamsDict = _AntsRegistrationConvergenceParamsDictNoTag | AntsRegistrationConvergenceParamsDictTagged


_AntsRegistrationStageParamsDictNoTag = typing.TypedDict('_AntsRegistrationStageParamsDictNoTag', {
    "transform": typing.Union[AntsRegistrationTransformRigidParamsDictTagged, AntsRegistrationTransformAffineParamsDictTagged, AntsRegistrationTransformCompositeAffineParamsDictTagged, AntsRegistrationTransformSimilarityParamsDictTagged, AntsRegistrationTransformTranslationParamsDictTagged, AntsRegistrationTransformBsplineParamsDictTagged, AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged, AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged, AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged, AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged, AntsRegistrationTransformSynParamsDictTagged, AntsRegistrationTransformBsplineSynParamsDictTagged, AntsRegistrationTransformExponentialParamsDictTagged, AntsRegistrationTransformBsplineExponentialParamsDictTagged],
    "metric": typing.Union[AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged, AntsRegistrationMetricMutualInformationParamsDictTagged, AntsRegistrationMetricMattesParamsDictTagged, AntsRegistrationMetricMeanSquaresParamsDictTagged, AntsRegistrationMetricDemonsParamsDictTagged, AntsRegistrationMetricGlobalCorrelationParamsDictTagged, AntsRegistrationMetricEuclideanIcpParamsDictTagged, AntsRegistrationMetricPointSetExpectationParamsDictTagged, AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged, AntsRegistrationMetricIgdmParamsDictTagged],
    "convergence": AntsRegistrationConvergenceParamsDict,
    "smoothing_sigmas": str,
    "shrink_factors": str,
    "use_histogram_matching": typing.NotRequired[bool | None],
})
AntsRegistrationStageParamsDictTagged = typing.TypedDict('AntsRegistrationStageParamsDictTagged', {
    "@type": typing.Literal["stage"],
    "transform": typing.Union[AntsRegistrationTransformRigidParamsDictTagged, AntsRegistrationTransformAffineParamsDictTagged, AntsRegistrationTransformCompositeAffineParamsDictTagged, AntsRegistrationTransformSimilarityParamsDictTagged, AntsRegistrationTransformTranslationParamsDictTagged, AntsRegistrationTransformBsplineParamsDictTagged, AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged, AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged, AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged, AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged, AntsRegistrationTransformSynParamsDictTagged, AntsRegistrationTransformBsplineSynParamsDictTagged, AntsRegistrationTransformExponentialParamsDictTagged, AntsRegistrationTransformBsplineExponentialParamsDictTagged],
    "metric": typing.Union[AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged, AntsRegistrationMetricMutualInformationParamsDictTagged, AntsRegistrationMetricMattesParamsDictTagged, AntsRegistrationMetricMeanSquaresParamsDictTagged, AntsRegistrationMetricDemonsParamsDictTagged, AntsRegistrationMetricGlobalCorrelationParamsDictTagged, AntsRegistrationMetricEuclideanIcpParamsDictTagged, AntsRegistrationMetricPointSetExpectationParamsDictTagged, AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged, AntsRegistrationMetricIgdmParamsDictTagged],
    "convergence": AntsRegistrationConvergenceParamsDict,
    "smoothing_sigmas": str,
    "shrink_factors": str,
    "use_histogram_matching": typing.NotRequired[bool | None],
})
AntsRegistrationStageParamsDict = _AntsRegistrationStageParamsDictNoTag | AntsRegistrationStageParamsDictTagged


_AntsRegistrationWinsorizeImageIntensitiesParamsDictNoTag = typing.TypedDict('_AntsRegistrationWinsorizeImageIntensitiesParamsDictNoTag', {
    "lower_quantile": float,
    "upper_quantile": float,
})
AntsRegistrationWinsorizeImageIntensitiesParamsDictTagged = typing.TypedDict('AntsRegistrationWinsorizeImageIntensitiesParamsDictTagged', {
    "@type": typing.Literal["winsorize_image_intensities"],
    "lower_quantile": float,
    "upper_quantile": float,
})
AntsRegistrationWinsorizeImageIntensitiesParamsDict = _AntsRegistrationWinsorizeImageIntensitiesParamsDictNoTag | AntsRegistrationWinsorizeImageIntensitiesParamsDictTagged


_AntsRegistrationMovingMaskParamsDictNoTag = typing.TypedDict('_AntsRegistrationMovingMaskParamsDictNoTag', {
    "moving_mask_value": str,
})
AntsRegistrationMovingMaskParamsDictTagged = typing.TypedDict('AntsRegistrationMovingMaskParamsDictTagged', {
    "@type": typing.Literal["moving_mask"],
    "moving_mask_value": str,
})
AntsRegistrationMovingMaskParamsDict = _AntsRegistrationMovingMaskParamsDictNoTag | AntsRegistrationMovingMaskParamsDictTagged


_AntsRegistrationMasksParamsDictNoTag = typing.TypedDict('_AntsRegistrationMasksParamsDictNoTag', {
    "fixed_mask": typing.NotRequired[str | None],
    "moving_mask": typing.NotRequired[AntsRegistrationMovingMaskParamsDict | None],
})
AntsRegistrationMasksParamsDictTagged = typing.TypedDict('AntsRegistrationMasksParamsDictTagged', {
    "@type": typing.Literal["masks"],
    "fixed_mask": typing.NotRequired[str | None],
    "moving_mask": typing.NotRequired[AntsRegistrationMovingMaskParamsDict | None],
})
AntsRegistrationMasksParamsDict = _AntsRegistrationMasksParamsDictNoTag | AntsRegistrationMasksParamsDictTagged


_AntsRegistrationParamsDictNoTag = typing.TypedDict('_AntsRegistrationParamsDictNoTag', {
    "dimensionality": typing.NotRequired[typing.Literal[2, 3, 4] | None],
    "output": typing.NotRequired[str | None],
    "save_state": typing.NotRequired[str | None],
    "restore_state": typing.NotRequired[str | None],
    "write_composite_transform": typing.NotRequired[bool | None],
    "print_similarity_measure_interval": typing.NotRequired[int | None],
    "write_interval_volumes": typing.NotRequired[int | None],
    "collapse_output_transforms": typing.NotRequired[bool | None],
    "initialize_transforms_per_stage": typing.NotRequired[bool | None],
    "interpolation": typing.NotRequired[typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None],
    "restrict_deformation": typing.NotRequired[list[bool] | None],
    "initial_fixed_transform": typing.NotRequired[str | None],
    "initial_moving_transform": typing.NotRequired[typing.Union[AntsRegistrationInitialMovingTransformParamsDictTagged, AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged, AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged] | None],
    "stages": list[AntsRegistrationStageParamsDict],
    "winsorize_image_intensities": typing.NotRequired[AntsRegistrationWinsorizeImageIntensitiesParamsDict | None],
    "masks": typing.NotRequired[AntsRegistrationMasksParamsDict | None],
    "minc": typing.NotRequired[bool | None],
    "random_seed": typing.NotRequired[int | None],
    "verbose": typing.NotRequired[bool | None],
    "float": typing.NotRequired[bool | None],
})
AntsRegistrationParamsDictTagged = typing.TypedDict('AntsRegistrationParamsDictTagged', {
    "@type": typing.Literal["ants/antsRegistration"],
    "dimensionality": typing.NotRequired[typing.Literal[2, 3, 4] | None],
    "output": typing.NotRequired[str | None],
    "save_state": typing.NotRequired[str | None],
    "restore_state": typing.NotRequired[str | None],
    "write_composite_transform": typing.NotRequired[bool | None],
    "print_similarity_measure_interval": typing.NotRequired[int | None],
    "write_interval_volumes": typing.NotRequired[int | None],
    "collapse_output_transforms": typing.NotRequired[bool | None],
    "initialize_transforms_per_stage": typing.NotRequired[bool | None],
    "interpolation": typing.NotRequired[typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None],
    "restrict_deformation": typing.NotRequired[list[bool] | None],
    "initial_fixed_transform": typing.NotRequired[str | None],
    "initial_moving_transform": typing.NotRequired[typing.Union[AntsRegistrationInitialMovingTransformParamsDictTagged, AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged, AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged] | None],
    "stages": list[AntsRegistrationStageParamsDict],
    "winsorize_image_intensities": typing.NotRequired[AntsRegistrationWinsorizeImageIntensitiesParamsDict | None],
    "masks": typing.NotRequired[AntsRegistrationMasksParamsDict | None],
    "minc": typing.NotRequired[bool | None],
    "random_seed": typing.NotRequired[int | None],
    "verbose": typing.NotRequired[bool | None],
    "float": typing.NotRequired[bool | None],
})
AntsRegistrationParamsDict = _AntsRegistrationParamsDictNoTag | AntsRegistrationParamsDictTagged


def ants_registration_initial_moving_transform_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "initial_moving_transform": ants_registration_initial_moving_transform_cargs,
        "initial_moving_transform_use_inverse": ants_registration_initial_moving_transform_use_inverse_cargs,
        "initial_moving_transform_initialization_feature": ants_registration_initial_moving_transform_initialization_feature_cargs,
    }.get(t)


def ants_registration_initial_moving_transform_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "initial_moving_transform": ants_registration_initial_moving_transform_validate,
        "initial_moving_transform_use_inverse": ants_registration_initial_moving_transform_use_inverse_validate,
        "initial_moving_transform_initialization_feature": ants_registration_initial_moving_transform_initialization_feature_validate,
    }.get(t)


def ants_registration_transform_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "transform_rigid": ants_registration_transform_rigid_cargs,
        "transform_affine": ants_registration_transform_affine_cargs,
        "transform_composite_affine": ants_registration_transform_composite_affine_cargs,
        "transform_similarity": ants_registration_transform_similarity_cargs,
        "transform_translation": ants_registration_transform_translation_cargs,
        "transform_bspline": ants_registration_transform_bspline_cargs,
        "transform_gaussian_displacement_field": ants_registration_transform_gaussian_displacement_field_cargs,
        "transform_bspline_displacement_field": ants_registration_transform_bspline_displacement_field_cargs,
        "transform_time_varying_velocity_field": ants_registration_transform_time_varying_velocity_field_cargs,
        "transform_time_varying_bspline_velocity_field": ants_registration_transform_time_varying_bspline_velocity_field_cargs,
        "transform_syn": ants_registration_transform_syn_cargs,
        "transform_bspline_syn": ants_registration_transform_bspline_syn_cargs,
        "transform_exponential": ants_registration_transform_exponential_cargs,
        "transform_bspline_exponential": ants_registration_transform_bspline_exponential_cargs,
    }.get(t)


def ants_registration_transform_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "transform_rigid": ants_registration_transform_rigid_validate,
        "transform_affine": ants_registration_transform_affine_validate,
        "transform_composite_affine": ants_registration_transform_composite_affine_validate,
        "transform_similarity": ants_registration_transform_similarity_validate,
        "transform_translation": ants_registration_transform_translation_validate,
        "transform_bspline": ants_registration_transform_bspline_validate,
        "transform_gaussian_displacement_field": ants_registration_transform_gaussian_displacement_field_validate,
        "transform_bspline_displacement_field": ants_registration_transform_bspline_displacement_field_validate,
        "transform_time_varying_velocity_field": ants_registration_transform_time_varying_velocity_field_validate,
        "transform_time_varying_bspline_velocity_field": ants_registration_transform_time_varying_bspline_velocity_field_validate,
        "transform_syn": ants_registration_transform_syn_validate,
        "transform_bspline_syn": ants_registration_transform_bspline_syn_validate,
        "transform_exponential": ants_registration_transform_exponential_validate,
        "transform_bspline_exponential": ants_registration_transform_bspline_exponential_validate,
    }.get(t)


def ants_registration_metric_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "metric_ants_neighbourhood_cross_correlation": ants_registration_metric_ants_neighbourhood_cross_correlation_cargs,
        "metric_mutual_information": ants_registration_metric_mutual_information_cargs,
        "metric_mattes": ants_registration_metric_mattes_cargs,
        "metric_mean_squares": ants_registration_metric_mean_squares_cargs,
        "metric_demons": ants_registration_metric_demons_cargs,
        "metric_global_correlation": ants_registration_metric_global_correlation_cargs,
        "metric_euclidean_icp": ants_registration_metric_euclidean_icp_cargs,
        "metric_point_set_expectation": ants_registration_metric_point_set_expectation_cargs,
        "metric_jensen_havrda_charvet_tsallis": ants_registration_metric_jensen_havrda_charvet_tsallis_cargs,
        "metric_igdm": ants_registration_metric_igdm_cargs,
    }.get(t)


def ants_registration_metric_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "metric_ants_neighbourhood_cross_correlation": ants_registration_metric_ants_neighbourhood_cross_correlation_validate,
        "metric_mutual_information": ants_registration_metric_mutual_information_validate,
        "metric_mattes": ants_registration_metric_mattes_validate,
        "metric_mean_squares": ants_registration_metric_mean_squares_validate,
        "metric_demons": ants_registration_metric_demons_validate,
        "metric_global_correlation": ants_registration_metric_global_correlation_validate,
        "metric_euclidean_icp": ants_registration_metric_euclidean_icp_validate,
        "metric_point_set_expectation": ants_registration_metric_point_set_expectation_validate,
        "metric_jensen_havrda_charvet_tsallis": ants_registration_metric_jensen_havrda_charvet_tsallis_validate,
        "metric_igdm": ants_registration_metric_igdm_validate,
    }.get(t)


def ants_registration_initial_moving_transform(
    initial_moving_transform: InputPathType,
) -> AntsRegistrationInitialMovingTransformParamsDictTagged:
    """
    Build parameters.
    
    Args:
        initial_moving_transform:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "initial_moving_transform",
        "initial_moving_transform": initial_moving_transform,
    }
    return params


def ants_registration_initial_moving_transform_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationInitialMovingTransformParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("initial_moving_transform", None) is None:
        raise StyxValidationError("`initial_moving_transform` must not be None")
    if not isinstance(params["initial_moving_transform"], (pathlib.Path, str)):
        raise StyxValidationError(f'`initial_moving_transform` has the wrong type: Received `{type(params.get("initial_moving_transform", None))}` expected `InputPathType`')


def ants_registration_initial_moving_transform_cargs(
    params: AntsRegistrationInitialMovingTransformParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("initial_moving_transform", None)))
    return cargs


def ants_registration_use_inverse(
    use_inverse_value: bool,
) -> AntsRegistrationUseInverseParamsDictTagged:
    """
    Build parameters.
    
    Args:
        use_inverse_value: Use the inverse of the initial moving transform.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "use_inverse",
        "use_inverse_value": use_inverse_value,
    }
    return params


def ants_registration_use_inverse_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUseInverseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("use_inverse_value", None) is None:
        raise StyxValidationError("`use_inverse_value` must not be None")
    if not isinstance(params["use_inverse_value"], bool):
        raise StyxValidationError(f'`use_inverse_value` has the wrong type: Received `{type(params.get("use_inverse_value", None))}` expected `bool`')


def ants_registration_use_inverse_cargs(
    params: AntsRegistrationUseInverseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + ("1" if params.get("use_inverse_value", None) else "0"))
    return cargs


def ants_registration_initial_moving_transform_use_inverse(
    initial_moving_transform: InputPathType,
    use_inverse: AntsRegistrationUseInverseParamsDict | None = None,
) -> AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged:
    """
    Build parameters.
    
    Args:
        initial_moving_transform:.
        use_inverse:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "initial_moving_transform_use_inverse",
        "initial_moving_transform": initial_moving_transform,
    }
    if use_inverse is not None:
        params["use_inverse"] = use_inverse
    return params


def ants_registration_initial_moving_transform_use_inverse_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationInitialMovingTransformUseInverseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("initial_moving_transform", None) is None:
        raise StyxValidationError("`initial_moving_transform` must not be None")
    if not isinstance(params["initial_moving_transform"], (pathlib.Path, str)):
        raise StyxValidationError(f'`initial_moving_transform` has the wrong type: Received `{type(params.get("initial_moving_transform", None))}` expected `InputPathType`')
    if params.get("use_inverse", None) is not None:
        ants_registration_use_inverse_validate(params["use_inverse"])


def ants_registration_initial_moving_transform_use_inverse_cargs(
    params: AntsRegistrationInitialMovingTransformUseInverseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("initial_moving_transform", None)) + "".join((ants_registration_use_inverse_cargs(params.get("use_inverse", None), execution) if (params.get("use_inverse", None) is not None) else [])))
    return cargs


def ants_registration_initial_moving_transform_initialization_feature(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    initialization_feature: typing.Literal[0, 1, 2],
) -> AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        initialization_feature: Initialization feature. 0: Geometric center of\
            images, 1: Image intensities, 2: Origin of images.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "initial_moving_transform_initialization_feature",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "initialization_feature": initialization_feature,
    }
    return params


def ants_registration_initial_moving_transform_initialization_feature_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationInitialMovingTransformInitializationFeatureParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("initialization_feature", None) is None:
        raise StyxValidationError("`initialization_feature` must not be None")
    if not isinstance(params["initialization_feature"], int):
        raise StyxValidationError(f'`initialization_feature` has the wrong type: Received `{type(params.get("initialization_feature", None))}` expected `typing.Literal[0, 1, 2]`')
    if params["initialization_feature"] not in [0, 1, 2]:
        raise StyxValidationError("Parameter `initialization_feature` must be one of [0, 1, 2]")


def ants_registration_initial_moving_transform_initialization_feature_cargs(
    params: AntsRegistrationInitialMovingTransformInitializationFeatureParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("initialization_feature", None)) + "]")
    return cargs


def ants_registration_transform_rigid(
    gradient_step: float,
) -> AntsRegistrationTransformRigidParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_rigid",
        "gradient_step": gradient_step,
    }
    return params


def ants_registration_transform_rigid_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformRigidParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')


def ants_registration_transform_rigid_cargs(
    params: AntsRegistrationTransformRigidParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Rigid[" + str(params.get("gradient_step", None)) + "]")
    return cargs


def ants_registration_transform_affine(
    gradient_step: float,
) -> AntsRegistrationTransformAffineParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_affine",
        "gradient_step": gradient_step,
    }
    return params


def ants_registration_transform_affine_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformAffineParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')


def ants_registration_transform_affine_cargs(
    params: AntsRegistrationTransformAffineParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Affine[" + str(params.get("gradient_step", None)) + "]")
    return cargs


def ants_registration_transform_composite_affine(
    gradient_step: float,
) -> AntsRegistrationTransformCompositeAffineParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_composite_affine",
        "gradient_step": gradient_step,
    }
    return params


def ants_registration_transform_composite_affine_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformCompositeAffineParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')


def ants_registration_transform_composite_affine_cargs(
    params: AntsRegistrationTransformCompositeAffineParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("CompositeAffine[" + str(params.get("gradient_step", None)) + "]")
    return cargs


def ants_registration_transform_similarity(
    gradient_step: float,
) -> AntsRegistrationTransformSimilarityParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_similarity",
        "gradient_step": gradient_step,
    }
    return params


def ants_registration_transform_similarity_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformSimilarityParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')


def ants_registration_transform_similarity_cargs(
    params: AntsRegistrationTransformSimilarityParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Similarity[" + str(params.get("gradient_step", None)) + "]")
    return cargs


def ants_registration_transform_translation(
    gradient_step: float,
) -> AntsRegistrationTransformTranslationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_translation",
        "gradient_step": gradient_step,
    }
    return params


def ants_registration_transform_translation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformTranslationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')


def ants_registration_transform_translation_cargs(
    params: AntsRegistrationTransformTranslationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Translation[" + str(params.get("gradient_step", None)) + "]")
    return cargs


def ants_registration_transform_bspline(
    gradient_step: float,
    mesh_size_at_base_level: float,
) -> AntsRegistrationTransformBsplineParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        mesh_size_at_base_level:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_bspline",
        "gradient_step": gradient_step,
        "mesh_size_at_base_level": mesh_size_at_base_level,
    }
    return params


def ants_registration_transform_bspline_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformBsplineParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("mesh_size_at_base_level", None) is None:
        raise StyxValidationError("`mesh_size_at_base_level` must not be None")
    if not isinstance(params["mesh_size_at_base_level"], (float, int)):
        raise StyxValidationError(f'`mesh_size_at_base_level` has the wrong type: Received `{type(params.get("mesh_size_at_base_level", None))}` expected `float`')


def ants_registration_transform_bspline_cargs(
    params: AntsRegistrationTransformBsplineParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("BSpline[" + str(params.get("gradient_step", None)) + "," + str(params.get("mesh_size_at_base_level", None)) + "]")
    return cargs


def ants_registration_transform_gaussian_displacement_field(
    gradient_step: float,
    update_field_variance_in_voxel_space: float,
    total_field_variance_in_voxel_space: float,
) -> AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        update_field_variance_in_voxel_space:.
        total_field_variance_in_voxel_space:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_gaussian_displacement_field",
        "gradient_step": gradient_step,
        "update_field_variance_in_voxel_space": update_field_variance_in_voxel_space,
        "total_field_variance_in_voxel_space": total_field_variance_in_voxel_space,
    }
    return params


def ants_registration_transform_gaussian_displacement_field_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformGaussianDisplacementFieldParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("update_field_variance_in_voxel_space", None) is None:
        raise StyxValidationError("`update_field_variance_in_voxel_space` must not be None")
    if not isinstance(params["update_field_variance_in_voxel_space"], (float, int)):
        raise StyxValidationError(f'`update_field_variance_in_voxel_space` has the wrong type: Received `{type(params.get("update_field_variance_in_voxel_space", None))}` expected `float`')
    if params.get("total_field_variance_in_voxel_space", None) is None:
        raise StyxValidationError("`total_field_variance_in_voxel_space` must not be None")
    if not isinstance(params["total_field_variance_in_voxel_space"], (float, int)):
        raise StyxValidationError(f'`total_field_variance_in_voxel_space` has the wrong type: Received `{type(params.get("total_field_variance_in_voxel_space", None))}` expected `float`')


def ants_registration_transform_gaussian_displacement_field_cargs(
    params: AntsRegistrationTransformGaussianDisplacementFieldParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("GaussianDisplacementField[" + str(params.get("gradient_step", None)) + "," + str(params.get("update_field_variance_in_voxel_space", None)) + "," + str(params.get("total_field_variance_in_voxel_space", None)) + "]")
    return cargs


def ants_registration_spline_order(
    spline_order_value: float,
) -> AntsRegistrationSplineOrderParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spline_order_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "spline_order",
        "spline_order_value": spline_order_value,
    }
    return params


def ants_registration_spline_order_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSplineOrderParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spline_order_value", None) is None:
        raise StyxValidationError("`spline_order_value` must not be None")
    if not isinstance(params["spline_order_value"], (float, int)):
        raise StyxValidationError(f'`spline_order_value` has the wrong type: Received `{type(params.get("spline_order_value", None))}` expected `float`')


def ants_registration_spline_order_cargs(
    params: AntsRegistrationSplineOrderParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("spline_order_value", None)))
    return cargs


def ants_registration_total_field_mesh_size_at_base_level(
    total_field_mesh_size_at_base_level_value: float,
    spline_order: AntsRegistrationSplineOrderParamsDict | None = None,
) -> AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        total_field_mesh_size_at_base_level_value:.
        spline_order:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "total_field_mesh_size_at_base_level",
        "total_field_mesh_size_at_base_level_value": total_field_mesh_size_at_base_level_value,
    }
    if spline_order is not None:
        params["spline_order"] = spline_order
    return params


def ants_registration_total_field_mesh_size_at_base_level_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("total_field_mesh_size_at_base_level_value", None) is None:
        raise StyxValidationError("`total_field_mesh_size_at_base_level_value` must not be None")
    if not isinstance(params["total_field_mesh_size_at_base_level_value"], (float, int)):
        raise StyxValidationError(f'`total_field_mesh_size_at_base_level_value` has the wrong type: Received `{type(params.get("total_field_mesh_size_at_base_level_value", None))}` expected `float`')
    if params.get("spline_order", None) is not None:
        ants_registration_spline_order_validate(params["spline_order"])


def ants_registration_total_field_mesh_size_at_base_level_cargs(
    params: AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("total_field_mesh_size_at_base_level_value", None)) + "".join((ants_registration_spline_order_cargs(params.get("spline_order", None), execution) if (params.get("spline_order", None) is not None) else [])))
    return cargs


def ants_registration_transform_bspline_displacement_field(
    gradient_step: float,
    update_field_mesh_size_at_base_level: float,
    total_field_mesh_size_at_base_level: AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDict | None = None,
) -> AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        update_field_mesh_size_at_base_level:.
        total_field_mesh_size_at_base_level:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_bspline_displacement_field",
        "gradient_step": gradient_step,
        "update_field_mesh_size_at_base_level": update_field_mesh_size_at_base_level,
    }
    if total_field_mesh_size_at_base_level is not None:
        params["total_field_mesh_size_at_base_level"] = total_field_mesh_size_at_base_level
    return params


def ants_registration_transform_bspline_displacement_field_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformBsplineDisplacementFieldParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("update_field_mesh_size_at_base_level", None) is None:
        raise StyxValidationError("`update_field_mesh_size_at_base_level` must not be None")
    if not isinstance(params["update_field_mesh_size_at_base_level"], (float, int)):
        raise StyxValidationError(f'`update_field_mesh_size_at_base_level` has the wrong type: Received `{type(params.get("update_field_mesh_size_at_base_level", None))}` expected `float`')
    if params.get("total_field_mesh_size_at_base_level", None) is not None:
        ants_registration_total_field_mesh_size_at_base_level_validate(params["total_field_mesh_size_at_base_level"])


def ants_registration_transform_bspline_displacement_field_cargs(
    params: AntsRegistrationTransformBsplineDisplacementFieldParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("BSplineDisplacementField[" + str(params.get("gradient_step", None)) + "," + str(params.get("update_field_mesh_size_at_base_level", None)) + "".join((ants_registration_total_field_mesh_size_at_base_level_cargs(params.get("total_field_mesh_size_at_base_level", None), execution) if (params.get("total_field_mesh_size_at_base_level", None) is not None) else [])) + "]")
    return cargs


def ants_registration_transform_time_varying_velocity_field(
    gradient_step: float,
    number_of_time_indices: float,
    update_field_variance_in_voxel_space: float,
    update_field_time_variance: float,
    total_field_variance_in_voxel_space: float,
    total_field_time_variance: float,
) -> AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        number_of_time_indices:.
        update_field_variance_in_voxel_space:.
        update_field_time_variance:.
        total_field_variance_in_voxel_space:.
        total_field_time_variance:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_time_varying_velocity_field",
        "gradient_step": gradient_step,
        "number_of_time_indices": number_of_time_indices,
        "update_field_variance_in_voxel_space": update_field_variance_in_voxel_space,
        "update_field_time_variance": update_field_time_variance,
        "total_field_variance_in_voxel_space": total_field_variance_in_voxel_space,
        "total_field_time_variance": total_field_time_variance,
    }
    return params


def ants_registration_transform_time_varying_velocity_field_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformTimeVaryingVelocityFieldParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("number_of_time_indices", None) is None:
        raise StyxValidationError("`number_of_time_indices` must not be None")
    if not isinstance(params["number_of_time_indices"], (float, int)):
        raise StyxValidationError(f'`number_of_time_indices` has the wrong type: Received `{type(params.get("number_of_time_indices", None))}` expected `float`')
    if params.get("update_field_variance_in_voxel_space", None) is None:
        raise StyxValidationError("`update_field_variance_in_voxel_space` must not be None")
    if not isinstance(params["update_field_variance_in_voxel_space"], (float, int)):
        raise StyxValidationError(f'`update_field_variance_in_voxel_space` has the wrong type: Received `{type(params.get("update_field_variance_in_voxel_space", None))}` expected `float`')
    if params.get("update_field_time_variance", None) is None:
        raise StyxValidationError("`update_field_time_variance` must not be None")
    if not isinstance(params["update_field_time_variance"], (float, int)):
        raise StyxValidationError(f'`update_field_time_variance` has the wrong type: Received `{type(params.get("update_field_time_variance", None))}` expected `float`')
    if params.get("total_field_variance_in_voxel_space", None) is None:
        raise StyxValidationError("`total_field_variance_in_voxel_space` must not be None")
    if not isinstance(params["total_field_variance_in_voxel_space"], (float, int)):
        raise StyxValidationError(f'`total_field_variance_in_voxel_space` has the wrong type: Received `{type(params.get("total_field_variance_in_voxel_space", None))}` expected `float`')
    if params.get("total_field_time_variance", None) is None:
        raise StyxValidationError("`total_field_time_variance` must not be None")
    if not isinstance(params["total_field_time_variance"], (float, int)):
        raise StyxValidationError(f'`total_field_time_variance` has the wrong type: Received `{type(params.get("total_field_time_variance", None))}` expected `float`')


def ants_registration_transform_time_varying_velocity_field_cargs(
    params: AntsRegistrationTransformTimeVaryingVelocityFieldParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("TimeVaryingVelocityField[" + str(params.get("gradient_step", None)) + "," + str(params.get("number_of_time_indices", None)) + "," + str(params.get("update_field_variance_in_voxel_space", None)) + "," + str(params.get("update_field_time_variance", None)) + "," + str(params.get("total_field_variance_in_voxel_space", None)) + "," + str(params.get("total_field_time_variance", None)) + "]")
    return cargs


def ants_registration_spline_order_1(
    spline_order_value: float,
) -> AntsRegistrationSplineOrder1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spline_order_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "spline_order_1",
        "spline_order_value": spline_order_value,
    }
    return params


def ants_registration_spline_order_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSplineOrder1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spline_order_value", None) is None:
        raise StyxValidationError("`spline_order_value` must not be None")
    if not isinstance(params["spline_order_value"], (float, int)):
        raise StyxValidationError(f'`spline_order_value` has the wrong type: Received `{type(params.get("spline_order_value", None))}` expected `float`')


def ants_registration_spline_order_1_cargs(
    params: AntsRegistrationSplineOrder1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("spline_order_value", None)))
    return cargs


def ants_registration_number_of_time_point_samples(
    number_of_time_point_samples_value: float,
    spline_order: AntsRegistrationSplineOrder1ParamsDict | None = None,
) -> AntsRegistrationNumberOfTimePointSamplesParamsDictTagged:
    """
    Build parameters.
    
    Args:
        number_of_time_point_samples_value:.
        spline_order:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "number_of_time_point_samples",
        "number_of_time_point_samples_value": number_of_time_point_samples_value,
    }
    if spline_order is not None:
        params["spline_order"] = spline_order
    return params


def ants_registration_number_of_time_point_samples_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationNumberOfTimePointSamplesParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("number_of_time_point_samples_value", None) is None:
        raise StyxValidationError("`number_of_time_point_samples_value` must not be None")
    if not isinstance(params["number_of_time_point_samples_value"], (float, int)):
        raise StyxValidationError(f'`number_of_time_point_samples_value` has the wrong type: Received `{type(params.get("number_of_time_point_samples_value", None))}` expected `float`')
    if params.get("spline_order", None) is not None:
        ants_registration_spline_order_1_validate(params["spline_order"])


def ants_registration_number_of_time_point_samples_cargs(
    params: AntsRegistrationNumberOfTimePointSamplesParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("number_of_time_point_samples_value", None)) + "".join((ants_registration_spline_order_1_cargs(params.get("spline_order", None), execution) if (params.get("spline_order", None) is not None) else [])))
    return cargs


def ants_registration_transform_time_varying_bspline_velocity_field(
    gradient_step: float,
    velocity_field_mesh_size: float,
    number_of_time_point_samples: AntsRegistrationNumberOfTimePointSamplesParamsDict | None = None,
) -> AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        velocity_field_mesh_size:.
        number_of_time_point_samples:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_time_varying_bspline_velocity_field",
        "gradient_step": gradient_step,
        "velocity_field_mesh_size": velocity_field_mesh_size,
    }
    if number_of_time_point_samples is not None:
        params["number_of_time_point_samples"] = number_of_time_point_samples
    return params


def ants_registration_transform_time_varying_bspline_velocity_field_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("velocity_field_mesh_size", None) is None:
        raise StyxValidationError("`velocity_field_mesh_size` must not be None")
    if not isinstance(params["velocity_field_mesh_size"], (float, int)):
        raise StyxValidationError(f'`velocity_field_mesh_size` has the wrong type: Received `{type(params.get("velocity_field_mesh_size", None))}` expected `float`')
    if params.get("number_of_time_point_samples", None) is not None:
        ants_registration_number_of_time_point_samples_validate(params["number_of_time_point_samples"])


def ants_registration_transform_time_varying_bspline_velocity_field_cargs(
    params: AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("TimeVaryingBSplineVelocityField[" + str(params.get("gradient_step", None)) + "," + str(params.get("velocity_field_mesh_size", None)) + "".join((ants_registration_number_of_time_point_samples_cargs(params.get("number_of_time_point_samples", None), execution) if (params.get("number_of_time_point_samples", None) is not None) else [])) + "]")
    return cargs


def ants_registration_total_field_variance_in_voxel_space(
    total_field_variance_in_voxel_space_value: float,
) -> AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        total_field_variance_in_voxel_space_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "total_field_variance_in_voxel_space",
        "total_field_variance_in_voxel_space_value": total_field_variance_in_voxel_space_value,
    }
    return params


def ants_registration_total_field_variance_in_voxel_space_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("total_field_variance_in_voxel_space_value", None) is None:
        raise StyxValidationError("`total_field_variance_in_voxel_space_value` must not be None")
    if not isinstance(params["total_field_variance_in_voxel_space_value"], (float, int)):
        raise StyxValidationError(f'`total_field_variance_in_voxel_space_value` has the wrong type: Received `{type(params.get("total_field_variance_in_voxel_space_value", None))}` expected `float`')


def ants_registration_total_field_variance_in_voxel_space_cargs(
    params: AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("total_field_variance_in_voxel_space_value", None)))
    return cargs


def ants_registration_update_field_variance_in_voxel_space(
    update_field_variance_in_voxel_space_value: float,
    total_field_variance_in_voxel_space: AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDict | None = None,
) -> AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        update_field_variance_in_voxel_space_value:.
        total_field_variance_in_voxel_space:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "update_field_variance_in_voxel_space",
        "update_field_variance_in_voxel_space_value": update_field_variance_in_voxel_space_value,
    }
    if total_field_variance_in_voxel_space is not None:
        params["total_field_variance_in_voxel_space"] = total_field_variance_in_voxel_space
    return params


def ants_registration_update_field_variance_in_voxel_space_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("update_field_variance_in_voxel_space_value", None) is None:
        raise StyxValidationError("`update_field_variance_in_voxel_space_value` must not be None")
    if not isinstance(params["update_field_variance_in_voxel_space_value"], (float, int)):
        raise StyxValidationError(f'`update_field_variance_in_voxel_space_value` has the wrong type: Received `{type(params.get("update_field_variance_in_voxel_space_value", None))}` expected `float`')
    if params.get("total_field_variance_in_voxel_space", None) is not None:
        ants_registration_total_field_variance_in_voxel_space_validate(params["total_field_variance_in_voxel_space"])


def ants_registration_update_field_variance_in_voxel_space_cargs(
    params: AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("update_field_variance_in_voxel_space_value", None)) + "".join((ants_registration_total_field_variance_in_voxel_space_cargs(params.get("total_field_variance_in_voxel_space", None), execution) if (params.get("total_field_variance_in_voxel_space", None) is not None) else [])))
    return cargs


def ants_registration_transform_syn(
    gradient_step: float,
    update_field_variance_in_voxel_space: AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDict | None = None,
) -> AntsRegistrationTransformSynParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        update_field_variance_in_voxel_space:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_syn",
        "gradient_step": gradient_step,
    }
    if update_field_variance_in_voxel_space is not None:
        params["update_field_variance_in_voxel_space"] = update_field_variance_in_voxel_space
    return params


def ants_registration_transform_syn_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformSynParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("update_field_variance_in_voxel_space", None) is not None:
        ants_registration_update_field_variance_in_voxel_space_validate(params["update_field_variance_in_voxel_space"])


def ants_registration_transform_syn_cargs(
    params: AntsRegistrationTransformSynParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("SyN[" + str(params.get("gradient_step", None)) + "".join((ants_registration_update_field_variance_in_voxel_space_cargs(params.get("update_field_variance_in_voxel_space", None), execution) if (params.get("update_field_variance_in_voxel_space", None) is not None) else [])) + "]")
    return cargs


def ants_registration_spline_order_2(
    spline_order_value: float,
) -> AntsRegistrationSplineOrder2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spline_order_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "spline_order_2",
        "spline_order_value": spline_order_value,
    }
    return params


def ants_registration_spline_order_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSplineOrder2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spline_order_value", None) is None:
        raise StyxValidationError("`spline_order_value` must not be None")
    if not isinstance(params["spline_order_value"], (float, int)):
        raise StyxValidationError(f'`spline_order_value` has the wrong type: Received `{type(params.get("spline_order_value", None))}` expected `float`')


def ants_registration_spline_order_2_cargs(
    params: AntsRegistrationSplineOrder2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("spline_order_value", None)))
    return cargs


def ants_registration_total_field_mesh_size_at_base_level_1(
    total_field_mesh_size_at_base_level_value: float,
    spline_order: AntsRegistrationSplineOrder2ParamsDict | None = None,
) -> AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        total_field_mesh_size_at_base_level_value:.
        spline_order:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "total_field_mesh_size_at_base_level_1",
        "total_field_mesh_size_at_base_level_value": total_field_mesh_size_at_base_level_value,
    }
    if spline_order is not None:
        params["spline_order"] = spline_order
    return params


def ants_registration_total_field_mesh_size_at_base_level_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("total_field_mesh_size_at_base_level_value", None) is None:
        raise StyxValidationError("`total_field_mesh_size_at_base_level_value` must not be None")
    if not isinstance(params["total_field_mesh_size_at_base_level_value"], (float, int)):
        raise StyxValidationError(f'`total_field_mesh_size_at_base_level_value` has the wrong type: Received `{type(params.get("total_field_mesh_size_at_base_level_value", None))}` expected `float`')
    if params.get("spline_order", None) is not None:
        ants_registration_spline_order_2_validate(params["spline_order"])


def ants_registration_total_field_mesh_size_at_base_level_1_cargs(
    params: AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("total_field_mesh_size_at_base_level_value", None)) + "".join((ants_registration_spline_order_2_cargs(params.get("spline_order", None), execution) if (params.get("spline_order", None) is not None) else [])))
    return cargs


def ants_registration_transform_bspline_syn(
    gradient_step: float,
    update_field_mesh_size_at_base_level: float,
    total_field_mesh_size_at_base_level: AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDict | None = None,
) -> AntsRegistrationTransformBsplineSynParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        update_field_mesh_size_at_base_level:.
        total_field_mesh_size_at_base_level:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_bspline_syn",
        "gradient_step": gradient_step,
        "update_field_mesh_size_at_base_level": update_field_mesh_size_at_base_level,
    }
    if total_field_mesh_size_at_base_level is not None:
        params["total_field_mesh_size_at_base_level"] = total_field_mesh_size_at_base_level
    return params


def ants_registration_transform_bspline_syn_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformBsplineSynParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("update_field_mesh_size_at_base_level", None) is None:
        raise StyxValidationError("`update_field_mesh_size_at_base_level` must not be None")
    if not isinstance(params["update_field_mesh_size_at_base_level"], (float, int)):
        raise StyxValidationError(f'`update_field_mesh_size_at_base_level` has the wrong type: Received `{type(params.get("update_field_mesh_size_at_base_level", None))}` expected `float`')
    if params.get("total_field_mesh_size_at_base_level", None) is not None:
        ants_registration_total_field_mesh_size_at_base_level_1_validate(params["total_field_mesh_size_at_base_level"])


def ants_registration_transform_bspline_syn_cargs(
    params: AntsRegistrationTransformBsplineSynParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("BSplineSyN[" + str(params.get("gradient_step", None)) + "," + str(params.get("update_field_mesh_size_at_base_level", None)) + "".join((ants_registration_total_field_mesh_size_at_base_level_1_cargs(params.get("total_field_mesh_size_at_base_level", None), execution) if (params.get("total_field_mesh_size_at_base_level", None) is not None) else [])) + "]")
    return cargs


def ants_registration_number_of_integration_steps(
    number_of_integration_steps_value: float,
) -> AntsRegistrationNumberOfIntegrationStepsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        number_of_integration_steps_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "number_of_integration_steps",
        "number_of_integration_steps_value": number_of_integration_steps_value,
    }
    return params


def ants_registration_number_of_integration_steps_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationNumberOfIntegrationStepsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("number_of_integration_steps_value", None) is None:
        raise StyxValidationError("`number_of_integration_steps_value` must not be None")
    if not isinstance(params["number_of_integration_steps_value"], (float, int)):
        raise StyxValidationError(f'`number_of_integration_steps_value` has the wrong type: Received `{type(params.get("number_of_integration_steps_value", None))}` expected `float`')


def ants_registration_number_of_integration_steps_cargs(
    params: AntsRegistrationNumberOfIntegrationStepsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("number_of_integration_steps_value", None)))
    return cargs


def ants_registration_transform_exponential(
    gradient_step: float,
    update_field_variance_in_voxel_space: float,
    velocity_field_variance_in_voxel_space: float,
    number_of_integration_steps: AntsRegistrationNumberOfIntegrationStepsParamsDict | None = None,
) -> AntsRegistrationTransformExponentialParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        update_field_variance_in_voxel_space:.
        velocity_field_variance_in_voxel_space:.
        number_of_integration_steps:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_exponential",
        "gradient_step": gradient_step,
        "update_field_variance_in_voxel_space": update_field_variance_in_voxel_space,
        "velocity_field_variance_in_voxel_space": velocity_field_variance_in_voxel_space,
    }
    if number_of_integration_steps is not None:
        params["number_of_integration_steps"] = number_of_integration_steps
    return params


def ants_registration_transform_exponential_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformExponentialParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("update_field_variance_in_voxel_space", None) is None:
        raise StyxValidationError("`update_field_variance_in_voxel_space` must not be None")
    if not isinstance(params["update_field_variance_in_voxel_space"], (float, int)):
        raise StyxValidationError(f'`update_field_variance_in_voxel_space` has the wrong type: Received `{type(params.get("update_field_variance_in_voxel_space", None))}` expected `float`')
    if params.get("velocity_field_variance_in_voxel_space", None) is None:
        raise StyxValidationError("`velocity_field_variance_in_voxel_space` must not be None")
    if not isinstance(params["velocity_field_variance_in_voxel_space"], (float, int)):
        raise StyxValidationError(f'`velocity_field_variance_in_voxel_space` has the wrong type: Received `{type(params.get("velocity_field_variance_in_voxel_space", None))}` expected `float`')
    if params.get("number_of_integration_steps", None) is not None:
        ants_registration_number_of_integration_steps_validate(params["number_of_integration_steps"])


def ants_registration_transform_exponential_cargs(
    params: AntsRegistrationTransformExponentialParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Exponential[" + str(params.get("gradient_step", None)) + "," + str(params.get("update_field_variance_in_voxel_space", None)) + "," + str(params.get("velocity_field_variance_in_voxel_space", None)) + "".join((ants_registration_number_of_integration_steps_cargs(params.get("number_of_integration_steps", None), execution) if (params.get("number_of_integration_steps", None) is not None) else [])) + "]")
    return cargs


def ants_registration_spline_order_3(
    spline_order_value: float,
) -> AntsRegistrationSplineOrder3ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spline_order_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "spline_order_3",
        "spline_order_value": spline_order_value,
    }
    return params


def ants_registration_spline_order_3_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSplineOrder3ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spline_order_value", None) is None:
        raise StyxValidationError("`spline_order_value` must not be None")
    if not isinstance(params["spline_order_value"], (float, int)):
        raise StyxValidationError(f'`spline_order_value` has the wrong type: Received `{type(params.get("spline_order_value", None))}` expected `float`')


def ants_registration_spline_order_3_cargs(
    params: AntsRegistrationSplineOrder3ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("spline_order_value", None)))
    return cargs


def ants_registration_number_of_integration_steps_1(
    number_of_integration_steps_value: float,
    spline_order: AntsRegistrationSplineOrder3ParamsDict | None = None,
) -> AntsRegistrationNumberOfIntegrationSteps1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        number_of_integration_steps_value:.
        spline_order:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "number_of_integration_steps_1",
        "number_of_integration_steps_value": number_of_integration_steps_value,
    }
    if spline_order is not None:
        params["spline_order"] = spline_order
    return params


def ants_registration_number_of_integration_steps_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationNumberOfIntegrationSteps1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("number_of_integration_steps_value", None) is None:
        raise StyxValidationError("`number_of_integration_steps_value` must not be None")
    if not isinstance(params["number_of_integration_steps_value"], (float, int)):
        raise StyxValidationError(f'`number_of_integration_steps_value` has the wrong type: Received `{type(params.get("number_of_integration_steps_value", None))}` expected `float`')
    if params.get("spline_order", None) is not None:
        ants_registration_spline_order_3_validate(params["spline_order"])


def ants_registration_number_of_integration_steps_1_cargs(
    params: AntsRegistrationNumberOfIntegrationSteps1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("number_of_integration_steps_value", None)) + "".join((ants_registration_spline_order_3_cargs(params.get("spline_order", None), execution) if (params.get("spline_order", None) is not None) else [])))
    return cargs


def ants_registration_velocity_field_mesh_size_at_base_level(
    velocity_field_mesh_size_at_base_level_value: float,
    number_of_integration_steps: AntsRegistrationNumberOfIntegrationSteps1ParamsDict | None = None,
) -> AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        velocity_field_mesh_size_at_base_level_value:.
        number_of_integration_steps:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "velocity_field_mesh_size_at_base_level",
        "velocity_field_mesh_size_at_base_level_value": velocity_field_mesh_size_at_base_level_value,
    }
    if number_of_integration_steps is not None:
        params["number_of_integration_steps"] = number_of_integration_steps
    return params


def ants_registration_velocity_field_mesh_size_at_base_level_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("velocity_field_mesh_size_at_base_level_value", None) is None:
        raise StyxValidationError("`velocity_field_mesh_size_at_base_level_value` must not be None")
    if not isinstance(params["velocity_field_mesh_size_at_base_level_value"], (float, int)):
        raise StyxValidationError(f'`velocity_field_mesh_size_at_base_level_value` has the wrong type: Received `{type(params.get("velocity_field_mesh_size_at_base_level_value", None))}` expected `float`')
    if params.get("number_of_integration_steps", None) is not None:
        ants_registration_number_of_integration_steps_1_validate(params["number_of_integration_steps"])


def ants_registration_velocity_field_mesh_size_at_base_level_cargs(
    params: AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("velocity_field_mesh_size_at_base_level_value", None)) + "".join((ants_registration_number_of_integration_steps_1_cargs(params.get("number_of_integration_steps", None), execution) if (params.get("number_of_integration_steps", None) is not None) else [])))
    return cargs


def ants_registration_transform_bspline_exponential(
    gradient_step: float,
    update_field_mesh_size_at_base_level: float,
    velocity_field_mesh_size_at_base_level: AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDict | None = None,
) -> AntsRegistrationTransformBsplineExponentialParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_step:.
        update_field_mesh_size_at_base_level:.
        velocity_field_mesh_size_at_base_level:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "transform_bspline_exponential",
        "gradient_step": gradient_step,
        "update_field_mesh_size_at_base_level": update_field_mesh_size_at_base_level,
    }
    if velocity_field_mesh_size_at_base_level is not None:
        params["velocity_field_mesh_size_at_base_level"] = velocity_field_mesh_size_at_base_level
    return params


def ants_registration_transform_bspline_exponential_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationTransformBsplineExponentialParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_step", None) is None:
        raise StyxValidationError("`gradient_step` must not be None")
    if not isinstance(params["gradient_step"], (float, int)):
        raise StyxValidationError(f'`gradient_step` has the wrong type: Received `{type(params.get("gradient_step", None))}` expected `float`')
    if params.get("update_field_mesh_size_at_base_level", None) is None:
        raise StyxValidationError("`update_field_mesh_size_at_base_level` must not be None")
    if not isinstance(params["update_field_mesh_size_at_base_level"], (float, int)):
        raise StyxValidationError(f'`update_field_mesh_size_at_base_level` has the wrong type: Received `{type(params.get("update_field_mesh_size_at_base_level", None))}` expected `float`')
    if params.get("velocity_field_mesh_size_at_base_level", None) is not None:
        ants_registration_velocity_field_mesh_size_at_base_level_validate(params["velocity_field_mesh_size_at_base_level"])


def ants_registration_transform_bspline_exponential_cargs(
    params: AntsRegistrationTransformBsplineExponentialParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("BSplineExponential[" + str(params.get("gradient_step", None)) + "," + str(params.get("update_field_mesh_size_at_base_level", None)) + "".join((ants_registration_velocity_field_mesh_size_at_base_level_cargs(params.get("velocity_field_mesh_size_at_base_level", None), execution) if (params.get("velocity_field_mesh_size_at_base_level", None) is not None) else [])) + "]")
    return cargs


def ants_registration_use_gradient_filter(
    use_gradient_filter_value: bool,
) -> AntsRegistrationUseGradientFilterParamsDictTagged:
    """
    Build parameters.
    
    Args:
        use_gradient_filter_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "use_gradient_filter",
        "use_gradient_filter_value": use_gradient_filter_value,
    }
    return params


def ants_registration_use_gradient_filter_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUseGradientFilterParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("use_gradient_filter_value", None) is None:
        raise StyxValidationError("`use_gradient_filter_value` must not be None")
    if not isinstance(params["use_gradient_filter_value"], bool):
        raise StyxValidationError(f'`use_gradient_filter_value` has the wrong type: Received `{type(params.get("use_gradient_filter_value", None))}` expected `bool`')


def ants_registration_use_gradient_filter_cargs(
    params: AntsRegistrationUseGradientFilterParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + ("true" if params.get("use_gradient_filter_value", None) else "false"))
    return cargs


def ants_registration_sampling_percentage(
    sampling_percentage_value: float,
    use_gradient_filter: AntsRegistrationUseGradientFilterParamsDict | None = None,
) -> AntsRegistrationSamplingPercentageParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        use_gradient_filter:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if use_gradient_filter is not None:
        params["use_gradient_filter"] = use_gradient_filter
    return params


def ants_registration_sampling_percentage_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentageParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("use_gradient_filter", None) is not None:
        ants_registration_use_gradient_filter_validate(params["use_gradient_filter"])


def ants_registration_sampling_percentage_cargs(
    params: AntsRegistrationSamplingPercentageParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_use_gradient_filter_cargs(params.get("use_gradient_filter", None), execution) if (params.get("use_gradient_filter", None) is not None) else [])))
    return cargs


def ants_registration_sampling_strategy(
    sampling_strategy_value: typing.Literal["None", "Regular", "Random"],
    sampling_percentage: AntsRegistrationSamplingPercentageParamsDict | None = None,
) -> AntsRegistrationSamplingStrategyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_strategy_value:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_strategy",
        "sampling_strategy_value": sampling_strategy_value,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_sampling_strategy_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingStrategyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_strategy_value", None) is None:
        raise StyxValidationError("`sampling_strategy_value` must not be None")
    if not isinstance(params["sampling_strategy_value"], str):
        raise StyxValidationError(f'`sampling_strategy_value` has the wrong type: Received `{type(params.get("sampling_strategy_value", None))}` expected `typing.Literal["None", "Regular", "Random"]`')
    if params["sampling_strategy_value"] not in ["None", "Regular", "Random"]:
        raise StyxValidationError("Parameter `sampling_strategy_value` must be one of [\"None\", \"Regular\", \"Random\"]")
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_validate(params["sampling_percentage"])


def ants_registration_sampling_strategy_cargs(
    params: AntsRegistrationSamplingStrategyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("sampling_strategy_value", None) + "".join((ants_registration_sampling_percentage_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])))
    return cargs


def ants_registration_radius(
    radius_value: float,
    sampling_strategy: AntsRegistrationSamplingStrategyParamsDict | None = None,
) -> AntsRegistrationRadiusParamsDictTagged:
    """
    Build parameters.
    
    Args:
        radius_value:.
        sampling_strategy:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "radius",
        "radius_value": radius_value,
    }
    if sampling_strategy is not None:
        params["sampling_strategy"] = sampling_strategy
    return params


def ants_registration_radius_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationRadiusParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("radius_value", None) is None:
        raise StyxValidationError("`radius_value` must not be None")
    if not isinstance(params["radius_value"], (float, int)):
        raise StyxValidationError(f'`radius_value` has the wrong type: Received `{type(params.get("radius_value", None))}` expected `float`')
    if params.get("sampling_strategy", None) is not None:
        ants_registration_sampling_strategy_validate(params["sampling_strategy"])


def ants_registration_radius_cargs(
    params: AntsRegistrationRadiusParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("radius_value", None)) + "".join((ants_registration_sampling_strategy_cargs(params.get("sampling_strategy", None), execution) if (params.get("sampling_strategy", None) is not None) else [])))
    return cargs


def ants_registration_metric_ants_neighbourhood_cross_correlation(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    metric_weight: float,
    radius: AntsRegistrationRadiusParamsDict | None = None,
) -> AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        metric_weight:.
        radius:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_ants_neighbourhood_cross_correlation",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "metric_weight": metric_weight,
    }
    if radius is not None:
        params["radius"] = radius
    return params


def ants_registration_metric_ants_neighbourhood_cross_correlation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("radius", None) is not None:
        ants_registration_radius_validate(params["radius"])


def ants_registration_metric_ants_neighbourhood_cross_correlation_cargs(
    params: AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("CC[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_radius_cargs(params.get("radius", None), execution) if (params.get("radius", None) is not None) else [])) + "]")
    return cargs


def ants_registration_use_gradient_filter_1(
    use_gradient_filter_value: bool,
) -> AntsRegistrationUseGradientFilter1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        use_gradient_filter_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "use_gradient_filter_1",
        "use_gradient_filter_value": use_gradient_filter_value,
    }
    return params


def ants_registration_use_gradient_filter_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUseGradientFilter1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("use_gradient_filter_value", None) is None:
        raise StyxValidationError("`use_gradient_filter_value` must not be None")
    if not isinstance(params["use_gradient_filter_value"], bool):
        raise StyxValidationError(f'`use_gradient_filter_value` has the wrong type: Received `{type(params.get("use_gradient_filter_value", None))}` expected `bool`')


def ants_registration_use_gradient_filter_1_cargs(
    params: AntsRegistrationUseGradientFilter1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + ("true" if params.get("use_gradient_filter_value", None) else "false"))
    return cargs


def ants_registration_sampling_percentage_1(
    sampling_percentage_value: float,
    use_gradient_filter: AntsRegistrationUseGradientFilter1ParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        use_gradient_filter:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_1",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if use_gradient_filter is not None:
        params["use_gradient_filter"] = use_gradient_filter
    return params


def ants_registration_sampling_percentage_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("use_gradient_filter", None) is not None:
        ants_registration_use_gradient_filter_1_validate(params["use_gradient_filter"])


def ants_registration_sampling_percentage_1_cargs(
    params: AntsRegistrationSamplingPercentage1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_use_gradient_filter_1_cargs(params.get("use_gradient_filter", None), execution) if (params.get("use_gradient_filter", None) is not None) else [])))
    return cargs


def ants_registration_sampling_strategy_1(
    sampling_strategy_value: typing.Literal["None", "Regular", "Random"],
    sampling_percentage: AntsRegistrationSamplingPercentage1ParamsDict | None = None,
) -> AntsRegistrationSamplingStrategy1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_strategy_value:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_strategy_1",
        "sampling_strategy_value": sampling_strategy_value,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_sampling_strategy_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingStrategy1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_strategy_value", None) is None:
        raise StyxValidationError("`sampling_strategy_value` must not be None")
    if not isinstance(params["sampling_strategy_value"], str):
        raise StyxValidationError(f'`sampling_strategy_value` has the wrong type: Received `{type(params.get("sampling_strategy_value", None))}` expected `typing.Literal["None", "Regular", "Random"]`')
    if params["sampling_strategy_value"] not in ["None", "Regular", "Random"]:
        raise StyxValidationError("Parameter `sampling_strategy_value` must be one of [\"None\", \"Regular\", \"Random\"]")
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_1_validate(params["sampling_percentage"])


def ants_registration_sampling_strategy_1_cargs(
    params: AntsRegistrationSamplingStrategy1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("sampling_strategy_value", None) + "".join((ants_registration_sampling_percentage_1_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])))
    return cargs


def ants_registration_number_of_bins(
    number_of_bins_value: float,
    sampling_strategy: AntsRegistrationSamplingStrategy1ParamsDict | None = None,
) -> AntsRegistrationNumberOfBinsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        number_of_bins_value:.
        sampling_strategy:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "number_of_bins",
        "number_of_bins_value": number_of_bins_value,
    }
    if sampling_strategy is not None:
        params["sampling_strategy"] = sampling_strategy
    return params


def ants_registration_number_of_bins_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationNumberOfBinsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("number_of_bins_value", None) is None:
        raise StyxValidationError("`number_of_bins_value` must not be None")
    if not isinstance(params["number_of_bins_value"], (float, int)):
        raise StyxValidationError(f'`number_of_bins_value` has the wrong type: Received `{type(params.get("number_of_bins_value", None))}` expected `float`')
    if params.get("sampling_strategy", None) is not None:
        ants_registration_sampling_strategy_1_validate(params["sampling_strategy"])


def ants_registration_number_of_bins_cargs(
    params: AntsRegistrationNumberOfBinsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("number_of_bins_value", None)) + "".join((ants_registration_sampling_strategy_1_cargs(params.get("sampling_strategy", None), execution) if (params.get("sampling_strategy", None) is not None) else [])))
    return cargs


def ants_registration_metric_mutual_information(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    metric_weight: float,
    number_of_bins: AntsRegistrationNumberOfBinsParamsDict | None = None,
) -> AntsRegistrationMetricMutualInformationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        metric_weight:.
        number_of_bins:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_mutual_information",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "metric_weight": metric_weight,
    }
    if number_of_bins is not None:
        params["number_of_bins"] = number_of_bins
    return params


def ants_registration_metric_mutual_information_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricMutualInformationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("number_of_bins", None) is not None:
        ants_registration_number_of_bins_validate(params["number_of_bins"])


def ants_registration_metric_mutual_information_cargs(
    params: AntsRegistrationMetricMutualInformationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("MI[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_number_of_bins_cargs(params.get("number_of_bins", None), execution) if (params.get("number_of_bins", None) is not None) else [])) + "]")
    return cargs


def ants_registration_use_gradient_filter_2(
    use_gradient_filter_value: bool,
) -> AntsRegistrationUseGradientFilter2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        use_gradient_filter_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "use_gradient_filter_2",
        "use_gradient_filter_value": use_gradient_filter_value,
    }
    return params


def ants_registration_use_gradient_filter_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUseGradientFilter2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("use_gradient_filter_value", None) is None:
        raise StyxValidationError("`use_gradient_filter_value` must not be None")
    if not isinstance(params["use_gradient_filter_value"], bool):
        raise StyxValidationError(f'`use_gradient_filter_value` has the wrong type: Received `{type(params.get("use_gradient_filter_value", None))}` expected `bool`')


def ants_registration_use_gradient_filter_2_cargs(
    params: AntsRegistrationUseGradientFilter2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + ("true" if params.get("use_gradient_filter_value", None) else "false"))
    return cargs


def ants_registration_sampling_percentage_2(
    sampling_percentage_value: float,
    use_gradient_filter: AntsRegistrationUseGradientFilter2ParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        use_gradient_filter:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_2",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if use_gradient_filter is not None:
        params["use_gradient_filter"] = use_gradient_filter
    return params


def ants_registration_sampling_percentage_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("use_gradient_filter", None) is not None:
        ants_registration_use_gradient_filter_2_validate(params["use_gradient_filter"])


def ants_registration_sampling_percentage_2_cargs(
    params: AntsRegistrationSamplingPercentage2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_use_gradient_filter_2_cargs(params.get("use_gradient_filter", None), execution) if (params.get("use_gradient_filter", None) is not None) else [])))
    return cargs


def ants_registration_sampling_strategy_2(
    sampling_strategy_value: typing.Literal["None", "Regular", "Random"],
    sampling_percentage: AntsRegistrationSamplingPercentage2ParamsDict | None = None,
) -> AntsRegistrationSamplingStrategy2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_strategy_value:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_strategy_2",
        "sampling_strategy_value": sampling_strategy_value,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_sampling_strategy_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingStrategy2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_strategy_value", None) is None:
        raise StyxValidationError("`sampling_strategy_value` must not be None")
    if not isinstance(params["sampling_strategy_value"], str):
        raise StyxValidationError(f'`sampling_strategy_value` has the wrong type: Received `{type(params.get("sampling_strategy_value", None))}` expected `typing.Literal["None", "Regular", "Random"]`')
    if params["sampling_strategy_value"] not in ["None", "Regular", "Random"]:
        raise StyxValidationError("Parameter `sampling_strategy_value` must be one of [\"None\", \"Regular\", \"Random\"]")
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_2_validate(params["sampling_percentage"])


def ants_registration_sampling_strategy_2_cargs(
    params: AntsRegistrationSamplingStrategy2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("sampling_strategy_value", None) + "".join((ants_registration_sampling_percentage_2_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])))
    return cargs


def ants_registration_number_of_bins_1(
    number_of_bins_value: float,
    sampling_strategy: AntsRegistrationSamplingStrategy2ParamsDict | None = None,
) -> AntsRegistrationNumberOfBins1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        number_of_bins_value:.
        sampling_strategy:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "number_of_bins_1",
        "number_of_bins_value": number_of_bins_value,
    }
    if sampling_strategy is not None:
        params["sampling_strategy"] = sampling_strategy
    return params


def ants_registration_number_of_bins_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationNumberOfBins1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("number_of_bins_value", None) is None:
        raise StyxValidationError("`number_of_bins_value` must not be None")
    if not isinstance(params["number_of_bins_value"], (float, int)):
        raise StyxValidationError(f'`number_of_bins_value` has the wrong type: Received `{type(params.get("number_of_bins_value", None))}` expected `float`')
    if params.get("sampling_strategy", None) is not None:
        ants_registration_sampling_strategy_2_validate(params["sampling_strategy"])


def ants_registration_number_of_bins_1_cargs(
    params: AntsRegistrationNumberOfBins1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("number_of_bins_value", None)) + "".join((ants_registration_sampling_strategy_2_cargs(params.get("sampling_strategy", None), execution) if (params.get("sampling_strategy", None) is not None) else [])))
    return cargs


def ants_registration_metric_mattes(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    metric_weight: float,
    number_of_bins: AntsRegistrationNumberOfBins1ParamsDict | None = None,
) -> AntsRegistrationMetricMattesParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        metric_weight:.
        number_of_bins:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_mattes",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "metric_weight": metric_weight,
    }
    if number_of_bins is not None:
        params["number_of_bins"] = number_of_bins
    return params


def ants_registration_metric_mattes_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricMattesParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("number_of_bins", None) is not None:
        ants_registration_number_of_bins_1_validate(params["number_of_bins"])


def ants_registration_metric_mattes_cargs(
    params: AntsRegistrationMetricMattesParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Mattes[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_number_of_bins_1_cargs(params.get("number_of_bins", None), execution) if (params.get("number_of_bins", None) is not None) else [])) + "]")
    return cargs


def ants_registration_use_gradient_filter_3(
    use_gradient_filter_value: bool,
) -> AntsRegistrationUseGradientFilter3ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        use_gradient_filter_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "use_gradient_filter_3",
        "use_gradient_filter_value": use_gradient_filter_value,
    }
    return params


def ants_registration_use_gradient_filter_3_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUseGradientFilter3ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("use_gradient_filter_value", None) is None:
        raise StyxValidationError("`use_gradient_filter_value` must not be None")
    if not isinstance(params["use_gradient_filter_value"], bool):
        raise StyxValidationError(f'`use_gradient_filter_value` has the wrong type: Received `{type(params.get("use_gradient_filter_value", None))}` expected `bool`')


def ants_registration_use_gradient_filter_3_cargs(
    params: AntsRegistrationUseGradientFilter3ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + ("true" if params.get("use_gradient_filter_value", None) else "false"))
    return cargs


def ants_registration_sampling_percentage_3(
    sampling_percentage_value: float,
    use_gradient_filter: AntsRegistrationUseGradientFilter3ParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage3ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        use_gradient_filter:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_3",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if use_gradient_filter is not None:
        params["use_gradient_filter"] = use_gradient_filter
    return params


def ants_registration_sampling_percentage_3_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage3ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("use_gradient_filter", None) is not None:
        ants_registration_use_gradient_filter_3_validate(params["use_gradient_filter"])


def ants_registration_sampling_percentage_3_cargs(
    params: AntsRegistrationSamplingPercentage3ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_use_gradient_filter_3_cargs(params.get("use_gradient_filter", None), execution) if (params.get("use_gradient_filter", None) is not None) else [])))
    return cargs


def ants_registration_sampling_strategy_3(
    sampling_strategy_value: typing.Literal["None", "Regular", "Random"],
    sampling_percentage: AntsRegistrationSamplingPercentage3ParamsDict | None = None,
) -> AntsRegistrationSamplingStrategy3ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_strategy_value:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_strategy_3",
        "sampling_strategy_value": sampling_strategy_value,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_sampling_strategy_3_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingStrategy3ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_strategy_value", None) is None:
        raise StyxValidationError("`sampling_strategy_value` must not be None")
    if not isinstance(params["sampling_strategy_value"], str):
        raise StyxValidationError(f'`sampling_strategy_value` has the wrong type: Received `{type(params.get("sampling_strategy_value", None))}` expected `typing.Literal["None", "Regular", "Random"]`')
    if params["sampling_strategy_value"] not in ["None", "Regular", "Random"]:
        raise StyxValidationError("Parameter `sampling_strategy_value` must be one of [\"None\", \"Regular\", \"Random\"]")
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_3_validate(params["sampling_percentage"])


def ants_registration_sampling_strategy_3_cargs(
    params: AntsRegistrationSamplingStrategy3ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("sampling_strategy_value", None) + "".join((ants_registration_sampling_percentage_3_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])))
    return cargs


def ants_registration_radius_1(
    radius_value: float,
    sampling_strategy: AntsRegistrationSamplingStrategy3ParamsDict | None = None,
) -> AntsRegistrationRadius1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        radius_value:.
        sampling_strategy:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "radius_1",
        "radius_value": radius_value,
    }
    if sampling_strategy is not None:
        params["sampling_strategy"] = sampling_strategy
    return params


def ants_registration_radius_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationRadius1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("radius_value", None) is None:
        raise StyxValidationError("`radius_value` must not be None")
    if not isinstance(params["radius_value"], (float, int)):
        raise StyxValidationError(f'`radius_value` has the wrong type: Received `{type(params.get("radius_value", None))}` expected `float`')
    if params.get("sampling_strategy", None) is not None:
        ants_registration_sampling_strategy_3_validate(params["sampling_strategy"])


def ants_registration_radius_1_cargs(
    params: AntsRegistrationRadius1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("radius_value", None)) + "".join((ants_registration_sampling_strategy_3_cargs(params.get("sampling_strategy", None), execution) if (params.get("sampling_strategy", None) is not None) else [])))
    return cargs


def ants_registration_metric_mean_squares(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    metric_weight: float,
    radius: AntsRegistrationRadius1ParamsDict | None = None,
) -> AntsRegistrationMetricMeanSquaresParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        metric_weight:.
        radius:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_mean_squares",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "metric_weight": metric_weight,
    }
    if radius is not None:
        params["radius"] = radius
    return params


def ants_registration_metric_mean_squares_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricMeanSquaresParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("radius", None) is not None:
        ants_registration_radius_1_validate(params["radius"])


def ants_registration_metric_mean_squares_cargs(
    params: AntsRegistrationMetricMeanSquaresParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("MeanSquares[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_radius_1_cargs(params.get("radius", None), execution) if (params.get("radius", None) is not None) else [])) + "]")
    return cargs


def ants_registration_use_gradient_filter_4(
    use_gradient_filter_value: bool,
) -> AntsRegistrationUseGradientFilter4ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        use_gradient_filter_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "use_gradient_filter_4",
        "use_gradient_filter_value": use_gradient_filter_value,
    }
    return params


def ants_registration_use_gradient_filter_4_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUseGradientFilter4ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("use_gradient_filter_value", None) is None:
        raise StyxValidationError("`use_gradient_filter_value` must not be None")
    if not isinstance(params["use_gradient_filter_value"], bool):
        raise StyxValidationError(f'`use_gradient_filter_value` has the wrong type: Received `{type(params.get("use_gradient_filter_value", None))}` expected `bool`')


def ants_registration_use_gradient_filter_4_cargs(
    params: AntsRegistrationUseGradientFilter4ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + ("true" if params.get("use_gradient_filter_value", None) else "false"))
    return cargs


def ants_registration_sampling_percentage_4(
    sampling_percentage_value: float,
    use_gradient_filter: AntsRegistrationUseGradientFilter4ParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage4ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        use_gradient_filter:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_4",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if use_gradient_filter is not None:
        params["use_gradient_filter"] = use_gradient_filter
    return params


def ants_registration_sampling_percentage_4_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage4ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("use_gradient_filter", None) is not None:
        ants_registration_use_gradient_filter_4_validate(params["use_gradient_filter"])


def ants_registration_sampling_percentage_4_cargs(
    params: AntsRegistrationSamplingPercentage4ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_use_gradient_filter_4_cargs(params.get("use_gradient_filter", None), execution) if (params.get("use_gradient_filter", None) is not None) else [])))
    return cargs


def ants_registration_sampling_strategy_4(
    sampling_strategy_value: typing.Literal["None", "Regular", "Random"],
    sampling_percentage: AntsRegistrationSamplingPercentage4ParamsDict | None = None,
) -> AntsRegistrationSamplingStrategy4ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_strategy_value:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_strategy_4",
        "sampling_strategy_value": sampling_strategy_value,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_sampling_strategy_4_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingStrategy4ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_strategy_value", None) is None:
        raise StyxValidationError("`sampling_strategy_value` must not be None")
    if not isinstance(params["sampling_strategy_value"], str):
        raise StyxValidationError(f'`sampling_strategy_value` has the wrong type: Received `{type(params.get("sampling_strategy_value", None))}` expected `typing.Literal["None", "Regular", "Random"]`')
    if params["sampling_strategy_value"] not in ["None", "Regular", "Random"]:
        raise StyxValidationError("Parameter `sampling_strategy_value` must be one of [\"None\", \"Regular\", \"Random\"]")
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_4_validate(params["sampling_percentage"])


def ants_registration_sampling_strategy_4_cargs(
    params: AntsRegistrationSamplingStrategy4ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("sampling_strategy_value", None) + "".join((ants_registration_sampling_percentage_4_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])))
    return cargs


def ants_registration_number_of_bins_2(
    number_of_bins_value: float,
    sampling_strategy: AntsRegistrationSamplingStrategy4ParamsDict | None = None,
) -> AntsRegistrationNumberOfBins2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        number_of_bins_value:.
        sampling_strategy:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "number_of_bins_2",
        "number_of_bins_value": number_of_bins_value,
    }
    if sampling_strategy is not None:
        params["sampling_strategy"] = sampling_strategy
    return params


def ants_registration_number_of_bins_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationNumberOfBins2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("number_of_bins_value", None) is None:
        raise StyxValidationError("`number_of_bins_value` must not be None")
    if not isinstance(params["number_of_bins_value"], (float, int)):
        raise StyxValidationError(f'`number_of_bins_value` has the wrong type: Received `{type(params.get("number_of_bins_value", None))}` expected `float`')
    if params.get("sampling_strategy", None) is not None:
        ants_registration_sampling_strategy_4_validate(params["sampling_strategy"])


def ants_registration_number_of_bins_2_cargs(
    params: AntsRegistrationNumberOfBins2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("number_of_bins_value", None)) + "".join((ants_registration_sampling_strategy_4_cargs(params.get("sampling_strategy", None), execution) if (params.get("sampling_strategy", None) is not None) else [])))
    return cargs


def ants_registration_metric_demons(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    metric_weight: float,
    number_of_bins: AntsRegistrationNumberOfBins2ParamsDict | None = None,
) -> AntsRegistrationMetricDemonsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        metric_weight:.
        number_of_bins:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_demons",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "metric_weight": metric_weight,
    }
    if number_of_bins is not None:
        params["number_of_bins"] = number_of_bins
    return params


def ants_registration_metric_demons_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricDemonsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("number_of_bins", None) is not None:
        ants_registration_number_of_bins_2_validate(params["number_of_bins"])


def ants_registration_metric_demons_cargs(
    params: AntsRegistrationMetricDemonsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("Demons[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_number_of_bins_2_cargs(params.get("number_of_bins", None), execution) if (params.get("number_of_bins", None) is not None) else [])) + "]")
    return cargs


def ants_registration_use_gradient_filter_5(
    use_gradient_filter_value: bool,
) -> AntsRegistrationUseGradientFilter5ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        use_gradient_filter_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "use_gradient_filter_5",
        "use_gradient_filter_value": use_gradient_filter_value,
    }
    return params


def ants_registration_use_gradient_filter_5_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationUseGradientFilter5ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("use_gradient_filter_value", None) is None:
        raise StyxValidationError("`use_gradient_filter_value` must not be None")
    if not isinstance(params["use_gradient_filter_value"], bool):
        raise StyxValidationError(f'`use_gradient_filter_value` has the wrong type: Received `{type(params.get("use_gradient_filter_value", None))}` expected `bool`')


def ants_registration_use_gradient_filter_5_cargs(
    params: AntsRegistrationUseGradientFilter5ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + ("true" if params.get("use_gradient_filter_value", None) else "false"))
    return cargs


def ants_registration_sampling_percentage_5(
    sampling_percentage_value: float,
    use_gradient_filter: AntsRegistrationUseGradientFilter5ParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage5ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        use_gradient_filter:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_5",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if use_gradient_filter is not None:
        params["use_gradient_filter"] = use_gradient_filter
    return params


def ants_registration_sampling_percentage_5_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage5ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("use_gradient_filter", None) is not None:
        ants_registration_use_gradient_filter_5_validate(params["use_gradient_filter"])


def ants_registration_sampling_percentage_5_cargs(
    params: AntsRegistrationSamplingPercentage5ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_use_gradient_filter_5_cargs(params.get("use_gradient_filter", None), execution) if (params.get("use_gradient_filter", None) is not None) else [])))
    return cargs


def ants_registration_sampling_strategy_5(
    sampling_strategy_value: typing.Literal["None", "Regular", "Random"],
    sampling_percentage: AntsRegistrationSamplingPercentage5ParamsDict | None = None,
) -> AntsRegistrationSamplingStrategy5ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_strategy_value:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_strategy_5",
        "sampling_strategy_value": sampling_strategy_value,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_sampling_strategy_5_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingStrategy5ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_strategy_value", None) is None:
        raise StyxValidationError("`sampling_strategy_value` must not be None")
    if not isinstance(params["sampling_strategy_value"], str):
        raise StyxValidationError(f'`sampling_strategy_value` has the wrong type: Received `{type(params.get("sampling_strategy_value", None))}` expected `typing.Literal["None", "Regular", "Random"]`')
    if params["sampling_strategy_value"] not in ["None", "Regular", "Random"]:
        raise StyxValidationError("Parameter `sampling_strategy_value` must be one of [\"None\", \"Regular\", \"Random\"]")
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_5_validate(params["sampling_percentage"])


def ants_registration_sampling_strategy_5_cargs(
    params: AntsRegistrationSamplingStrategy5ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("sampling_strategy_value", None) + "".join((ants_registration_sampling_percentage_5_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])))
    return cargs


def ants_registration_radius_2(
    radius_value: float,
    sampling_strategy: AntsRegistrationSamplingStrategy5ParamsDict | None = None,
) -> AntsRegistrationRadius2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        radius_value:.
        sampling_strategy:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "radius_2",
        "radius_value": radius_value,
    }
    if sampling_strategy is not None:
        params["sampling_strategy"] = sampling_strategy
    return params


def ants_registration_radius_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationRadius2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("radius_value", None) is None:
        raise StyxValidationError("`radius_value` must not be None")
    if not isinstance(params["radius_value"], (float, int)):
        raise StyxValidationError(f'`radius_value` has the wrong type: Received `{type(params.get("radius_value", None))}` expected `float`')
    if params.get("sampling_strategy", None) is not None:
        ants_registration_sampling_strategy_5_validate(params["sampling_strategy"])


def ants_registration_radius_2_cargs(
    params: AntsRegistrationRadius2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("radius_value", None)) + "".join((ants_registration_sampling_strategy_5_cargs(params.get("sampling_strategy", None), execution) if (params.get("sampling_strategy", None) is not None) else [])))
    return cargs


def ants_registration_metric_global_correlation(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    metric_weight: float,
    radius: AntsRegistrationRadius2ParamsDict | None = None,
) -> AntsRegistrationMetricGlobalCorrelationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        metric_weight:.
        radius:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_global_correlation",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "metric_weight": metric_weight,
    }
    if radius is not None:
        params["radius"] = radius
    return params


def ants_registration_metric_global_correlation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricGlobalCorrelationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("radius", None) is not None:
        ants_registration_radius_2_validate(params["radius"])


def ants_registration_metric_global_correlation_cargs(
    params: AntsRegistrationMetricGlobalCorrelationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("GC[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_radius_2_cargs(params.get("radius", None), execution) if (params.get("radius", None) is not None) else [])) + "]")
    return cargs


def ants_registration_boundary_points_only(
    boundary_points_only_value: typing.Literal["0"],
) -> AntsRegistrationBoundaryPointsOnlyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        boundary_points_only_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "boundary_points_only",
        "boundary_points_only_value": boundary_points_only_value,
    }
    return params


def ants_registration_boundary_points_only_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationBoundaryPointsOnlyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("boundary_points_only_value", None) is None:
        raise StyxValidationError("`boundary_points_only_value` must not be None")
    if not isinstance(params["boundary_points_only_value"], str):
        raise StyxValidationError(f'`boundary_points_only_value` has the wrong type: Received `{type(params.get("boundary_points_only_value", None))}` expected `typing.Literal["0"]`')
    if params["boundary_points_only_value"] not in ["0"]:
        raise StyxValidationError("Parameter `boundary_points_only_value` must be one of [\"0\"]")


def ants_registration_boundary_points_only_cargs(
    params: AntsRegistrationBoundaryPointsOnlyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("boundary_points_only_value", None))
    return cargs


def ants_registration_sampling_percentage_6(
    sampling_percentage_value: float,
    boundary_points_only: AntsRegistrationBoundaryPointsOnlyParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage6ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        boundary_points_only:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_6",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if boundary_points_only is not None:
        params["boundary_points_only"] = boundary_points_only
    return params


def ants_registration_sampling_percentage_6_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage6ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("boundary_points_only", None) is not None:
        ants_registration_boundary_points_only_validate(params["boundary_points_only"])


def ants_registration_sampling_percentage_6_cargs(
    params: AntsRegistrationSamplingPercentage6ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_boundary_points_only_cargs(params.get("boundary_points_only", None), execution) if (params.get("boundary_points_only", None) is not None) else [])))
    return cargs


def ants_registration_metric_euclidean_icp(
    fixed_point_set: str,
    moving_point_set: str,
    metric_weight: float,
    sampling_percentage: AntsRegistrationSamplingPercentage6ParamsDict | None = None,
) -> AntsRegistrationMetricEuclideanIcpParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_point_set:.
        moving_point_set:.
        metric_weight:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_euclidean_icp",
        "fixed_point_set": fixed_point_set,
        "moving_point_set": moving_point_set,
        "metric_weight": metric_weight,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_metric_euclidean_icp_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricEuclideanIcpParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_point_set", None) is None:
        raise StyxValidationError("`fixed_point_set` must not be None")
    if not isinstance(params["fixed_point_set"], str):
        raise StyxValidationError(f'`fixed_point_set` has the wrong type: Received `{type(params.get("fixed_point_set", None))}` expected `str`')
    if params.get("moving_point_set", None) is None:
        raise StyxValidationError("`moving_point_set` must not be None")
    if not isinstance(params["moving_point_set"], str):
        raise StyxValidationError(f'`moving_point_set` has the wrong type: Received `{type(params.get("moving_point_set", None))}` expected `str`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_6_validate(params["sampling_percentage"])


def ants_registration_metric_euclidean_icp_cargs(
    params: AntsRegistrationMetricEuclideanIcpParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("ICP[" + params.get("fixed_point_set", None) + "," + params.get("moving_point_set", None) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_sampling_percentage_6_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])) + "]")
    return cargs


def ants_registration_k_neighborhood(
    k_neighborhood_value: float,
) -> AntsRegistrationKNeighborhoodParamsDictTagged:
    """
    Build parameters.
    
    Args:
        k_neighborhood_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "k_neighborhood",
        "k_neighborhood_value": k_neighborhood_value,
    }
    return params


def ants_registration_k_neighborhood_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationKNeighborhoodParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("k_neighborhood_value", None) is None:
        raise StyxValidationError("`k_neighborhood_value` must not be None")
    if not isinstance(params["k_neighborhood_value"], (float, int)):
        raise StyxValidationError(f'`k_neighborhood_value` has the wrong type: Received `{type(params.get("k_neighborhood_value", None))}` expected `float`')


def ants_registration_k_neighborhood_cargs(
    params: AntsRegistrationKNeighborhoodParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("k_neighborhood_value", None)))
    return cargs


def ants_registration_point_set_sigma(
    point_set_sigma_value: float,
    k_neighborhood: AntsRegistrationKNeighborhoodParamsDict | None = None,
) -> AntsRegistrationPointSetSigmaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        point_set_sigma_value:.
        k_neighborhood:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "point_set_sigma",
        "point_set_sigma_value": point_set_sigma_value,
    }
    if k_neighborhood is not None:
        params["k_neighborhood"] = k_neighborhood
    return params


def ants_registration_point_set_sigma_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationPointSetSigmaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("point_set_sigma_value", None) is None:
        raise StyxValidationError("`point_set_sigma_value` must not be None")
    if not isinstance(params["point_set_sigma_value"], (float, int)):
        raise StyxValidationError(f'`point_set_sigma_value` has the wrong type: Received `{type(params.get("point_set_sigma_value", None))}` expected `float`')
    if params.get("k_neighborhood", None) is not None:
        ants_registration_k_neighborhood_validate(params["k_neighborhood"])


def ants_registration_point_set_sigma_cargs(
    params: AntsRegistrationPointSetSigmaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("point_set_sigma_value", None)) + "".join((ants_registration_k_neighborhood_cargs(params.get("k_neighborhood", None), execution) if (params.get("k_neighborhood", None) is not None) else [])))
    return cargs


def ants_registration_boundary_points_only_1(
    boundary_points_only_value: typing.Literal["0"],
    point_set_sigma: AntsRegistrationPointSetSigmaParamsDict | None = None,
) -> AntsRegistrationBoundaryPointsOnly1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        boundary_points_only_value:.
        point_set_sigma:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "boundary_points_only_1",
        "boundary_points_only_value": boundary_points_only_value,
    }
    if point_set_sigma is not None:
        params["point_set_sigma"] = point_set_sigma
    return params


def ants_registration_boundary_points_only_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationBoundaryPointsOnly1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("boundary_points_only_value", None) is None:
        raise StyxValidationError("`boundary_points_only_value` must not be None")
    if not isinstance(params["boundary_points_only_value"], str):
        raise StyxValidationError(f'`boundary_points_only_value` has the wrong type: Received `{type(params.get("boundary_points_only_value", None))}` expected `typing.Literal["0"]`')
    if params["boundary_points_only_value"] not in ["0"]:
        raise StyxValidationError("Parameter `boundary_points_only_value` must be one of [\"0\"]")
    if params.get("point_set_sigma", None) is not None:
        ants_registration_point_set_sigma_validate(params["point_set_sigma"])


def ants_registration_boundary_points_only_1_cargs(
    params: AntsRegistrationBoundaryPointsOnly1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("boundary_points_only_value", None) + "".join((ants_registration_point_set_sigma_cargs(params.get("point_set_sigma", None), execution) if (params.get("point_set_sigma", None) is not None) else [])))
    return cargs


def ants_registration_sampling_percentage_7(
    sampling_percentage_value: float,
    boundary_points_only: AntsRegistrationBoundaryPointsOnly1ParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage7ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        boundary_points_only:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_7",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if boundary_points_only is not None:
        params["boundary_points_only"] = boundary_points_only
    return params


def ants_registration_sampling_percentage_7_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage7ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("boundary_points_only", None) is not None:
        ants_registration_boundary_points_only_1_validate(params["boundary_points_only"])


def ants_registration_sampling_percentage_7_cargs(
    params: AntsRegistrationSamplingPercentage7ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_boundary_points_only_1_cargs(params.get("boundary_points_only", None), execution) if (params.get("boundary_points_only", None) is not None) else [])))
    return cargs


def ants_registration_metric_point_set_expectation(
    fixed_point_set: str,
    moving_point_set: str,
    metric_weight: float,
    sampling_percentage: AntsRegistrationSamplingPercentage7ParamsDict | None = None,
) -> AntsRegistrationMetricPointSetExpectationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_point_set:.
        moving_point_set:.
        metric_weight:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_point_set_expectation",
        "fixed_point_set": fixed_point_set,
        "moving_point_set": moving_point_set,
        "metric_weight": metric_weight,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_metric_point_set_expectation_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricPointSetExpectationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_point_set", None) is None:
        raise StyxValidationError("`fixed_point_set` must not be None")
    if not isinstance(params["fixed_point_set"], str):
        raise StyxValidationError(f'`fixed_point_set` has the wrong type: Received `{type(params.get("fixed_point_set", None))}` expected `str`')
    if params.get("moving_point_set", None) is None:
        raise StyxValidationError("`moving_point_set` must not be None")
    if not isinstance(params["moving_point_set"], str):
        raise StyxValidationError(f'`moving_point_set` has the wrong type: Received `{type(params.get("moving_point_set", None))}` expected `str`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_7_validate(params["sampling_percentage"])


def ants_registration_metric_point_set_expectation_cargs(
    params: AntsRegistrationMetricPointSetExpectationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("PSE[" + params.get("fixed_point_set", None) + "," + params.get("moving_point_set", None) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_sampling_percentage_7_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])) + "]")
    return cargs


def ants_registration_k_neighborhood_1(
    k_neighborhood_value: float,
) -> AntsRegistrationKNeighborhood1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        k_neighborhood_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "k_neighborhood_1",
        "k_neighborhood_value": k_neighborhood_value,
    }
    return params


def ants_registration_k_neighborhood_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationKNeighborhood1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("k_neighborhood_value", None) is None:
        raise StyxValidationError("`k_neighborhood_value` must not be None")
    if not isinstance(params["k_neighborhood_value"], (float, int)):
        raise StyxValidationError(f'`k_neighborhood_value` has the wrong type: Received `{type(params.get("k_neighborhood_value", None))}` expected `float`')


def ants_registration_k_neighborhood_1_cargs(
    params: AntsRegistrationKNeighborhood1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("k_neighborhood_value", None)))
    return cargs


def ants_registration_point_set_sigma_1(
    point_set_sigma_value: float,
    k_neighborhood: AntsRegistrationKNeighborhood1ParamsDict | None = None,
) -> AntsRegistrationPointSetSigma1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        point_set_sigma_value:.
        k_neighborhood:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "point_set_sigma_1",
        "point_set_sigma_value": point_set_sigma_value,
    }
    if k_neighborhood is not None:
        params["k_neighborhood"] = k_neighborhood
    return params


def ants_registration_point_set_sigma_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationPointSetSigma1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("point_set_sigma_value", None) is None:
        raise StyxValidationError("`point_set_sigma_value` must not be None")
    if not isinstance(params["point_set_sigma_value"], (float, int)):
        raise StyxValidationError(f'`point_set_sigma_value` has the wrong type: Received `{type(params.get("point_set_sigma_value", None))}` expected `float`')
    if params.get("k_neighborhood", None) is not None:
        ants_registration_k_neighborhood_1_validate(params["k_neighborhood"])


def ants_registration_point_set_sigma_1_cargs(
    params: AntsRegistrationPointSetSigma1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("point_set_sigma_value", None)) + "".join((ants_registration_k_neighborhood_1_cargs(params.get("k_neighborhood", None), execution) if (params.get("k_neighborhood", None) is not None) else [])))
    return cargs


def ants_registration_boundary_points_only_2(
    boundary_points_only_value: typing.Literal["0"],
    point_set_sigma: AntsRegistrationPointSetSigma1ParamsDict | None = None,
) -> AntsRegistrationBoundaryPointsOnly2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        boundary_points_only_value:.
        point_set_sigma:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "boundary_points_only_2",
        "boundary_points_only_value": boundary_points_only_value,
    }
    if point_set_sigma is not None:
        params["point_set_sigma"] = point_set_sigma
    return params


def ants_registration_boundary_points_only_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationBoundaryPointsOnly2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("boundary_points_only_value", None) is None:
        raise StyxValidationError("`boundary_points_only_value` must not be None")
    if not isinstance(params["boundary_points_only_value"], str):
        raise StyxValidationError(f'`boundary_points_only_value` has the wrong type: Received `{type(params.get("boundary_points_only_value", None))}` expected `typing.Literal["0"]`')
    if params["boundary_points_only_value"] not in ["0"]:
        raise StyxValidationError("Parameter `boundary_points_only_value` must be one of [\"0\"]")
    if params.get("point_set_sigma", None) is not None:
        ants_registration_point_set_sigma_1_validate(params["point_set_sigma"])


def ants_registration_boundary_points_only_2_cargs(
    params: AntsRegistrationBoundaryPointsOnly2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("boundary_points_only_value", None) + "".join((ants_registration_point_set_sigma_1_cargs(params.get("point_set_sigma", None), execution) if (params.get("point_set_sigma", None) is not None) else [])))
    return cargs


def ants_registration_sampling_percentage_8(
    sampling_percentage_value: float,
    boundary_points_only: AntsRegistrationBoundaryPointsOnly2ParamsDict | None = None,
) -> AntsRegistrationSamplingPercentage8ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        sampling_percentage_value:.
        boundary_points_only:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sampling_percentage_8",
        "sampling_percentage_value": sampling_percentage_value,
    }
    if boundary_points_only is not None:
        params["boundary_points_only"] = boundary_points_only
    return params


def ants_registration_sampling_percentage_8_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationSamplingPercentage8ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("sampling_percentage_value", None) is None:
        raise StyxValidationError("`sampling_percentage_value` must not be None")
    if not isinstance(params["sampling_percentage_value"], (float, int)):
        raise StyxValidationError(f'`sampling_percentage_value` has the wrong type: Received `{type(params.get("sampling_percentage_value", None))}` expected `float`')
    if not (0 <= params["sampling_percentage_value"] <= 1):
        raise StyxValidationError("Parameter `sampling_percentage_value` must be between 0 and 1 (inclusive)")
    if params.get("boundary_points_only", None) is not None:
        ants_registration_boundary_points_only_2_validate(params["boundary_points_only"])


def ants_registration_sampling_percentage_8_cargs(
    params: AntsRegistrationSamplingPercentage8ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("sampling_percentage_value", None)) + "".join((ants_registration_boundary_points_only_2_cargs(params.get("boundary_points_only", None), execution) if (params.get("boundary_points_only", None) is not None) else [])))
    return cargs


def ants_registration_metric_jensen_havrda_charvet_tsallis(
    fixed_point_set: str,
    moving_point_set: str,
    metric_weight: float,
    sampling_percentage: AntsRegistrationSamplingPercentage8ParamsDict | None = None,
) -> AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_point_set:.
        moving_point_set:.
        metric_weight:.
        sampling_percentage:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_jensen_havrda_charvet_tsallis",
        "fixed_point_set": fixed_point_set,
        "moving_point_set": moving_point_set,
        "metric_weight": metric_weight,
    }
    if sampling_percentage is not None:
        params["sampling_percentage"] = sampling_percentage
    return params


def ants_registration_metric_jensen_havrda_charvet_tsallis_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_point_set", None) is None:
        raise StyxValidationError("`fixed_point_set` must not be None")
    if not isinstance(params["fixed_point_set"], str):
        raise StyxValidationError(f'`fixed_point_set` has the wrong type: Received `{type(params.get("fixed_point_set", None))}` expected `str`')
    if params.get("moving_point_set", None) is None:
        raise StyxValidationError("`moving_point_set` must not be None")
    if not isinstance(params["moving_point_set"], str):
        raise StyxValidationError(f'`moving_point_set` has the wrong type: Received `{type(params.get("moving_point_set", None))}` expected `str`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("sampling_percentage", None) is not None:
        ants_registration_sampling_percentage_8_validate(params["sampling_percentage"])


def ants_registration_metric_jensen_havrda_charvet_tsallis_cargs(
    params: AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("JHCT[" + params.get("fixed_point_set", None) + "," + params.get("moving_point_set", None) + "," + str(params.get("metric_weight", None)) + "".join((ants_registration_sampling_percentage_8_cargs(params.get("sampling_percentage", None), execution) if (params.get("sampling_percentage", None) is not None) else [])) + "]")
    return cargs


def ants_registration_gradient_sigma(
    gradient_sigma_value: float,
) -> AntsRegistrationGradientSigmaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        gradient_sigma_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "gradient_sigma",
        "gradient_sigma_value": gradient_sigma_value,
    }
    return params


def ants_registration_gradient_sigma_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationGradientSigmaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("gradient_sigma_value", None) is None:
        raise StyxValidationError("`gradient_sigma_value` must not be None")
    if not isinstance(params["gradient_sigma_value"], (float, int)):
        raise StyxValidationError(f'`gradient_sigma_value` has the wrong type: Received `{type(params.get("gradient_sigma_value", None))}` expected `float`')


def ants_registration_gradient_sigma_cargs(
    params: AntsRegistrationGradientSigmaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("gradient_sigma_value", None)))
    return cargs


def ants_registration_k_neighborhood_2(
    k_neighborhood_value: float,
    gradient_sigma: AntsRegistrationGradientSigmaParamsDict | None = None,
) -> AntsRegistrationKNeighborhood2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        k_neighborhood_value:.
        gradient_sigma:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "k_neighborhood_2",
        "k_neighborhood_value": k_neighborhood_value,
    }
    if gradient_sigma is not None:
        params["gradient_sigma"] = gradient_sigma
    return params


def ants_registration_k_neighborhood_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationKNeighborhood2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("k_neighborhood_value", None) is None:
        raise StyxValidationError("`k_neighborhood_value` must not be None")
    if not isinstance(params["k_neighborhood_value"], (float, int)):
        raise StyxValidationError(f'`k_neighborhood_value` has the wrong type: Received `{type(params.get("k_neighborhood_value", None))}` expected `float`')
    if params.get("gradient_sigma", None) is not None:
        ants_registration_gradient_sigma_validate(params["gradient_sigma"])


def ants_registration_k_neighborhood_2_cargs(
    params: AntsRegistrationKNeighborhood2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("k_neighborhood_value", None)) + "".join((ants_registration_gradient_sigma_cargs(params.get("gradient_sigma", None), execution) if (params.get("gradient_sigma", None) is not None) else [])))
    return cargs


def ants_registration_distance_sigma(
    distance_sigma_value: float,
    k_neighborhood: AntsRegistrationKNeighborhood2ParamsDict | None = None,
) -> AntsRegistrationDistanceSigmaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        distance_sigma_value:.
        k_neighborhood:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "distance_sigma",
        "distance_sigma_value": distance_sigma_value,
    }
    if k_neighborhood is not None:
        params["k_neighborhood"] = k_neighborhood
    return params


def ants_registration_distance_sigma_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationDistanceSigmaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("distance_sigma_value", None) is None:
        raise StyxValidationError("`distance_sigma_value` must not be None")
    if not isinstance(params["distance_sigma_value"], (float, int)):
        raise StyxValidationError(f'`distance_sigma_value` has the wrong type: Received `{type(params.get("distance_sigma_value", None))}` expected `float`')
    if params.get("k_neighborhood", None) is not None:
        ants_registration_k_neighborhood_2_validate(params["k_neighborhood"])


def ants_registration_distance_sigma_cargs(
    params: AntsRegistrationDistanceSigmaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("distance_sigma_value", None)) + "".join((ants_registration_k_neighborhood_2_cargs(params.get("k_neighborhood", None), execution) if (params.get("k_neighborhood", None) is not None) else [])))
    return cargs


def ants_registration_intensity_sigma(
    intensity_sigma_value: float,
    distance_sigma: AntsRegistrationDistanceSigmaParamsDict | None = None,
) -> AntsRegistrationIntensitySigmaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        intensity_sigma_value:.
        distance_sigma:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "intensity_sigma",
        "intensity_sigma_value": intensity_sigma_value,
    }
    if distance_sigma is not None:
        params["distance_sigma"] = distance_sigma
    return params


def ants_registration_intensity_sigma_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationIntensitySigmaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("intensity_sigma_value", None) is None:
        raise StyxValidationError("`intensity_sigma_value` must not be None")
    if not isinstance(params["intensity_sigma_value"], (float, int)):
        raise StyxValidationError(f'`intensity_sigma_value` has the wrong type: Received `{type(params.get("intensity_sigma_value", None))}` expected `float`')
    if params.get("distance_sigma", None) is not None:
        ants_registration_distance_sigma_validate(params["distance_sigma"])


def ants_registration_intensity_sigma_cargs(
    params: AntsRegistrationIntensitySigmaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + str(params.get("intensity_sigma_value", None)) + "".join((ants_registration_distance_sigma_cargs(params.get("distance_sigma", None), execution) if (params.get("distance_sigma", None) is not None) else [])))
    return cargs


def ants_registration_neighborhood_radius(
    neighborhood_radius_value: str,
    intensity_sigma: AntsRegistrationIntensitySigmaParamsDict | None = None,
) -> AntsRegistrationNeighborhoodRadiusParamsDictTagged:
    """
    Build parameters.
    
    Args:
        neighborhood_radius_value:.
        intensity_sigma:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "neighborhood_radius",
        "neighborhood_radius_value": neighborhood_radius_value,
    }
    if intensity_sigma is not None:
        params["intensity_sigma"] = intensity_sigma
    return params


def ants_registration_neighborhood_radius_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationNeighborhoodRadiusParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("neighborhood_radius_value", None) is None:
        raise StyxValidationError("`neighborhood_radius_value` must not be None")
    if not isinstance(params["neighborhood_radius_value"], str):
        raise StyxValidationError(f'`neighborhood_radius_value` has the wrong type: Received `{type(params.get("neighborhood_radius_value", None))}` expected `str`')
    if params.get("intensity_sigma", None) is not None:
        ants_registration_intensity_sigma_validate(params["intensity_sigma"])


def ants_registration_neighborhood_radius_cargs(
    params: AntsRegistrationNeighborhoodRadiusParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("neighborhood_radius_value", None) + "".join((ants_registration_intensity_sigma_cargs(params.get("intensity_sigma", None), execution) if (params.get("intensity_sigma", None) is not None) else [])))
    return cargs


def ants_registration_metric_igdm(
    fixed_image: InputPathType,
    moving_image: InputPathType,
    metric_weight: float,
    fixed_mask: str,
    moving_mask: str,
    neighborhood_radius: AntsRegistrationNeighborhoodRadiusParamsDict | None = None,
) -> AntsRegistrationMetricIgdmParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_image:.
        moving_image:.
        metric_weight:.
        fixed_mask:.
        moving_mask:.
        neighborhood_radius:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "metric_igdm",
        "fixed_image": fixed_image,
        "moving_image": moving_image,
        "metric_weight": metric_weight,
        "fixed_mask": fixed_mask,
        "moving_mask": moving_mask,
    }
    if neighborhood_radius is not None:
        params["neighborhood_radius"] = neighborhood_radius
    return params


def ants_registration_metric_igdm_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMetricIgdmParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_image", None) is None:
        raise StyxValidationError("`fixed_image` must not be None")
    if not isinstance(params["fixed_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`fixed_image` has the wrong type: Received `{type(params.get("fixed_image", None))}` expected `InputPathType`')
    if params.get("moving_image", None) is None:
        raise StyxValidationError("`moving_image` must not be None")
    if not isinstance(params["moving_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`moving_image` has the wrong type: Received `{type(params.get("moving_image", None))}` expected `InputPathType`')
    if params.get("metric_weight", None) is None:
        raise StyxValidationError("`metric_weight` must not be None")
    if not isinstance(params["metric_weight"], (float, int)):
        raise StyxValidationError(f'`metric_weight` has the wrong type: Received `{type(params.get("metric_weight", None))}` expected `float`')
    if params.get("fixed_mask", None) is None:
        raise StyxValidationError("`fixed_mask` must not be None")
    if not isinstance(params["fixed_mask"], str):
        raise StyxValidationError(f'`fixed_mask` has the wrong type: Received `{type(params.get("fixed_mask", None))}` expected `str`')
    if params.get("moving_mask", None) is None:
        raise StyxValidationError("`moving_mask` must not be None")
    if not isinstance(params["moving_mask"], str):
        raise StyxValidationError(f'`moving_mask` has the wrong type: Received `{type(params.get("moving_mask", None))}` expected `str`')
    if params.get("neighborhood_radius", None) is not None:
        ants_registration_neighborhood_radius_validate(params["neighborhood_radius"])


def ants_registration_metric_igdm_cargs(
    params: AntsRegistrationMetricIgdmParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("IGDM[" + execution.input_file(params.get("fixed_image", None)) + "," + execution.input_file(params.get("moving_image", None)) + "," + str(params.get("metric_weight", None)) + "," + params.get("fixed_mask", None) + "," + params.get("moving_mask", None) + "".join((ants_registration_neighborhood_radius_cargs(params.get("neighborhood_radius", None), execution) if (params.get("neighborhood_radius", None) is not None) else [])) + "]")
    return cargs


def ants_registration_convergence(
    convergence: str,
    convergence_threshold: float,
    convergence_window_size: int,
) -> AntsRegistrationConvergenceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        convergence:.
        convergence_threshold:.
        convergence_window_size:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "convergence",
        "convergence": convergence,
        "convergence_threshold": convergence_threshold,
        "convergence_window_size": convergence_window_size,
    }
    return params


def ants_registration_convergence_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationConvergenceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("convergence", None) is None:
        raise StyxValidationError("`convergence` must not be None")
    if not isinstance(params["convergence"], str):
        raise StyxValidationError(f'`convergence` has the wrong type: Received `{type(params.get("convergence", None))}` expected `str`')
    if params.get("convergence_threshold", None) is None:
        raise StyxValidationError("`convergence_threshold` must not be None")
    if not isinstance(params["convergence_threshold"], (float, int)):
        raise StyxValidationError(f'`convergence_threshold` has the wrong type: Received `{type(params.get("convergence_threshold", None))}` expected `float`')
    if params.get("convergence_window_size", None) is None:
        raise StyxValidationError("`convergence_window_size` must not be None")
    if not isinstance(params["convergence_window_size"], int):
        raise StyxValidationError(f'`convergence_window_size` has the wrong type: Received `{type(params.get("convergence_window_size", None))}` expected `int`')


def ants_registration_convergence_cargs(
    params: AntsRegistrationConvergenceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + params.get("convergence", None) + "," + str(params.get("convergence_threshold", None)) + "," + str(params.get("convergence_window_size", None)) + "]")
    return cargs


def ants_registration_stage(
    transform: typing.Union[AntsRegistrationTransformRigidParamsDictTagged, AntsRegistrationTransformAffineParamsDictTagged, AntsRegistrationTransformCompositeAffineParamsDictTagged, AntsRegistrationTransformSimilarityParamsDictTagged, AntsRegistrationTransformTranslationParamsDictTagged, AntsRegistrationTransformBsplineParamsDictTagged, AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged, AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged, AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged, AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged, AntsRegistrationTransformSynParamsDictTagged, AntsRegistrationTransformBsplineSynParamsDictTagged, AntsRegistrationTransformExponentialParamsDictTagged, AntsRegistrationTransformBsplineExponentialParamsDictTagged],
    metric: typing.Union[AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged, AntsRegistrationMetricMutualInformationParamsDictTagged, AntsRegistrationMetricMattesParamsDictTagged, AntsRegistrationMetricMeanSquaresParamsDictTagged, AntsRegistrationMetricDemonsParamsDictTagged, AntsRegistrationMetricGlobalCorrelationParamsDictTagged, AntsRegistrationMetricEuclideanIcpParamsDictTagged, AntsRegistrationMetricPointSetExpectationParamsDictTagged, AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged, AntsRegistrationMetricIgdmParamsDictTagged],
    convergence: AntsRegistrationConvergenceParamsDict,
    smoothing_sigmas: str,
    shrink_factors: str,
    use_histogram_matching: bool | None = None,
) -> AntsRegistrationStageParamsDictTagged:
    """
    Build parameters.
    
    Args:
        transform: Several transform options are available. The gradientStep or\
            learningRate characterizes the gradient descent optimization and is\
            scaled appropriately for each transform using the shift scales\
            estimator. Subsequent parameters are transform-specific and can be\
            determined from the usage. For the B-spline transforms one can also\
            specify the smoothing in terms of spline distance (i.e. knot spacing).
        metric: These image metrics are available--- CC: ANTS neighborhood\
            cross correlation, MI: Mutual information, Demons: (Thirion),\
            MeanSquares, and GC: Global Correlation. The "metricWeight" variable is\
            used to modulate the per stage weighting of the metrics. The metrics\
            can also employ a sampling strategy defined by a sampling percentage.\
            The sampling strategy defaults to 'None' (aka a dense sampling of one\
            sample per voxel), otherwise it defines a point set over which to\
            optimize the metric. The point set can be on a regular lattice or a\
            random lattice of points slightly perturbed to minimize aliasing\
            artifacts. samplingPercentage defines the fraction of points to select\
            from the domain. useGradientFilter specifies whether a smoothingfilter\
            is applied when estimating the metric gradient.In addition, three point\
            set metrics are available: Euclidean (ICP), Point-set expectation\
            (PSE), and Jensen-Havrda-Charvet-Tsallis (JHCT).
        convergence: Convergence is determined from the number of iterations\
            per level and is determined by fitting a line to the normalized energy\
            profile of the last N iterations (where N is specified by the window\
            size) and determining the slope which is then compared with the\
            convergence threshold.
        smoothing_sigmas: Specify the sigma of gaussian smoothing at each\
            level. Units are given in terms of voxels ('vox') or physical spacing\
            ('mm'). Example usage is '4x2x1mm' and '4x2x1vox' where no units\
            implies voxel spacing.
        shrink_factors: Specify the shrink factor for the virtual domain\
            (typically the fixed image) at each level.
        use_histogram_matching: Use histogram matching.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "stage",
        "transform": transform,
        "metric": metric,
        "convergence": convergence,
        "smoothing_sigmas": smoothing_sigmas,
        "shrink_factors": shrink_factors,
    }
    if use_histogram_matching is not None:
        params["use_histogram_matching"] = use_histogram_matching
    return params


def ants_registration_stage_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationStageParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("transform", None) is None:
        raise StyxValidationError("`transform` must not be None")
    if not isinstance(params["transform"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["transform"])}\'')
    if "@type" not in params["transform"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["transform"]["@type"] not in ["transform_rigid", "transform_affine", "transform_composite_affine", "transform_similarity", "transform_translation", "transform_bspline", "transform_gaussian_displacement_field", "transform_bspline_displacement_field", "transform_time_varying_velocity_field", "transform_time_varying_bspline_velocity_field", "transform_syn", "transform_bspline_syn", "transform_exponential", "transform_bspline_exponential"]:
        raise StyxValidationError("Parameter `transform`s `@type` must be one of [\"transform_rigid\", \"transform_affine\", \"transform_composite_affine\", \"transform_similarity\", \"transform_translation\", \"transform_bspline\", \"transform_gaussian_displacement_field\", \"transform_bspline_displacement_field\", \"transform_time_varying_velocity_field\", \"transform_time_varying_bspline_velocity_field\", \"transform_syn\", \"transform_bspline_syn\", \"transform_exponential\", \"transform_bspline_exponential\"]")
    ants_registration_transform_validate_dyn_fn(params["transform"]["@type"])(params["transform"])
    if params.get("metric", None) is None:
        raise StyxValidationError("`metric` must not be None")
    if not isinstance(params["metric"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["metric"])}\'')
    if "@type" not in params["metric"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["metric"]["@type"] not in ["metric_ants_neighbourhood_cross_correlation", "metric_mutual_information", "metric_mattes", "metric_mean_squares", "metric_demons", "metric_global_correlation", "metric_euclidean_icp", "metric_point_set_expectation", "metric_jensen_havrda_charvet_tsallis", "metric_igdm"]:
        raise StyxValidationError("Parameter `metric`s `@type` must be one of [\"metric_ants_neighbourhood_cross_correlation\", \"metric_mutual_information\", \"metric_mattes\", \"metric_mean_squares\", \"metric_demons\", \"metric_global_correlation\", \"metric_euclidean_icp\", \"metric_point_set_expectation\", \"metric_jensen_havrda_charvet_tsallis\", \"metric_igdm\"]")
    ants_registration_metric_validate_dyn_fn(params["metric"]["@type"])(params["metric"])
    if params.get("convergence", None) is None:
        raise StyxValidationError("`convergence` must not be None")
    ants_registration_convergence_validate(params["convergence"])
    if params.get("smoothing_sigmas", None) is None:
        raise StyxValidationError("`smoothing_sigmas` must not be None")
    if not isinstance(params["smoothing_sigmas"], str):
        raise StyxValidationError(f'`smoothing_sigmas` has the wrong type: Received `{type(params.get("smoothing_sigmas", None))}` expected `str`')
    if params.get("shrink_factors", None) is None:
        raise StyxValidationError("`shrink_factors` must not be None")
    if not isinstance(params["shrink_factors"], str):
        raise StyxValidationError(f'`shrink_factors` has the wrong type: Received `{type(params.get("shrink_factors", None))}` expected `str`')
    if params.get("use_histogram_matching", None) is not None:
        if not isinstance(params["use_histogram_matching"], bool):
            raise StyxValidationError(f'`use_histogram_matching` has the wrong type: Received `{type(params.get("use_histogram_matching", None))}` expected `bool | None`')


def ants_registration_stage_cargs(
    params: AntsRegistrationStageParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.extend([
        "--transform",
        *ants_registration_transform_cargs_dyn_fn(params.get("transform", None)["@type"])(params.get("transform", None), execution)
    ])
    cargs.extend([
        "--metric",
        *ants_registration_metric_cargs_dyn_fn(params.get("metric", None)["@type"])(params.get("metric", None), execution)
    ])
    cargs.extend([
        "--convergence",
        *ants_registration_convergence_cargs(params.get("convergence", None), execution)
    ])
    cargs.extend([
        "--smoothing-sigmas",
        params.get("smoothing_sigmas", None)
    ])
    cargs.extend([
        "--shrink-factors",
        params.get("shrink_factors", None)
    ])
    if params.get("use_histogram_matching", None) is not None:
        cargs.extend([
            "--use-histogram-matching",
            ("1" if params.get("use_histogram_matching", None) else "0")
        ])
    return cargs


def ants_registration_winsorize_image_intensities(
    lower_quantile: float,
    upper_quantile: float,
) -> AntsRegistrationWinsorizeImageIntensitiesParamsDictTagged:
    """
    Build parameters.
    
    Args:
        lower_quantile:.
        upper_quantile:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "winsorize_image_intensities",
        "lower_quantile": lower_quantile,
        "upper_quantile": upper_quantile,
    }
    return params


def ants_registration_winsorize_image_intensities_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationWinsorizeImageIntensitiesParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("lower_quantile", None) is None:
        raise StyxValidationError("`lower_quantile` must not be None")
    if not isinstance(params["lower_quantile"], (float, int)):
        raise StyxValidationError(f'`lower_quantile` has the wrong type: Received `{type(params.get("lower_quantile", None))}` expected `float`')
    if params.get("upper_quantile", None) is None:
        raise StyxValidationError("`upper_quantile` must not be None")
    if not isinstance(params["upper_quantile"], (float, int)):
        raise StyxValidationError(f'`upper_quantile` has the wrong type: Received `{type(params.get("upper_quantile", None))}` expected `float`')


def ants_registration_winsorize_image_intensities_cargs(
    params: AntsRegistrationWinsorizeImageIntensitiesParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("[" + str(params.get("lower_quantile", None)) + "," + str(params.get("upper_quantile", None)) + "]")
    return cargs


def ants_registration_moving_mask(
    moving_mask_value: str,
) -> AntsRegistrationMovingMaskParamsDictTagged:
    """
    Build parameters.
    
    Args:
        moving_mask_value:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "moving_mask",
        "moving_mask_value": moving_mask_value,
    }
    return params


def ants_registration_moving_mask_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMovingMaskParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("moving_mask_value", None) is None:
        raise StyxValidationError("`moving_mask_value` must not be None")
    if not isinstance(params["moving_mask_value"], str):
        raise StyxValidationError(f'`moving_mask_value` has the wrong type: Received `{type(params.get("moving_mask_value", None))}` expected `str`')


def ants_registration_moving_mask_cargs(
    params: AntsRegistrationMovingMaskParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("," + params.get("moving_mask_value", None))
    return cargs


def ants_registration_masks(
    fixed_mask: str | None = None,
    moving_mask: AntsRegistrationMovingMaskParamsDict | None = None,
) -> AntsRegistrationMasksParamsDictTagged:
    """
    Build parameters.
    
    Args:
        fixed_mask:.
        moving_mask:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "masks",
    }
    if fixed_mask is not None:
        params["fixed_mask"] = fixed_mask
    if moving_mask is not None:
        params["moving_mask"] = moving_mask
    return params


def ants_registration_masks_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationMasksParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("fixed_mask", None) is not None:
        if not isinstance(params["fixed_mask"], str):
            raise StyxValidationError(f'`fixed_mask` has the wrong type: Received `{type(params.get("fixed_mask", None))}` expected `str | None`')
    if params.get("moving_mask", None) is not None:
        ants_registration_moving_mask_validate(params["moving_mask"])


def ants_registration_masks_cargs(
    params: AntsRegistrationMasksParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("fixed_mask", None) is not None or params.get("moving_mask", None) is not None:
        cargs.append("[" + (params.get("fixed_mask", None) if (params.get("fixed_mask", None) is not None) else "") + "".join((ants_registration_moving_mask_cargs(params.get("moving_mask", None), execution) if (params.get("moving_mask", None) is not None) else [])) + "]")
    return cargs


class AntsRegistrationOutputs(typing.NamedTuple):
    """
    Output object returned when calling `AntsRegistrationParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    generic_affine: OutputPathType | None
    """The output is the generic affine transformation matrix."""
    inverse_warped: OutputPathType | None
    """The output is the warped fixed image."""
    inverse_warp: OutputPathType | None
    """The output is the inverse warp field."""
    warped: OutputPathType | None
    """The output is the warped moving image."""
    warp: OutputPathType | None
    """The output is the warp field."""


def ants_registration_params(
    stages: list[AntsRegistrationStageParamsDict],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    output: str | None = None,
    save_state: str | None = None,
    restore_state: str | None = None,
    write_composite_transform: bool | None = None,
    print_similarity_measure_interval: int | None = None,
    write_interval_volumes: int | None = None,
    collapse_output_transforms: bool | None = None,
    initialize_transforms_per_stage: bool | None = None,
    interpolation: typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None = None,
    restrict_deformation: list[bool] | None = None,
    initial_fixed_transform: str | None = None,
    initial_moving_transform: typing.Union[AntsRegistrationInitialMovingTransformParamsDictTagged, AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged, AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged] | None = None,
    winsorize_image_intensities: AntsRegistrationWinsorizeImageIntensitiesParamsDict | None = None,
    masks: AntsRegistrationMasksParamsDict | None = None,
    minc: bool | None = None,
    random_seed: int | None = None,
    verbose: bool | None = None,
    float_: bool | None = None,
) -> AntsRegistrationParamsDictTagged:
    """
    Build parameters.
    
    Args:
        stages: Stages of the registration process.
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. If not specified, we try to infer the\
            dimensionality from the input image.
        output: Specify the output transform prefix (output format is .nii.gz\
            ). Optionally, one can choose to warp the moving image to the fixed\
            space and, if the inverse transform exists, one can also output the\
            warped fixed image. Note that only the images specified in the first\
            metric call are warped. Use antsApplyTransforms to warp other images\
            using the resultant transform(s). When a composite transform is not\
            specified, linear transforms are specified with a '.mat' suffix and\
            displacement fields with a 'Warp.nii.gz' suffix (and\
            'InverseWarp.nii.gz', when applicable. In addition, for velocity-based\
            transforms, the full velocity field is written to file\
            ('VelocityField.nii.gz') as long as the collapse transforms flag is\
            turned off ('-z 0').
        save_state: Specify the output file for the current state of the\
            registration. The state file is written to an hdf5 composite file. It\
            is specially usefull if we want to save the current state of a SyN\
            registration to the disk, so we can load and restore that later to\
            continue the next registration process directly started from the last\
            saved state. The output file of this flag is the same as the\
            write-composite-transform, unless the last transform is a SyN\
            transform. In that case, the inverse displacement field of the SyN\
            transform is also added to the output composite transform. Again notice\
            that this file cannot be treated as a transform, and restore-state\
            option must be used to load the written file by this flag.
        restore_state: Specify the initial state of the registration which get\
            immediately used to directly initialize the registration process. The\
            flag is mutually exclusive with other intialization flags.If this flag\
            is used, none of the initial-moving-transform and\
            initial-fixed-transform cannot be used.
        write_composite_transform: Boolean specifying whether or not the\
            composite transform (and its inverse, if it exists) should be written\
            to an hdf5 composite file. This is false by default so that only the\
            transform for each stage is written to file.
        print_similarity_measure_interval: Prints out the CC similarity metric\
            measure between the full-size input fixed and the transformed moving\
            images at each iteration a value of 0 (the default) indicates that the\
            full scale computation should not take placeany value greater than 0\
            represents the interval of full scale metric computation.
        write_interval_volumes: Writes out the output volume at each iteration.\
            It helps to present the registration process as a short movie a value\
            of 0 (the default) indicates that this option should not take placeany\
            value greater than 0 represents the interval between the iterations\
            which outputs are written to the disk.
        collapse_output_transforms: Collapse output transforms. Specifically,\
            enabling this option combines all adjacent transforms where possible.\
            All adjacent linear transforms are written to disk in the form of an\
            itk affine transform (called xxxGenericAffine.mat).\
            Similarly, all adjacent displacement field transforms are combined\
            when written to disk (e.g. xxxWarp.nii.gz and xxxInverseWarp.nii.gz\
            (if available)). Also, an output composite transform including the\
            collapsed transforms is written to the disk (called\
            outputCollapsed(Inverse)Composite).
        initialize_transforms_per_stage: Initialize linear transforms from the\
            previous stage. By enabling this option, the current linear stage\
            transform is directly intialized from the previous stage's linear\
            transform; this allows multiple linear stages to be run where each\
            stage directly updates the estimated linear transform from the previous\
            stage. (e.g. Translation -> Rigid -> Affine).
        interpolation: Several interpolation options are available in ITK.\
            These have all been made available. Currently the interpolator choice\
            is only used to warp (and possibly inverse warp) the final output\
            image(s).
        restrict_deformation: This option allows the user to restrict the\
            optimization of the displacement field, translation, rigid or affine\
            transform on a per-component basis. For example, if one wants to limit\
            the deformation or rotation of 3-D volume to the first two dimensions,\
            this is possible by specifying a weight vector of '1x1x0' for a\
            deformation field or '1x1x0x1x1x0' for a rigid transformation.\
            Low-dimensional restriction only works if there are no preceding\
            transformations.All stages up to and including the desired stage must\
            have this option specified,even if they should not be restricted (in\
            which case specify 1x1x1...).
        initial_fixed_transform: Specify the initial fixed transform(s) which\
            get immediately incorporated into the composite transform. The order of\
            the transforms is stack-esque in that the last transform specified on\
            the command line is the first to be applied. In addition to\
            initialization with ITK transforms, the user can perform an initial\
            translation alignment by specifying the fixed and moving images and\
            selecting an initialization feature. These features include using the\
            geometric center of the images (=0), the image intensities (=1), or the\
            origin of the images (=2).
        initial_moving_transform: Specify the initial moving transform(s) which\
            get immediately incorporated into the composite transform. The order of\
            the transforms is stack-esque in that the last transform specified on\
            the command line is the first to be applied. In addition to\
            initialization with ITK transforms, the user can perform an initial\
            translation alignment by specifying the fixed and moving images and\
            selecting an initialization feature. These features include using the\
            geometric center of the images (=0), the image intensities (=1), or the\
            origin of the images (=2).
        winsorize_image_intensities: Winsorize data based on specified\
            quantiles.
        masks: Image masks to limit voxels considered by the metric. Two\
            options are allowed for mask specification: 1) Either the user\
            specifies a single mask to be used for all stages or 2) the user\
            specifies a mask for each stage. With the latter one can select to\
            which stages masks are applied by supplying valid file names. If the\
            file does not exist, a mask will not be used for that stage. Note that\
            we handle the fixed and moving masks separately to enforce this\
            constraint.
        minc: Use MINC file formats for transformations.
        random_seed: Random seed.
        verbose: Verbose output.
        float_: Use 'float' instead of 'double' for computations.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants/antsRegistration",
        "stages": stages,
    }
    if dimensionality is not None:
        params["dimensionality"] = dimensionality
    if output is not None:
        params["output"] = output
    if save_state is not None:
        params["save_state"] = save_state
    if restore_state is not None:
        params["restore_state"] = restore_state
    if write_composite_transform is not None:
        params["write_composite_transform"] = write_composite_transform
    if print_similarity_measure_interval is not None:
        params["print_similarity_measure_interval"] = print_similarity_measure_interval
    if write_interval_volumes is not None:
        params["write_interval_volumes"] = write_interval_volumes
    if collapse_output_transforms is not None:
        params["collapse_output_transforms"] = collapse_output_transforms
    if initialize_transforms_per_stage is not None:
        params["initialize_transforms_per_stage"] = initialize_transforms_per_stage
    if interpolation is not None:
        params["interpolation"] = interpolation
    if restrict_deformation is not None:
        params["restrict_deformation"] = restrict_deformation
    if initial_fixed_transform is not None:
        params["initial_fixed_transform"] = initial_fixed_transform
    if initial_moving_transform is not None:
        params["initial_moving_transform"] = initial_moving_transform
    if winsorize_image_intensities is not None:
        params["winsorize_image_intensities"] = winsorize_image_intensities
    if masks is not None:
        params["masks"] = masks
    if minc is not None:
        params["minc"] = minc
    if random_seed is not None:
        params["random_seed"] = random_seed
    if verbose is not None:
        params["verbose"] = verbose
    if float_ is not None:
        params["float"] = float_
    return params


def ants_registration_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `AntsRegistrationParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("dimensionality", None) is not None:
        if not isinstance(params["dimensionality"], int):
            raise StyxValidationError(f'`dimensionality` has the wrong type: Received `{type(params.get("dimensionality", None))}` expected `typing.Literal[2, 3, 4] | None`')
        if params["dimensionality"] not in [2, 3, 4]:
            raise StyxValidationError("Parameter `dimensionality` must be one of [2, 3, 4]")
    if params.get("output", None) is not None:
        if not isinstance(params["output"], str):
            raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str | None`')
    if params.get("save_state", None) is not None:
        if not isinstance(params["save_state"], str):
            raise StyxValidationError(f'`save_state` has the wrong type: Received `{type(params.get("save_state", None))}` expected `str | None`')
    if params.get("restore_state", None) is not None:
        if not isinstance(params["restore_state"], str):
            raise StyxValidationError(f'`restore_state` has the wrong type: Received `{type(params.get("restore_state", None))}` expected `str | None`')
    if params.get("write_composite_transform", None) is not None:
        if not isinstance(params["write_composite_transform"], bool):
            raise StyxValidationError(f'`write_composite_transform` has the wrong type: Received `{type(params.get("write_composite_transform", None))}` expected `bool | None`')
    if params.get("print_similarity_measure_interval", None) is not None:
        if not isinstance(params["print_similarity_measure_interval"], int):
            raise StyxValidationError(f'`print_similarity_measure_interval` has the wrong type: Received `{type(params.get("print_similarity_measure_interval", None))}` expected `int | None`')
    if params.get("write_interval_volumes", None) is not None:
        if not isinstance(params["write_interval_volumes"], int):
            raise StyxValidationError(f'`write_interval_volumes` has the wrong type: Received `{type(params.get("write_interval_volumes", None))}` expected `int | None`')
        if params["write_interval_volumes"] < 0:
            raise StyxValidationError("Parameter `write_interval_volumes` must be at least 0")
    if params.get("collapse_output_transforms", None) is not None:
        if not isinstance(params["collapse_output_transforms"], bool):
            raise StyxValidationError(f'`collapse_output_transforms` has the wrong type: Received `{type(params.get("collapse_output_transforms", None))}` expected `bool | None`')
    if params.get("initialize_transforms_per_stage", None) is not None:
        if not isinstance(params["initialize_transforms_per_stage"], bool):
            raise StyxValidationError(f'`initialize_transforms_per_stage` has the wrong type: Received `{type(params.get("initialize_transforms_per_stage", None))}` expected `bool | None`')
    if params.get("interpolation", None) is not None:
        if not isinstance(params["interpolation"], str):
            raise StyxValidationError(f'`interpolation` has the wrong type: Received `{type(params.get("interpolation", None))}` expected `typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None`')
        if params["interpolation"] not in ["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"]:
            raise StyxValidationError("Parameter `interpolation` must be one of [\"Linear\", \"NearestNeighbor\", \"MultiLabel\", \"Gaussian\", \"BSpline\", \"CosineWindowedSinc\", \"WelchWindowedSinc\", \"HammingWindowedSinc\", \"LanczosWindowedSinc\", \"GenericLabel\"]")
    if params.get("restrict_deformation", None) is not None:
        if not isinstance(params["restrict_deformation"], list):
            raise StyxValidationError(f'`restrict_deformation` has the wrong type: Received `{type(params.get("restrict_deformation", None))}` expected `list[bool] | None`')
        if not (3 <= len(params["restrict_deformation"]) <= 6):
            raise StyxValidationError("Parameter `restrict_deformation` must contain between 3 and 6 elements (inclusive)")
        for e in params["restrict_deformation"]:
            if not isinstance(e, bool):
                raise StyxValidationError(f'`restrict_deformation` has the wrong type: Received `{type(params.get("restrict_deformation", None))}` expected `list[bool] | None`')
    if params.get("initial_fixed_transform", None) is not None:
        if not isinstance(params["initial_fixed_transform"], str):
            raise StyxValidationError(f'`initial_fixed_transform` has the wrong type: Received `{type(params.get("initial_fixed_transform", None))}` expected `str | None`')
    if params.get("initial_moving_transform", None) is not None:
        if not isinstance(params["initial_moving_transform"], dict):
            raise StyxValidationError(f'Params object has the wrong type \'{type(params["initial_moving_transform"])}\'')
        if "@type" not in params["initial_moving_transform"]:
            raise StyxValidationError("Params object is missing `@type`")
        if params["initial_moving_transform"]["@type"] not in ["initial_moving_transform", "initial_moving_transform_use_inverse", "initial_moving_transform_initialization_feature"]:
            raise StyxValidationError("Parameter `initial_moving_transform`s `@type` must be one of [\"initial_moving_transform\", \"initial_moving_transform_use_inverse\", \"initial_moving_transform_initialization_feature\"]")
        ants_registration_initial_moving_transform_validate_dyn_fn(params["initial_moving_transform"]["@type"])(params["initial_moving_transform"])
    if params.get("stages", None) is None:
        raise StyxValidationError("`stages` must not be None")
    if not isinstance(params["stages"], list):
        raise StyxValidationError(f'`stages` has the wrong type: Received `{type(params.get("stages", None))}` expected `list[AntsRegistrationStageParamsDict]`')
    for e in params["stages"]:
        ants_registration_stage_validate(e)
    if params.get("winsorize_image_intensities", None) is not None:
        ants_registration_winsorize_image_intensities_validate(params["winsorize_image_intensities"])
    if params.get("masks", None) is not None:
        ants_registration_masks_validate(params["masks"])
    if params.get("minc", None) is not None:
        if not isinstance(params["minc"], bool):
            raise StyxValidationError(f'`minc` has the wrong type: Received `{type(params.get("minc", None))}` expected `bool | None`')
    if params.get("random_seed", None) is not None:
        if not isinstance(params["random_seed"], int):
            raise StyxValidationError(f'`random_seed` has the wrong type: Received `{type(params.get("random_seed", None))}` expected `int | None`')
        if params["random_seed"] < 1:
            raise StyxValidationError("Parameter `random_seed` must be at least 1")
    if params.get("verbose", None) is not None:
        if not isinstance(params["verbose"], bool):
            raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", None))}` expected `bool | None`')
    if params.get("float", None) is not None:
        if not isinstance(params["float"], bool):
            raise StyxValidationError(f'`float` has the wrong type: Received `{type(params.get("float", None))}` expected `bool | None`')


def ants_registration_cargs(
    params: AntsRegistrationParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("antsRegistration")
    if params.get("dimensionality", None) is not None:
        cargs.extend([
            "--dimensionality",
            str(params.get("dimensionality", None))
        ])
    if params.get("output", None) is not None:
        cargs.extend([
            "-o",
            params.get("output", None)
        ])
    if params.get("save_state", None) is not None:
        cargs.extend([
            "-j",
            params.get("save_state", None)
        ])
    if params.get("restore_state", None) is not None:
        cargs.extend([
            "-k",
            params.get("restore_state", None)
        ])
    if params.get("write_composite_transform", None) is not None:
        cargs.extend([
            "-a",
            ("1" if params.get("write_composite_transform", None) else "0")
        ])
    if params.get("print_similarity_measure_interval", None) is not None:
        cargs.extend([
            "-p",
            str(params.get("print_similarity_measure_interval", None))
        ])
    if params.get("write_interval_volumes", None) is not None:
        cargs.extend([
            "--write-interval-volumes",
            str(params.get("write_interval_volumes", None))
        ])
    if params.get("collapse_output_transforms", None) is not None:
        cargs.extend([
            "--collapse-output-transforms",
            ("1" if params.get("collapse_output_transforms", None) else "0")
        ])
    if params.get("initialize_transforms_per_stage", None) is not None:
        cargs.extend([
            "-i",
            ("1" if params.get("initialize_transforms_per_stage", None) else "0")
        ])
    if params.get("interpolation", None) is not None:
        cargs.extend([
            "--interpolation",
            params.get("interpolation", None)
        ])
    if params.get("restrict_deformation", None) is not None:
        cargs.extend([
            "-g",
            *"x".join(["1" if v else "0" for v in params.get("restrict_deformation", None)])
        ])
    if params.get("initial_fixed_transform", None) is not None:
        cargs.extend([
            "-q",
            params.get("initial_fixed_transform", None)
        ])
    if params.get("initial_moving_transform", None) is not None:
        cargs.extend([
            "--initial-moving-transform",
            *ants_registration_initial_moving_transform_cargs_dyn_fn(params.get("initial_moving_transform", None)["@type"])(params.get("initial_moving_transform", None), execution)
        ])
    cargs.extend([a for c in [ants_registration_stage_cargs(s, execution) for s in params.get("stages", None)] for a in c])
    if params.get("winsorize_image_intensities", None) is not None:
        cargs.extend([
            "--winsorize-image-intensities",
            *ants_registration_winsorize_image_intensities_cargs(params.get("winsorize_image_intensities", None), execution)
        ])
    if params.get("masks", None) is not None:
        cargs.extend([
            "--masks",
            *ants_registration_masks_cargs(params.get("masks", None), execution)
        ])
    if params.get("minc", None) is not None:
        cargs.extend([
            "--minc",
            ("1" if params.get("minc", None) else "0")
        ])
    if params.get("random_seed", None) is not None:
        cargs.extend([
            "--random-seed",
            str(params.get("random_seed", None))
        ])
    if params.get("verbose", None) is not None:
        cargs.extend([
            "-v",
            ("1" if params.get("verbose", None) else "0")
        ])
    if params.get("float", None) is not None:
        cargs.extend([
            "--float",
            ("1" if params.get("float", None) else "0")
        ])
    return cargs


def ants_registration_outputs(
    params: AntsRegistrationParamsDict,
    execution: Execution,
) -> AntsRegistrationOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = AntsRegistrationOutputs(
        root=execution.output_file("."),
        generic_affine=execution.output_file(params.get("output", None) + "0GenericAffine.mat") if (params.get("output") is not None) else None,
        inverse_warped=execution.output_file(params.get("output", None) + "InverseWarped.nii.gz") if (params.get("output") is not None) else None,
        inverse_warp=execution.output_file(params.get("output", None) + "1InverseWarp.nii.gz") if (params.get("output") is not None) else None,
        warped=execution.output_file(params.get("output", None) + "Warped.nii.gz") if (params.get("output") is not None) else None,
        warp=execution.output_file(params.get("output", None) + "1Warp.nii.gz") if (params.get("output") is not None) else None,
    )
    return ret


def ants_registration_execute(
    params: AntsRegistrationParamsDict,
    runner: Runner | None = None,
) -> AntsRegistrationOutputs:
    """
    antsRegistration
    
    This program is a user-level registration application meant to utilize
    classes in ITK v4.0 and later. The user can specify any number of "stages"
    where a stage consists of a transform; an image metric; and iterations,
    shrink factors, and smoothing sigmas for each level. Note that explicitly
    setting the dimensionality, metric, transform, output, convergence,
    shrink-factors, and smoothing-sigmas parameters is mandatory.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsRegistrationOutputs`).
    """
    ants_registration_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(ANTS_REGISTRATION_METADATA)
    params = execution.params(params)
    cargs = ants_registration_cargs(params, execution)
    ret = ants_registration_outputs(params, execution)
    execution.run(cargs)
    return ret


def ants_registration(
    stages: list[AntsRegistrationStageParamsDict],
    dimensionality: typing.Literal[2, 3, 4] | None = None,
    output: str | None = None,
    save_state: str | None = None,
    restore_state: str | None = None,
    write_composite_transform: bool | None = None,
    print_similarity_measure_interval: int | None = None,
    write_interval_volumes: int | None = None,
    collapse_output_transforms: bool | None = None,
    initialize_transforms_per_stage: bool | None = None,
    interpolation: typing.Literal["Linear", "NearestNeighbor", "MultiLabel", "Gaussian", "BSpline", "CosineWindowedSinc", "WelchWindowedSinc", "HammingWindowedSinc", "LanczosWindowedSinc", "GenericLabel"] | None = None,
    restrict_deformation: list[bool] | None = None,
    initial_fixed_transform: str | None = None,
    initial_moving_transform: typing.Union[AntsRegistrationInitialMovingTransformParamsDictTagged, AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged, AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged] | None = None,
    winsorize_image_intensities: AntsRegistrationWinsorizeImageIntensitiesParamsDict | None = None,
    masks: AntsRegistrationMasksParamsDict | None = None,
    minc: bool | None = None,
    random_seed: int | None = None,
    verbose: bool | None = None,
    float_: bool | None = None,
    runner: Runner | None = None,
) -> AntsRegistrationOutputs:
    """
    antsRegistration
    
    This program is a user-level registration application meant to utilize
    classes in ITK v4.0 and later. The user can specify any number of "stages"
    where a stage consists of a transform; an image metric; and iterations,
    shrink factors, and smoothing sigmas for each level. Note that explicitly
    setting the dimensionality, metric, transform, output, convergence,
    shrink-factors, and smoothing-sigmas parameters is mandatory.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        stages: Stages of the registration process.
        dimensionality: This option forces the image to be treated as a\
            specified-dimensional image. If not specified, we try to infer the\
            dimensionality from the input image.
        output: Specify the output transform prefix (output format is .nii.gz\
            ). Optionally, one can choose to warp the moving image to the fixed\
            space and, if the inverse transform exists, one can also output the\
            warped fixed image. Note that only the images specified in the first\
            metric call are warped. Use antsApplyTransforms to warp other images\
            using the resultant transform(s). When a composite transform is not\
            specified, linear transforms are specified with a '.mat' suffix and\
            displacement fields with a 'Warp.nii.gz' suffix (and\
            'InverseWarp.nii.gz', when applicable. In addition, for velocity-based\
            transforms, the full velocity field is written to file\
            ('VelocityField.nii.gz') as long as the collapse transforms flag is\
            turned off ('-z 0').
        save_state: Specify the output file for the current state of the\
            registration. The state file is written to an hdf5 composite file. It\
            is specially usefull if we want to save the current state of a SyN\
            registration to the disk, so we can load and restore that later to\
            continue the next registration process directly started from the last\
            saved state. The output file of this flag is the same as the\
            write-composite-transform, unless the last transform is a SyN\
            transform. In that case, the inverse displacement field of the SyN\
            transform is also added to the output composite transform. Again notice\
            that this file cannot be treated as a transform, and restore-state\
            option must be used to load the written file by this flag.
        restore_state: Specify the initial state of the registration which get\
            immediately used to directly initialize the registration process. The\
            flag is mutually exclusive with other intialization flags.If this flag\
            is used, none of the initial-moving-transform and\
            initial-fixed-transform cannot be used.
        write_composite_transform: Boolean specifying whether or not the\
            composite transform (and its inverse, if it exists) should be written\
            to an hdf5 composite file. This is false by default so that only the\
            transform for each stage is written to file.
        print_similarity_measure_interval: Prints out the CC similarity metric\
            measure between the full-size input fixed and the transformed moving\
            images at each iteration a value of 0 (the default) indicates that the\
            full scale computation should not take placeany value greater than 0\
            represents the interval of full scale metric computation.
        write_interval_volumes: Writes out the output volume at each iteration.\
            It helps to present the registration process as a short movie a value\
            of 0 (the default) indicates that this option should not take placeany\
            value greater than 0 represents the interval between the iterations\
            which outputs are written to the disk.
        collapse_output_transforms: Collapse output transforms. Specifically,\
            enabling this option combines all adjacent transforms where possible.\
            All adjacent linear transforms are written to disk in the form of an\
            itk affine transform (called xxxGenericAffine.mat).\
            Similarly, all adjacent displacement field transforms are combined\
            when written to disk (e.g. xxxWarp.nii.gz and xxxInverseWarp.nii.gz\
            (if available)). Also, an output composite transform including the\
            collapsed transforms is written to the disk (called\
            outputCollapsed(Inverse)Composite).
        initialize_transforms_per_stage: Initialize linear transforms from the\
            previous stage. By enabling this option, the current linear stage\
            transform is directly intialized from the previous stage's linear\
            transform; this allows multiple linear stages to be run where each\
            stage directly updates the estimated linear transform from the previous\
            stage. (e.g. Translation -> Rigid -> Affine).
        interpolation: Several interpolation options are available in ITK.\
            These have all been made available. Currently the interpolator choice\
            is only used to warp (and possibly inverse warp) the final output\
            image(s).
        restrict_deformation: This option allows the user to restrict the\
            optimization of the displacement field, translation, rigid or affine\
            transform on a per-component basis. For example, if one wants to limit\
            the deformation or rotation of 3-D volume to the first two dimensions,\
            this is possible by specifying a weight vector of '1x1x0' for a\
            deformation field or '1x1x0x1x1x0' for a rigid transformation.\
            Low-dimensional restriction only works if there are no preceding\
            transformations.All stages up to and including the desired stage must\
            have this option specified,even if they should not be restricted (in\
            which case specify 1x1x1...).
        initial_fixed_transform: Specify the initial fixed transform(s) which\
            get immediately incorporated into the composite transform. The order of\
            the transforms is stack-esque in that the last transform specified on\
            the command line is the first to be applied. In addition to\
            initialization with ITK transforms, the user can perform an initial\
            translation alignment by specifying the fixed and moving images and\
            selecting an initialization feature. These features include using the\
            geometric center of the images (=0), the image intensities (=1), or the\
            origin of the images (=2).
        initial_moving_transform: Specify the initial moving transform(s) which\
            get immediately incorporated into the composite transform. The order of\
            the transforms is stack-esque in that the last transform specified on\
            the command line is the first to be applied. In addition to\
            initialization with ITK transforms, the user can perform an initial\
            translation alignment by specifying the fixed and moving images and\
            selecting an initialization feature. These features include using the\
            geometric center of the images (=0), the image intensities (=1), or the\
            origin of the images (=2).
        winsorize_image_intensities: Winsorize data based on specified\
            quantiles.
        masks: Image masks to limit voxels considered by the metric. Two\
            options are allowed for mask specification: 1) Either the user\
            specifies a single mask to be used for all stages or 2) the user\
            specifies a mask for each stage. With the latter one can select to\
            which stages masks are applied by supplying valid file names. If the\
            file does not exist, a mask will not be used for that stage. Note that\
            we handle the fixed and moving masks separately to enforce this\
            constraint.
        minc: Use MINC file formats for transformations.
        random_seed: Random seed.
        verbose: Verbose output.
        float_: Use 'float' instead of 'double' for computations.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `AntsRegistrationOutputs`).
    """
    params = ants_registration_params(
        dimensionality=dimensionality,
        output=output,
        save_state=save_state,
        restore_state=restore_state,
        write_composite_transform=write_composite_transform,
        print_similarity_measure_interval=print_similarity_measure_interval,
        write_interval_volumes=write_interval_volumes,
        collapse_output_transforms=collapse_output_transforms,
        initialize_transforms_per_stage=initialize_transforms_per_stage,
        interpolation=interpolation,
        restrict_deformation=restrict_deformation,
        initial_fixed_transform=initial_fixed_transform,
        initial_moving_transform=initial_moving_transform,
        stages=stages,
        winsorize_image_intensities=winsorize_image_intensities,
        masks=masks,
        minc=minc,
        random_seed=random_seed,
        verbose=verbose,
        float_=float_,
    )
    return ants_registration_execute(params, runner)


__all__ = [
    "ANTS_REGISTRATION_METADATA",
    "AntsRegistrationBoundaryPointsOnly1ParamsDict",
    "AntsRegistrationBoundaryPointsOnly1ParamsDictTagged",
    "AntsRegistrationBoundaryPointsOnly2ParamsDict",
    "AntsRegistrationBoundaryPointsOnly2ParamsDictTagged",
    "AntsRegistrationBoundaryPointsOnlyParamsDict",
    "AntsRegistrationBoundaryPointsOnlyParamsDictTagged",
    "AntsRegistrationConvergenceParamsDict",
    "AntsRegistrationConvergenceParamsDictTagged",
    "AntsRegistrationDistanceSigmaParamsDict",
    "AntsRegistrationDistanceSigmaParamsDictTagged",
    "AntsRegistrationGradientSigmaParamsDict",
    "AntsRegistrationGradientSigmaParamsDictTagged",
    "AntsRegistrationInitialMovingTransformInitializationFeatureParamsDict",
    "AntsRegistrationInitialMovingTransformInitializationFeatureParamsDictTagged",
    "AntsRegistrationInitialMovingTransformParamsDict",
    "AntsRegistrationInitialMovingTransformParamsDictTagged",
    "AntsRegistrationInitialMovingTransformUseInverseParamsDict",
    "AntsRegistrationInitialMovingTransformUseInverseParamsDictTagged",
    "AntsRegistrationIntensitySigmaParamsDict",
    "AntsRegistrationIntensitySigmaParamsDictTagged",
    "AntsRegistrationKNeighborhood1ParamsDict",
    "AntsRegistrationKNeighborhood1ParamsDictTagged",
    "AntsRegistrationKNeighborhood2ParamsDict",
    "AntsRegistrationKNeighborhood2ParamsDictTagged",
    "AntsRegistrationKNeighborhoodParamsDict",
    "AntsRegistrationKNeighborhoodParamsDictTagged",
    "AntsRegistrationMasksParamsDict",
    "AntsRegistrationMasksParamsDictTagged",
    "AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDict",
    "AntsRegistrationMetricAntsNeighbourhoodCrossCorrelationParamsDictTagged",
    "AntsRegistrationMetricDemonsParamsDict",
    "AntsRegistrationMetricDemonsParamsDictTagged",
    "AntsRegistrationMetricEuclideanIcpParamsDict",
    "AntsRegistrationMetricEuclideanIcpParamsDictTagged",
    "AntsRegistrationMetricGlobalCorrelationParamsDict",
    "AntsRegistrationMetricGlobalCorrelationParamsDictTagged",
    "AntsRegistrationMetricIgdmParamsDict",
    "AntsRegistrationMetricIgdmParamsDictTagged",
    "AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDict",
    "AntsRegistrationMetricJensenHavrdaCharvetTsallisParamsDictTagged",
    "AntsRegistrationMetricMattesParamsDict",
    "AntsRegistrationMetricMattesParamsDictTagged",
    "AntsRegistrationMetricMeanSquaresParamsDict",
    "AntsRegistrationMetricMeanSquaresParamsDictTagged",
    "AntsRegistrationMetricMutualInformationParamsDict",
    "AntsRegistrationMetricMutualInformationParamsDictTagged",
    "AntsRegistrationMetricPointSetExpectationParamsDict",
    "AntsRegistrationMetricPointSetExpectationParamsDictTagged",
    "AntsRegistrationMovingMaskParamsDict",
    "AntsRegistrationMovingMaskParamsDictTagged",
    "AntsRegistrationNeighborhoodRadiusParamsDict",
    "AntsRegistrationNeighborhoodRadiusParamsDictTagged",
    "AntsRegistrationNumberOfBins1ParamsDict",
    "AntsRegistrationNumberOfBins1ParamsDictTagged",
    "AntsRegistrationNumberOfBins2ParamsDict",
    "AntsRegistrationNumberOfBins2ParamsDictTagged",
    "AntsRegistrationNumberOfBinsParamsDict",
    "AntsRegistrationNumberOfBinsParamsDictTagged",
    "AntsRegistrationNumberOfIntegrationSteps1ParamsDict",
    "AntsRegistrationNumberOfIntegrationSteps1ParamsDictTagged",
    "AntsRegistrationNumberOfIntegrationStepsParamsDict",
    "AntsRegistrationNumberOfIntegrationStepsParamsDictTagged",
    "AntsRegistrationNumberOfTimePointSamplesParamsDict",
    "AntsRegistrationNumberOfTimePointSamplesParamsDictTagged",
    "AntsRegistrationOutputs",
    "AntsRegistrationParamsDict",
    "AntsRegistrationParamsDictTagged",
    "AntsRegistrationPointSetSigma1ParamsDict",
    "AntsRegistrationPointSetSigma1ParamsDictTagged",
    "AntsRegistrationPointSetSigmaParamsDict",
    "AntsRegistrationPointSetSigmaParamsDictTagged",
    "AntsRegistrationRadius1ParamsDict",
    "AntsRegistrationRadius1ParamsDictTagged",
    "AntsRegistrationRadius2ParamsDict",
    "AntsRegistrationRadius2ParamsDictTagged",
    "AntsRegistrationRadiusParamsDict",
    "AntsRegistrationRadiusParamsDictTagged",
    "AntsRegistrationSamplingPercentage1ParamsDict",
    "AntsRegistrationSamplingPercentage1ParamsDictTagged",
    "AntsRegistrationSamplingPercentage2ParamsDict",
    "AntsRegistrationSamplingPercentage2ParamsDictTagged",
    "AntsRegistrationSamplingPercentage3ParamsDict",
    "AntsRegistrationSamplingPercentage3ParamsDictTagged",
    "AntsRegistrationSamplingPercentage4ParamsDict",
    "AntsRegistrationSamplingPercentage4ParamsDictTagged",
    "AntsRegistrationSamplingPercentage5ParamsDict",
    "AntsRegistrationSamplingPercentage5ParamsDictTagged",
    "AntsRegistrationSamplingPercentage6ParamsDict",
    "AntsRegistrationSamplingPercentage6ParamsDictTagged",
    "AntsRegistrationSamplingPercentage7ParamsDict",
    "AntsRegistrationSamplingPercentage7ParamsDictTagged",
    "AntsRegistrationSamplingPercentage8ParamsDict",
    "AntsRegistrationSamplingPercentage8ParamsDictTagged",
    "AntsRegistrationSamplingPercentageParamsDict",
    "AntsRegistrationSamplingPercentageParamsDictTagged",
    "AntsRegistrationSamplingStrategy1ParamsDict",
    "AntsRegistrationSamplingStrategy1ParamsDictTagged",
    "AntsRegistrationSamplingStrategy2ParamsDict",
    "AntsRegistrationSamplingStrategy2ParamsDictTagged",
    "AntsRegistrationSamplingStrategy3ParamsDict",
    "AntsRegistrationSamplingStrategy3ParamsDictTagged",
    "AntsRegistrationSamplingStrategy4ParamsDict",
    "AntsRegistrationSamplingStrategy4ParamsDictTagged",
    "AntsRegistrationSamplingStrategy5ParamsDict",
    "AntsRegistrationSamplingStrategy5ParamsDictTagged",
    "AntsRegistrationSamplingStrategyParamsDict",
    "AntsRegistrationSamplingStrategyParamsDictTagged",
    "AntsRegistrationSplineOrder1ParamsDict",
    "AntsRegistrationSplineOrder1ParamsDictTagged",
    "AntsRegistrationSplineOrder2ParamsDict",
    "AntsRegistrationSplineOrder2ParamsDictTagged",
    "AntsRegistrationSplineOrder3ParamsDict",
    "AntsRegistrationSplineOrder3ParamsDictTagged",
    "AntsRegistrationSplineOrderParamsDict",
    "AntsRegistrationSplineOrderParamsDictTagged",
    "AntsRegistrationStageParamsDict",
    "AntsRegistrationStageParamsDictTagged",
    "AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDict",
    "AntsRegistrationTotalFieldMeshSizeAtBaseLevel1ParamsDictTagged",
    "AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDict",
    "AntsRegistrationTotalFieldMeshSizeAtBaseLevelParamsDictTagged",
    "AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDict",
    "AntsRegistrationTotalFieldVarianceInVoxelSpaceParamsDictTagged",
    "AntsRegistrationTransformAffineParamsDict",
    "AntsRegistrationTransformAffineParamsDictTagged",
    "AntsRegistrationTransformBsplineDisplacementFieldParamsDict",
    "AntsRegistrationTransformBsplineDisplacementFieldParamsDictTagged",
    "AntsRegistrationTransformBsplineExponentialParamsDict",
    "AntsRegistrationTransformBsplineExponentialParamsDictTagged",
    "AntsRegistrationTransformBsplineParamsDict",
    "AntsRegistrationTransformBsplineParamsDictTagged",
    "AntsRegistrationTransformBsplineSynParamsDict",
    "AntsRegistrationTransformBsplineSynParamsDictTagged",
    "AntsRegistrationTransformCompositeAffineParamsDict",
    "AntsRegistrationTransformCompositeAffineParamsDictTagged",
    "AntsRegistrationTransformExponentialParamsDict",
    "AntsRegistrationTransformExponentialParamsDictTagged",
    "AntsRegistrationTransformGaussianDisplacementFieldParamsDict",
    "AntsRegistrationTransformGaussianDisplacementFieldParamsDictTagged",
    "AntsRegistrationTransformRigidParamsDict",
    "AntsRegistrationTransformRigidParamsDictTagged",
    "AntsRegistrationTransformSimilarityParamsDict",
    "AntsRegistrationTransformSimilarityParamsDictTagged",
    "AntsRegistrationTransformSynParamsDict",
    "AntsRegistrationTransformSynParamsDictTagged",
    "AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDict",
    "AntsRegistrationTransformTimeVaryingBsplineVelocityFieldParamsDictTagged",
    "AntsRegistrationTransformTimeVaryingVelocityFieldParamsDict",
    "AntsRegistrationTransformTimeVaryingVelocityFieldParamsDictTagged",
    "AntsRegistrationTransformTranslationParamsDict",
    "AntsRegistrationTransformTranslationParamsDictTagged",
    "AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDict",
    "AntsRegistrationUpdateFieldVarianceInVoxelSpaceParamsDictTagged",
    "AntsRegistrationUseGradientFilter1ParamsDict",
    "AntsRegistrationUseGradientFilter1ParamsDictTagged",
    "AntsRegistrationUseGradientFilter2ParamsDict",
    "AntsRegistrationUseGradientFilter2ParamsDictTagged",
    "AntsRegistrationUseGradientFilter3ParamsDict",
    "AntsRegistrationUseGradientFilter3ParamsDictTagged",
    "AntsRegistrationUseGradientFilter4ParamsDict",
    "AntsRegistrationUseGradientFilter4ParamsDictTagged",
    "AntsRegistrationUseGradientFilter5ParamsDict",
    "AntsRegistrationUseGradientFilter5ParamsDictTagged",
    "AntsRegistrationUseGradientFilterParamsDict",
    "AntsRegistrationUseGradientFilterParamsDictTagged",
    "AntsRegistrationUseInverseParamsDict",
    "AntsRegistrationUseInverseParamsDictTagged",
    "AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDict",
    "AntsRegistrationVelocityFieldMeshSizeAtBaseLevelParamsDictTagged",
    "AntsRegistrationWinsorizeImageIntensitiesParamsDict",
    "AntsRegistrationWinsorizeImageIntensitiesParamsDictTagged",
    "ants_registration",
    "ants_registration_boundary_points_only",
    "ants_registration_boundary_points_only_1",
    "ants_registration_boundary_points_only_2",
    "ants_registration_convergence",
    "ants_registration_distance_sigma",
    "ants_registration_execute",
    "ants_registration_gradient_sigma",
    "ants_registration_initial_moving_transform",
    "ants_registration_initial_moving_transform_initialization_feature",
    "ants_registration_initial_moving_transform_use_inverse",
    "ants_registration_intensity_sigma",
    "ants_registration_k_neighborhood",
    "ants_registration_k_neighborhood_1",
    "ants_registration_k_neighborhood_2",
    "ants_registration_masks",
    "ants_registration_metric_ants_neighbourhood_cross_correlation",
    "ants_registration_metric_demons",
    "ants_registration_metric_euclidean_icp",
    "ants_registration_metric_global_correlation",
    "ants_registration_metric_igdm",
    "ants_registration_metric_jensen_havrda_charvet_tsallis",
    "ants_registration_metric_mattes",
    "ants_registration_metric_mean_squares",
    "ants_registration_metric_mutual_information",
    "ants_registration_metric_point_set_expectation",
    "ants_registration_moving_mask",
    "ants_registration_neighborhood_radius",
    "ants_registration_number_of_bins",
    "ants_registration_number_of_bins_1",
    "ants_registration_number_of_bins_2",
    "ants_registration_number_of_integration_steps",
    "ants_registration_number_of_integration_steps_1",
    "ants_registration_number_of_time_point_samples",
    "ants_registration_params",
    "ants_registration_point_set_sigma",
    "ants_registration_point_set_sigma_1",
    "ants_registration_radius",
    "ants_registration_radius_1",
    "ants_registration_radius_2",
    "ants_registration_sampling_percentage",
    "ants_registration_sampling_percentage_1",
    "ants_registration_sampling_percentage_2",
    "ants_registration_sampling_percentage_3",
    "ants_registration_sampling_percentage_4",
    "ants_registration_sampling_percentage_5",
    "ants_registration_sampling_percentage_6",
    "ants_registration_sampling_percentage_7",
    "ants_registration_sampling_percentage_8",
    "ants_registration_sampling_strategy",
    "ants_registration_sampling_strategy_1",
    "ants_registration_sampling_strategy_2",
    "ants_registration_sampling_strategy_3",
    "ants_registration_sampling_strategy_4",
    "ants_registration_sampling_strategy_5",
    "ants_registration_spline_order",
    "ants_registration_spline_order_1",
    "ants_registration_spline_order_2",
    "ants_registration_spline_order_3",
    "ants_registration_stage",
    "ants_registration_total_field_mesh_size_at_base_level",
    "ants_registration_total_field_mesh_size_at_base_level_1",
    "ants_registration_total_field_variance_in_voxel_space",
    "ants_registration_transform_affine",
    "ants_registration_transform_bspline",
    "ants_registration_transform_bspline_displacement_field",
    "ants_registration_transform_bspline_exponential",
    "ants_registration_transform_bspline_syn",
    "ants_registration_transform_composite_affine",
    "ants_registration_transform_exponential",
    "ants_registration_transform_gaussian_displacement_field",
    "ants_registration_transform_rigid",
    "ants_registration_transform_similarity",
    "ants_registration_transform_syn",
    "ants_registration_transform_time_varying_bspline_velocity_field",
    "ants_registration_transform_time_varying_velocity_field",
    "ants_registration_transform_translation",
    "ants_registration_update_field_variance_in_voxel_space",
    "ants_registration_use_gradient_filter",
    "ants_registration_use_gradient_filter_1",
    "ants_registration_use_gradient_filter_2",
    "ants_registration_use_gradient_filter_3",
    "ants_registration_use_gradient_filter_4",
    "ants_registration_use_gradient_filter_5",
    "ants_registration_use_inverse",
    "ants_registration_velocity_field_mesh_size_at_base_level",
    "ants_registration_winsorize_image_intensities",
]
