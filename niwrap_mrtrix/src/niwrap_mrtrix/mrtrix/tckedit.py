# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

TCKEDIT_METADATA = Metadata(
    id="8969d0b343f6f6903fb3ca1d150899aafd2fdca5.boutiques",
    name="tckedit",
    package="mrtrix",
    container_image_tag="mrtrix3/mrtrix3:3.0.4",
)


_TckeditVariousStringParamsDictNoTag = typing.TypedDict('_TckeditVariousStringParamsDictNoTag', {
    "obj": str,
})
TckeditVariousStringParamsDictTagged = typing.TypedDict('TckeditVariousStringParamsDictTagged', {
    "@type": typing.Literal["VariousString"],
    "obj": str,
})
TckeditVariousStringParamsDict = _TckeditVariousStringParamsDictNoTag | TckeditVariousStringParamsDictTagged


_TckeditVariousFileParamsDictNoTag = typing.TypedDict('_TckeditVariousFileParamsDictNoTag', {
    "obj": InputPathType,
})
TckeditVariousFileParamsDictTagged = typing.TypedDict('TckeditVariousFileParamsDictTagged', {
    "@type": typing.Literal["VariousFile"],
    "obj": InputPathType,
})
TckeditVariousFileParamsDict = _TckeditVariousFileParamsDictNoTag | TckeditVariousFileParamsDictTagged


_TckeditIncludeParamsDictNoTag = typing.TypedDict('_TckeditIncludeParamsDictNoTag', {
    "spec": typing.Union[TckeditVariousStringParamsDictTagged, TckeditVariousFileParamsDictTagged],
})
TckeditIncludeParamsDictTagged = typing.TypedDict('TckeditIncludeParamsDictTagged', {
    "@type": typing.Literal["include"],
    "spec": typing.Union[TckeditVariousStringParamsDictTagged, TckeditVariousFileParamsDictTagged],
})
TckeditIncludeParamsDict = _TckeditIncludeParamsDictNoTag | TckeditIncludeParamsDictTagged


_TckeditIncludeOrderedParamsDictNoTag = typing.TypedDict('_TckeditIncludeOrderedParamsDictNoTag', {
    "image": str,
})
TckeditIncludeOrderedParamsDictTagged = typing.TypedDict('TckeditIncludeOrderedParamsDictTagged', {
    "@type": typing.Literal["include_ordered"],
    "image": str,
})
TckeditIncludeOrderedParamsDict = _TckeditIncludeOrderedParamsDictNoTag | TckeditIncludeOrderedParamsDictTagged


_TckeditVariousString1ParamsDictNoTag = typing.TypedDict('_TckeditVariousString1ParamsDictNoTag', {
    "obj": str,
})
TckeditVariousString1ParamsDictTagged = typing.TypedDict('TckeditVariousString1ParamsDictTagged', {
    "@type": typing.Literal["VariousString_1"],
    "obj": str,
})
TckeditVariousString1ParamsDict = _TckeditVariousString1ParamsDictNoTag | TckeditVariousString1ParamsDictTagged


_TckeditVariousFile1ParamsDictNoTag = typing.TypedDict('_TckeditVariousFile1ParamsDictNoTag', {
    "obj": InputPathType,
})
TckeditVariousFile1ParamsDictTagged = typing.TypedDict('TckeditVariousFile1ParamsDictTagged', {
    "@type": typing.Literal["VariousFile_1"],
    "obj": InputPathType,
})
TckeditVariousFile1ParamsDict = _TckeditVariousFile1ParamsDictNoTag | TckeditVariousFile1ParamsDictTagged


_TckeditExcludeParamsDictNoTag = typing.TypedDict('_TckeditExcludeParamsDictNoTag', {
    "spec": typing.Union[TckeditVariousString1ParamsDictTagged, TckeditVariousFile1ParamsDictTagged],
})
TckeditExcludeParamsDictTagged = typing.TypedDict('TckeditExcludeParamsDictTagged', {
    "@type": typing.Literal["exclude"],
    "spec": typing.Union[TckeditVariousString1ParamsDictTagged, TckeditVariousFile1ParamsDictTagged],
})
TckeditExcludeParamsDict = _TckeditExcludeParamsDictNoTag | TckeditExcludeParamsDictTagged


_TckeditVariousString2ParamsDictNoTag = typing.TypedDict('_TckeditVariousString2ParamsDictNoTag', {
    "obj": str,
})
TckeditVariousString2ParamsDictTagged = typing.TypedDict('TckeditVariousString2ParamsDictTagged', {
    "@type": typing.Literal["VariousString_2"],
    "obj": str,
})
TckeditVariousString2ParamsDict = _TckeditVariousString2ParamsDictNoTag | TckeditVariousString2ParamsDictTagged


_TckeditVariousFile2ParamsDictNoTag = typing.TypedDict('_TckeditVariousFile2ParamsDictNoTag', {
    "obj": InputPathType,
})
TckeditVariousFile2ParamsDictTagged = typing.TypedDict('TckeditVariousFile2ParamsDictTagged', {
    "@type": typing.Literal["VariousFile_2"],
    "obj": InputPathType,
})
TckeditVariousFile2ParamsDict = _TckeditVariousFile2ParamsDictNoTag | TckeditVariousFile2ParamsDictTagged


_TckeditMaskParamsDictNoTag = typing.TypedDict('_TckeditMaskParamsDictNoTag', {
    "spec": typing.Union[TckeditVariousString2ParamsDictTagged, TckeditVariousFile2ParamsDictTagged],
})
TckeditMaskParamsDictTagged = typing.TypedDict('TckeditMaskParamsDictTagged', {
    "@type": typing.Literal["mask"],
    "spec": typing.Union[TckeditVariousString2ParamsDictTagged, TckeditVariousFile2ParamsDictTagged],
})
TckeditMaskParamsDict = _TckeditMaskParamsDictNoTag | TckeditMaskParamsDictTagged


_TckeditConfigParamsDictNoTag = typing.TypedDict('_TckeditConfigParamsDictNoTag', {
    "key": str,
    "value": str,
})
TckeditConfigParamsDictTagged = typing.TypedDict('TckeditConfigParamsDictTagged', {
    "@type": typing.Literal["config"],
    "key": str,
    "value": str,
})
TckeditConfigParamsDict = _TckeditConfigParamsDictNoTag | TckeditConfigParamsDictTagged


_TckeditParamsDictNoTag = typing.TypedDict('_TckeditParamsDictNoTag', {
    "include": typing.NotRequired[list[TckeditIncludeParamsDict] | None],
    "include_ordered": typing.NotRequired[list[TckeditIncludeOrderedParamsDict] | None],
    "exclude": typing.NotRequired[list[TckeditExcludeParamsDict] | None],
    "mask": typing.NotRequired[list[TckeditMaskParamsDict] | None],
    "maxlength": typing.NotRequired[float | None],
    "minlength": typing.NotRequired[float | None],
    "number": typing.NotRequired[int | None],
    "skip": typing.NotRequired[int | None],
    "maxweight": typing.NotRequired[float | None],
    "minweight": typing.NotRequired[float | None],
    "inverse": bool,
    "ends_only": bool,
    "tck_weights_in": typing.NotRequired[InputPathType | None],
    "tck_weights_out": typing.NotRequired[str | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[TckeditConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "tracks_in": list[InputPathType],
    "tracks_out": str,
})
TckeditParamsDictTagged = typing.TypedDict('TckeditParamsDictTagged', {
    "@type": typing.Literal["mrtrix/tckedit"],
    "include": typing.NotRequired[list[TckeditIncludeParamsDict] | None],
    "include_ordered": typing.NotRequired[list[TckeditIncludeOrderedParamsDict] | None],
    "exclude": typing.NotRequired[list[TckeditExcludeParamsDict] | None],
    "mask": typing.NotRequired[list[TckeditMaskParamsDict] | None],
    "maxlength": typing.NotRequired[float | None],
    "minlength": typing.NotRequired[float | None],
    "number": typing.NotRequired[int | None],
    "skip": typing.NotRequired[int | None],
    "maxweight": typing.NotRequired[float | None],
    "minweight": typing.NotRequired[float | None],
    "inverse": bool,
    "ends_only": bool,
    "tck_weights_in": typing.NotRequired[InputPathType | None],
    "tck_weights_out": typing.NotRequired[str | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[TckeditConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "tracks_in": list[InputPathType],
    "tracks_out": str,
})
TckeditParamsDict = _TckeditParamsDictNoTag | TckeditParamsDictTagged


def tckedit_spec_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString": tckedit_various_string_cargs,
        "VariousFile": tckedit_various_file_cargs,
    }.get(t)


def tckedit_spec_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString": tckedit_various_string_validate,
        "VariousFile": tckedit_various_file_validate,
    }.get(t)


def tckedit_spec_cargs_dyn_fn_(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString_1": tckedit_various_string_1_cargs,
        "VariousFile_1": tckedit_various_file_1_cargs,
    }.get(t)


def tckedit_spec_validate_dyn_fn_(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString_1": tckedit_various_string_1_validate,
        "VariousFile_1": tckedit_various_file_1_validate,
    }.get(t)


def tckedit_spec_cargs_dyn_fn_2(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString_2": tckedit_various_string_2_cargs,
        "VariousFile_2": tckedit_various_file_2_cargs,
    }.get(t)


def tckedit_spec_validate_dyn_fn_2(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString_2": tckedit_various_string_2_validate,
        "VariousFile_2": tckedit_various_file_2_validate,
    }.get(t)


def tckedit_various_string(
    obj: str,
) -> TckeditVariousStringParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString",
        "obj": obj,
    }
    return params


def tckedit_various_string_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditVariousStringParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def tckedit_various_string_cargs(
    params: TckeditVariousStringParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def tckedit_various_file(
    obj: InputPathType,
) -> TckeditVariousFileParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile",
        "obj": obj,
    }
    return params


def tckedit_various_file_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditVariousFileParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def tckedit_various_file_cargs(
    params: TckeditVariousFileParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def tckedit_include(
    spec: typing.Union[TckeditVariousStringParamsDictTagged, TckeditVariousFileParamsDictTagged],
) -> TckeditIncludeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec: specify an inclusion region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius).\
            Streamlines must traverse ALL inclusion regions to be accepted.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "include",
        "spec": spec,
    }
    return params


def tckedit_include_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditIncludeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec", None) is None:
        raise StyxValidationError("`spec` must not be None")
    if not isinstance(params["spec"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["spec"])}\'')
    if "@type" not in params["spec"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["spec"]["@type"] not in ["VariousString", "VariousFile"]:
        raise StyxValidationError("Parameter `spec`s `@type` must be one of [\"VariousString\", \"VariousFile\"]")
    tckedit_spec_validate_dyn_fn(params["spec"]["@type"])(params["spec"])


def tckedit_include_cargs(
    params: TckeditIncludeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-include")
    cargs.extend(tckedit_spec_cargs_dyn_fn(params.get("spec", None)["@type"])(params.get("spec", None), execution))
    return cargs


def tckedit_include_ordered(
    image: str,
) -> TckeditIncludeOrderedParamsDictTagged:
    """
    Build parameters.
    
    Args:
        image: specify an inclusion region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius).\
            Streamlines must traverse ALL inclusion_ordered regions in the order\
            they are specified in order to be accepted.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "include_ordered",
        "image": image,
    }
    return params


def tckedit_include_ordered_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditIncludeOrderedParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("image", None) is None:
        raise StyxValidationError("`image` must not be None")
    if not isinstance(params["image"], str):
        raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `str`')


def tckedit_include_ordered_cargs(
    params: TckeditIncludeOrderedParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-include_ordered")
    cargs.append(params.get("image", None))
    return cargs


def tckedit_various_string_1(
    obj: str,
) -> TckeditVariousString1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString_1",
        "obj": obj,
    }
    return params


def tckedit_various_string_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditVariousString1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def tckedit_various_string_1_cargs(
    params: TckeditVariousString1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def tckedit_various_file_1(
    obj: InputPathType,
) -> TckeditVariousFile1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile_1",
        "obj": obj,
    }
    return params


def tckedit_various_file_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditVariousFile1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def tckedit_various_file_1_cargs(
    params: TckeditVariousFile1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def tckedit_exclude(
    spec: typing.Union[TckeditVariousString1ParamsDictTagged, TckeditVariousFile1ParamsDictTagged],
) -> TckeditExcludeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec: specify an exclusion region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius).\
            Streamlines that enter ANY exclude region will be discarded.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "exclude",
        "spec": spec,
    }
    return params


def tckedit_exclude_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditExcludeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec", None) is None:
        raise StyxValidationError("`spec` must not be None")
    if not isinstance(params["spec"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["spec"])}\'')
    if "@type" not in params["spec"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["spec"]["@type"] not in ["VariousString_1", "VariousFile_1"]:
        raise StyxValidationError("Parameter `spec`s `@type` must be one of [\"VariousString_1\", \"VariousFile_1\"]")
    tckedit_spec_validate_dyn_fn_(params["spec"]["@type"])(params["spec"])


def tckedit_exclude_cargs(
    params: TckeditExcludeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-exclude")
    cargs.extend(tckedit_spec_cargs_dyn_fn_(params.get("spec", None)["@type"])(params.get("spec", None), execution))
    return cargs


def tckedit_various_string_2(
    obj: str,
) -> TckeditVariousString2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString_2",
        "obj": obj,
    }
    return params


def tckedit_various_string_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditVariousString2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def tckedit_various_string_2_cargs(
    params: TckeditVariousString2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def tckedit_various_file_2(
    obj: InputPathType,
) -> TckeditVariousFile2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile_2",
        "obj": obj,
    }
    return params


def tckedit_various_file_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditVariousFile2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def tckedit_various_file_2_cargs(
    params: TckeditVariousFile2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def tckedit_mask(
    spec: typing.Union[TckeditVariousString2ParamsDictTagged, TckeditVariousFile2ParamsDictTagged],
) -> TckeditMaskParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec: specify a masking region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius). If\
            defined, streamlines exiting the mask will be truncated.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mask",
        "spec": spec,
    }
    return params


def tckedit_mask_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditMaskParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec", None) is None:
        raise StyxValidationError("`spec` must not be None")
    if not isinstance(params["spec"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["spec"])}\'')
    if "@type" not in params["spec"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["spec"]["@type"] not in ["VariousString_2", "VariousFile_2"]:
        raise StyxValidationError("Parameter `spec`s `@type` must be one of [\"VariousString_2\", \"VariousFile_2\"]")
    tckedit_spec_validate_dyn_fn_2(params["spec"]["@type"])(params["spec"])


def tckedit_mask_cargs(
    params: TckeditMaskParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-mask")
    cargs.extend(tckedit_spec_cargs_dyn_fn_2(params.get("spec", None)["@type"])(params.get("spec", None), execution))
    return cargs


def tckedit_config(
    key: str,
    value: str,
) -> TckeditConfigParamsDictTagged:
    """
    Build parameters.
    
    Args:
        key: temporarily set the value of an MRtrix config file entry.
        value: temporarily set the value of an MRtrix config file entry.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "config",
        "key": key,
        "value": value,
    }
    return params


def tckedit_config_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditConfigParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("key", None) is None:
        raise StyxValidationError("`key` must not be None")
    if not isinstance(params["key"], str):
        raise StyxValidationError(f'`key` has the wrong type: Received `{type(params.get("key", None))}` expected `str`')
    if params.get("value", None) is None:
        raise StyxValidationError("`value` must not be None")
    if not isinstance(params["value"], str):
        raise StyxValidationError(f'`value` has the wrong type: Received `{type(params.get("value", None))}` expected `str`')


def tckedit_config_cargs(
    params: TckeditConfigParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-config")
    cargs.append(params.get("key", None))
    cargs.append(params.get("value", None))
    return cargs


class TckeditOutputs(typing.NamedTuple):
    """
    Output object returned when calling `TckeditParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    tracks_out: OutputPathType
    """the output track file"""
    tck_weights_out: OutputPathType | None
    """specify the path for an output text scalar file containing streamline
    weights """


def tckedit_params(
    tracks_in: list[InputPathType],
    tracks_out: str,
    include: list[TckeditIncludeParamsDict] | None = None,
    include_ordered: list[TckeditIncludeOrderedParamsDict] | None = None,
    exclude: list[TckeditExcludeParamsDict] | None = None,
    mask: list[TckeditMaskParamsDict] | None = None,
    maxlength: float | None = None,
    minlength: float | None = None,
    number: int | None = None,
    skip: int | None = None,
    maxweight: float | None = None,
    minweight: float | None = None,
    inverse: bool = False,
    ends_only: bool = False,
    tck_weights_in: InputPathType | None = None,
    tck_weights_out: str | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[TckeditConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
) -> TckeditParamsDictTagged:
    """
    Build parameters.
    
    Args:
        tracks_in: the input track file(s).
        tracks_out: the output track file.
        include: specify an inclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion regions to be\
            accepted.
        include_ordered: specify an inclusion region of interest, as either a\
            binary mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion_ordered regions\
            in the order they are specified in order to be accepted.
        exclude: specify an exclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines that enter ANY exclude region will be\
            discarded.
        mask: specify a masking region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius). If\
            defined, streamlines exiting the mask will be truncated.
        maxlength: set the maximum length of any streamline in mm.
        minlength: set the minimum length of any streamline in mm.
        number: set the desired number of selected streamlines to be propagated\
            to the output file.
        skip: omit this number of selected streamlines before commencing\
            writing to the output file.
        maxweight: set the maximum weight of any streamline.
        minweight: set the minimum weight of any streamline.
        inverse: output the inverse selection of streamlines based on the\
            criteria provided; i.e. only those streamlines that fail at least one\
            selection criterion, and/or vertices that are outside masks if\
            provided, will be written to file.
        ends_only: only test the ends of each streamline against the provided\
            include/exclude ROIs.
        tck_weights_in: specify a text scalar file containing the streamline\
            weights.
        tck_weights_out: specify the path for an output text scalar file\
            containing streamline weights.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mrtrix/tckedit",
        "inverse": inverse,
        "ends_only": ends_only,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help_,
        "version": version,
        "tracks_in": tracks_in,
        "tracks_out": tracks_out,
    }
    if include is not None:
        params["include"] = include
    if include_ordered is not None:
        params["include_ordered"] = include_ordered
    if exclude is not None:
        params["exclude"] = exclude
    if mask is not None:
        params["mask"] = mask
    if maxlength is not None:
        params["maxlength"] = maxlength
    if minlength is not None:
        params["minlength"] = minlength
    if number is not None:
        params["number"] = number
    if skip is not None:
        params["skip"] = skip
    if maxweight is not None:
        params["maxweight"] = maxweight
    if minweight is not None:
        params["minweight"] = minweight
    if tck_weights_in is not None:
        params["tck_weights_in"] = tck_weights_in
    if tck_weights_out is not None:
        params["tck_weights_out"] = tck_weights_out
    if nthreads is not None:
        params["nthreads"] = nthreads
    if config is not None:
        params["config"] = config
    return params


def tckedit_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckeditParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("include", None) is not None:
        if not isinstance(params["include"], list):
            raise StyxValidationError(f'`include` has the wrong type: Received `{type(params.get("include", None))}` expected `list[TckeditIncludeParamsDict] | None`')
        for e in params["include"]:
            tckedit_include_validate(e)
    if params.get("include_ordered", None) is not None:
        if not isinstance(params["include_ordered"], list):
            raise StyxValidationError(f'`include_ordered` has the wrong type: Received `{type(params.get("include_ordered", None))}` expected `list[TckeditIncludeOrderedParamsDict] | None`')
        for e in params["include_ordered"]:
            tckedit_include_ordered_validate(e)
    if params.get("exclude", None) is not None:
        if not isinstance(params["exclude"], list):
            raise StyxValidationError(f'`exclude` has the wrong type: Received `{type(params.get("exclude", None))}` expected `list[TckeditExcludeParamsDict] | None`')
        for e in params["exclude"]:
            tckedit_exclude_validate(e)
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], list):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `list[TckeditMaskParamsDict] | None`')
        for e in params["mask"]:
            tckedit_mask_validate(e)
    if params.get("maxlength", None) is not None:
        if not isinstance(params["maxlength"], (float, int)):
            raise StyxValidationError(f'`maxlength` has the wrong type: Received `{type(params.get("maxlength", None))}` expected `float | None`')
    if params.get("minlength", None) is not None:
        if not isinstance(params["minlength"], (float, int)):
            raise StyxValidationError(f'`minlength` has the wrong type: Received `{type(params.get("minlength", None))}` expected `float | None`')
    if params.get("number", None) is not None:
        if not isinstance(params["number"], int):
            raise StyxValidationError(f'`number` has the wrong type: Received `{type(params.get("number", None))}` expected `int | None`')
    if params.get("skip", None) is not None:
        if not isinstance(params["skip"], int):
            raise StyxValidationError(f'`skip` has the wrong type: Received `{type(params.get("skip", None))}` expected `int | None`')
    if params.get("maxweight", None) is not None:
        if not isinstance(params["maxweight"], (float, int)):
            raise StyxValidationError(f'`maxweight` has the wrong type: Received `{type(params.get("maxweight", None))}` expected `float | None`')
    if params.get("minweight", None) is not None:
        if not isinstance(params["minweight"], (float, int)):
            raise StyxValidationError(f'`minweight` has the wrong type: Received `{type(params.get("minweight", None))}` expected `float | None`')
    if params.get("inverse", False) is None:
        raise StyxValidationError("`inverse` must not be None")
    if not isinstance(params["inverse"], bool):
        raise StyxValidationError(f'`inverse` has the wrong type: Received `{type(params.get("inverse", False))}` expected `bool`')
    if params.get("ends_only", False) is None:
        raise StyxValidationError("`ends_only` must not be None")
    if not isinstance(params["ends_only"], bool):
        raise StyxValidationError(f'`ends_only` has the wrong type: Received `{type(params.get("ends_only", False))}` expected `bool`')
    if params.get("tck_weights_in", None) is not None:
        if not isinstance(params["tck_weights_in"], (pathlib.Path, str)):
            raise StyxValidationError(f'`tck_weights_in` has the wrong type: Received `{type(params.get("tck_weights_in", None))}` expected `InputPathType | None`')
    if params.get("tck_weights_out", None) is not None:
        if not isinstance(params["tck_weights_out"], str):
            raise StyxValidationError(f'`tck_weights_out` has the wrong type: Received `{type(params.get("tck_weights_out", None))}` expected `str | None`')
    if params.get("info", False) is None:
        raise StyxValidationError("`info` must not be None")
    if not isinstance(params["info"], bool):
        raise StyxValidationError(f'`info` has the wrong type: Received `{type(params.get("info", False))}` expected `bool`')
    if params.get("quiet", False) is None:
        raise StyxValidationError("`quiet` must not be None")
    if not isinstance(params["quiet"], bool):
        raise StyxValidationError(f'`quiet` has the wrong type: Received `{type(params.get("quiet", False))}` expected `bool`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("force", False) is None:
        raise StyxValidationError("`force` must not be None")
    if not isinstance(params["force"], bool):
        raise StyxValidationError(f'`force` has the wrong type: Received `{type(params.get("force", False))}` expected `bool`')
    if params.get("nthreads", None) is not None:
        if not isinstance(params["nthreads"], int):
            raise StyxValidationError(f'`nthreads` has the wrong type: Received `{type(params.get("nthreads", None))}` expected `int | None`')
    if params.get("config", None) is not None:
        if not isinstance(params["config"], list):
            raise StyxValidationError(f'`config` has the wrong type: Received `{type(params.get("config", None))}` expected `list[TckeditConfigParamsDict] | None`')
        for e in params["config"]:
            tckedit_config_validate(e)
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("tracks_in", None) is None:
        raise StyxValidationError("`tracks_in` must not be None")
    if not isinstance(params["tracks_in"], list):
        raise StyxValidationError(f'`tracks_in` has the wrong type: Received `{type(params.get("tracks_in", None))}` expected `list[InputPathType]`')
    for e in params["tracks_in"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`tracks_in` has the wrong type: Received `{type(params.get("tracks_in", None))}` expected `list[InputPathType]`')
    if params.get("tracks_out", None) is None:
        raise StyxValidationError("`tracks_out` must not be None")
    if not isinstance(params["tracks_out"], str):
        raise StyxValidationError(f'`tracks_out` has the wrong type: Received `{type(params.get("tracks_out", None))}` expected `str`')


def tckedit_cargs(
    params: TckeditParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("tckedit")
    if params.get("include", None) is not None:
        cargs.extend([a for c in [tckedit_include_cargs(s, execution) for s in params.get("include", None)] for a in c])
    if params.get("include_ordered", None) is not None:
        cargs.extend([a for c in [tckedit_include_ordered_cargs(s, execution) for s in params.get("include_ordered", None)] for a in c])
    if params.get("exclude", None) is not None:
        cargs.extend([a for c in [tckedit_exclude_cargs(s, execution) for s in params.get("exclude", None)] for a in c])
    if params.get("mask", None) is not None:
        cargs.extend([a for c in [tckedit_mask_cargs(s, execution) for s in params.get("mask", None)] for a in c])
    if params.get("maxlength", None) is not None:
        cargs.extend([
            "-maxlength",
            str(params.get("maxlength", None))
        ])
    if params.get("minlength", None) is not None:
        cargs.extend([
            "-minlength",
            str(params.get("minlength", None))
        ])
    if params.get("number", None) is not None:
        cargs.extend([
            "-number",
            str(params.get("number", None))
        ])
    if params.get("skip", None) is not None:
        cargs.extend([
            "-skip",
            str(params.get("skip", None))
        ])
    if params.get("maxweight", None) is not None:
        cargs.extend([
            "-maxweight",
            str(params.get("maxweight", None))
        ])
    if params.get("minweight", None) is not None:
        cargs.extend([
            "-minweight",
            str(params.get("minweight", None))
        ])
    if params.get("inverse", False):
        cargs.append("-inverse")
    if params.get("ends_only", False):
        cargs.append("-ends_only")
    if params.get("tck_weights_in", None) is not None:
        cargs.extend([
            "-tck_weights_in",
            execution.input_file(params.get("tck_weights_in", None))
        ])
    if params.get("tck_weights_out", None) is not None:
        cargs.extend([
            "-tck_weights_out",
            params.get("tck_weights_out", None)
        ])
    if params.get("info", False):
        cargs.append("-info")
    if params.get("quiet", False):
        cargs.append("-quiet")
    if params.get("debug", False):
        cargs.append("-debug")
    if params.get("force", False):
        cargs.append("-force")
    if params.get("nthreads", None) is not None:
        cargs.extend([
            "-nthreads",
            str(params.get("nthreads", None))
        ])
    if params.get("config", None) is not None:
        cargs.extend([a for c in [tckedit_config_cargs(s, execution) for s in params.get("config", None)] for a in c])
    if params.get("help", False):
        cargs.append("-help")
    if params.get("version", False):
        cargs.append("-version")
    cargs.extend([execution.input_file(f) for f in params.get("tracks_in", None)])
    cargs.append(params.get("tracks_out", None))
    return cargs


def tckedit_outputs(
    params: TckeditParamsDict,
    execution: Execution,
) -> TckeditOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = TckeditOutputs(
        root=execution.output_file("."),
        tracks_out=execution.output_file(params.get("tracks_out", None)),
        tck_weights_out=execution.output_file(params.get("tck_weights_out", None)) if (params.get("tck_weights_out") is not None) else None,
    )
    return ret


def tckedit_execute(
    params: TckeditParamsDict,
    runner: Runner | None = None,
) -> TckeditOutputs:
    """
    tckedit
    
    Perform various editing operations on track files.
    
    This command can be used to perform various types of manipulations on track
    data. A range of such manipulations are demonstrated in the examples
    provided below.
    
    References:
    
    .
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TckeditOutputs`).
    """
    tckedit_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(TCKEDIT_METADATA)
    params = execution.params(params)
    cargs = tckedit_cargs(params, execution)
    ret = tckedit_outputs(params, execution)
    execution.run(cargs)
    return ret


def tckedit(
    tracks_in: list[InputPathType],
    tracks_out: str,
    include: list[TckeditIncludeParamsDict] | None = None,
    include_ordered: list[TckeditIncludeOrderedParamsDict] | None = None,
    exclude: list[TckeditExcludeParamsDict] | None = None,
    mask: list[TckeditMaskParamsDict] | None = None,
    maxlength: float | None = None,
    minlength: float | None = None,
    number: int | None = None,
    skip: int | None = None,
    maxweight: float | None = None,
    minweight: float | None = None,
    inverse: bool = False,
    ends_only: bool = False,
    tck_weights_in: InputPathType | None = None,
    tck_weights_out: str | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[TckeditConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> TckeditOutputs:
    """
    tckedit
    
    Perform various editing operations on track files.
    
    This command can be used to perform various types of manipulations on track
    data. A range of such manipulations are demonstrated in the examples
    provided below.
    
    References:
    
    .
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        tracks_in: the input track file(s).
        tracks_out: the output track file.
        include: specify an inclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion regions to be\
            accepted.
        include_ordered: specify an inclusion region of interest, as either a\
            binary mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion_ordered regions\
            in the order they are specified in order to be accepted.
        exclude: specify an exclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines that enter ANY exclude region will be\
            discarded.
        mask: specify a masking region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius). If\
            defined, streamlines exiting the mask will be truncated.
        maxlength: set the maximum length of any streamline in mm.
        minlength: set the minimum length of any streamline in mm.
        number: set the desired number of selected streamlines to be propagated\
            to the output file.
        skip: omit this number of selected streamlines before commencing\
            writing to the output file.
        maxweight: set the maximum weight of any streamline.
        minweight: set the minimum weight of any streamline.
        inverse: output the inverse selection of streamlines based on the\
            criteria provided; i.e. only those streamlines that fail at least one\
            selection criterion, and/or vertices that are outside masks if\
            provided, will be written to file.
        ends_only: only test the ends of each streamline against the provided\
            include/exclude ROIs.
        tck_weights_in: specify a text scalar file containing the streamline\
            weights.
        tck_weights_out: specify the path for an output text scalar file\
            containing streamline weights.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TckeditOutputs`).
    """
    params = tckedit_params(
        include=include,
        include_ordered=include_ordered,
        exclude=exclude,
        mask=mask,
        maxlength=maxlength,
        minlength=minlength,
        number=number,
        skip=skip,
        maxweight=maxweight,
        minweight=minweight,
        inverse=inverse,
        ends_only=ends_only,
        tck_weights_in=tck_weights_in,
        tck_weights_out=tck_weights_out,
        info=info,
        quiet=quiet,
        debug=debug,
        force=force,
        nthreads=nthreads,
        config=config,
        help_=help_,
        version=version,
        tracks_in=tracks_in,
        tracks_out=tracks_out,
    )
    return tckedit_execute(params, runner)


__all__ = [
    "TCKEDIT_METADATA",
    "TckeditConfigParamsDict",
    "TckeditConfigParamsDictTagged",
    "TckeditExcludeParamsDict",
    "TckeditExcludeParamsDictTagged",
    "TckeditIncludeOrderedParamsDict",
    "TckeditIncludeOrderedParamsDictTagged",
    "TckeditIncludeParamsDict",
    "TckeditIncludeParamsDictTagged",
    "TckeditMaskParamsDict",
    "TckeditMaskParamsDictTagged",
    "TckeditOutputs",
    "TckeditParamsDict",
    "TckeditParamsDictTagged",
    "TckeditVariousFile1ParamsDict",
    "TckeditVariousFile1ParamsDictTagged",
    "TckeditVariousFile2ParamsDict",
    "TckeditVariousFile2ParamsDictTagged",
    "TckeditVariousFileParamsDict",
    "TckeditVariousFileParamsDictTagged",
    "TckeditVariousString1ParamsDict",
    "TckeditVariousString1ParamsDictTagged",
    "TckeditVariousString2ParamsDict",
    "TckeditVariousString2ParamsDictTagged",
    "TckeditVariousStringParamsDict",
    "TckeditVariousStringParamsDictTagged",
    "tckedit",
    "tckedit_config",
    "tckedit_exclude",
    "tckedit_execute",
    "tckedit_include",
    "tckedit_include_ordered",
    "tckedit_mask",
    "tckedit_params",
    "tckedit_various_file",
    "tckedit_various_file_1",
    "tckedit_various_file_2",
    "tckedit_various_string",
    "tckedit_various_string_1",
    "tckedit_various_string_2",
]
