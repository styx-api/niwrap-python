# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

TCKMAP_METADATA = Metadata(
    id="6c3a1a0072e37f35d493f0f168ff70a6ce77b20d.boutiques",
    name="tckmap",
    package="mrtrix",
    container_image_tag="mrtrix3/mrtrix3:3.0.4",
)


_TckmapVariousStringParamsDictNoTag = typing.TypedDict('_TckmapVariousStringParamsDictNoTag', {
    "obj": str,
})
TckmapVariousStringParamsDictTagged = typing.TypedDict('TckmapVariousStringParamsDictTagged', {
    "@type": typing.Literal["VariousString"],
    "obj": str,
})
TckmapVariousStringParamsDict = _TckmapVariousStringParamsDictNoTag | TckmapVariousStringParamsDictTagged


_TckmapVariousFileParamsDictNoTag = typing.TypedDict('_TckmapVariousFileParamsDictNoTag', {
    "obj": InputPathType,
})
TckmapVariousFileParamsDictTagged = typing.TypedDict('TckmapVariousFileParamsDictTagged', {
    "@type": typing.Literal["VariousFile"],
    "obj": InputPathType,
})
TckmapVariousFileParamsDict = _TckmapVariousFileParamsDictNoTag | TckmapVariousFileParamsDictTagged


_TckmapConfigParamsDictNoTag = typing.TypedDict('_TckmapConfigParamsDictNoTag', {
    "key": str,
    "value": str,
})
TckmapConfigParamsDictTagged = typing.TypedDict('TckmapConfigParamsDictTagged', {
    "@type": typing.Literal["config"],
    "key": str,
    "value": str,
})
TckmapConfigParamsDict = _TckmapConfigParamsDictNoTag | TckmapConfigParamsDictTagged


_TckmapParamsDictNoTag = typing.TypedDict('_TckmapParamsDictNoTag', {
    "template": typing.NotRequired[InputPathType | None],
    "vox": typing.NotRequired[list[float] | None],
    "datatype": typing.NotRequired[str | None],
    "dec": bool,
    "dixel": typing.NotRequired[typing.Union[TckmapVariousStringParamsDictTagged, TckmapVariousFileParamsDictTagged] | None],
    "tod": typing.NotRequired[int | None],
    "contrast": typing.NotRequired[str | None],
    "image": typing.NotRequired[InputPathType | None],
    "vector_file": typing.NotRequired[InputPathType | None],
    "stat_vox": typing.NotRequired[str | None],
    "stat_tck": typing.NotRequired[str | None],
    "fwhm_tck": typing.NotRequired[float | None],
    "map_zero": bool,
    "backtrack": bool,
    "upsample": typing.NotRequired[int | None],
    "precise": bool,
    "ends_only": bool,
    "tck_weights_in": typing.NotRequired[InputPathType | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[TckmapConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "tracks": InputPathType,
    "output": str,
})
TckmapParamsDictTagged = typing.TypedDict('TckmapParamsDictTagged', {
    "@type": typing.Literal["mrtrix/tckmap"],
    "template": typing.NotRequired[InputPathType | None],
    "vox": typing.NotRequired[list[float] | None],
    "datatype": typing.NotRequired[str | None],
    "dec": bool,
    "dixel": typing.NotRequired[typing.Union[TckmapVariousStringParamsDictTagged, TckmapVariousFileParamsDictTagged] | None],
    "tod": typing.NotRequired[int | None],
    "contrast": typing.NotRequired[str | None],
    "image": typing.NotRequired[InputPathType | None],
    "vector_file": typing.NotRequired[InputPathType | None],
    "stat_vox": typing.NotRequired[str | None],
    "stat_tck": typing.NotRequired[str | None],
    "fwhm_tck": typing.NotRequired[float | None],
    "map_zero": bool,
    "backtrack": bool,
    "upsample": typing.NotRequired[int | None],
    "precise": bool,
    "ends_only": bool,
    "tck_weights_in": typing.NotRequired[InputPathType | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[TckmapConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "tracks": InputPathType,
    "output": str,
})
TckmapParamsDict = _TckmapParamsDictNoTag | TckmapParamsDictTagged


def tckmap_dixel_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString": tckmap_various_string_cargs,
        "VariousFile": tckmap_various_file_cargs,
    }.get(t)


def tckmap_dixel_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString": tckmap_various_string_validate,
        "VariousFile": tckmap_various_file_validate,
    }.get(t)


def tckmap_various_string(
    obj: str,
) -> TckmapVariousStringParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString",
        "obj": obj,
    }
    return params


def tckmap_various_string_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckmapVariousStringParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def tckmap_various_string_cargs(
    params: TckmapVariousStringParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def tckmap_various_file(
    obj: InputPathType,
) -> TckmapVariousFileParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile",
        "obj": obj,
    }
    return params


def tckmap_various_file_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckmapVariousFileParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def tckmap_various_file_cargs(
    params: TckmapVariousFileParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def tckmap_config(
    key: str,
    value: str,
) -> TckmapConfigParamsDictTagged:
    """
    Build parameters.
    
    Args:
        key: temporarily set the value of an MRtrix config file entry.
        value: temporarily set the value of an MRtrix config file entry.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "config",
        "key": key,
        "value": value,
    }
    return params


def tckmap_config_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckmapConfigParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("key", None) is None:
        raise StyxValidationError("`key` must not be None")
    if not isinstance(params["key"], str):
        raise StyxValidationError(f'`key` has the wrong type: Received `{type(params.get("key", None))}` expected `str`')
    if params.get("value", None) is None:
        raise StyxValidationError("`value` must not be None")
    if not isinstance(params["value"], str):
        raise StyxValidationError(f'`value` has the wrong type: Received `{type(params.get("value", None))}` expected `str`')


def tckmap_config_cargs(
    params: TckmapConfigParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-config")
    cargs.append(params.get("key", None))
    cargs.append(params.get("value", None))
    return cargs


class TckmapOutputs(typing.NamedTuple):
    """
    Output object returned when calling `TckmapParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output: OutputPathType
    """the output track-weighted image"""


def tckmap_params(
    tracks: InputPathType,
    output: str,
    template: InputPathType | None = None,
    vox: list[float] | None = None,
    datatype: str | None = None,
    dec: bool = False,
    dixel: typing.Union[TckmapVariousStringParamsDictTagged, TckmapVariousFileParamsDictTagged] | None = None,
    tod: int | None = None,
    contrast: str | None = None,
    image: InputPathType | None = None,
    vector_file: InputPathType | None = None,
    stat_vox: str | None = None,
    stat_tck: str | None = None,
    fwhm_tck: float | None = None,
    map_zero: bool = False,
    backtrack: bool = False,
    upsample: int | None = None,
    precise: bool = False,
    ends_only: bool = False,
    tck_weights_in: InputPathType | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[TckmapConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
) -> TckmapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        tracks: the input track file.
        output: the output track-weighted image.
        template: an image file to be used as a template for the output (the\
            output image will have the same transform and field of view).
        vox: provide either an isotropic voxel size (in mm), or comma-separated\
            list of 3 voxel dimensions.
        datatype: specify output image data type.
        dec: perform track mapping in directionally-encoded colour (DEC) space.
        dixel: map streamlines to dixels within each voxel; requires either a\
            number of dixels (references an internal direction set), or a path to a\
            text file containing a set of directions stored as azimuth/elevation\
            pairs.
        tod: generate a Track Orientation Distribution (TOD) in each voxel;\
            need to specify the maximum spherical harmonic degree lmax to use when\
            generating Apodised Point Spread Functions.
        contrast: define the desired form of contrast for the output image\
            Options are: tdi, length, invlength, scalar_map, scalar_map_count,\
            fod_amp, curvature, vector_file (default: tdi).
        image: provide the scalar image map for generating images with\
            'scalar_map' / 'scalar_map_count' contrast, or the spherical harmonics\
            image for 'fod_amp' contrast.
        vector_file: provide the vector data file for generating images with\
            'vector_file' contrast.
        stat_vox: define the statistic for choosing the final voxel intensities\
            for a given contrast type given the individual values from the tracks\
            passing through each voxel.\
            Options are: sum, min, mean, max (default: sum).
        stat_tck: define the statistic for choosing the contribution to be made\
            by each streamline as a function of the samples taken along their\
            lengths.\
            Only has an effect for 'scalar_map', 'fod_amp' and 'curvature'\
            contrast types.\
            Options are: sum, min, mean, max, median, mean_nonzero, gaussian,\
            ends_min, ends_mean, ends_max, ends_prod (default: mean).
        fwhm_tck: when using gaussian-smoothed per-track statistic, specify the\
            desired full-width half-maximum of the Gaussian smoothing kernel (in\
            mm).
        map_zero: if a streamline has zero contribution based on the contrast &\
            statistic, typically it is not mapped; use this option to still\
            contribute to the map even if this is the case (these non-contributing\
            voxels can then influence the mean value in each voxel of the map).
        backtrack: when using -stat_tck ends_*, if the streamline endpoint is\
            outside the FoV, backtrack along the streamline trajectory until an\
            appropriate point is found.
        upsample: upsample the tracks by some ratio using Hermite interpolation\
            before mappping\
            (If omitted, an appropriate ratio will be determined automatically).
        precise: use a more precise streamline mapping strategy, that\
            accurately quantifies the length through each voxel (these lengths are\
            then taken into account during TWI calculation).
        ends_only: only map the streamline endpoints to the image.
        tck_weights_in: specify a text scalar file containing the streamline\
            weights.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mrtrix/tckmap",
        "dec": dec,
        "map_zero": map_zero,
        "backtrack": backtrack,
        "precise": precise,
        "ends_only": ends_only,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help_,
        "version": version,
        "tracks": tracks,
        "output": output,
    }
    if template is not None:
        params["template"] = template
    if vox is not None:
        params["vox"] = vox
    if datatype is not None:
        params["datatype"] = datatype
    if dixel is not None:
        params["dixel"] = dixel
    if tod is not None:
        params["tod"] = tod
    if contrast is not None:
        params["contrast"] = contrast
    if image is not None:
        params["image"] = image
    if vector_file is not None:
        params["vector_file"] = vector_file
    if stat_vox is not None:
        params["stat_vox"] = stat_vox
    if stat_tck is not None:
        params["stat_tck"] = stat_tck
    if fwhm_tck is not None:
        params["fwhm_tck"] = fwhm_tck
    if upsample is not None:
        params["upsample"] = upsample
    if tck_weights_in is not None:
        params["tck_weights_in"] = tck_weights_in
    if nthreads is not None:
        params["nthreads"] = nthreads
    if config is not None:
        params["config"] = config
    return params


def tckmap_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckmapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("template", None) is not None:
        if not isinstance(params["template"], (pathlib.Path, str)):
            raise StyxValidationError(f'`template` has the wrong type: Received `{type(params.get("template", None))}` expected `InputPathType | None`')
    if params.get("vox", None) is not None:
        if not isinstance(params["vox"], list):
            raise StyxValidationError(f'`vox` has the wrong type: Received `{type(params.get("vox", None))}` expected `list[float] | None`')
        for e in params["vox"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`vox` has the wrong type: Received `{type(params.get("vox", None))}` expected `list[float] | None`')
    if params.get("datatype", None) is not None:
        if not isinstance(params["datatype"], str):
            raise StyxValidationError(f'`datatype` has the wrong type: Received `{type(params.get("datatype", None))}` expected `str | None`')
    if params.get("dec", False) is None:
        raise StyxValidationError("`dec` must not be None")
    if not isinstance(params["dec"], bool):
        raise StyxValidationError(f'`dec` has the wrong type: Received `{type(params.get("dec", False))}` expected `bool`')
    if params.get("dixel", None) is not None:
        if not isinstance(params["dixel"], dict):
            raise StyxValidationError(f'Params object has the wrong type \'{type(params["dixel"])}\'')
        if "@type" not in params["dixel"]:
            raise StyxValidationError("Params object is missing `@type`")
        if params["dixel"]["@type"] not in ["VariousString", "VariousFile"]:
            raise StyxValidationError("Parameter `dixel`s `@type` must be one of [\"VariousString\", \"VariousFile\"]")
        tckmap_dixel_validate_dyn_fn(params["dixel"]["@type"])(params["dixel"])
    if params.get("tod", None) is not None:
        if not isinstance(params["tod"], int):
            raise StyxValidationError(f'`tod` has the wrong type: Received `{type(params.get("tod", None))}` expected `int | None`')
    if params.get("contrast", None) is not None:
        if not isinstance(params["contrast"], str):
            raise StyxValidationError(f'`contrast` has the wrong type: Received `{type(params.get("contrast", None))}` expected `str | None`')
    if params.get("image", None) is not None:
        if not isinstance(params["image"], (pathlib.Path, str)):
            raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `InputPathType | None`')
    if params.get("vector_file", None) is not None:
        if not isinstance(params["vector_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`vector_file` has the wrong type: Received `{type(params.get("vector_file", None))}` expected `InputPathType | None`')
    if params.get("stat_vox", None) is not None:
        if not isinstance(params["stat_vox"], str):
            raise StyxValidationError(f'`stat_vox` has the wrong type: Received `{type(params.get("stat_vox", None))}` expected `str | None`')
    if params.get("stat_tck", None) is not None:
        if not isinstance(params["stat_tck"], str):
            raise StyxValidationError(f'`stat_tck` has the wrong type: Received `{type(params.get("stat_tck", None))}` expected `str | None`')
    if params.get("fwhm_tck", None) is not None:
        if not isinstance(params["fwhm_tck"], (float, int)):
            raise StyxValidationError(f'`fwhm_tck` has the wrong type: Received `{type(params.get("fwhm_tck", None))}` expected `float | None`')
    if params.get("map_zero", False) is None:
        raise StyxValidationError("`map_zero` must not be None")
    if not isinstance(params["map_zero"], bool):
        raise StyxValidationError(f'`map_zero` has the wrong type: Received `{type(params.get("map_zero", False))}` expected `bool`')
    if params.get("backtrack", False) is None:
        raise StyxValidationError("`backtrack` must not be None")
    if not isinstance(params["backtrack"], bool):
        raise StyxValidationError(f'`backtrack` has the wrong type: Received `{type(params.get("backtrack", False))}` expected `bool`')
    if params.get("upsample", None) is not None:
        if not isinstance(params["upsample"], int):
            raise StyxValidationError(f'`upsample` has the wrong type: Received `{type(params.get("upsample", None))}` expected `int | None`')
    if params.get("precise", False) is None:
        raise StyxValidationError("`precise` must not be None")
    if not isinstance(params["precise"], bool):
        raise StyxValidationError(f'`precise` has the wrong type: Received `{type(params.get("precise", False))}` expected `bool`')
    if params.get("ends_only", False) is None:
        raise StyxValidationError("`ends_only` must not be None")
    if not isinstance(params["ends_only"], bool):
        raise StyxValidationError(f'`ends_only` has the wrong type: Received `{type(params.get("ends_only", False))}` expected `bool`')
    if params.get("tck_weights_in", None) is not None:
        if not isinstance(params["tck_weights_in"], (pathlib.Path, str)):
            raise StyxValidationError(f'`tck_weights_in` has the wrong type: Received `{type(params.get("tck_weights_in", None))}` expected `InputPathType | None`')
    if params.get("info", False) is None:
        raise StyxValidationError("`info` must not be None")
    if not isinstance(params["info"], bool):
        raise StyxValidationError(f'`info` has the wrong type: Received `{type(params.get("info", False))}` expected `bool`')
    if params.get("quiet", False) is None:
        raise StyxValidationError("`quiet` must not be None")
    if not isinstance(params["quiet"], bool):
        raise StyxValidationError(f'`quiet` has the wrong type: Received `{type(params.get("quiet", False))}` expected `bool`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("force", False) is None:
        raise StyxValidationError("`force` must not be None")
    if not isinstance(params["force"], bool):
        raise StyxValidationError(f'`force` has the wrong type: Received `{type(params.get("force", False))}` expected `bool`')
    if params.get("nthreads", None) is not None:
        if not isinstance(params["nthreads"], int):
            raise StyxValidationError(f'`nthreads` has the wrong type: Received `{type(params.get("nthreads", None))}` expected `int | None`')
    if params.get("config", None) is not None:
        if not isinstance(params["config"], list):
            raise StyxValidationError(f'`config` has the wrong type: Received `{type(params.get("config", None))}` expected `list[TckmapConfigParamsDict] | None`')
        for e in params["config"]:
            tckmap_config_validate(e)
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("tracks", None) is None:
        raise StyxValidationError("`tracks` must not be None")
    if not isinstance(params["tracks"], (pathlib.Path, str)):
        raise StyxValidationError(f'`tracks` has the wrong type: Received `{type(params.get("tracks", None))}` expected `InputPathType`')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')


def tckmap_cargs(
    params: TckmapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("tckmap")
    if params.get("template", None) is not None:
        cargs.extend([
            "-template",
            execution.input_file(params.get("template", None))
        ])
    if params.get("vox", None) is not None:
        cargs.extend([
            "-vox",
            ",".join(map(str, params.get("vox", None)))
        ])
    if params.get("datatype", None) is not None:
        cargs.extend([
            "-datatype",
            params.get("datatype", None)
        ])
    if params.get("dec", False):
        cargs.append("-dec")
    if params.get("dixel", None) is not None:
        cargs.extend([
            "-dixel",
            *tckmap_dixel_cargs_dyn_fn(params.get("dixel", None)["@type"])(params.get("dixel", None), execution)
        ])
    if params.get("tod", None) is not None:
        cargs.extend([
            "-tod",
            str(params.get("tod", None))
        ])
    if params.get("contrast", None) is not None:
        cargs.extend([
            "-contrast",
            params.get("contrast", None)
        ])
    if params.get("image", None) is not None:
        cargs.extend([
            "-image",
            execution.input_file(params.get("image", None))
        ])
    if params.get("vector_file", None) is not None:
        cargs.extend([
            "-vector_file",
            execution.input_file(params.get("vector_file", None))
        ])
    if params.get("stat_vox", None) is not None:
        cargs.extend([
            "-stat_vox",
            params.get("stat_vox", None)
        ])
    if params.get("stat_tck", None) is not None:
        cargs.extend([
            "-stat_tck",
            params.get("stat_tck", None)
        ])
    if params.get("fwhm_tck", None) is not None:
        cargs.extend([
            "-fwhm_tck",
            str(params.get("fwhm_tck", None))
        ])
    if params.get("map_zero", False):
        cargs.append("-map_zero")
    if params.get("backtrack", False):
        cargs.append("-backtrack")
    if params.get("upsample", None) is not None:
        cargs.extend([
            "-upsample",
            str(params.get("upsample", None))
        ])
    if params.get("precise", False):
        cargs.append("-precise")
    if params.get("ends_only", False):
        cargs.append("-ends_only")
    if params.get("tck_weights_in", None) is not None:
        cargs.extend([
            "-tck_weights_in",
            execution.input_file(params.get("tck_weights_in", None))
        ])
    if params.get("info", False):
        cargs.append("-info")
    if params.get("quiet", False):
        cargs.append("-quiet")
    if params.get("debug", False):
        cargs.append("-debug")
    if params.get("force", False):
        cargs.append("-force")
    if params.get("nthreads", None) is not None:
        cargs.extend([
            "-nthreads",
            str(params.get("nthreads", None))
        ])
    if params.get("config", None) is not None:
        cargs.extend([a for c in [tckmap_config_cargs(s, execution) for s in params.get("config", None)] for a in c])
    if params.get("help", False):
        cargs.append("-help")
    if params.get("version", False):
        cargs.append("-version")
    cargs.append(execution.input_file(params.get("tracks", None)))
    cargs.append(params.get("output", None))
    return cargs


def tckmap_outputs(
    params: TckmapParamsDict,
    execution: Execution,
) -> TckmapOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = TckmapOutputs(
        root=execution.output_file("."),
        output=execution.output_file(params.get("output", None)),
    )
    return ret


def tckmap_execute(
    params: TckmapParamsDict,
    runner: Runner | None = None,
) -> TckmapOutputs:
    """
    tckmap
    
    Use track data as a form of contrast for producing a high-resolution image.
    
    Note: if you run into limitations with RAM usage, make sure you output the
    results to a .mif file or .mih / .dat file pair - this will avoid the
    allocation of an additional buffer to store the output for write-out.
    
    References:
    
    * For TDI or DEC TDI:
    Calamante, F.; Tournier, J.-D.; Jackson, G. D. & Connelly, A. Track-density
    imaging (TDI): Super-resolution white matter imaging using whole-brain
    track-density mapping. NeuroImage, 2010, 53, 1233-1243
    
    * If using -contrast length and -stat_vox mean:
    Pannek, K.; Mathias, J. L.; Bigler, E. D.; Brown, G.; Taylor, J. D. & Rose,
    S. E. The average pathlength map: A diffusion MRI tractography-derived index
    for studying brain pathology. NeuroImage, 2011, 55, 133-141
    
    * If using -dixel option with TDI contrast only:
    Smith, R.E., Tournier, J-D., Calamante, F., Connelly, A. A novel paradigm
    for automated segmentation of very large whole-brain probabilistic
    tractography data sets. In proc. ISMRM, 2011, 19, 673
    
    * If using -dixel option with any other contrast:
    Pannek, K., Raffelt, D., Salvado, O., Rose, S. Incorporating directional
    information in diffusion tractography derived maps: angular track imaging
    (ATI). In Proc. ISMRM, 2012, 20, 1912
    
    * If using -tod option:
    Dhollander, T., Emsell, L., Van Hecke, W., Maes, F., Sunaert, S., Suetens,
    P. Track Orientation Density Imaging (TODI) and Track Orientation
    Distribution (TOD) based tractography. NeuroImage, 2014, 94, 312-336
    
    * If using other contrasts / statistics:
    Calamante, F.; Tournier, J.-D.; Smith, R. E. & Connelly, A. A generalised
    framework for super-resolution track-weighted imaging. NeuroImage, 2012, 59,
    2494-2503
    
    * If using -precise mapping option:
    Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT:
    Spherical-deconvolution informed filtering of tractograms. NeuroImage, 2013,
    67, 298-312 (Appendix 3).
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TckmapOutputs`).
    """
    tckmap_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(TCKMAP_METADATA)
    params = execution.params(params)
    cargs = tckmap_cargs(params, execution)
    ret = tckmap_outputs(params, execution)
    execution.run(cargs)
    return ret


def tckmap(
    tracks: InputPathType,
    output: str,
    template: InputPathType | None = None,
    vox: list[float] | None = None,
    datatype: str | None = None,
    dec: bool = False,
    dixel: typing.Union[TckmapVariousStringParamsDictTagged, TckmapVariousFileParamsDictTagged] | None = None,
    tod: int | None = None,
    contrast: str | None = None,
    image: InputPathType | None = None,
    vector_file: InputPathType | None = None,
    stat_vox: str | None = None,
    stat_tck: str | None = None,
    fwhm_tck: float | None = None,
    map_zero: bool = False,
    backtrack: bool = False,
    upsample: int | None = None,
    precise: bool = False,
    ends_only: bool = False,
    tck_weights_in: InputPathType | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[TckmapConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> TckmapOutputs:
    """
    tckmap
    
    Use track data as a form of contrast for producing a high-resolution image.
    
    Note: if you run into limitations with RAM usage, make sure you output the
    results to a .mif file or .mih / .dat file pair - this will avoid the
    allocation of an additional buffer to store the output for write-out.
    
    References:
    
    * For TDI or DEC TDI:
    Calamante, F.; Tournier, J.-D.; Jackson, G. D. & Connelly, A. Track-density
    imaging (TDI): Super-resolution white matter imaging using whole-brain
    track-density mapping. NeuroImage, 2010, 53, 1233-1243
    
    * If using -contrast length and -stat_vox mean:
    Pannek, K.; Mathias, J. L.; Bigler, E. D.; Brown, G.; Taylor, J. D. & Rose,
    S. E. The average pathlength map: A diffusion MRI tractography-derived index
    for studying brain pathology. NeuroImage, 2011, 55, 133-141
    
    * If using -dixel option with TDI contrast only:
    Smith, R.E., Tournier, J-D., Calamante, F., Connelly, A. A novel paradigm
    for automated segmentation of very large whole-brain probabilistic
    tractography data sets. In proc. ISMRM, 2011, 19, 673
    
    * If using -dixel option with any other contrast:
    Pannek, K., Raffelt, D., Salvado, O., Rose, S. Incorporating directional
    information in diffusion tractography derived maps: angular track imaging
    (ATI). In Proc. ISMRM, 2012, 20, 1912
    
    * If using -tod option:
    Dhollander, T., Emsell, L., Van Hecke, W., Maes, F., Sunaert, S., Suetens,
    P. Track Orientation Density Imaging (TODI) and Track Orientation
    Distribution (TOD) based tractography. NeuroImage, 2014, 94, 312-336
    
    * If using other contrasts / statistics:
    Calamante, F.; Tournier, J.-D.; Smith, R. E. & Connelly, A. A generalised
    framework for super-resolution track-weighted imaging. NeuroImage, 2012, 59,
    2494-2503
    
    * If using -precise mapping option:
    Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT:
    Spherical-deconvolution informed filtering of tractograms. NeuroImage, 2013,
    67, 298-312 (Appendix 3).
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        tracks: the input track file.
        output: the output track-weighted image.
        template: an image file to be used as a template for the output (the\
            output image will have the same transform and field of view).
        vox: provide either an isotropic voxel size (in mm), or comma-separated\
            list of 3 voxel dimensions.
        datatype: specify output image data type.
        dec: perform track mapping in directionally-encoded colour (DEC) space.
        dixel: map streamlines to dixels within each voxel; requires either a\
            number of dixels (references an internal direction set), or a path to a\
            text file containing a set of directions stored as azimuth/elevation\
            pairs.
        tod: generate a Track Orientation Distribution (TOD) in each voxel;\
            need to specify the maximum spherical harmonic degree lmax to use when\
            generating Apodised Point Spread Functions.
        contrast: define the desired form of contrast for the output image\
            Options are: tdi, length, invlength, scalar_map, scalar_map_count,\
            fod_amp, curvature, vector_file (default: tdi).
        image: provide the scalar image map for generating images with\
            'scalar_map' / 'scalar_map_count' contrast, or the spherical harmonics\
            image for 'fod_amp' contrast.
        vector_file: provide the vector data file for generating images with\
            'vector_file' contrast.
        stat_vox: define the statistic for choosing the final voxel intensities\
            for a given contrast type given the individual values from the tracks\
            passing through each voxel.\
            Options are: sum, min, mean, max (default: sum).
        stat_tck: define the statistic for choosing the contribution to be made\
            by each streamline as a function of the samples taken along their\
            lengths.\
            Only has an effect for 'scalar_map', 'fod_amp' and 'curvature'\
            contrast types.\
            Options are: sum, min, mean, max, median, mean_nonzero, gaussian,\
            ends_min, ends_mean, ends_max, ends_prod (default: mean).
        fwhm_tck: when using gaussian-smoothed per-track statistic, specify the\
            desired full-width half-maximum of the Gaussian smoothing kernel (in\
            mm).
        map_zero: if a streamline has zero contribution based on the contrast &\
            statistic, typically it is not mapped; use this option to still\
            contribute to the map even if this is the case (these non-contributing\
            voxels can then influence the mean value in each voxel of the map).
        backtrack: when using -stat_tck ends_*, if the streamline endpoint is\
            outside the FoV, backtrack along the streamline trajectory until an\
            appropriate point is found.
        upsample: upsample the tracks by some ratio using Hermite interpolation\
            before mappping\
            (If omitted, an appropriate ratio will be determined automatically).
        precise: use a more precise streamline mapping strategy, that\
            accurately quantifies the length through each voxel (these lengths are\
            then taken into account during TWI calculation).
        ends_only: only map the streamline endpoints to the image.
        tck_weights_in: specify a text scalar file containing the streamline\
            weights.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TckmapOutputs`).
    """
    params = tckmap_params(
        template=template,
        vox=vox,
        datatype=datatype,
        dec=dec,
        dixel=dixel,
        tod=tod,
        contrast=contrast,
        image=image,
        vector_file=vector_file,
        stat_vox=stat_vox,
        stat_tck=stat_tck,
        fwhm_tck=fwhm_tck,
        map_zero=map_zero,
        backtrack=backtrack,
        upsample=upsample,
        precise=precise,
        ends_only=ends_only,
        tck_weights_in=tck_weights_in,
        info=info,
        quiet=quiet,
        debug=debug,
        force=force,
        nthreads=nthreads,
        config=config,
        help_=help_,
        version=version,
        tracks=tracks,
        output=output,
    )
    return tckmap_execute(params, runner)


__all__ = [
    "TCKMAP_METADATA",
    "TckmapConfigParamsDict",
    "TckmapConfigParamsDictTagged",
    "TckmapOutputs",
    "TckmapParamsDict",
    "TckmapParamsDictTagged",
    "TckmapVariousFileParamsDict",
    "TckmapVariousFileParamsDictTagged",
    "TckmapVariousStringParamsDict",
    "TckmapVariousStringParamsDictTagged",
    "tckmap",
    "tckmap_config",
    "tckmap_execute",
    "tckmap_params",
    "tckmap_various_file",
    "tckmap_various_string",
]
