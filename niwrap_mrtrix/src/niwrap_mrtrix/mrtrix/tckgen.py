# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

TCKGEN_METADATA = Metadata(
    id="49bb9108a82b9af72391f635d21ece29154ff9f6.boutiques",
    name="tckgen",
    package="mrtrix",
    container_image_tag="mrtrix3/mrtrix3:3.0.4",
)


_TckgenSeedImageParamsDictNoTag = typing.TypedDict('_TckgenSeedImageParamsDictNoTag', {
    "image": InputPathType,
})
TckgenSeedImageParamsDictTagged = typing.TypedDict('TckgenSeedImageParamsDictTagged', {
    "@type": typing.Literal["seed_image"],
    "image": InputPathType,
})
TckgenSeedImageParamsDict = _TckgenSeedImageParamsDictNoTag | TckgenSeedImageParamsDictTagged


_TckgenSeedSphereParamsDictNoTag = typing.TypedDict('_TckgenSeedSphereParamsDictNoTag', {
    "spec": list[float],
})
TckgenSeedSphereParamsDictTagged = typing.TypedDict('TckgenSeedSphereParamsDictTagged', {
    "@type": typing.Literal["seed_sphere"],
    "spec": list[float],
})
TckgenSeedSphereParamsDict = _TckgenSeedSphereParamsDictNoTag | TckgenSeedSphereParamsDictTagged


_TckgenSeedRandomPerVoxelParamsDictNoTag = typing.TypedDict('_TckgenSeedRandomPerVoxelParamsDictNoTag', {
    "image": InputPathType,
    "num_per_voxel": int,
})
TckgenSeedRandomPerVoxelParamsDictTagged = typing.TypedDict('TckgenSeedRandomPerVoxelParamsDictTagged', {
    "@type": typing.Literal["seed_random_per_voxel"],
    "image": InputPathType,
    "num_per_voxel": int,
})
TckgenSeedRandomPerVoxelParamsDict = _TckgenSeedRandomPerVoxelParamsDictNoTag | TckgenSeedRandomPerVoxelParamsDictTagged


_TckgenSeedGridPerVoxelParamsDictNoTag = typing.TypedDict('_TckgenSeedGridPerVoxelParamsDictNoTag', {
    "image": InputPathType,
    "grid_size": int,
})
TckgenSeedGridPerVoxelParamsDictTagged = typing.TypedDict('TckgenSeedGridPerVoxelParamsDictTagged', {
    "@type": typing.Literal["seed_grid_per_voxel"],
    "image": InputPathType,
    "grid_size": int,
})
TckgenSeedGridPerVoxelParamsDict = _TckgenSeedGridPerVoxelParamsDictNoTag | TckgenSeedGridPerVoxelParamsDictTagged


_TckgenSeedRejectionParamsDictNoTag = typing.TypedDict('_TckgenSeedRejectionParamsDictNoTag', {
    "image": InputPathType,
})
TckgenSeedRejectionParamsDictTagged = typing.TypedDict('TckgenSeedRejectionParamsDictTagged', {
    "@type": typing.Literal["seed_rejection"],
    "image": InputPathType,
})
TckgenSeedRejectionParamsDict = _TckgenSeedRejectionParamsDictNoTag | TckgenSeedRejectionParamsDictTagged


_TckgenSeedGmwmiParamsDictNoTag = typing.TypedDict('_TckgenSeedGmwmiParamsDictNoTag', {
    "image": InputPathType,
})
TckgenSeedGmwmiParamsDictTagged = typing.TypedDict('TckgenSeedGmwmiParamsDictTagged', {
    "@type": typing.Literal["seed_gmwmi"],
    "image": InputPathType,
})
TckgenSeedGmwmiParamsDict = _TckgenSeedGmwmiParamsDictNoTag | TckgenSeedGmwmiParamsDictTagged


_TckgenVariousStringParamsDictNoTag = typing.TypedDict('_TckgenVariousStringParamsDictNoTag', {
    "obj": str,
})
TckgenVariousStringParamsDictTagged = typing.TypedDict('TckgenVariousStringParamsDictTagged', {
    "@type": typing.Literal["VariousString"],
    "obj": str,
})
TckgenVariousStringParamsDict = _TckgenVariousStringParamsDictNoTag | TckgenVariousStringParamsDictTagged


_TckgenVariousFileParamsDictNoTag = typing.TypedDict('_TckgenVariousFileParamsDictNoTag', {
    "obj": InputPathType,
})
TckgenVariousFileParamsDictTagged = typing.TypedDict('TckgenVariousFileParamsDictTagged', {
    "@type": typing.Literal["VariousFile"],
    "obj": InputPathType,
})
TckgenVariousFileParamsDict = _TckgenVariousFileParamsDictNoTag | TckgenVariousFileParamsDictTagged


_TckgenIncludeParamsDictNoTag = typing.TypedDict('_TckgenIncludeParamsDictNoTag', {
    "spec": typing.Union[TckgenVariousStringParamsDictTagged, TckgenVariousFileParamsDictTagged],
})
TckgenIncludeParamsDictTagged = typing.TypedDict('TckgenIncludeParamsDictTagged', {
    "@type": typing.Literal["include"],
    "spec": typing.Union[TckgenVariousStringParamsDictTagged, TckgenVariousFileParamsDictTagged],
})
TckgenIncludeParamsDict = _TckgenIncludeParamsDictNoTag | TckgenIncludeParamsDictTagged


_TckgenIncludeOrderedParamsDictNoTag = typing.TypedDict('_TckgenIncludeOrderedParamsDictNoTag', {
    "image": str,
})
TckgenIncludeOrderedParamsDictTagged = typing.TypedDict('TckgenIncludeOrderedParamsDictTagged', {
    "@type": typing.Literal["include_ordered"],
    "image": str,
})
TckgenIncludeOrderedParamsDict = _TckgenIncludeOrderedParamsDictNoTag | TckgenIncludeOrderedParamsDictTagged


_TckgenVariousString1ParamsDictNoTag = typing.TypedDict('_TckgenVariousString1ParamsDictNoTag', {
    "obj": str,
})
TckgenVariousString1ParamsDictTagged = typing.TypedDict('TckgenVariousString1ParamsDictTagged', {
    "@type": typing.Literal["VariousString_1"],
    "obj": str,
})
TckgenVariousString1ParamsDict = _TckgenVariousString1ParamsDictNoTag | TckgenVariousString1ParamsDictTagged


_TckgenVariousFile1ParamsDictNoTag = typing.TypedDict('_TckgenVariousFile1ParamsDictNoTag', {
    "obj": InputPathType,
})
TckgenVariousFile1ParamsDictTagged = typing.TypedDict('TckgenVariousFile1ParamsDictTagged', {
    "@type": typing.Literal["VariousFile_1"],
    "obj": InputPathType,
})
TckgenVariousFile1ParamsDict = _TckgenVariousFile1ParamsDictNoTag | TckgenVariousFile1ParamsDictTagged


_TckgenExcludeParamsDictNoTag = typing.TypedDict('_TckgenExcludeParamsDictNoTag', {
    "spec": typing.Union[TckgenVariousString1ParamsDictTagged, TckgenVariousFile1ParamsDictTagged],
})
TckgenExcludeParamsDictTagged = typing.TypedDict('TckgenExcludeParamsDictTagged', {
    "@type": typing.Literal["exclude"],
    "spec": typing.Union[TckgenVariousString1ParamsDictTagged, TckgenVariousFile1ParamsDictTagged],
})
TckgenExcludeParamsDict = _TckgenExcludeParamsDictNoTag | TckgenExcludeParamsDictTagged


_TckgenVariousString2ParamsDictNoTag = typing.TypedDict('_TckgenVariousString2ParamsDictNoTag', {
    "obj": str,
})
TckgenVariousString2ParamsDictTagged = typing.TypedDict('TckgenVariousString2ParamsDictTagged', {
    "@type": typing.Literal["VariousString_2"],
    "obj": str,
})
TckgenVariousString2ParamsDict = _TckgenVariousString2ParamsDictNoTag | TckgenVariousString2ParamsDictTagged


_TckgenVariousFile2ParamsDictNoTag = typing.TypedDict('_TckgenVariousFile2ParamsDictNoTag', {
    "obj": InputPathType,
})
TckgenVariousFile2ParamsDictTagged = typing.TypedDict('TckgenVariousFile2ParamsDictTagged', {
    "@type": typing.Literal["VariousFile_2"],
    "obj": InputPathType,
})
TckgenVariousFile2ParamsDict = _TckgenVariousFile2ParamsDictNoTag | TckgenVariousFile2ParamsDictTagged


_TckgenMaskParamsDictNoTag = typing.TypedDict('_TckgenMaskParamsDictNoTag', {
    "spec": typing.Union[TckgenVariousString2ParamsDictTagged, TckgenVariousFile2ParamsDictTagged],
})
TckgenMaskParamsDictTagged = typing.TypedDict('TckgenMaskParamsDictTagged', {
    "@type": typing.Literal["mask"],
    "spec": typing.Union[TckgenVariousString2ParamsDictTagged, TckgenVariousFile2ParamsDictTagged],
})
TckgenMaskParamsDict = _TckgenMaskParamsDictNoTag | TckgenMaskParamsDictTagged


_TckgenFslgradParamsDictNoTag = typing.TypedDict('_TckgenFslgradParamsDictNoTag', {
    "bvecs": InputPathType,
    "bvals": InputPathType,
})
TckgenFslgradParamsDictTagged = typing.TypedDict('TckgenFslgradParamsDictTagged', {
    "@type": typing.Literal["fslgrad"],
    "bvecs": InputPathType,
    "bvals": InputPathType,
})
TckgenFslgradParamsDict = _TckgenFslgradParamsDictNoTag | TckgenFslgradParamsDictTagged


_TckgenConfigParamsDictNoTag = typing.TypedDict('_TckgenConfigParamsDictNoTag', {
    "key": str,
    "value": str,
})
TckgenConfigParamsDictTagged = typing.TypedDict('TckgenConfigParamsDictTagged', {
    "@type": typing.Literal["config"],
    "key": str,
    "value": str,
})
TckgenConfigParamsDict = _TckgenConfigParamsDictNoTag | TckgenConfigParamsDictTagged


_TckgenParamsDictNoTag = typing.TypedDict('_TckgenParamsDictNoTag', {
    "algorithm": typing.NotRequired[str | None],
    "select": typing.NotRequired[int | None],
    "step": typing.NotRequired[float | None],
    "angle": typing.NotRequired[float | None],
    "minlength": typing.NotRequired[float | None],
    "maxlength": typing.NotRequired[float | None],
    "cutoff": typing.NotRequired[float | None],
    "trials": typing.NotRequired[int | None],
    "noprecomputed": bool,
    "rk4": bool,
    "stop": bool,
    "downsample": typing.NotRequired[int | None],
    "seed_image": typing.NotRequired[list[TckgenSeedImageParamsDict] | None],
    "seed_sphere": typing.NotRequired[list[TckgenSeedSphereParamsDict] | None],
    "seed_random_per_voxel": typing.NotRequired[list[TckgenSeedRandomPerVoxelParamsDict] | None],
    "seed_grid_per_voxel": typing.NotRequired[list[TckgenSeedGridPerVoxelParamsDict] | None],
    "seed_rejection": typing.NotRequired[list[TckgenSeedRejectionParamsDict] | None],
    "seed_gmwmi": typing.NotRequired[list[TckgenSeedGmwmiParamsDict] | None],
    "seed_dynamic": typing.NotRequired[InputPathType | None],
    "seeds": typing.NotRequired[int | None],
    "max_attempts_per_seed": typing.NotRequired[int | None],
    "seed_cutoff": typing.NotRequired[float | None],
    "seed_unidirectional": bool,
    "seed_direction": typing.NotRequired[list[float] | None],
    "output_seeds": typing.NotRequired[str | None],
    "include": typing.NotRequired[list[TckgenIncludeParamsDict] | None],
    "include_ordered": typing.NotRequired[list[TckgenIncludeOrderedParamsDict] | None],
    "exclude": typing.NotRequired[list[TckgenExcludeParamsDict] | None],
    "mask": typing.NotRequired[list[TckgenMaskParamsDict] | None],
    "act": typing.NotRequired[InputPathType | None],
    "backtrack": bool,
    "crop_at_gmwmi": bool,
    "power": typing.NotRequired[float | None],
    "samples": typing.NotRequired[int | None],
    "grad": typing.NotRequired[InputPathType | None],
    "fslgrad": typing.NotRequired[TckgenFslgradParamsDict | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[TckgenConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "source": InputPathType,
    "tracks": str,
})
TckgenParamsDictTagged = typing.TypedDict('TckgenParamsDictTagged', {
    "@type": typing.Literal["mrtrix/tckgen"],
    "algorithm": typing.NotRequired[str | None],
    "select": typing.NotRequired[int | None],
    "step": typing.NotRequired[float | None],
    "angle": typing.NotRequired[float | None],
    "minlength": typing.NotRequired[float | None],
    "maxlength": typing.NotRequired[float | None],
    "cutoff": typing.NotRequired[float | None],
    "trials": typing.NotRequired[int | None],
    "noprecomputed": bool,
    "rk4": bool,
    "stop": bool,
    "downsample": typing.NotRequired[int | None],
    "seed_image": typing.NotRequired[list[TckgenSeedImageParamsDict] | None],
    "seed_sphere": typing.NotRequired[list[TckgenSeedSphereParamsDict] | None],
    "seed_random_per_voxel": typing.NotRequired[list[TckgenSeedRandomPerVoxelParamsDict] | None],
    "seed_grid_per_voxel": typing.NotRequired[list[TckgenSeedGridPerVoxelParamsDict] | None],
    "seed_rejection": typing.NotRequired[list[TckgenSeedRejectionParamsDict] | None],
    "seed_gmwmi": typing.NotRequired[list[TckgenSeedGmwmiParamsDict] | None],
    "seed_dynamic": typing.NotRequired[InputPathType | None],
    "seeds": typing.NotRequired[int | None],
    "max_attempts_per_seed": typing.NotRequired[int | None],
    "seed_cutoff": typing.NotRequired[float | None],
    "seed_unidirectional": bool,
    "seed_direction": typing.NotRequired[list[float] | None],
    "output_seeds": typing.NotRequired[str | None],
    "include": typing.NotRequired[list[TckgenIncludeParamsDict] | None],
    "include_ordered": typing.NotRequired[list[TckgenIncludeOrderedParamsDict] | None],
    "exclude": typing.NotRequired[list[TckgenExcludeParamsDict] | None],
    "mask": typing.NotRequired[list[TckgenMaskParamsDict] | None],
    "act": typing.NotRequired[InputPathType | None],
    "backtrack": bool,
    "crop_at_gmwmi": bool,
    "power": typing.NotRequired[float | None],
    "samples": typing.NotRequired[int | None],
    "grad": typing.NotRequired[InputPathType | None],
    "fslgrad": typing.NotRequired[TckgenFslgradParamsDict | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[TckgenConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "source": InputPathType,
    "tracks": str,
})
TckgenParamsDict = _TckgenParamsDictNoTag | TckgenParamsDictTagged


def tckgen_spec_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString": tckgen_various_string_cargs,
        "VariousFile": tckgen_various_file_cargs,
    }.get(t)


def tckgen_spec_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString": tckgen_various_string_validate,
        "VariousFile": tckgen_various_file_validate,
    }.get(t)


def tckgen_spec_cargs_dyn_fn_(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString_1": tckgen_various_string_1_cargs,
        "VariousFile_1": tckgen_various_file_1_cargs,
    }.get(t)


def tckgen_spec_validate_dyn_fn_(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString_1": tckgen_various_string_1_validate,
        "VariousFile_1": tckgen_various_file_1_validate,
    }.get(t)


def tckgen_spec_cargs_dyn_fn_2(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString_2": tckgen_various_string_2_cargs,
        "VariousFile_2": tckgen_various_file_2_cargs,
    }.get(t)


def tckgen_spec_validate_dyn_fn_2(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString_2": tckgen_various_string_2_validate,
        "VariousFile_2": tckgen_various_file_2_validate,
    }.get(t)


def tckgen_seed_image(
    image: InputPathType,
) -> TckgenSeedImageParamsDictTagged:
    """
    Build parameters.
    
    Args:
        image: seed streamlines entirely at random within a mask image.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "seed_image",
        "image": image,
    }
    return params


def tckgen_seed_image_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenSeedImageParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("image", None) is None:
        raise StyxValidationError("`image` must not be None")
    if not isinstance(params["image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `InputPathType`')


def tckgen_seed_image_cargs(
    params: TckgenSeedImageParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-seed_image")
    cargs.append(execution.input_file(params.get("image", None)))
    return cargs


def tckgen_seed_sphere(
    spec: list[float],
) -> TckgenSeedSphereParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec: spherical seed as four comma-separated values (XYZ position and\
            radius).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "seed_sphere",
        "spec": spec,
    }
    return params


def tckgen_seed_sphere_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenSeedSphereParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec", None) is None:
        raise StyxValidationError("`spec` must not be None")
    if not isinstance(params["spec"], list):
        raise StyxValidationError(f'`spec` has the wrong type: Received `{type(params.get("spec", None))}` expected `list[float]`')
    for e in params["spec"]:
        if not isinstance(e, (float, int)):
            raise StyxValidationError(f'`spec` has the wrong type: Received `{type(params.get("spec", None))}` expected `list[float]`')


def tckgen_seed_sphere_cargs(
    params: TckgenSeedSphereParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-seed_sphere")
    cargs.append(",".join(map(str, params.get("spec", None))))
    return cargs


def tckgen_seed_random_per_voxel(
    image: InputPathType,
    num_per_voxel: int,
) -> TckgenSeedRandomPerVoxelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        image: seed a fixed number of streamlines per voxel in a mask image;\
            random placement of seeds in each voxel.
        num_per_voxel: seed a fixed number of streamlines per voxel in a mask\
            image; random placement of seeds in each voxel.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "seed_random_per_voxel",
        "image": image,
        "num_per_voxel": num_per_voxel,
    }
    return params


def tckgen_seed_random_per_voxel_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenSeedRandomPerVoxelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("image", None) is None:
        raise StyxValidationError("`image` must not be None")
    if not isinstance(params["image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `InputPathType`')
    if params.get("num_per_voxel", None) is None:
        raise StyxValidationError("`num_per_voxel` must not be None")
    if not isinstance(params["num_per_voxel"], int):
        raise StyxValidationError(f'`num_per_voxel` has the wrong type: Received `{type(params.get("num_per_voxel", None))}` expected `int`')


def tckgen_seed_random_per_voxel_cargs(
    params: TckgenSeedRandomPerVoxelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-seed_random_per_voxel")
    cargs.append(execution.input_file(params.get("image", None)))
    cargs.append(str(params.get("num_per_voxel", None)))
    return cargs


def tckgen_seed_grid_per_voxel(
    image: InputPathType,
    grid_size: int,
) -> TckgenSeedGridPerVoxelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        image: seed a fixed number of streamlines per voxel in a mask image;\
            place seeds on a 3D mesh grid (grid_size argument is per axis; so a\
            grid_size of 3 results in 27 seeds per voxel).
        grid_size: seed a fixed number of streamlines per voxel in a mask\
            image; place seeds on a 3D mesh grid (grid_size argument is per axis;\
            so a grid_size of 3 results in 27 seeds per voxel).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "seed_grid_per_voxel",
        "image": image,
        "grid_size": grid_size,
    }
    return params


def tckgen_seed_grid_per_voxel_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenSeedGridPerVoxelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("image", None) is None:
        raise StyxValidationError("`image` must not be None")
    if not isinstance(params["image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `InputPathType`')
    if params.get("grid_size", None) is None:
        raise StyxValidationError("`grid_size` must not be None")
    if not isinstance(params["grid_size"], int):
        raise StyxValidationError(f'`grid_size` has the wrong type: Received `{type(params.get("grid_size", None))}` expected `int`')


def tckgen_seed_grid_per_voxel_cargs(
    params: TckgenSeedGridPerVoxelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-seed_grid_per_voxel")
    cargs.append(execution.input_file(params.get("image", None)))
    cargs.append(str(params.get("grid_size", None)))
    return cargs


def tckgen_seed_rejection(
    image: InputPathType,
) -> TckgenSeedRejectionParamsDictTagged:
    """
    Build parameters.
    
    Args:
        image: seed from an image using rejection sampling (higher values =\
            more probable to seed from).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "seed_rejection",
        "image": image,
    }
    return params


def tckgen_seed_rejection_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenSeedRejectionParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("image", None) is None:
        raise StyxValidationError("`image` must not be None")
    if not isinstance(params["image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `InputPathType`')


def tckgen_seed_rejection_cargs(
    params: TckgenSeedRejectionParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-seed_rejection")
    cargs.append(execution.input_file(params.get("image", None)))
    return cargs


def tckgen_seed_gmwmi(
    image: InputPathType,
) -> TckgenSeedGmwmiParamsDictTagged:
    """
    Build parameters.
    
    Args:
        image: seed from the grey matter - white matter interface (only valid\
            if using ACT framework). Input image should be a 3D seeding volume;\
            seeds drawn within this image will be optimised to the interface using\
            the 5TT image provided using the -act option.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "seed_gmwmi",
        "image": image,
    }
    return params


def tckgen_seed_gmwmi_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenSeedGmwmiParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("image", None) is None:
        raise StyxValidationError("`image` must not be None")
    if not isinstance(params["image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `InputPathType`')


def tckgen_seed_gmwmi_cargs(
    params: TckgenSeedGmwmiParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-seed_gmwmi")
    cargs.append(execution.input_file(params.get("image", None)))
    return cargs


def tckgen_various_string(
    obj: str,
) -> TckgenVariousStringParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString",
        "obj": obj,
    }
    return params


def tckgen_various_string_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenVariousStringParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def tckgen_various_string_cargs(
    params: TckgenVariousStringParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def tckgen_various_file(
    obj: InputPathType,
) -> TckgenVariousFileParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile",
        "obj": obj,
    }
    return params


def tckgen_various_file_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenVariousFileParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def tckgen_various_file_cargs(
    params: TckgenVariousFileParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def tckgen_include(
    spec: typing.Union[TckgenVariousStringParamsDictTagged, TckgenVariousFileParamsDictTagged],
) -> TckgenIncludeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec: specify an inclusion region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius).\
            Streamlines must traverse ALL inclusion regions to be accepted.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "include",
        "spec": spec,
    }
    return params


def tckgen_include_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenIncludeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec", None) is None:
        raise StyxValidationError("`spec` must not be None")
    if not isinstance(params["spec"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["spec"])}\'')
    if "@type" not in params["spec"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["spec"]["@type"] not in ["VariousString", "VariousFile"]:
        raise StyxValidationError("Parameter `spec`s `@type` must be one of [\"VariousString\", \"VariousFile\"]")
    tckgen_spec_validate_dyn_fn(params["spec"]["@type"])(params["spec"])


def tckgen_include_cargs(
    params: TckgenIncludeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-include")
    cargs.extend(tckgen_spec_cargs_dyn_fn(params.get("spec", None)["@type"])(params.get("spec", None), execution))
    return cargs


def tckgen_include_ordered(
    image: str,
) -> TckgenIncludeOrderedParamsDictTagged:
    """
    Build parameters.
    
    Args:
        image: specify an inclusion region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius).\
            Streamlines must traverse ALL inclusion_ordered regions in the order\
            they are specified in order to be accepted.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "include_ordered",
        "image": image,
    }
    return params


def tckgen_include_ordered_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenIncludeOrderedParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("image", None) is None:
        raise StyxValidationError("`image` must not be None")
    if not isinstance(params["image"], str):
        raise StyxValidationError(f'`image` has the wrong type: Received `{type(params.get("image", None))}` expected `str`')


def tckgen_include_ordered_cargs(
    params: TckgenIncludeOrderedParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-include_ordered")
    cargs.append(params.get("image", None))
    return cargs


def tckgen_various_string_1(
    obj: str,
) -> TckgenVariousString1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString_1",
        "obj": obj,
    }
    return params


def tckgen_various_string_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenVariousString1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def tckgen_various_string_1_cargs(
    params: TckgenVariousString1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def tckgen_various_file_1(
    obj: InputPathType,
) -> TckgenVariousFile1ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile_1",
        "obj": obj,
    }
    return params


def tckgen_various_file_1_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenVariousFile1ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def tckgen_various_file_1_cargs(
    params: TckgenVariousFile1ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def tckgen_exclude(
    spec: typing.Union[TckgenVariousString1ParamsDictTagged, TckgenVariousFile1ParamsDictTagged],
) -> TckgenExcludeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec: specify an exclusion region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius).\
            Streamlines that enter ANY exclude region will be discarded.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "exclude",
        "spec": spec,
    }
    return params


def tckgen_exclude_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenExcludeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec", None) is None:
        raise StyxValidationError("`spec` must not be None")
    if not isinstance(params["spec"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["spec"])}\'')
    if "@type" not in params["spec"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["spec"]["@type"] not in ["VariousString_1", "VariousFile_1"]:
        raise StyxValidationError("Parameter `spec`s `@type` must be one of [\"VariousString_1\", \"VariousFile_1\"]")
    tckgen_spec_validate_dyn_fn_(params["spec"]["@type"])(params["spec"])


def tckgen_exclude_cargs(
    params: TckgenExcludeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-exclude")
    cargs.extend(tckgen_spec_cargs_dyn_fn_(params.get("spec", None)["@type"])(params.get("spec", None), execution))
    return cargs


def tckgen_various_string_2(
    obj: str,
) -> TckgenVariousString2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString_2",
        "obj": obj,
    }
    return params


def tckgen_various_string_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenVariousString2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def tckgen_various_string_2_cargs(
    params: TckgenVariousString2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def tckgen_various_file_2(
    obj: InputPathType,
) -> TckgenVariousFile2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile_2",
        "obj": obj,
    }
    return params


def tckgen_various_file_2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenVariousFile2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def tckgen_various_file_2_cargs(
    params: TckgenVariousFile2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def tckgen_mask(
    spec: typing.Union[TckgenVariousString2ParamsDictTagged, TckgenVariousFile2ParamsDictTagged],
) -> TckgenMaskParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec: specify a masking region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius). If\
            defined, streamlines exiting the mask will be truncated.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mask",
        "spec": spec,
    }
    return params


def tckgen_mask_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenMaskParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec", None) is None:
        raise StyxValidationError("`spec` must not be None")
    if not isinstance(params["spec"], dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params["spec"])}\'')
    if "@type" not in params["spec"]:
        raise StyxValidationError("Params object is missing `@type`")
    if params["spec"]["@type"] not in ["VariousString_2", "VariousFile_2"]:
        raise StyxValidationError("Parameter `spec`s `@type` must be one of [\"VariousString_2\", \"VariousFile_2\"]")
    tckgen_spec_validate_dyn_fn_2(params["spec"]["@type"])(params["spec"])


def tckgen_mask_cargs(
    params: TckgenMaskParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-mask")
    cargs.extend(tckgen_spec_cargs_dyn_fn_2(params.get("spec", None)["@type"])(params.get("spec", None), execution))
    return cargs


def tckgen_fslgrad(
    bvecs: InputPathType,
    bvals: InputPathType,
) -> TckgenFslgradParamsDictTagged:
    """
    Build parameters.
    
    Args:
        bvecs: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
        bvals: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fslgrad",
        "bvecs": bvecs,
        "bvals": bvals,
    }
    return params


def tckgen_fslgrad_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenFslgradParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("bvecs", None) is None:
        raise StyxValidationError("`bvecs` must not be None")
    if not isinstance(params["bvecs"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvecs` has the wrong type: Received `{type(params.get("bvecs", None))}` expected `InputPathType`')
    if params.get("bvals", None) is None:
        raise StyxValidationError("`bvals` must not be None")
    if not isinstance(params["bvals"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvals` has the wrong type: Received `{type(params.get("bvals", None))}` expected `InputPathType`')


def tckgen_fslgrad_cargs(
    params: TckgenFslgradParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-fslgrad")
    cargs.append(execution.input_file(params.get("bvecs", None)))
    cargs.append(execution.input_file(params.get("bvals", None)))
    return cargs


def tckgen_config(
    key: str,
    value: str,
) -> TckgenConfigParamsDictTagged:
    """
    Build parameters.
    
    Args:
        key: temporarily set the value of an MRtrix config file entry.
        value: temporarily set the value of an MRtrix config file entry.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "config",
        "key": key,
        "value": value,
    }
    return params


def tckgen_config_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenConfigParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("key", None) is None:
        raise StyxValidationError("`key` must not be None")
    if not isinstance(params["key"], str):
        raise StyxValidationError(f'`key` has the wrong type: Received `{type(params.get("key", None))}` expected `str`')
    if params.get("value", None) is None:
        raise StyxValidationError("`value` must not be None")
    if not isinstance(params["value"], str):
        raise StyxValidationError(f'`value` has the wrong type: Received `{type(params.get("value", None))}` expected `str`')


def tckgen_config_cargs(
    params: TckgenConfigParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-config")
    cargs.append(params.get("key", None))
    cargs.append(params.get("value", None))
    return cargs


class TckgenOutputs(typing.NamedTuple):
    """
    Output object returned when calling `TckgenParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    tracks: OutputPathType
    """the output file containing the tracks generated."""
    output_seeds: OutputPathType | None
    """output the seed location of all successful streamlines to a file """


def tckgen_params(
    source: InputPathType,
    tracks: str,
    algorithm: str | None = None,
    select_: int | None = None,
    step: float | None = None,
    angle: float | None = None,
    minlength: float | None = None,
    maxlength: float | None = None,
    cutoff: float | None = None,
    trials: int | None = None,
    noprecomputed: bool = False,
    rk4: bool = False,
    stop: bool = False,
    downsample: int | None = None,
    seed_image: list[TckgenSeedImageParamsDict] | None = None,
    seed_sphere: list[TckgenSeedSphereParamsDict] | None = None,
    seed_random_per_voxel: list[TckgenSeedRandomPerVoxelParamsDict] | None = None,
    seed_grid_per_voxel: list[TckgenSeedGridPerVoxelParamsDict] | None = None,
    seed_rejection: list[TckgenSeedRejectionParamsDict] | None = None,
    seed_gmwmi: list[TckgenSeedGmwmiParamsDict] | None = None,
    seed_dynamic: InputPathType | None = None,
    seeds: int | None = None,
    max_attempts_per_seed: int | None = None,
    seed_cutoff: float | None = None,
    seed_unidirectional: bool = False,
    seed_direction: list[float] | None = None,
    output_seeds: str | None = None,
    include: list[TckgenIncludeParamsDict] | None = None,
    include_ordered: list[TckgenIncludeOrderedParamsDict] | None = None,
    exclude: list[TckgenExcludeParamsDict] | None = None,
    mask: list[TckgenMaskParamsDict] | None = None,
    act: InputPathType | None = None,
    backtrack: bool = False,
    crop_at_gmwmi: bool = False,
    power: float | None = None,
    samples: int | None = None,
    grad: InputPathType | None = None,
    fslgrad: TckgenFslgradParamsDict | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[TckgenConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
) -> TckgenParamsDictTagged:
    """
    Build parameters.
    
    Args:
        source: The image containing the source data. The type of image data\
            required depends on the algorithm used (see Description section).
        tracks: the output file containing the tracks generated.
        algorithm: specify the tractography algorithm to use. Valid choices\
            are: FACT, iFOD1, iFOD2, Nulldist1, Nulldist2, SD_Stream, Seedtest,\
            Tensor_Det, Tensor_Prob (default: iFOD2).
        select_: set the desired number of streamlines to be selected by\
            tckgen, after all selection criteria have been applied (i.e.\
            inclusion/exclusion ROIs, min/max length, etc). tckgen will keep\
            seeding streamlines until this number of streamlines have been\
            selected, or the maximum allowed number of seeds has been exceeded (see\
            -seeds option). By default, 5000 streamlines are to be selected. Set to\
            zero to disable, which will result in streamlines being seeded until\
            the number specified by -seeds has been reached.
        step: set the step size of the algorithm in mm (defaults: for\
            first-order algorithms, 0.1 x voxelsize; if using RK4, 0.25 x\
            voxelsize; for iFOD2: 0.5 x voxelsize).
        angle: set the maximum angle in degrees between successive steps\
            (defaults: 60 for deterministic algorithms; 15 for iFOD1 / nulldist1;\
            45 for iFOD2 / nulldist2).
        minlength: set the minimum length of any track in mm (defaults: without\
            ACT, 5 x voxelsize; with ACT, 2 x voxelsize).
        maxlength: set the maximum length of any track in mm (default: 100 x\
            voxelsize).
        cutoff: set the FOD amplitude / fixel size / tensor FA cutoff for\
            terminating tracks (defaults: 0.1 for FOD-based algorithms; 0.1 for\
            fixel-based algorithms; 0.1 for tensor-based algorithms; threshold\
            multiplied by 0.5 when using ACT).
        trials: set the maximum number of sampling trials at each point (only\
            used for iFOD1 / iFOD2) (default: 1000).
        noprecomputed: do NOT pre-compute legendre polynomial values. Warning:\
            this will slow down the algorithm by a factor of approximately 4.
        rk4: use 4th-order Runge-Kutta integration (slower, but eliminates\
            curvature overshoot in 1st-order deterministic methods).
        stop: stop propagating a streamline once it has traversed all include\
            regions.
        downsample: downsample the generated streamlines to reduce output file\
            size (default is (samples-1) for iFOD2, no downsampling for all other\
            algorithms).
        seed_image: seed streamlines entirely at random within a mask image.
        seed_sphere: spherical seed as four comma-separated values (XYZ\
            position and radius).
        seed_random_per_voxel: seed a fixed number of streamlines per voxel in\
            a mask image; random placement of seeds in each voxel.
        seed_grid_per_voxel: seed a fixed number of streamlines per voxel in a\
            mask image; place seeds on a 3D mesh grid (grid_size argument is per\
            axis; so a grid_size of 3 results in 27 seeds per voxel).
        seed_rejection: seed from an image using rejection sampling (higher\
            values = more probable to seed from).
        seed_gmwmi: seed from the grey matter - white matter interface (only\
            valid if using ACT framework). Input image should be a 3D seeding\
            volume; seeds drawn within this image will be optimised to the\
            interface using the 5TT image provided using the -act option.
        seed_dynamic: determine seed points dynamically using the SIFT model\
            (must not provide any other seeding mechanism). Note that while this\
            seeding mechanism improves the distribution of reconstructed\
            streamlines density, it should NOT be used as a substitute for the SIFT\
            method itself.
        seeds: set the number of seeds that tckgen will attempt to track from.\
            If this option is NOT provided, the default number of seeds is set to\
            1000 the number of selected streamlines. If -select is NOT also\
            specified, tckgen will continue tracking until this number of seeds has\
            been attempted. However, if -select is also specified, tckgen will stop\
            when the number of seeds attempted reaches the number specified here,\
            OR when the number of streamlines selected reaches the number requested\
            with the -select option. This can be used to prevent the program from\
            running indefinitely when no or very few streamlines can be found that\
            match the selection criteria. Setting this to zero will cause tckgen to\
            keep attempting seeds until the number specified by -select has been\
            reached.
        max_attempts_per_seed: set the maximum number of times that the\
            tracking algorithm should attempt to find an appropriate tracking\
            direction from a given seed point. This should be set high enough to\
            ensure that an actual plausible seed point is not discarded prematurely\
            as being unable to initiate tracking from. Higher settings may affect\
            performance if many seeds are genuinely impossible to track from, as\
            many attempts will still be made in vain for such seeds. (default:\
            1000).
        seed_cutoff: set the minimum FA or FOD amplitude for seeding tracks\
            (default is the same as the normal -cutoff).
        seed_unidirectional: track from the seed point in one direction only\
            (default is to track in both directions).
        seed_direction: specify a seeding direction for the tracking (this\
            should be supplied as a vector of 3 comma-separated values.
        output_seeds: output the seed location of all successful streamlines to\
            a file.
        include: specify an inclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion regions to be\
            accepted.
        include_ordered: specify an inclusion region of interest, as either a\
            binary mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion_ordered regions\
            in the order they are specified in order to be accepted.
        exclude: specify an exclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines that enter ANY exclude region will be\
            discarded.
        mask: specify a masking region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius). If\
            defined, streamlines exiting the mask will be truncated.
        act: use the Anatomically-Constrained Tractography framework during\
            tracking; provided image must be in the 5TT (five-tissue-type) format.
        backtrack: allow tracks to be truncated and re-tracked if a poor\
            structural termination is encountered.
        crop_at_gmwmi: crop streamline endpoints more precisely as they cross\
            the GM-WM interface.
        power: raise the FOD to the power specified (defaults are: 1.0 for\
            iFOD1; 1.0/nsamples for iFOD2).
        samples: set the number of FOD samples to take per step (Default: 4).
        grad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in a text file. This should be supplied as a 4xN text file\
            with each line is in the format [ X Y Z b ], where [ X Y Z ] describe\
            the direction of the applied gradient, and b gives the b-value in units\
            of s/mm^2. If a diffusion gradient scheme is present in the input image\
            header, the data provided with this option will be instead used.
        fslgrad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mrtrix/tckgen",
        "noprecomputed": noprecomputed,
        "rk4": rk4,
        "stop": stop,
        "seed_unidirectional": seed_unidirectional,
        "backtrack": backtrack,
        "crop_at_gmwmi": crop_at_gmwmi,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help_,
        "version": version,
        "source": source,
        "tracks": tracks,
    }
    if algorithm is not None:
        params["algorithm"] = algorithm
    if select_ is not None:
        params["select"] = select_
    if step is not None:
        params["step"] = step
    if angle is not None:
        params["angle"] = angle
    if minlength is not None:
        params["minlength"] = minlength
    if maxlength is not None:
        params["maxlength"] = maxlength
    if cutoff is not None:
        params["cutoff"] = cutoff
    if trials is not None:
        params["trials"] = trials
    if downsample is not None:
        params["downsample"] = downsample
    if seed_image is not None:
        params["seed_image"] = seed_image
    if seed_sphere is not None:
        params["seed_sphere"] = seed_sphere
    if seed_random_per_voxel is not None:
        params["seed_random_per_voxel"] = seed_random_per_voxel
    if seed_grid_per_voxel is not None:
        params["seed_grid_per_voxel"] = seed_grid_per_voxel
    if seed_rejection is not None:
        params["seed_rejection"] = seed_rejection
    if seed_gmwmi is not None:
        params["seed_gmwmi"] = seed_gmwmi
    if seed_dynamic is not None:
        params["seed_dynamic"] = seed_dynamic
    if seeds is not None:
        params["seeds"] = seeds
    if max_attempts_per_seed is not None:
        params["max_attempts_per_seed"] = max_attempts_per_seed
    if seed_cutoff is not None:
        params["seed_cutoff"] = seed_cutoff
    if seed_direction is not None:
        params["seed_direction"] = seed_direction
    if output_seeds is not None:
        params["output_seeds"] = output_seeds
    if include is not None:
        params["include"] = include
    if include_ordered is not None:
        params["include_ordered"] = include_ordered
    if exclude is not None:
        params["exclude"] = exclude
    if mask is not None:
        params["mask"] = mask
    if act is not None:
        params["act"] = act
    if power is not None:
        params["power"] = power
    if samples is not None:
        params["samples"] = samples
    if grad is not None:
        params["grad"] = grad
    if fslgrad is not None:
        params["fslgrad"] = fslgrad
    if nthreads is not None:
        params["nthreads"] = nthreads
    if config is not None:
        params["config"] = config
    return params


def tckgen_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TckgenParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("algorithm", None) is not None:
        if not isinstance(params["algorithm"], str):
            raise StyxValidationError(f'`algorithm` has the wrong type: Received `{type(params.get("algorithm", None))}` expected `str | None`')
    if params.get("select", None) is not None:
        if not isinstance(params["select"], int):
            raise StyxValidationError(f'`select` has the wrong type: Received `{type(params.get("select", None))}` expected `int | None`')
    if params.get("step", None) is not None:
        if not isinstance(params["step"], (float, int)):
            raise StyxValidationError(f'`step` has the wrong type: Received `{type(params.get("step", None))}` expected `float | None`')
    if params.get("angle", None) is not None:
        if not isinstance(params["angle"], (float, int)):
            raise StyxValidationError(f'`angle` has the wrong type: Received `{type(params.get("angle", None))}` expected `float | None`')
    if params.get("minlength", None) is not None:
        if not isinstance(params["minlength"], (float, int)):
            raise StyxValidationError(f'`minlength` has the wrong type: Received `{type(params.get("minlength", None))}` expected `float | None`')
    if params.get("maxlength", None) is not None:
        if not isinstance(params["maxlength"], (float, int)):
            raise StyxValidationError(f'`maxlength` has the wrong type: Received `{type(params.get("maxlength", None))}` expected `float | None`')
    if params.get("cutoff", None) is not None:
        if not isinstance(params["cutoff"], (float, int)):
            raise StyxValidationError(f'`cutoff` has the wrong type: Received `{type(params.get("cutoff", None))}` expected `float | None`')
    if params.get("trials", None) is not None:
        if not isinstance(params["trials"], int):
            raise StyxValidationError(f'`trials` has the wrong type: Received `{type(params.get("trials", None))}` expected `int | None`')
    if params.get("noprecomputed", False) is None:
        raise StyxValidationError("`noprecomputed` must not be None")
    if not isinstance(params["noprecomputed"], bool):
        raise StyxValidationError(f'`noprecomputed` has the wrong type: Received `{type(params.get("noprecomputed", False))}` expected `bool`')
    if params.get("rk4", False) is None:
        raise StyxValidationError("`rk4` must not be None")
    if not isinstance(params["rk4"], bool):
        raise StyxValidationError(f'`rk4` has the wrong type: Received `{type(params.get("rk4", False))}` expected `bool`')
    if params.get("stop", False) is None:
        raise StyxValidationError("`stop` must not be None")
    if not isinstance(params["stop"], bool):
        raise StyxValidationError(f'`stop` has the wrong type: Received `{type(params.get("stop", False))}` expected `bool`')
    if params.get("downsample", None) is not None:
        if not isinstance(params["downsample"], int):
            raise StyxValidationError(f'`downsample` has the wrong type: Received `{type(params.get("downsample", None))}` expected `int | None`')
    if params.get("seed_image", None) is not None:
        if not isinstance(params["seed_image"], list):
            raise StyxValidationError(f'`seed_image` has the wrong type: Received `{type(params.get("seed_image", None))}` expected `list[TckgenSeedImageParamsDict] | None`')
        for e in params["seed_image"]:
            tckgen_seed_image_validate(e)
    if params.get("seed_sphere", None) is not None:
        if not isinstance(params["seed_sphere"], list):
            raise StyxValidationError(f'`seed_sphere` has the wrong type: Received `{type(params.get("seed_sphere", None))}` expected `list[TckgenSeedSphereParamsDict] | None`')
        for e in params["seed_sphere"]:
            tckgen_seed_sphere_validate(e)
    if params.get("seed_random_per_voxel", None) is not None:
        if not isinstance(params["seed_random_per_voxel"], list):
            raise StyxValidationError(f'`seed_random_per_voxel` has the wrong type: Received `{type(params.get("seed_random_per_voxel", None))}` expected `list[TckgenSeedRandomPerVoxelParamsDict] | None`')
        for e in params["seed_random_per_voxel"]:
            tckgen_seed_random_per_voxel_validate(e)
    if params.get("seed_grid_per_voxel", None) is not None:
        if not isinstance(params["seed_grid_per_voxel"], list):
            raise StyxValidationError(f'`seed_grid_per_voxel` has the wrong type: Received `{type(params.get("seed_grid_per_voxel", None))}` expected `list[TckgenSeedGridPerVoxelParamsDict] | None`')
        for e in params["seed_grid_per_voxel"]:
            tckgen_seed_grid_per_voxel_validate(e)
    if params.get("seed_rejection", None) is not None:
        if not isinstance(params["seed_rejection"], list):
            raise StyxValidationError(f'`seed_rejection` has the wrong type: Received `{type(params.get("seed_rejection", None))}` expected `list[TckgenSeedRejectionParamsDict] | None`')
        for e in params["seed_rejection"]:
            tckgen_seed_rejection_validate(e)
    if params.get("seed_gmwmi", None) is not None:
        if not isinstance(params["seed_gmwmi"], list):
            raise StyxValidationError(f'`seed_gmwmi` has the wrong type: Received `{type(params.get("seed_gmwmi", None))}` expected `list[TckgenSeedGmwmiParamsDict] | None`')
        for e in params["seed_gmwmi"]:
            tckgen_seed_gmwmi_validate(e)
    if params.get("seed_dynamic", None) is not None:
        if not isinstance(params["seed_dynamic"], (pathlib.Path, str)):
            raise StyxValidationError(f'`seed_dynamic` has the wrong type: Received `{type(params.get("seed_dynamic", None))}` expected `InputPathType | None`')
    if params.get("seeds", None) is not None:
        if not isinstance(params["seeds"], int):
            raise StyxValidationError(f'`seeds` has the wrong type: Received `{type(params.get("seeds", None))}` expected `int | None`')
    if params.get("max_attempts_per_seed", None) is not None:
        if not isinstance(params["max_attempts_per_seed"], int):
            raise StyxValidationError(f'`max_attempts_per_seed` has the wrong type: Received `{type(params.get("max_attempts_per_seed", None))}` expected `int | None`')
    if params.get("seed_cutoff", None) is not None:
        if not isinstance(params["seed_cutoff"], (float, int)):
            raise StyxValidationError(f'`seed_cutoff` has the wrong type: Received `{type(params.get("seed_cutoff", None))}` expected `float | None`')
    if params.get("seed_unidirectional", False) is None:
        raise StyxValidationError("`seed_unidirectional` must not be None")
    if not isinstance(params["seed_unidirectional"], bool):
        raise StyxValidationError(f'`seed_unidirectional` has the wrong type: Received `{type(params.get("seed_unidirectional", False))}` expected `bool`')
    if params.get("seed_direction", None) is not None:
        if not isinstance(params["seed_direction"], list):
            raise StyxValidationError(f'`seed_direction` has the wrong type: Received `{type(params.get("seed_direction", None))}` expected `list[float] | None`')
        for e in params["seed_direction"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`seed_direction` has the wrong type: Received `{type(params.get("seed_direction", None))}` expected `list[float] | None`')
    if params.get("output_seeds", None) is not None:
        if not isinstance(params["output_seeds"], str):
            raise StyxValidationError(f'`output_seeds` has the wrong type: Received `{type(params.get("output_seeds", None))}` expected `str | None`')
    if params.get("include", None) is not None:
        if not isinstance(params["include"], list):
            raise StyxValidationError(f'`include` has the wrong type: Received `{type(params.get("include", None))}` expected `list[TckgenIncludeParamsDict] | None`')
        for e in params["include"]:
            tckgen_include_validate(e)
    if params.get("include_ordered", None) is not None:
        if not isinstance(params["include_ordered"], list):
            raise StyxValidationError(f'`include_ordered` has the wrong type: Received `{type(params.get("include_ordered", None))}` expected `list[TckgenIncludeOrderedParamsDict] | None`')
        for e in params["include_ordered"]:
            tckgen_include_ordered_validate(e)
    if params.get("exclude", None) is not None:
        if not isinstance(params["exclude"], list):
            raise StyxValidationError(f'`exclude` has the wrong type: Received `{type(params.get("exclude", None))}` expected `list[TckgenExcludeParamsDict] | None`')
        for e in params["exclude"]:
            tckgen_exclude_validate(e)
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], list):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `list[TckgenMaskParamsDict] | None`')
        for e in params["mask"]:
            tckgen_mask_validate(e)
    if params.get("act", None) is not None:
        if not isinstance(params["act"], (pathlib.Path, str)):
            raise StyxValidationError(f'`act` has the wrong type: Received `{type(params.get("act", None))}` expected `InputPathType | None`')
    if params.get("backtrack", False) is None:
        raise StyxValidationError("`backtrack` must not be None")
    if not isinstance(params["backtrack"], bool):
        raise StyxValidationError(f'`backtrack` has the wrong type: Received `{type(params.get("backtrack", False))}` expected `bool`')
    if params.get("crop_at_gmwmi", False) is None:
        raise StyxValidationError("`crop_at_gmwmi` must not be None")
    if not isinstance(params["crop_at_gmwmi"], bool):
        raise StyxValidationError(f'`crop_at_gmwmi` has the wrong type: Received `{type(params.get("crop_at_gmwmi", False))}` expected `bool`')
    if params.get("power", None) is not None:
        if not isinstance(params["power"], (float, int)):
            raise StyxValidationError(f'`power` has the wrong type: Received `{type(params.get("power", None))}` expected `float | None`')
    if params.get("samples", None) is not None:
        if not isinstance(params["samples"], int):
            raise StyxValidationError(f'`samples` has the wrong type: Received `{type(params.get("samples", None))}` expected `int | None`')
    if params.get("grad", None) is not None:
        if not isinstance(params["grad"], (pathlib.Path, str)):
            raise StyxValidationError(f'`grad` has the wrong type: Received `{type(params.get("grad", None))}` expected `InputPathType | None`')
    if params.get("fslgrad", None) is not None:
        tckgen_fslgrad_validate(params["fslgrad"])
    if params.get("info", False) is None:
        raise StyxValidationError("`info` must not be None")
    if not isinstance(params["info"], bool):
        raise StyxValidationError(f'`info` has the wrong type: Received `{type(params.get("info", False))}` expected `bool`')
    if params.get("quiet", False) is None:
        raise StyxValidationError("`quiet` must not be None")
    if not isinstance(params["quiet"], bool):
        raise StyxValidationError(f'`quiet` has the wrong type: Received `{type(params.get("quiet", False))}` expected `bool`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("force", False) is None:
        raise StyxValidationError("`force` must not be None")
    if not isinstance(params["force"], bool):
        raise StyxValidationError(f'`force` has the wrong type: Received `{type(params.get("force", False))}` expected `bool`')
    if params.get("nthreads", None) is not None:
        if not isinstance(params["nthreads"], int):
            raise StyxValidationError(f'`nthreads` has the wrong type: Received `{type(params.get("nthreads", None))}` expected `int | None`')
    if params.get("config", None) is not None:
        if not isinstance(params["config"], list):
            raise StyxValidationError(f'`config` has the wrong type: Received `{type(params.get("config", None))}` expected `list[TckgenConfigParamsDict] | None`')
        for e in params["config"]:
            tckgen_config_validate(e)
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("source", None) is None:
        raise StyxValidationError("`source` must not be None")
    if not isinstance(params["source"], (pathlib.Path, str)):
        raise StyxValidationError(f'`source` has the wrong type: Received `{type(params.get("source", None))}` expected `InputPathType`')
    if params.get("tracks", None) is None:
        raise StyxValidationError("`tracks` must not be None")
    if not isinstance(params["tracks"], str):
        raise StyxValidationError(f'`tracks` has the wrong type: Received `{type(params.get("tracks", None))}` expected `str`')


def tckgen_cargs(
    params: TckgenParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("tckgen")
    if params.get("algorithm", None) is not None:
        cargs.extend([
            "-algorithm",
            params.get("algorithm", None)
        ])
    if params.get("select", None) is not None:
        cargs.extend([
            "-select",
            str(params.get("select", None))
        ])
    if params.get("step", None) is not None:
        cargs.extend([
            "-step",
            str(params.get("step", None))
        ])
    if params.get("angle", None) is not None:
        cargs.extend([
            "-angle",
            str(params.get("angle", None))
        ])
    if params.get("minlength", None) is not None:
        cargs.extend([
            "-minlength",
            str(params.get("minlength", None))
        ])
    if params.get("maxlength", None) is not None:
        cargs.extend([
            "-maxlength",
            str(params.get("maxlength", None))
        ])
    if params.get("cutoff", None) is not None:
        cargs.extend([
            "-cutoff",
            str(params.get("cutoff", None))
        ])
    if params.get("trials", None) is not None:
        cargs.extend([
            "-trials",
            str(params.get("trials", None))
        ])
    if params.get("noprecomputed", False):
        cargs.append("-noprecomputed")
    if params.get("rk4", False):
        cargs.append("-rk4")
    if params.get("stop", False):
        cargs.append("-stop")
    if params.get("downsample", None) is not None:
        cargs.extend([
            "-downsample",
            str(params.get("downsample", None))
        ])
    if params.get("seed_image", None) is not None:
        cargs.extend([a for c in [tckgen_seed_image_cargs(s, execution) for s in params.get("seed_image", None)] for a in c])
    if params.get("seed_sphere", None) is not None:
        cargs.extend([a for c in [tckgen_seed_sphere_cargs(s, execution) for s in params.get("seed_sphere", None)] for a in c])
    if params.get("seed_random_per_voxel", None) is not None:
        cargs.extend([a for c in [tckgen_seed_random_per_voxel_cargs(s, execution) for s in params.get("seed_random_per_voxel", None)] for a in c])
    if params.get("seed_grid_per_voxel", None) is not None:
        cargs.extend([a for c in [tckgen_seed_grid_per_voxel_cargs(s, execution) for s in params.get("seed_grid_per_voxel", None)] for a in c])
    if params.get("seed_rejection", None) is not None:
        cargs.extend([a for c in [tckgen_seed_rejection_cargs(s, execution) for s in params.get("seed_rejection", None)] for a in c])
    if params.get("seed_gmwmi", None) is not None:
        cargs.extend([a for c in [tckgen_seed_gmwmi_cargs(s, execution) for s in params.get("seed_gmwmi", None)] for a in c])
    if params.get("seed_dynamic", None) is not None:
        cargs.extend([
            "-seed_dynamic",
            execution.input_file(params.get("seed_dynamic", None))
        ])
    if params.get("seeds", None) is not None:
        cargs.extend([
            "-seeds",
            str(params.get("seeds", None))
        ])
    if params.get("max_attempts_per_seed", None) is not None:
        cargs.extend([
            "-max_attempts_per_seed",
            str(params.get("max_attempts_per_seed", None))
        ])
    if params.get("seed_cutoff", None) is not None:
        cargs.extend([
            "-seed_cutoff",
            str(params.get("seed_cutoff", None))
        ])
    if params.get("seed_unidirectional", False):
        cargs.append("-seed_unidirectional")
    if params.get("seed_direction", None) is not None:
        cargs.extend([
            "-seed_direction",
            ",".join(map(str, params.get("seed_direction", None)))
        ])
    if params.get("output_seeds", None) is not None:
        cargs.extend([
            "-output_seeds",
            params.get("output_seeds", None)
        ])
    if params.get("include", None) is not None:
        cargs.extend([a for c in [tckgen_include_cargs(s, execution) for s in params.get("include", None)] for a in c])
    if params.get("include_ordered", None) is not None:
        cargs.extend([a for c in [tckgen_include_ordered_cargs(s, execution) for s in params.get("include_ordered", None)] for a in c])
    if params.get("exclude", None) is not None:
        cargs.extend([a for c in [tckgen_exclude_cargs(s, execution) for s in params.get("exclude", None)] for a in c])
    if params.get("mask", None) is not None:
        cargs.extend([a for c in [tckgen_mask_cargs(s, execution) for s in params.get("mask", None)] for a in c])
    if params.get("act", None) is not None:
        cargs.extend([
            "-act",
            execution.input_file(params.get("act", None))
        ])
    if params.get("backtrack", False):
        cargs.append("-backtrack")
    if params.get("crop_at_gmwmi", False):
        cargs.append("-crop_at_gmwmi")
    if params.get("power", None) is not None:
        cargs.extend([
            "-power",
            str(params.get("power", None))
        ])
    if params.get("samples", None) is not None:
        cargs.extend([
            "-samples",
            str(params.get("samples", None))
        ])
    if params.get("grad", None) is not None:
        cargs.extend([
            "-grad",
            execution.input_file(params.get("grad", None))
        ])
    if params.get("fslgrad", None) is not None:
        cargs.extend(tckgen_fslgrad_cargs(params.get("fslgrad", None), execution))
    if params.get("info", False):
        cargs.append("-info")
    if params.get("quiet", False):
        cargs.append("-quiet")
    if params.get("debug", False):
        cargs.append("-debug")
    if params.get("force", False):
        cargs.append("-force")
    if params.get("nthreads", None) is not None:
        cargs.extend([
            "-nthreads",
            str(params.get("nthreads", None))
        ])
    if params.get("config", None) is not None:
        cargs.extend([a for c in [tckgen_config_cargs(s, execution) for s in params.get("config", None)] for a in c])
    if params.get("help", False):
        cargs.append("-help")
    if params.get("version", False):
        cargs.append("-version")
    cargs.append(execution.input_file(params.get("source", None)))
    cargs.append(params.get("tracks", None))
    return cargs


def tckgen_outputs(
    params: TckgenParamsDict,
    execution: Execution,
) -> TckgenOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = TckgenOutputs(
        root=execution.output_file("."),
        tracks=execution.output_file(params.get("tracks", None)),
        output_seeds=execution.output_file(params.get("output_seeds", None)) if (params.get("output_seeds") is not None) else None,
    )
    return ret


def tckgen_execute(
    params: TckgenParamsDict,
    runner: Runner | None = None,
) -> TckgenOutputs:
    """
    tckgen
    
    Perform streamlines tractography.
    
    By default, tckgen produces a fixed number of streamlines, by attempting to
    seed from new random locations until the target number of streamlines have
    been selected (in other words, after all inclusion & exclusion criteria have
    been applied), or the maximum number of seeds has been exceeded (by default,
    this is 1000 x the desired number of selected streamlines). Use the -select
    and/or -seeds options to modify as required. See also the Seeding options
    section for alternative seeding strategies.
    
    Below is a list of available tracking algorithms, the input image data that
    they require, and a brief description of their behaviour:
    
    - FACT: Fiber Assigned by Continuous Tracking. A deterministic algorithm
    that takes as input a 4D image, with 3xN volumes, where N is the maximum
    number of fiber orientations in a voxel. Each triplet of volumes represents
    a 3D vector corresponding to a fiber orientation; the length of the vector
    additionally indicates some measure of density or anisotropy. As streamlines
    move from one voxel to another, the fiber orientation most collinear with
    the streamline orientation is selected (i.e. there is no intra-voxel
    interpolation).
    
    - iFOD1: First-order Integration over Fiber Orientation Distributions. A
    probabilistic algorithm that takes as input a Fiber Orientation Distribution
    (FOD) image represented in the Spherical Harmonic (SH) basis. At each
    streamline step, random samples from the local (trilinear interpolated) FOD
    are taken. A streamline is more probable to follow orientations where the
    FOD amplitude is large; but it may also rarely traverse orientations with
    small FOD amplitude.
    
    - iFOD2 (default): Second-order Integration over Fiber Orientation
    Distributions. A probabilistic algorithm that takes as input a Fiber
    Orientation Distribution (FOD) image represented in the Spherical Harmonic
    (SH) basis. Candidate streamline paths (based on short curved "arcs") are
    drawn, and the underlying (trilinear-interpolated) FOD amplitudes along
    those arcs are sampled. A streamline is more probable to follow a path where
    the FOD amplitudes along that path are large; but it may also rarely
    traverse orientations where the FOD amplitudes are small, as long as the
    amplitude remains above the FOD amplitude threshold along the entire path.
    
    - NullDist1 / NullDist2: Null Distribution tracking algorithms. These
    probabilistic algorithms expect as input the same image that was used when
    invoking the corresponding algorithm for which the null distribution is
    sought. These algorithms generate streamlines based on random orientation
    samples; that is, no image information relating to fiber orientations is
    used, and streamlines trajectories are determined entirely from random
    sampling. The NullDist2 algorithm is designed to be used in conjunction with
    iFOD2; NullDist1 should be used in conjunction with any first-order
    algorithm.
    
    - SD_STREAM: Streamlines tractography based on Spherical Deconvolution (SD).
    A deterministic algorithm that takes as input a Fiber Orientation
    Distribution (FOD) image represented in the Spherical Harmonic (SH) basis.
    At each streamline step, the local (trilinear-interpolated) FOD is sampled,
    and from the current streamline tangent orientation, a Newton optimisation
    on the sphere is performed in order to locate the orientation of the nearest
    FOD amplitude peak.
    
    - SeedTest: A dummy streamlines algorithm used for testing streamline
    seeding mechanisms. Any image can be used as input; the image will not be
    used in any way. For each seed point generated by the seeding mechanism(s),
    a streamline containing a single point corresponding to that seed location
    will be written to the output track file.
    
    - Tensor_Det: A deterministic algorithm that takes as input a 4D
    diffusion-weighted image (DWI) series. At each streamline step, the
    diffusion tensor is fitted to the local (trilinear-interpolated) diffusion
    data, and the streamline trajectory is determined as the principal
    eigenvector of that tensor.
    
    - Tensor_Prob: A probabilistic algorithm that takes as input a 4D
    diffusion-weighted image (DWI) series. Within each image voxel, a residual
    bootstrap is performed to obtain a unique realisation of the DWI data in
    that voxel for each streamline. These data are then sampled via trilinear
    interpolation at each streamline step, the diffusion tensor model is fitted,
    and the streamline follows the orientation of the principal eigenvector of
    that tensor.
    
    Note that the behaviour of the -angle option varies slightly depending on
    the order of integration: for any first-order method, this angle corresponds
    to the deviation in streamline trajectory per step; for higher-order
    methods, this corresponds to the change in underlying fibre orientation
    between the start and end points of each step.
    
    References:
    
    References based on streamlines algorithm used:
    
    * FACT:
    Mori, S.; Crain, B. J.; Chacko, V. P. & van Zijl, P. C. M. Three-dimensional
    tracking of axonal projections in the brain by magnetic resonance imaging.
    Annals of Neurology, 1999, 45, 265-269
    
    * iFOD1 or SD_STREAM:
    Tournier, J.-D.; Calamante, F. & Connelly, A. MRtrix: Diffusion tractography
    in crossing fiber regions. Int. J. Imaging Syst. Technol., 2012, 22, 53-66
    
    * iFOD2:
    Tournier, J.-D.; Calamante, F. & Connelly, A. Improved probabilistic
    streamlines tractography by 2nd order integration over fibre orientation
    distributions. Proceedings of the International Society for Magnetic
    Resonance in Medicine, 2010, 1670
    
    * Nulldist1 / Nulldist2:
    Morris, D. M.; Embleton, K. V. & Parker, G. J. Probabilistic fibre tracking:
    Differentiation of connections from chance events. NeuroImage, 2008, 42,
    1329-1339
    
    * Tensor_Det:
    Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo
    fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000,
    44, 625-632
    
    * Tensor_Prob:
    Jones, D. Tractography Gone Wild: Probabilistic Fibre Tracking Using the
    Wild Bootstrap With Diffusion Tensor MRI. IEEE Transactions on Medical
    Imaging, 2008, 27, 1268-1274
    
    References based on command-line options:
    
    * -rk4:
    Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo
    fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000,
    44, 625-632
    
    * -act, -backtrack, -seed_gmwmi:
    Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A.
    Anatomically-constrained tractography: Improved diffusion MRI streamlines
    tractography through effective use of anatomical information. NeuroImage,
    2012, 62, 1924-1938
    
    * -seed_dynamic:
    Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT2: Enabling
    dense quantitative assessment of brain white matter connectivity using
    streamlines tractography. NeuroImage, 2015, 119, 338-351.
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TckgenOutputs`).
    """
    tckgen_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(TCKGEN_METADATA)
    params = execution.params(params)
    cargs = tckgen_cargs(params, execution)
    ret = tckgen_outputs(params, execution)
    execution.run(cargs)
    return ret


def tckgen(
    source: InputPathType,
    tracks: str,
    algorithm: str | None = None,
    select_: int | None = None,
    step: float | None = None,
    angle: float | None = None,
    minlength: float | None = None,
    maxlength: float | None = None,
    cutoff: float | None = None,
    trials: int | None = None,
    noprecomputed: bool = False,
    rk4: bool = False,
    stop: bool = False,
    downsample: int | None = None,
    seed_image: list[TckgenSeedImageParamsDict] | None = None,
    seed_sphere: list[TckgenSeedSphereParamsDict] | None = None,
    seed_random_per_voxel: list[TckgenSeedRandomPerVoxelParamsDict] | None = None,
    seed_grid_per_voxel: list[TckgenSeedGridPerVoxelParamsDict] | None = None,
    seed_rejection: list[TckgenSeedRejectionParamsDict] | None = None,
    seed_gmwmi: list[TckgenSeedGmwmiParamsDict] | None = None,
    seed_dynamic: InputPathType | None = None,
    seeds: int | None = None,
    max_attempts_per_seed: int | None = None,
    seed_cutoff: float | None = None,
    seed_unidirectional: bool = False,
    seed_direction: list[float] | None = None,
    output_seeds: str | None = None,
    include: list[TckgenIncludeParamsDict] | None = None,
    include_ordered: list[TckgenIncludeOrderedParamsDict] | None = None,
    exclude: list[TckgenExcludeParamsDict] | None = None,
    mask: list[TckgenMaskParamsDict] | None = None,
    act: InputPathType | None = None,
    backtrack: bool = False,
    crop_at_gmwmi: bool = False,
    power: float | None = None,
    samples: int | None = None,
    grad: InputPathType | None = None,
    fslgrad: TckgenFslgradParamsDict | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[TckgenConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> TckgenOutputs:
    """
    tckgen
    
    Perform streamlines tractography.
    
    By default, tckgen produces a fixed number of streamlines, by attempting to
    seed from new random locations until the target number of streamlines have
    been selected (in other words, after all inclusion & exclusion criteria have
    been applied), or the maximum number of seeds has been exceeded (by default,
    this is 1000 x the desired number of selected streamlines). Use the -select
    and/or -seeds options to modify as required. See also the Seeding options
    section for alternative seeding strategies.
    
    Below is a list of available tracking algorithms, the input image data that
    they require, and a brief description of their behaviour:
    
    - FACT: Fiber Assigned by Continuous Tracking. A deterministic algorithm
    that takes as input a 4D image, with 3xN volumes, where N is the maximum
    number of fiber orientations in a voxel. Each triplet of volumes represents
    a 3D vector corresponding to a fiber orientation; the length of the vector
    additionally indicates some measure of density or anisotropy. As streamlines
    move from one voxel to another, the fiber orientation most collinear with
    the streamline orientation is selected (i.e. there is no intra-voxel
    interpolation).
    
    - iFOD1: First-order Integration over Fiber Orientation Distributions. A
    probabilistic algorithm that takes as input a Fiber Orientation Distribution
    (FOD) image represented in the Spherical Harmonic (SH) basis. At each
    streamline step, random samples from the local (trilinear interpolated) FOD
    are taken. A streamline is more probable to follow orientations where the
    FOD amplitude is large; but it may also rarely traverse orientations with
    small FOD amplitude.
    
    - iFOD2 (default): Second-order Integration over Fiber Orientation
    Distributions. A probabilistic algorithm that takes as input a Fiber
    Orientation Distribution (FOD) image represented in the Spherical Harmonic
    (SH) basis. Candidate streamline paths (based on short curved "arcs") are
    drawn, and the underlying (trilinear-interpolated) FOD amplitudes along
    those arcs are sampled. A streamline is more probable to follow a path where
    the FOD amplitudes along that path are large; but it may also rarely
    traverse orientations where the FOD amplitudes are small, as long as the
    amplitude remains above the FOD amplitude threshold along the entire path.
    
    - NullDist1 / NullDist2: Null Distribution tracking algorithms. These
    probabilistic algorithms expect as input the same image that was used when
    invoking the corresponding algorithm for which the null distribution is
    sought. These algorithms generate streamlines based on random orientation
    samples; that is, no image information relating to fiber orientations is
    used, and streamlines trajectories are determined entirely from random
    sampling. The NullDist2 algorithm is designed to be used in conjunction with
    iFOD2; NullDist1 should be used in conjunction with any first-order
    algorithm.
    
    - SD_STREAM: Streamlines tractography based on Spherical Deconvolution (SD).
    A deterministic algorithm that takes as input a Fiber Orientation
    Distribution (FOD) image represented in the Spherical Harmonic (SH) basis.
    At each streamline step, the local (trilinear-interpolated) FOD is sampled,
    and from the current streamline tangent orientation, a Newton optimisation
    on the sphere is performed in order to locate the orientation of the nearest
    FOD amplitude peak.
    
    - SeedTest: A dummy streamlines algorithm used for testing streamline
    seeding mechanisms. Any image can be used as input; the image will not be
    used in any way. For each seed point generated by the seeding mechanism(s),
    a streamline containing a single point corresponding to that seed location
    will be written to the output track file.
    
    - Tensor_Det: A deterministic algorithm that takes as input a 4D
    diffusion-weighted image (DWI) series. At each streamline step, the
    diffusion tensor is fitted to the local (trilinear-interpolated) diffusion
    data, and the streamline trajectory is determined as the principal
    eigenvector of that tensor.
    
    - Tensor_Prob: A probabilistic algorithm that takes as input a 4D
    diffusion-weighted image (DWI) series. Within each image voxel, a residual
    bootstrap is performed to obtain a unique realisation of the DWI data in
    that voxel for each streamline. These data are then sampled via trilinear
    interpolation at each streamline step, the diffusion tensor model is fitted,
    and the streamline follows the orientation of the principal eigenvector of
    that tensor.
    
    Note that the behaviour of the -angle option varies slightly depending on
    the order of integration: for any first-order method, this angle corresponds
    to the deviation in streamline trajectory per step; for higher-order
    methods, this corresponds to the change in underlying fibre orientation
    between the start and end points of each step.
    
    References:
    
    References based on streamlines algorithm used:
    
    * FACT:
    Mori, S.; Crain, B. J.; Chacko, V. P. & van Zijl, P. C. M. Three-dimensional
    tracking of axonal projections in the brain by magnetic resonance imaging.
    Annals of Neurology, 1999, 45, 265-269
    
    * iFOD1 or SD_STREAM:
    Tournier, J.-D.; Calamante, F. & Connelly, A. MRtrix: Diffusion tractography
    in crossing fiber regions. Int. J. Imaging Syst. Technol., 2012, 22, 53-66
    
    * iFOD2:
    Tournier, J.-D.; Calamante, F. & Connelly, A. Improved probabilistic
    streamlines tractography by 2nd order integration over fibre orientation
    distributions. Proceedings of the International Society for Magnetic
    Resonance in Medicine, 2010, 1670
    
    * Nulldist1 / Nulldist2:
    Morris, D. M.; Embleton, K. V. & Parker, G. J. Probabilistic fibre tracking:
    Differentiation of connections from chance events. NeuroImage, 2008, 42,
    1329-1339
    
    * Tensor_Det:
    Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo
    fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000,
    44, 625-632
    
    * Tensor_Prob:
    Jones, D. Tractography Gone Wild: Probabilistic Fibre Tracking Using the
    Wild Bootstrap With Diffusion Tensor MRI. IEEE Transactions on Medical
    Imaging, 2008, 27, 1268-1274
    
    References based on command-line options:
    
    * -rk4:
    Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo
    fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000,
    44, 625-632
    
    * -act, -backtrack, -seed_gmwmi:
    Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A.
    Anatomically-constrained tractography: Improved diffusion MRI streamlines
    tractography through effective use of anatomical information. NeuroImage,
    2012, 62, 1924-1938
    
    * -seed_dynamic:
    Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT2: Enabling
    dense quantitative assessment of brain white matter connectivity using
    streamlines tractography. NeuroImage, 2015, 119, 338-351.
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        source: The image containing the source data. The type of image data\
            required depends on the algorithm used (see Description section).
        tracks: the output file containing the tracks generated.
        algorithm: specify the tractography algorithm to use. Valid choices\
            are: FACT, iFOD1, iFOD2, Nulldist1, Nulldist2, SD_Stream, Seedtest,\
            Tensor_Det, Tensor_Prob (default: iFOD2).
        select_: set the desired number of streamlines to be selected by\
            tckgen, after all selection criteria have been applied (i.e.\
            inclusion/exclusion ROIs, min/max length, etc). tckgen will keep\
            seeding streamlines until this number of streamlines have been\
            selected, or the maximum allowed number of seeds has been exceeded (see\
            -seeds option). By default, 5000 streamlines are to be selected. Set to\
            zero to disable, which will result in streamlines being seeded until\
            the number specified by -seeds has been reached.
        step: set the step size of the algorithm in mm (defaults: for\
            first-order algorithms, 0.1 x voxelsize; if using RK4, 0.25 x\
            voxelsize; for iFOD2: 0.5 x voxelsize).
        angle: set the maximum angle in degrees between successive steps\
            (defaults: 60 for deterministic algorithms; 15 for iFOD1 / nulldist1;\
            45 for iFOD2 / nulldist2).
        minlength: set the minimum length of any track in mm (defaults: without\
            ACT, 5 x voxelsize; with ACT, 2 x voxelsize).
        maxlength: set the maximum length of any track in mm (default: 100 x\
            voxelsize).
        cutoff: set the FOD amplitude / fixel size / tensor FA cutoff for\
            terminating tracks (defaults: 0.1 for FOD-based algorithms; 0.1 for\
            fixel-based algorithms; 0.1 for tensor-based algorithms; threshold\
            multiplied by 0.5 when using ACT).
        trials: set the maximum number of sampling trials at each point (only\
            used for iFOD1 / iFOD2) (default: 1000).
        noprecomputed: do NOT pre-compute legendre polynomial values. Warning:\
            this will slow down the algorithm by a factor of approximately 4.
        rk4: use 4th-order Runge-Kutta integration (slower, but eliminates\
            curvature overshoot in 1st-order deterministic methods).
        stop: stop propagating a streamline once it has traversed all include\
            regions.
        downsample: downsample the generated streamlines to reduce output file\
            size (default is (samples-1) for iFOD2, no downsampling for all other\
            algorithms).
        seed_image: seed streamlines entirely at random within a mask image.
        seed_sphere: spherical seed as four comma-separated values (XYZ\
            position and radius).
        seed_random_per_voxel: seed a fixed number of streamlines per voxel in\
            a mask image; random placement of seeds in each voxel.
        seed_grid_per_voxel: seed a fixed number of streamlines per voxel in a\
            mask image; place seeds on a 3D mesh grid (grid_size argument is per\
            axis; so a grid_size of 3 results in 27 seeds per voxel).
        seed_rejection: seed from an image using rejection sampling (higher\
            values = more probable to seed from).
        seed_gmwmi: seed from the grey matter - white matter interface (only\
            valid if using ACT framework). Input image should be a 3D seeding\
            volume; seeds drawn within this image will be optimised to the\
            interface using the 5TT image provided using the -act option.
        seed_dynamic: determine seed points dynamically using the SIFT model\
            (must not provide any other seeding mechanism). Note that while this\
            seeding mechanism improves the distribution of reconstructed\
            streamlines density, it should NOT be used as a substitute for the SIFT\
            method itself.
        seeds: set the number of seeds that tckgen will attempt to track from.\
            If this option is NOT provided, the default number of seeds is set to\
            1000 the number of selected streamlines. If -select is NOT also\
            specified, tckgen will continue tracking until this number of seeds has\
            been attempted. However, if -select is also specified, tckgen will stop\
            when the number of seeds attempted reaches the number specified here,\
            OR when the number of streamlines selected reaches the number requested\
            with the -select option. This can be used to prevent the program from\
            running indefinitely when no or very few streamlines can be found that\
            match the selection criteria. Setting this to zero will cause tckgen to\
            keep attempting seeds until the number specified by -select has been\
            reached.
        max_attempts_per_seed: set the maximum number of times that the\
            tracking algorithm should attempt to find an appropriate tracking\
            direction from a given seed point. This should be set high enough to\
            ensure that an actual plausible seed point is not discarded prematurely\
            as being unable to initiate tracking from. Higher settings may affect\
            performance if many seeds are genuinely impossible to track from, as\
            many attempts will still be made in vain for such seeds. (default:\
            1000).
        seed_cutoff: set the minimum FA or FOD amplitude for seeding tracks\
            (default is the same as the normal -cutoff).
        seed_unidirectional: track from the seed point in one direction only\
            (default is to track in both directions).
        seed_direction: specify a seeding direction for the tracking (this\
            should be supplied as a vector of 3 comma-separated values.
        output_seeds: output the seed location of all successful streamlines to\
            a file.
        include: specify an inclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion regions to be\
            accepted.
        include_ordered: specify an inclusion region of interest, as either a\
            binary mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines must traverse ALL inclusion_ordered regions\
            in the order they are specified in order to be accepted.
        exclude: specify an exclusion region of interest, as either a binary\
            mask image, or as a sphere using 4 comma-separared values\
            (x,y,z,radius). Streamlines that enter ANY exclude region will be\
            discarded.
        mask: specify a masking region of interest, as either a binary mask\
            image, or as a sphere using 4 comma-separared values (x,y,z,radius). If\
            defined, streamlines exiting the mask will be truncated.
        act: use the Anatomically-Constrained Tractography framework during\
            tracking; provided image must be in the 5TT (five-tissue-type) format.
        backtrack: allow tracks to be truncated and re-tracked if a poor\
            structural termination is encountered.
        crop_at_gmwmi: crop streamline endpoints more precisely as they cross\
            the GM-WM interface.
        power: raise the FOD to the power specified (defaults are: 1.0 for\
            iFOD1; 1.0/nsamples for iFOD2).
        samples: set the number of FOD samples to take per step (Default: 4).
        grad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in a text file. This should be supplied as a 4xN text file\
            with each line is in the format [ X Y Z b ], where [ X Y Z ] describe\
            the direction of the applied gradient, and b gives the b-value in units\
            of s/mm^2. If a diffusion gradient scheme is present in the input image\
            header, the data provided with this option will be instead used.
        fslgrad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TckgenOutputs`).
    """
    params = tckgen_params(
        algorithm=algorithm,
        select_=select_,
        step=step,
        angle=angle,
        minlength=minlength,
        maxlength=maxlength,
        cutoff=cutoff,
        trials=trials,
        noprecomputed=noprecomputed,
        rk4=rk4,
        stop=stop,
        downsample=downsample,
        seed_image=seed_image,
        seed_sphere=seed_sphere,
        seed_random_per_voxel=seed_random_per_voxel,
        seed_grid_per_voxel=seed_grid_per_voxel,
        seed_rejection=seed_rejection,
        seed_gmwmi=seed_gmwmi,
        seed_dynamic=seed_dynamic,
        seeds=seeds,
        max_attempts_per_seed=max_attempts_per_seed,
        seed_cutoff=seed_cutoff,
        seed_unidirectional=seed_unidirectional,
        seed_direction=seed_direction,
        output_seeds=output_seeds,
        include=include,
        include_ordered=include_ordered,
        exclude=exclude,
        mask=mask,
        act=act,
        backtrack=backtrack,
        crop_at_gmwmi=crop_at_gmwmi,
        power=power,
        samples=samples,
        grad=grad,
        fslgrad=fslgrad,
        info=info,
        quiet=quiet,
        debug=debug,
        force=force,
        nthreads=nthreads,
        config=config,
        help_=help_,
        version=version,
        source=source,
        tracks=tracks,
    )
    return tckgen_execute(params, runner)


__all__ = [
    "TCKGEN_METADATA",
    "TckgenConfigParamsDict",
    "TckgenConfigParamsDictTagged",
    "TckgenExcludeParamsDict",
    "TckgenExcludeParamsDictTagged",
    "TckgenFslgradParamsDict",
    "TckgenFslgradParamsDictTagged",
    "TckgenIncludeOrderedParamsDict",
    "TckgenIncludeOrderedParamsDictTagged",
    "TckgenIncludeParamsDict",
    "TckgenIncludeParamsDictTagged",
    "TckgenMaskParamsDict",
    "TckgenMaskParamsDictTagged",
    "TckgenOutputs",
    "TckgenParamsDict",
    "TckgenParamsDictTagged",
    "TckgenSeedGmwmiParamsDict",
    "TckgenSeedGmwmiParamsDictTagged",
    "TckgenSeedGridPerVoxelParamsDict",
    "TckgenSeedGridPerVoxelParamsDictTagged",
    "TckgenSeedImageParamsDict",
    "TckgenSeedImageParamsDictTagged",
    "TckgenSeedRandomPerVoxelParamsDict",
    "TckgenSeedRandomPerVoxelParamsDictTagged",
    "TckgenSeedRejectionParamsDict",
    "TckgenSeedRejectionParamsDictTagged",
    "TckgenSeedSphereParamsDict",
    "TckgenSeedSphereParamsDictTagged",
    "TckgenVariousFile1ParamsDict",
    "TckgenVariousFile1ParamsDictTagged",
    "TckgenVariousFile2ParamsDict",
    "TckgenVariousFile2ParamsDictTagged",
    "TckgenVariousFileParamsDict",
    "TckgenVariousFileParamsDictTagged",
    "TckgenVariousString1ParamsDict",
    "TckgenVariousString1ParamsDictTagged",
    "TckgenVariousString2ParamsDict",
    "TckgenVariousString2ParamsDictTagged",
    "TckgenVariousStringParamsDict",
    "TckgenVariousStringParamsDictTagged",
    "tckgen",
    "tckgen_config",
    "tckgen_exclude",
    "tckgen_execute",
    "tckgen_fslgrad",
    "tckgen_include",
    "tckgen_include_ordered",
    "tckgen_mask",
    "tckgen_params",
    "tckgen_seed_gmwmi",
    "tckgen_seed_grid_per_voxel",
    "tckgen_seed_image",
    "tckgen_seed_random_per_voxel",
    "tckgen_seed_rejection",
    "tckgen_seed_sphere",
    "tckgen_various_file",
    "tckgen_various_file_1",
    "tckgen_various_file_2",
    "tckgen_various_string",
    "tckgen_various_string_1",
    "tckgen_various_string_2",
]
