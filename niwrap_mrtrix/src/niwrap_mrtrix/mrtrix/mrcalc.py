# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRCALC_METADATA = Metadata(
    id="653dbc736bd2e23e6344aa23f92d7d2506dd4a3a.boutiques",
    name="mrcalc",
    package="mrtrix",
    container_image_tag="mrtrix3/mrtrix3:3.0.4",
)


_MrcalcAbsParamsDictNoTag = typing.TypedDict('_MrcalcAbsParamsDictNoTag', {})
MrcalcAbsParamsDictTagged = typing.TypedDict('MrcalcAbsParamsDictTagged', {
    "@type": typing.Literal["abs"],
})
MrcalcAbsParamsDict = _MrcalcAbsParamsDictNoTag | MrcalcAbsParamsDictTagged


_MrcalcNegParamsDictNoTag = typing.TypedDict('_MrcalcNegParamsDictNoTag', {})
MrcalcNegParamsDictTagged = typing.TypedDict('MrcalcNegParamsDictTagged', {
    "@type": typing.Literal["neg"],
})
MrcalcNegParamsDict = _MrcalcNegParamsDictNoTag | MrcalcNegParamsDictTagged


_MrcalcAddParamsDictNoTag = typing.TypedDict('_MrcalcAddParamsDictNoTag', {})
MrcalcAddParamsDictTagged = typing.TypedDict('MrcalcAddParamsDictTagged', {
    "@type": typing.Literal["add"],
})
MrcalcAddParamsDict = _MrcalcAddParamsDictNoTag | MrcalcAddParamsDictTagged


_MrcalcSubtractParamsDictNoTag = typing.TypedDict('_MrcalcSubtractParamsDictNoTag', {})
MrcalcSubtractParamsDictTagged = typing.TypedDict('MrcalcSubtractParamsDictTagged', {
    "@type": typing.Literal["subtract"],
})
MrcalcSubtractParamsDict = _MrcalcSubtractParamsDictNoTag | MrcalcSubtractParamsDictTagged


_MrcalcMultiplyParamsDictNoTag = typing.TypedDict('_MrcalcMultiplyParamsDictNoTag', {})
MrcalcMultiplyParamsDictTagged = typing.TypedDict('MrcalcMultiplyParamsDictTagged', {
    "@type": typing.Literal["multiply"],
})
MrcalcMultiplyParamsDict = _MrcalcMultiplyParamsDictNoTag | MrcalcMultiplyParamsDictTagged


_MrcalcDivideParamsDictNoTag = typing.TypedDict('_MrcalcDivideParamsDictNoTag', {})
MrcalcDivideParamsDictTagged = typing.TypedDict('MrcalcDivideParamsDictTagged', {
    "@type": typing.Literal["divide"],
})
MrcalcDivideParamsDict = _MrcalcDivideParamsDictNoTag | MrcalcDivideParamsDictTagged


_MrcalcMinParamsDictNoTag = typing.TypedDict('_MrcalcMinParamsDictNoTag', {})
MrcalcMinParamsDictTagged = typing.TypedDict('MrcalcMinParamsDictTagged', {
    "@type": typing.Literal["min"],
})
MrcalcMinParamsDict = _MrcalcMinParamsDictNoTag | MrcalcMinParamsDictTagged


_MrcalcMaxParamsDictNoTag = typing.TypedDict('_MrcalcMaxParamsDictNoTag', {})
MrcalcMaxParamsDictTagged = typing.TypedDict('MrcalcMaxParamsDictTagged', {
    "@type": typing.Literal["max"],
})
MrcalcMaxParamsDict = _MrcalcMaxParamsDictNoTag | MrcalcMaxParamsDictTagged


_MrcalcLtParamsDictNoTag = typing.TypedDict('_MrcalcLtParamsDictNoTag', {})
MrcalcLtParamsDictTagged = typing.TypedDict('MrcalcLtParamsDictTagged', {
    "@type": typing.Literal["lt"],
})
MrcalcLtParamsDict = _MrcalcLtParamsDictNoTag | MrcalcLtParamsDictTagged


_MrcalcGtParamsDictNoTag = typing.TypedDict('_MrcalcGtParamsDictNoTag', {})
MrcalcGtParamsDictTagged = typing.TypedDict('MrcalcGtParamsDictTagged', {
    "@type": typing.Literal["gt"],
})
MrcalcGtParamsDict = _MrcalcGtParamsDictNoTag | MrcalcGtParamsDictTagged


_MrcalcLeParamsDictNoTag = typing.TypedDict('_MrcalcLeParamsDictNoTag', {})
MrcalcLeParamsDictTagged = typing.TypedDict('MrcalcLeParamsDictTagged', {
    "@type": typing.Literal["le"],
})
MrcalcLeParamsDict = _MrcalcLeParamsDictNoTag | MrcalcLeParamsDictTagged


_MrcalcGeParamsDictNoTag = typing.TypedDict('_MrcalcGeParamsDictNoTag', {})
MrcalcGeParamsDictTagged = typing.TypedDict('MrcalcGeParamsDictTagged', {
    "@type": typing.Literal["ge"],
})
MrcalcGeParamsDict = _MrcalcGeParamsDictNoTag | MrcalcGeParamsDictTagged


_MrcalcEqParamsDictNoTag = typing.TypedDict('_MrcalcEqParamsDictNoTag', {})
MrcalcEqParamsDictTagged = typing.TypedDict('MrcalcEqParamsDictTagged', {
    "@type": typing.Literal["eq"],
})
MrcalcEqParamsDict = _MrcalcEqParamsDictNoTag | MrcalcEqParamsDictTagged


_MrcalcNeqParamsDictNoTag = typing.TypedDict('_MrcalcNeqParamsDictNoTag', {})
MrcalcNeqParamsDictTagged = typing.TypedDict('MrcalcNeqParamsDictTagged', {
    "@type": typing.Literal["neq"],
})
MrcalcNeqParamsDict = _MrcalcNeqParamsDictNoTag | MrcalcNeqParamsDictTagged


_MrcalcIfParamsDictNoTag = typing.TypedDict('_MrcalcIfParamsDictNoTag', {})
MrcalcIfParamsDictTagged = typing.TypedDict('MrcalcIfParamsDictTagged', {
    "@type": typing.Literal["if"],
})
MrcalcIfParamsDict = _MrcalcIfParamsDictNoTag | MrcalcIfParamsDictTagged


_MrcalcReplaceParamsDictNoTag = typing.TypedDict('_MrcalcReplaceParamsDictNoTag', {})
MrcalcReplaceParamsDictTagged = typing.TypedDict('MrcalcReplaceParamsDictTagged', {
    "@type": typing.Literal["replace"],
})
MrcalcReplaceParamsDict = _MrcalcReplaceParamsDictNoTag | MrcalcReplaceParamsDictTagged


_MrcalcSqrtParamsDictNoTag = typing.TypedDict('_MrcalcSqrtParamsDictNoTag', {})
MrcalcSqrtParamsDictTagged = typing.TypedDict('MrcalcSqrtParamsDictTagged', {
    "@type": typing.Literal["sqrt"],
})
MrcalcSqrtParamsDict = _MrcalcSqrtParamsDictNoTag | MrcalcSqrtParamsDictTagged


_MrcalcPowParamsDictNoTag = typing.TypedDict('_MrcalcPowParamsDictNoTag', {})
MrcalcPowParamsDictTagged = typing.TypedDict('MrcalcPowParamsDictTagged', {
    "@type": typing.Literal["pow"],
})
MrcalcPowParamsDict = _MrcalcPowParamsDictNoTag | MrcalcPowParamsDictTagged


_MrcalcRoundParamsDictNoTag = typing.TypedDict('_MrcalcRoundParamsDictNoTag', {})
MrcalcRoundParamsDictTagged = typing.TypedDict('MrcalcRoundParamsDictTagged', {
    "@type": typing.Literal["round"],
})
MrcalcRoundParamsDict = _MrcalcRoundParamsDictNoTag | MrcalcRoundParamsDictTagged


_MrcalcCeilParamsDictNoTag = typing.TypedDict('_MrcalcCeilParamsDictNoTag', {})
MrcalcCeilParamsDictTagged = typing.TypedDict('MrcalcCeilParamsDictTagged', {
    "@type": typing.Literal["ceil"],
})
MrcalcCeilParamsDict = _MrcalcCeilParamsDictNoTag | MrcalcCeilParamsDictTagged


_MrcalcFloorParamsDictNoTag = typing.TypedDict('_MrcalcFloorParamsDictNoTag', {})
MrcalcFloorParamsDictTagged = typing.TypedDict('MrcalcFloorParamsDictTagged', {
    "@type": typing.Literal["floor"],
})
MrcalcFloorParamsDict = _MrcalcFloorParamsDictNoTag | MrcalcFloorParamsDictTagged


_MrcalcNotParamsDictNoTag = typing.TypedDict('_MrcalcNotParamsDictNoTag', {})
MrcalcNotParamsDictTagged = typing.TypedDict('MrcalcNotParamsDictTagged', {
    "@type": typing.Literal["not"],
})
MrcalcNotParamsDict = _MrcalcNotParamsDictNoTag | MrcalcNotParamsDictTagged


_MrcalcAndParamsDictNoTag = typing.TypedDict('_MrcalcAndParamsDictNoTag', {})
MrcalcAndParamsDictTagged = typing.TypedDict('MrcalcAndParamsDictTagged', {
    "@type": typing.Literal["and"],
})
MrcalcAndParamsDict = _MrcalcAndParamsDictNoTag | MrcalcAndParamsDictTagged


_MrcalcOrParamsDictNoTag = typing.TypedDict('_MrcalcOrParamsDictNoTag', {})
MrcalcOrParamsDictTagged = typing.TypedDict('MrcalcOrParamsDictTagged', {
    "@type": typing.Literal["or"],
})
MrcalcOrParamsDict = _MrcalcOrParamsDictNoTag | MrcalcOrParamsDictTagged


_MrcalcXorParamsDictNoTag = typing.TypedDict('_MrcalcXorParamsDictNoTag', {})
MrcalcXorParamsDictTagged = typing.TypedDict('MrcalcXorParamsDictTagged', {
    "@type": typing.Literal["xor"],
})
MrcalcXorParamsDict = _MrcalcXorParamsDictNoTag | MrcalcXorParamsDictTagged


_MrcalcIsnanParamsDictNoTag = typing.TypedDict('_MrcalcIsnanParamsDictNoTag', {})
MrcalcIsnanParamsDictTagged = typing.TypedDict('MrcalcIsnanParamsDictTagged', {
    "@type": typing.Literal["isnan"],
})
MrcalcIsnanParamsDict = _MrcalcIsnanParamsDictNoTag | MrcalcIsnanParamsDictTagged


_MrcalcIsinfParamsDictNoTag = typing.TypedDict('_MrcalcIsinfParamsDictNoTag', {})
MrcalcIsinfParamsDictTagged = typing.TypedDict('MrcalcIsinfParamsDictTagged', {
    "@type": typing.Literal["isinf"],
})
MrcalcIsinfParamsDict = _MrcalcIsinfParamsDictNoTag | MrcalcIsinfParamsDictTagged


_MrcalcFiniteParamsDictNoTag = typing.TypedDict('_MrcalcFiniteParamsDictNoTag', {})
MrcalcFiniteParamsDictTagged = typing.TypedDict('MrcalcFiniteParamsDictTagged', {
    "@type": typing.Literal["finite"],
})
MrcalcFiniteParamsDict = _MrcalcFiniteParamsDictNoTag | MrcalcFiniteParamsDictTagged


_MrcalcComplexParamsDictNoTag = typing.TypedDict('_MrcalcComplexParamsDictNoTag', {})
MrcalcComplexParamsDictTagged = typing.TypedDict('MrcalcComplexParamsDictTagged', {
    "@type": typing.Literal["complex"],
})
MrcalcComplexParamsDict = _MrcalcComplexParamsDictNoTag | MrcalcComplexParamsDictTagged


_MrcalcPolarParamsDictNoTag = typing.TypedDict('_MrcalcPolarParamsDictNoTag', {})
MrcalcPolarParamsDictTagged = typing.TypedDict('MrcalcPolarParamsDictTagged', {
    "@type": typing.Literal["polar"],
})
MrcalcPolarParamsDict = _MrcalcPolarParamsDictNoTag | MrcalcPolarParamsDictTagged


_MrcalcRealParamsDictNoTag = typing.TypedDict('_MrcalcRealParamsDictNoTag', {})
MrcalcRealParamsDictTagged = typing.TypedDict('MrcalcRealParamsDictTagged', {
    "@type": typing.Literal["real"],
})
MrcalcRealParamsDict = _MrcalcRealParamsDictNoTag | MrcalcRealParamsDictTagged


_MrcalcImagParamsDictNoTag = typing.TypedDict('_MrcalcImagParamsDictNoTag', {})
MrcalcImagParamsDictTagged = typing.TypedDict('MrcalcImagParamsDictTagged', {
    "@type": typing.Literal["imag"],
})
MrcalcImagParamsDict = _MrcalcImagParamsDictNoTag | MrcalcImagParamsDictTagged


_MrcalcPhaseParamsDictNoTag = typing.TypedDict('_MrcalcPhaseParamsDictNoTag', {})
MrcalcPhaseParamsDictTagged = typing.TypedDict('MrcalcPhaseParamsDictTagged', {
    "@type": typing.Literal["phase"],
})
MrcalcPhaseParamsDict = _MrcalcPhaseParamsDictNoTag | MrcalcPhaseParamsDictTagged


_MrcalcConjParamsDictNoTag = typing.TypedDict('_MrcalcConjParamsDictNoTag', {})
MrcalcConjParamsDictTagged = typing.TypedDict('MrcalcConjParamsDictTagged', {
    "@type": typing.Literal["conj"],
})
MrcalcConjParamsDict = _MrcalcConjParamsDictNoTag | MrcalcConjParamsDictTagged


_MrcalcProjParamsDictNoTag = typing.TypedDict('_MrcalcProjParamsDictNoTag', {})
MrcalcProjParamsDictTagged = typing.TypedDict('MrcalcProjParamsDictTagged', {
    "@type": typing.Literal["proj"],
})
MrcalcProjParamsDict = _MrcalcProjParamsDictNoTag | MrcalcProjParamsDictTagged


_MrcalcExpParamsDictNoTag = typing.TypedDict('_MrcalcExpParamsDictNoTag', {})
MrcalcExpParamsDictTagged = typing.TypedDict('MrcalcExpParamsDictTagged', {
    "@type": typing.Literal["exp"],
})
MrcalcExpParamsDict = _MrcalcExpParamsDictNoTag | MrcalcExpParamsDictTagged


_MrcalcLogParamsDictNoTag = typing.TypedDict('_MrcalcLogParamsDictNoTag', {})
MrcalcLogParamsDictTagged = typing.TypedDict('MrcalcLogParamsDictTagged', {
    "@type": typing.Literal["log"],
})
MrcalcLogParamsDict = _MrcalcLogParamsDictNoTag | MrcalcLogParamsDictTagged


_MrcalcLog10ParamsDictNoTag = typing.TypedDict('_MrcalcLog10ParamsDictNoTag', {})
MrcalcLog10ParamsDictTagged = typing.TypedDict('MrcalcLog10ParamsDictTagged', {
    "@type": typing.Literal["log10"],
})
MrcalcLog10ParamsDict = _MrcalcLog10ParamsDictNoTag | MrcalcLog10ParamsDictTagged


_MrcalcCosParamsDictNoTag = typing.TypedDict('_MrcalcCosParamsDictNoTag', {})
MrcalcCosParamsDictTagged = typing.TypedDict('MrcalcCosParamsDictTagged', {
    "@type": typing.Literal["cos"],
})
MrcalcCosParamsDict = _MrcalcCosParamsDictNoTag | MrcalcCosParamsDictTagged


_MrcalcSinParamsDictNoTag = typing.TypedDict('_MrcalcSinParamsDictNoTag', {})
MrcalcSinParamsDictTagged = typing.TypedDict('MrcalcSinParamsDictTagged', {
    "@type": typing.Literal["sin"],
})
MrcalcSinParamsDict = _MrcalcSinParamsDictNoTag | MrcalcSinParamsDictTagged


_MrcalcTanParamsDictNoTag = typing.TypedDict('_MrcalcTanParamsDictNoTag', {})
MrcalcTanParamsDictTagged = typing.TypedDict('MrcalcTanParamsDictTagged', {
    "@type": typing.Literal["tan"],
})
MrcalcTanParamsDict = _MrcalcTanParamsDictNoTag | MrcalcTanParamsDictTagged


_MrcalcAcosParamsDictNoTag = typing.TypedDict('_MrcalcAcosParamsDictNoTag', {})
MrcalcAcosParamsDictTagged = typing.TypedDict('MrcalcAcosParamsDictTagged', {
    "@type": typing.Literal["acos"],
})
MrcalcAcosParamsDict = _MrcalcAcosParamsDictNoTag | MrcalcAcosParamsDictTagged


_MrcalcAsinParamsDictNoTag = typing.TypedDict('_MrcalcAsinParamsDictNoTag', {})
MrcalcAsinParamsDictTagged = typing.TypedDict('MrcalcAsinParamsDictTagged', {
    "@type": typing.Literal["asin"],
})
MrcalcAsinParamsDict = _MrcalcAsinParamsDictNoTag | MrcalcAsinParamsDictTagged


_MrcalcAtanParamsDictNoTag = typing.TypedDict('_MrcalcAtanParamsDictNoTag', {})
MrcalcAtanParamsDictTagged = typing.TypedDict('MrcalcAtanParamsDictTagged', {
    "@type": typing.Literal["atan"],
})
MrcalcAtanParamsDict = _MrcalcAtanParamsDictNoTag | MrcalcAtanParamsDictTagged


_MrcalcCoshParamsDictNoTag = typing.TypedDict('_MrcalcCoshParamsDictNoTag', {})
MrcalcCoshParamsDictTagged = typing.TypedDict('MrcalcCoshParamsDictTagged', {
    "@type": typing.Literal["cosh"],
})
MrcalcCoshParamsDict = _MrcalcCoshParamsDictNoTag | MrcalcCoshParamsDictTagged


_MrcalcSinhParamsDictNoTag = typing.TypedDict('_MrcalcSinhParamsDictNoTag', {})
MrcalcSinhParamsDictTagged = typing.TypedDict('MrcalcSinhParamsDictTagged', {
    "@type": typing.Literal["sinh"],
})
MrcalcSinhParamsDict = _MrcalcSinhParamsDictNoTag | MrcalcSinhParamsDictTagged


_MrcalcTanhParamsDictNoTag = typing.TypedDict('_MrcalcTanhParamsDictNoTag', {})
MrcalcTanhParamsDictTagged = typing.TypedDict('MrcalcTanhParamsDictTagged', {
    "@type": typing.Literal["tanh"],
})
MrcalcTanhParamsDict = _MrcalcTanhParamsDictNoTag | MrcalcTanhParamsDictTagged


_MrcalcAcoshParamsDictNoTag = typing.TypedDict('_MrcalcAcoshParamsDictNoTag', {})
MrcalcAcoshParamsDictTagged = typing.TypedDict('MrcalcAcoshParamsDictTagged', {
    "@type": typing.Literal["acosh"],
})
MrcalcAcoshParamsDict = _MrcalcAcoshParamsDictNoTag | MrcalcAcoshParamsDictTagged


_MrcalcAsinhParamsDictNoTag = typing.TypedDict('_MrcalcAsinhParamsDictNoTag', {})
MrcalcAsinhParamsDictTagged = typing.TypedDict('MrcalcAsinhParamsDictTagged', {
    "@type": typing.Literal["asinh"],
})
MrcalcAsinhParamsDict = _MrcalcAsinhParamsDictNoTag | MrcalcAsinhParamsDictTagged


_MrcalcAtanhParamsDictNoTag = typing.TypedDict('_MrcalcAtanhParamsDictNoTag', {})
MrcalcAtanhParamsDictTagged = typing.TypedDict('MrcalcAtanhParamsDictTagged', {
    "@type": typing.Literal["atanh"],
})
MrcalcAtanhParamsDict = _MrcalcAtanhParamsDictNoTag | MrcalcAtanhParamsDictTagged


_MrcalcConfigParamsDictNoTag = typing.TypedDict('_MrcalcConfigParamsDictNoTag', {
    "key": str,
    "value": str,
})
MrcalcConfigParamsDictTagged = typing.TypedDict('MrcalcConfigParamsDictTagged', {
    "@type": typing.Literal["config"],
    "key": str,
    "value": str,
})
MrcalcConfigParamsDict = _MrcalcConfigParamsDictNoTag | MrcalcConfigParamsDictTagged


_MrcalcVariousStringParamsDictNoTag = typing.TypedDict('_MrcalcVariousStringParamsDictNoTag', {
    "obj": str,
})
MrcalcVariousStringParamsDictTagged = typing.TypedDict('MrcalcVariousStringParamsDictTagged', {
    "@type": typing.Literal["VariousString"],
    "obj": str,
})
MrcalcVariousStringParamsDict = _MrcalcVariousStringParamsDictNoTag | MrcalcVariousStringParamsDictTagged


_MrcalcVariousFileParamsDictNoTag = typing.TypedDict('_MrcalcVariousFileParamsDictNoTag', {
    "obj": InputPathType,
})
MrcalcVariousFileParamsDictTagged = typing.TypedDict('MrcalcVariousFileParamsDictTagged', {
    "@type": typing.Literal["VariousFile"],
    "obj": InputPathType,
})
MrcalcVariousFileParamsDict = _MrcalcVariousFileParamsDictNoTag | MrcalcVariousFileParamsDictTagged


_MrcalcParamsDictNoTag = typing.TypedDict('_MrcalcParamsDictNoTag', {
    "abs": typing.NotRequired[list[MrcalcAbsParamsDict] | None],
    "neg": typing.NotRequired[list[MrcalcNegParamsDict] | None],
    "add": typing.NotRequired[list[MrcalcAddParamsDict] | None],
    "subtract": typing.NotRequired[list[MrcalcSubtractParamsDict] | None],
    "multiply": typing.NotRequired[list[MrcalcMultiplyParamsDict] | None],
    "divide": typing.NotRequired[list[MrcalcDivideParamsDict] | None],
    "min": typing.NotRequired[list[MrcalcMinParamsDict] | None],
    "max": typing.NotRequired[list[MrcalcMaxParamsDict] | None],
    "lt": typing.NotRequired[list[MrcalcLtParamsDict] | None],
    "gt": typing.NotRequired[list[MrcalcGtParamsDict] | None],
    "le": typing.NotRequired[list[MrcalcLeParamsDict] | None],
    "ge": typing.NotRequired[list[MrcalcGeParamsDict] | None],
    "eq": typing.NotRequired[list[MrcalcEqParamsDict] | None],
    "neq": typing.NotRequired[list[MrcalcNeqParamsDict] | None],
    "if": typing.NotRequired[list[MrcalcIfParamsDict] | None],
    "replace": typing.NotRequired[list[MrcalcReplaceParamsDict] | None],
    "sqrt": typing.NotRequired[list[MrcalcSqrtParamsDict] | None],
    "pow": typing.NotRequired[list[MrcalcPowParamsDict] | None],
    "round": typing.NotRequired[list[MrcalcRoundParamsDict] | None],
    "ceil": typing.NotRequired[list[MrcalcCeilParamsDict] | None],
    "floor": typing.NotRequired[list[MrcalcFloorParamsDict] | None],
    "not": typing.NotRequired[list[MrcalcNotParamsDict] | None],
    "and": typing.NotRequired[list[MrcalcAndParamsDict] | None],
    "or": typing.NotRequired[list[MrcalcOrParamsDict] | None],
    "xor": typing.NotRequired[list[MrcalcXorParamsDict] | None],
    "isnan": typing.NotRequired[list[MrcalcIsnanParamsDict] | None],
    "isinf": typing.NotRequired[list[MrcalcIsinfParamsDict] | None],
    "finite": typing.NotRequired[list[MrcalcFiniteParamsDict] | None],
    "complex": typing.NotRequired[list[MrcalcComplexParamsDict] | None],
    "polar": typing.NotRequired[list[MrcalcPolarParamsDict] | None],
    "real": typing.NotRequired[list[MrcalcRealParamsDict] | None],
    "imag": typing.NotRequired[list[MrcalcImagParamsDict] | None],
    "phase": typing.NotRequired[list[MrcalcPhaseParamsDict] | None],
    "conj": typing.NotRequired[list[MrcalcConjParamsDict] | None],
    "proj": typing.NotRequired[list[MrcalcProjParamsDict] | None],
    "exp": typing.NotRequired[list[MrcalcExpParamsDict] | None],
    "log": typing.NotRequired[list[MrcalcLogParamsDict] | None],
    "log10": typing.NotRequired[list[MrcalcLog10ParamsDict] | None],
    "cos": typing.NotRequired[list[MrcalcCosParamsDict] | None],
    "sin": typing.NotRequired[list[MrcalcSinParamsDict] | None],
    "tan": typing.NotRequired[list[MrcalcTanParamsDict] | None],
    "acos": typing.NotRequired[list[MrcalcAcosParamsDict] | None],
    "asin": typing.NotRequired[list[MrcalcAsinParamsDict] | None],
    "atan": typing.NotRequired[list[MrcalcAtanParamsDict] | None],
    "cosh": typing.NotRequired[list[MrcalcCoshParamsDict] | None],
    "sinh": typing.NotRequired[list[MrcalcSinhParamsDict] | None],
    "tanh": typing.NotRequired[list[MrcalcTanhParamsDict] | None],
    "acosh": typing.NotRequired[list[MrcalcAcoshParamsDict] | None],
    "asinh": typing.NotRequired[list[MrcalcAsinhParamsDict] | None],
    "atanh": typing.NotRequired[list[MrcalcAtanhParamsDict] | None],
    "datatype": typing.NotRequired[str | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[MrcalcConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "operand": list[typing.Union[MrcalcVariousStringParamsDictTagged, MrcalcVariousFileParamsDictTagged]],
})
MrcalcParamsDictTagged = typing.TypedDict('MrcalcParamsDictTagged', {
    "@type": typing.Literal["mrtrix/mrcalc"],
    "abs": typing.NotRequired[list[MrcalcAbsParamsDict] | None],
    "neg": typing.NotRequired[list[MrcalcNegParamsDict] | None],
    "add": typing.NotRequired[list[MrcalcAddParamsDict] | None],
    "subtract": typing.NotRequired[list[MrcalcSubtractParamsDict] | None],
    "multiply": typing.NotRequired[list[MrcalcMultiplyParamsDict] | None],
    "divide": typing.NotRequired[list[MrcalcDivideParamsDict] | None],
    "min": typing.NotRequired[list[MrcalcMinParamsDict] | None],
    "max": typing.NotRequired[list[MrcalcMaxParamsDict] | None],
    "lt": typing.NotRequired[list[MrcalcLtParamsDict] | None],
    "gt": typing.NotRequired[list[MrcalcGtParamsDict] | None],
    "le": typing.NotRequired[list[MrcalcLeParamsDict] | None],
    "ge": typing.NotRequired[list[MrcalcGeParamsDict] | None],
    "eq": typing.NotRequired[list[MrcalcEqParamsDict] | None],
    "neq": typing.NotRequired[list[MrcalcNeqParamsDict] | None],
    "if": typing.NotRequired[list[MrcalcIfParamsDict] | None],
    "replace": typing.NotRequired[list[MrcalcReplaceParamsDict] | None],
    "sqrt": typing.NotRequired[list[MrcalcSqrtParamsDict] | None],
    "pow": typing.NotRequired[list[MrcalcPowParamsDict] | None],
    "round": typing.NotRequired[list[MrcalcRoundParamsDict] | None],
    "ceil": typing.NotRequired[list[MrcalcCeilParamsDict] | None],
    "floor": typing.NotRequired[list[MrcalcFloorParamsDict] | None],
    "not": typing.NotRequired[list[MrcalcNotParamsDict] | None],
    "and": typing.NotRequired[list[MrcalcAndParamsDict] | None],
    "or": typing.NotRequired[list[MrcalcOrParamsDict] | None],
    "xor": typing.NotRequired[list[MrcalcXorParamsDict] | None],
    "isnan": typing.NotRequired[list[MrcalcIsnanParamsDict] | None],
    "isinf": typing.NotRequired[list[MrcalcIsinfParamsDict] | None],
    "finite": typing.NotRequired[list[MrcalcFiniteParamsDict] | None],
    "complex": typing.NotRequired[list[MrcalcComplexParamsDict] | None],
    "polar": typing.NotRequired[list[MrcalcPolarParamsDict] | None],
    "real": typing.NotRequired[list[MrcalcRealParamsDict] | None],
    "imag": typing.NotRequired[list[MrcalcImagParamsDict] | None],
    "phase": typing.NotRequired[list[MrcalcPhaseParamsDict] | None],
    "conj": typing.NotRequired[list[MrcalcConjParamsDict] | None],
    "proj": typing.NotRequired[list[MrcalcProjParamsDict] | None],
    "exp": typing.NotRequired[list[MrcalcExpParamsDict] | None],
    "log": typing.NotRequired[list[MrcalcLogParamsDict] | None],
    "log10": typing.NotRequired[list[MrcalcLog10ParamsDict] | None],
    "cos": typing.NotRequired[list[MrcalcCosParamsDict] | None],
    "sin": typing.NotRequired[list[MrcalcSinParamsDict] | None],
    "tan": typing.NotRequired[list[MrcalcTanParamsDict] | None],
    "acos": typing.NotRequired[list[MrcalcAcosParamsDict] | None],
    "asin": typing.NotRequired[list[MrcalcAsinParamsDict] | None],
    "atan": typing.NotRequired[list[MrcalcAtanParamsDict] | None],
    "cosh": typing.NotRequired[list[MrcalcCoshParamsDict] | None],
    "sinh": typing.NotRequired[list[MrcalcSinhParamsDict] | None],
    "tanh": typing.NotRequired[list[MrcalcTanhParamsDict] | None],
    "acosh": typing.NotRequired[list[MrcalcAcoshParamsDict] | None],
    "asinh": typing.NotRequired[list[MrcalcAsinhParamsDict] | None],
    "atanh": typing.NotRequired[list[MrcalcAtanhParamsDict] | None],
    "datatype": typing.NotRequired[str | None],
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[MrcalcConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "operand": list[typing.Union[MrcalcVariousStringParamsDictTagged, MrcalcVariousFileParamsDictTagged]],
})
MrcalcParamsDict = _MrcalcParamsDictNoTag | MrcalcParamsDictTagged


def mrcalc_operand_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString": mrcalc_various_string_cargs,
        "VariousFile": mrcalc_various_file_cargs,
    }.get(t)


def mrcalc_operand_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString": mrcalc_various_string_validate,
        "VariousFile": mrcalc_various_file_validate,
    }.get(t)


def mrcalc_abs(
) -> MrcalcAbsParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "abs",
    }
    return params


def mrcalc_abs_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAbsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_abs_cargs(
    params: MrcalcAbsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-abs")
    return cargs


def mrcalc_neg(
) -> MrcalcNegParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "neg",
    }
    return params


def mrcalc_neg_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcNegParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_neg_cargs(
    params: MrcalcNegParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-neg")
    return cargs


def mrcalc_add(
) -> MrcalcAddParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "add",
    }
    return params


def mrcalc_add_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAddParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_add_cargs(
    params: MrcalcAddParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-add")
    return cargs


def mrcalc_subtract(
) -> MrcalcSubtractParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "subtract",
    }
    return params


def mrcalc_subtract_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcSubtractParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_subtract_cargs(
    params: MrcalcSubtractParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-subtract")
    return cargs


def mrcalc_multiply(
) -> MrcalcMultiplyParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "multiply",
    }
    return params


def mrcalc_multiply_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcMultiplyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_multiply_cargs(
    params: MrcalcMultiplyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-multiply")
    return cargs


def mrcalc_divide(
) -> MrcalcDivideParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "divide",
    }
    return params


def mrcalc_divide_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcDivideParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_divide_cargs(
    params: MrcalcDivideParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-divide")
    return cargs


def mrcalc_min(
) -> MrcalcMinParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "min",
    }
    return params


def mrcalc_min_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcMinParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_min_cargs(
    params: MrcalcMinParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-min")
    return cargs


def mrcalc_max(
) -> MrcalcMaxParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "max",
    }
    return params


def mrcalc_max_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcMaxParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_max_cargs(
    params: MrcalcMaxParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-max")
    return cargs


def mrcalc_lt(
) -> MrcalcLtParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "lt",
    }
    return params


def mrcalc_lt_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcLtParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_lt_cargs(
    params: MrcalcLtParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-lt")
    return cargs


def mrcalc_gt(
) -> MrcalcGtParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "gt",
    }
    return params


def mrcalc_gt_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcGtParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_gt_cargs(
    params: MrcalcGtParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-gt")
    return cargs


def mrcalc_le(
) -> MrcalcLeParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "le",
    }
    return params


def mrcalc_le_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcLeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_le_cargs(
    params: MrcalcLeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-le")
    return cargs


def mrcalc_ge(
) -> MrcalcGeParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ge",
    }
    return params


def mrcalc_ge_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcGeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_ge_cargs(
    params: MrcalcGeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-ge")
    return cargs


def mrcalc_eq(
) -> MrcalcEqParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "eq",
    }
    return params


def mrcalc_eq_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcEqParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_eq_cargs(
    params: MrcalcEqParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-eq")
    return cargs


def mrcalc_neq(
) -> MrcalcNeqParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "neq",
    }
    return params


def mrcalc_neq_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcNeqParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_neq_cargs(
    params: MrcalcNeqParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-neq")
    return cargs


def mrcalc_if(
) -> MrcalcIfParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "if",
    }
    return params


def mrcalc_if_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcIfParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_if_cargs(
    params: MrcalcIfParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-if")
    return cargs


def mrcalc_replace(
) -> MrcalcReplaceParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "replace",
    }
    return params


def mrcalc_replace_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcReplaceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_replace_cargs(
    params: MrcalcReplaceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-replace")
    return cargs


def mrcalc_sqrt(
) -> MrcalcSqrtParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sqrt",
    }
    return params


def mrcalc_sqrt_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcSqrtParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_sqrt_cargs(
    params: MrcalcSqrtParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-sqrt")
    return cargs


def mrcalc_pow(
) -> MrcalcPowParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "pow",
    }
    return params


def mrcalc_pow_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcPowParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_pow_cargs(
    params: MrcalcPowParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-pow")
    return cargs


def mrcalc_round(
) -> MrcalcRoundParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "round",
    }
    return params


def mrcalc_round_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcRoundParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_round_cargs(
    params: MrcalcRoundParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-round")
    return cargs


def mrcalc_ceil(
) -> MrcalcCeilParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ceil",
    }
    return params


def mrcalc_ceil_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcCeilParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_ceil_cargs(
    params: MrcalcCeilParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-ceil")
    return cargs


def mrcalc_floor(
) -> MrcalcFloorParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "floor",
    }
    return params


def mrcalc_floor_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcFloorParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_floor_cargs(
    params: MrcalcFloorParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-floor")
    return cargs


def mrcalc_not(
) -> MrcalcNotParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "not",
    }
    return params


def mrcalc_not_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcNotParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_not_cargs(
    params: MrcalcNotParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-not")
    return cargs


def mrcalc_and(
) -> MrcalcAndParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "and",
    }
    return params


def mrcalc_and_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAndParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_and_cargs(
    params: MrcalcAndParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-and")
    return cargs


def mrcalc_or(
) -> MrcalcOrParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "or",
    }
    return params


def mrcalc_or_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcOrParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_or_cargs(
    params: MrcalcOrParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-or")
    return cargs


def mrcalc_xor(
) -> MrcalcXorParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "xor",
    }
    return params


def mrcalc_xor_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcXorParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_xor_cargs(
    params: MrcalcXorParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-xor")
    return cargs


def mrcalc_isnan(
) -> MrcalcIsnanParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "isnan",
    }
    return params


def mrcalc_isnan_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcIsnanParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_isnan_cargs(
    params: MrcalcIsnanParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-isnan")
    return cargs


def mrcalc_isinf(
) -> MrcalcIsinfParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "isinf",
    }
    return params


def mrcalc_isinf_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcIsinfParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_isinf_cargs(
    params: MrcalcIsinfParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-isinf")
    return cargs


def mrcalc_finite(
) -> MrcalcFiniteParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "finite",
    }
    return params


def mrcalc_finite_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcFiniteParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_finite_cargs(
    params: MrcalcFiniteParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-finite")
    return cargs


def mrcalc_complex(
) -> MrcalcComplexParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "complex",
    }
    return params


def mrcalc_complex_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcComplexParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_complex_cargs(
    params: MrcalcComplexParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-complex")
    return cargs


def mrcalc_polar(
) -> MrcalcPolarParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "polar",
    }
    return params


def mrcalc_polar_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcPolarParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_polar_cargs(
    params: MrcalcPolarParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-polar")
    return cargs


def mrcalc_real(
) -> MrcalcRealParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "real",
    }
    return params


def mrcalc_real_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcRealParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_real_cargs(
    params: MrcalcRealParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-real")
    return cargs


def mrcalc_imag(
) -> MrcalcImagParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "imag",
    }
    return params


def mrcalc_imag_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcImagParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_imag_cargs(
    params: MrcalcImagParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-imag")
    return cargs


def mrcalc_phase(
) -> MrcalcPhaseParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "phase",
    }
    return params


def mrcalc_phase_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcPhaseParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_phase_cargs(
    params: MrcalcPhaseParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-phase")
    return cargs


def mrcalc_conj(
) -> MrcalcConjParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "conj",
    }
    return params


def mrcalc_conj_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcConjParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_conj_cargs(
    params: MrcalcConjParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-conj")
    return cargs


def mrcalc_proj(
) -> MrcalcProjParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "proj",
    }
    return params


def mrcalc_proj_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcProjParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_proj_cargs(
    params: MrcalcProjParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-proj")
    return cargs


def mrcalc_exp(
) -> MrcalcExpParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "exp",
    }
    return params


def mrcalc_exp_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcExpParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_exp_cargs(
    params: MrcalcExpParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-exp")
    return cargs


def mrcalc_log(
) -> MrcalcLogParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "log",
    }
    return params


def mrcalc_log_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcLogParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_log_cargs(
    params: MrcalcLogParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-log")
    return cargs


def mrcalc_log10(
) -> MrcalcLog10ParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "log10",
    }
    return params


def mrcalc_log10_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcLog10ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_log10_cargs(
    params: MrcalcLog10ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-log10")
    return cargs


def mrcalc_cos(
) -> MrcalcCosParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "cos",
    }
    return params


def mrcalc_cos_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcCosParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_cos_cargs(
    params: MrcalcCosParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-cos")
    return cargs


def mrcalc_sin(
) -> MrcalcSinParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sin",
    }
    return params


def mrcalc_sin_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcSinParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_sin_cargs(
    params: MrcalcSinParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-sin")
    return cargs


def mrcalc_tan(
) -> MrcalcTanParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "tan",
    }
    return params


def mrcalc_tan_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcTanParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_tan_cargs(
    params: MrcalcTanParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-tan")
    return cargs


def mrcalc_acos(
) -> MrcalcAcosParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "acos",
    }
    return params


def mrcalc_acos_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAcosParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_acos_cargs(
    params: MrcalcAcosParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-acos")
    return cargs


def mrcalc_asin(
) -> MrcalcAsinParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "asin",
    }
    return params


def mrcalc_asin_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAsinParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_asin_cargs(
    params: MrcalcAsinParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-asin")
    return cargs


def mrcalc_atan(
) -> MrcalcAtanParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "atan",
    }
    return params


def mrcalc_atan_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAtanParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_atan_cargs(
    params: MrcalcAtanParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-atan")
    return cargs


def mrcalc_cosh(
) -> MrcalcCoshParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "cosh",
    }
    return params


def mrcalc_cosh_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcCoshParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_cosh_cargs(
    params: MrcalcCoshParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-cosh")
    return cargs


def mrcalc_sinh(
) -> MrcalcSinhParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "sinh",
    }
    return params


def mrcalc_sinh_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcSinhParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_sinh_cargs(
    params: MrcalcSinhParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-sinh")
    return cargs


def mrcalc_tanh(
) -> MrcalcTanhParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "tanh",
    }
    return params


def mrcalc_tanh_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcTanhParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_tanh_cargs(
    params: MrcalcTanhParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-tanh")
    return cargs


def mrcalc_acosh(
) -> MrcalcAcoshParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "acosh",
    }
    return params


def mrcalc_acosh_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAcoshParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_acosh_cargs(
    params: MrcalcAcoshParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-acosh")
    return cargs


def mrcalc_asinh(
) -> MrcalcAsinhParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "asinh",
    }
    return params


def mrcalc_asinh_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAsinhParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_asinh_cargs(
    params: MrcalcAsinhParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-asinh")
    return cargs


def mrcalc_atanh(
) -> MrcalcAtanhParamsDictTagged:
    """
    Build parameters.
    
    Args:
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "atanh",
    }
    return params


def mrcalc_atanh_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcAtanhParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')


def mrcalc_atanh_cargs(
    params: MrcalcAtanhParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-atanh")
    return cargs


def mrcalc_config(
    key: str,
    value: str,
) -> MrcalcConfigParamsDictTagged:
    """
    Build parameters.
    
    Args:
        key: temporarily set the value of an MRtrix config file entry.
        value: temporarily set the value of an MRtrix config file entry.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "config",
        "key": key,
        "value": value,
    }
    return params


def mrcalc_config_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcConfigParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("key", None) is None:
        raise StyxValidationError("`key` must not be None")
    if not isinstance(params["key"], str):
        raise StyxValidationError(f'`key` has the wrong type: Received `{type(params.get("key", None))}` expected `str`')
    if params.get("value", None) is None:
        raise StyxValidationError("`value` must not be None")
    if not isinstance(params["value"], str):
        raise StyxValidationError(f'`value` has the wrong type: Received `{type(params.get("value", None))}` expected `str`')


def mrcalc_config_cargs(
    params: MrcalcConfigParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-config")
    cargs.append(params.get("key", None))
    cargs.append(params.get("value", None))
    return cargs


def mrcalc_various_string(
    obj: str,
) -> MrcalcVariousStringParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString",
        "obj": obj,
    }
    return params


def mrcalc_various_string_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcVariousStringParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def mrcalc_various_string_cargs(
    params: MrcalcVariousStringParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def mrcalc_various_file(
    obj: InputPathType,
) -> MrcalcVariousFileParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile",
        "obj": obj,
    }
    return params


def mrcalc_various_file_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcVariousFileParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def mrcalc_various_file_cargs(
    params: MrcalcVariousFileParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


class MrcalcOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MrcalcParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mrcalc_params(
    operand: list[typing.Union[MrcalcVariousStringParamsDictTagged, MrcalcVariousFileParamsDictTagged]],
    abs_: list[MrcalcAbsParamsDict] | None = None,
    neg: list[MrcalcNegParamsDict] | None = None,
    add: list[MrcalcAddParamsDict] | None = None,
    subtract: list[MrcalcSubtractParamsDict] | None = None,
    multiply: list[MrcalcMultiplyParamsDict] | None = None,
    divide: list[MrcalcDivideParamsDict] | None = None,
    min_: list[MrcalcMinParamsDict] | None = None,
    max_: list[MrcalcMaxParamsDict] | None = None,
    lt: list[MrcalcLtParamsDict] | None = None,
    gt: list[MrcalcGtParamsDict] | None = None,
    le: list[MrcalcLeParamsDict] | None = None,
    ge: list[MrcalcGeParamsDict] | None = None,
    eq: list[MrcalcEqParamsDict] | None = None,
    neq: list[MrcalcNeqParamsDict] | None = None,
    if_: list[MrcalcIfParamsDict] | None = None,
    replace: list[MrcalcReplaceParamsDict] | None = None,
    sqrt: list[MrcalcSqrtParamsDict] | None = None,
    pow_: list[MrcalcPowParamsDict] | None = None,
    round_: list[MrcalcRoundParamsDict] | None = None,
    ceil: list[MrcalcCeilParamsDict] | None = None,
    floor: list[MrcalcFloorParamsDict] | None = None,
    not_: list[MrcalcNotParamsDict] | None = None,
    and_: list[MrcalcAndParamsDict] | None = None,
    or_: list[MrcalcOrParamsDict] | None = None,
    xor: list[MrcalcXorParamsDict] | None = None,
    isnan: list[MrcalcIsnanParamsDict] | None = None,
    isinf: list[MrcalcIsinfParamsDict] | None = None,
    finite: list[MrcalcFiniteParamsDict] | None = None,
    complex_: list[MrcalcComplexParamsDict] | None = None,
    polar: list[MrcalcPolarParamsDict] | None = None,
    real: list[MrcalcRealParamsDict] | None = None,
    imag: list[MrcalcImagParamsDict] | None = None,
    phase: list[MrcalcPhaseParamsDict] | None = None,
    conj: list[MrcalcConjParamsDict] | None = None,
    proj: list[MrcalcProjParamsDict] | None = None,
    exp: list[MrcalcExpParamsDict] | None = None,
    log: list[MrcalcLogParamsDict] | None = None,
    log10: list[MrcalcLog10ParamsDict] | None = None,
    cos: list[MrcalcCosParamsDict] | None = None,
    sin: list[MrcalcSinParamsDict] | None = None,
    tan: list[MrcalcTanParamsDict] | None = None,
    acos: list[MrcalcAcosParamsDict] | None = None,
    asin: list[MrcalcAsinParamsDict] | None = None,
    atan: list[MrcalcAtanParamsDict] | None = None,
    cosh: list[MrcalcCoshParamsDict] | None = None,
    sinh: list[MrcalcSinhParamsDict] | None = None,
    tanh: list[MrcalcTanhParamsDict] | None = None,
    acosh: list[MrcalcAcoshParamsDict] | None = None,
    asinh: list[MrcalcAsinhParamsDict] | None = None,
    atanh: list[MrcalcAtanhParamsDict] | None = None,
    datatype: str | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[MrcalcConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
) -> MrcalcParamsDictTagged:
    """
    Build parameters.
    
    Args:
        operand: an input image, intensity value, or the special keywords\
            'rand' (random number between 0 and 1) or 'randn' (random number from\
            unit std.dev. normal distribution) or the mathematical constants 'e'\
            and 'pi'.
        abs_: |%1| : return absolute value (magnitude) of real or complex\
            number.
        neg: -%1 : negative value.
        add: (%1 + %2) : add values.
        subtract: (%1 - %2) : subtract nth operand from (n-1)th.
        multiply: (%1 * %2) : multiply values.
        divide: (%1 / %2) : divide (n-1)th operand by nth.
        min_: min (%1, %2) : smallest of last two operands.
        max_: max (%1, %2) : greatest of last two operands.
        lt: (%1 < %2) : less-than operator (true=1, false=0).
        gt: (%1 > %2) : greater-than operator (true=1, false=0).
        le: (%1 <= %2) : less-than-or-equal-to operator (true=1, false=0).
        ge: (%1 >= %2) : greater-than-or-equal-to operator (true=1, false=0).
        eq: (%1 == %2) : equal-to operator (true=1, false=0).
        neq: (%1 != %2) : not-equal-to operator (true=1, false=0).
        if_: (%1 ? %2 : %3) : if first operand is true (non-zero), return\
            second operand, otherwise return third operand.
        replace: (%1, %2 -> %3) : Wherever first operand is equal to the second\
            operand, replace with third operand.
        sqrt: sqrt (%1) : square root.
        pow_: %1^%2 : raise (n-1)th operand to nth power.
        round_: round (%1) : round to nearest integer.
        ceil: ceil (%1) : round up to nearest integer.
        floor: floor (%1) : round down to nearest integer.
        not_: !%1 : NOT operator: true (1) if operand is false (i.e. zero).
        and_: (%1 && %2) : AND operator: true (1) if both operands are true\
            (i.e. non-zero).
        or_: (%1 || %2) : OR operator: true (1) if either operand is true (i.e.\
            non-zero).
        xor: (%1 ^^ %2) : XOR operator: true (1) if only one of the operands is\
            true (i.e. non-zero).
        isnan: isnan (%1) : true (1) if operand is not-a-number (NaN).
        isinf: isinf (%1) : true (1) if operand is infinite (Inf).
        finite: finite (%1) : true (1) if operand is finite (i.e. not NaN or\
            Inf).
        complex_: (%1 + %2 i) : create complex number using the last two\
            operands as real,imaginary components.
        polar: (%1 /_ %2) : create complex number using the last two operands\
            as magnitude,phase components (phase in radians).
        real: real (%1) : real part of complex number.
        imag: imag (%1) : imaginary part of complex number.
        phase: phase (%1) : phase of complex number (use -abs for magnitude).
        conj: conj (%1) : complex conjugate.
        proj: proj (%1) : projection onto the Riemann sphere.
        exp: exp (%1) : exponential function.
        log: log (%1) : natural logarithm.
        log10: log10 (%1) : common logarithm.
        cos: cos (%1) : cosine.
        sin: sin (%1) : sine.
        tan: tan (%1) : tangent.
        acos: acos (%1) : inverse cosine.
        asin: asin (%1) : inverse sine.
        atan: atan (%1) : inverse tangent.
        cosh: cosh (%1) : hyperbolic cosine.
        sinh: sinh (%1) : hyperbolic sine.
        tanh: tanh (%1) : hyperbolic tangent.
        acosh: acosh (%1) : inverse hyperbolic cosine.
        asinh: asinh (%1) : inverse hyperbolic sine.
        atanh: atanh (%1) : inverse hyperbolic tangent.
        datatype: specify output image data type. Valid choices are: float32,\
            float32le, float32be, float64, float64le, float64be, int64, uint64,\
            int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le,\
            int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be,\
            cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be,\
            int8, uint8, bit.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mrtrix/mrcalc",
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help_,
        "version": version,
        "operand": operand,
    }
    if abs_ is not None:
        params["abs"] = abs_
    if neg is not None:
        params["neg"] = neg
    if add is not None:
        params["add"] = add
    if subtract is not None:
        params["subtract"] = subtract
    if multiply is not None:
        params["multiply"] = multiply
    if divide is not None:
        params["divide"] = divide
    if min_ is not None:
        params["min"] = min_
    if max_ is not None:
        params["max"] = max_
    if lt is not None:
        params["lt"] = lt
    if gt is not None:
        params["gt"] = gt
    if le is not None:
        params["le"] = le
    if ge is not None:
        params["ge"] = ge
    if eq is not None:
        params["eq"] = eq
    if neq is not None:
        params["neq"] = neq
    if if_ is not None:
        params["if"] = if_
    if replace is not None:
        params["replace"] = replace
    if sqrt is not None:
        params["sqrt"] = sqrt
    if pow_ is not None:
        params["pow"] = pow_
    if round_ is not None:
        params["round"] = round_
    if ceil is not None:
        params["ceil"] = ceil
    if floor is not None:
        params["floor"] = floor
    if not_ is not None:
        params["not"] = not_
    if and_ is not None:
        params["and"] = and_
    if or_ is not None:
        params["or"] = or_
    if xor is not None:
        params["xor"] = xor
    if isnan is not None:
        params["isnan"] = isnan
    if isinf is not None:
        params["isinf"] = isinf
    if finite is not None:
        params["finite"] = finite
    if complex_ is not None:
        params["complex"] = complex_
    if polar is not None:
        params["polar"] = polar
    if real is not None:
        params["real"] = real
    if imag is not None:
        params["imag"] = imag
    if phase is not None:
        params["phase"] = phase
    if conj is not None:
        params["conj"] = conj
    if proj is not None:
        params["proj"] = proj
    if exp is not None:
        params["exp"] = exp
    if log is not None:
        params["log"] = log
    if log10 is not None:
        params["log10"] = log10
    if cos is not None:
        params["cos"] = cos
    if sin is not None:
        params["sin"] = sin
    if tan is not None:
        params["tan"] = tan
    if acos is not None:
        params["acos"] = acos
    if asin is not None:
        params["asin"] = asin
    if atan is not None:
        params["atan"] = atan
    if cosh is not None:
        params["cosh"] = cosh
    if sinh is not None:
        params["sinh"] = sinh
    if tanh is not None:
        params["tanh"] = tanh
    if acosh is not None:
        params["acosh"] = acosh
    if asinh is not None:
        params["asinh"] = asinh
    if atanh is not None:
        params["atanh"] = atanh
    if datatype is not None:
        params["datatype"] = datatype
    if nthreads is not None:
        params["nthreads"] = nthreads
    if config is not None:
        params["config"] = config
    return params


def mrcalc_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrcalcParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("abs", None) is not None:
        if not isinstance(params["abs"], list):
            raise StyxValidationError(f'`abs` has the wrong type: Received `{type(params.get("abs", None))}` expected `list[MrcalcAbsParamsDict] | None`')
        for e in params["abs"]:
            mrcalc_abs_validate(e)
    if params.get("neg", None) is not None:
        if not isinstance(params["neg"], list):
            raise StyxValidationError(f'`neg` has the wrong type: Received `{type(params.get("neg", None))}` expected `list[MrcalcNegParamsDict] | None`')
        for e in params["neg"]:
            mrcalc_neg_validate(e)
    if params.get("add", None) is not None:
        if not isinstance(params["add"], list):
            raise StyxValidationError(f'`add` has the wrong type: Received `{type(params.get("add", None))}` expected `list[MrcalcAddParamsDict] | None`')
        for e in params["add"]:
            mrcalc_add_validate(e)
    if params.get("subtract", None) is not None:
        if not isinstance(params["subtract"], list):
            raise StyxValidationError(f'`subtract` has the wrong type: Received `{type(params.get("subtract", None))}` expected `list[MrcalcSubtractParamsDict] | None`')
        for e in params["subtract"]:
            mrcalc_subtract_validate(e)
    if params.get("multiply", None) is not None:
        if not isinstance(params["multiply"], list):
            raise StyxValidationError(f'`multiply` has the wrong type: Received `{type(params.get("multiply", None))}` expected `list[MrcalcMultiplyParamsDict] | None`')
        for e in params["multiply"]:
            mrcalc_multiply_validate(e)
    if params.get("divide", None) is not None:
        if not isinstance(params["divide"], list):
            raise StyxValidationError(f'`divide` has the wrong type: Received `{type(params.get("divide", None))}` expected `list[MrcalcDivideParamsDict] | None`')
        for e in params["divide"]:
            mrcalc_divide_validate(e)
    if params.get("min", None) is not None:
        if not isinstance(params["min"], list):
            raise StyxValidationError(f'`min` has the wrong type: Received `{type(params.get("min", None))}` expected `list[MrcalcMinParamsDict] | None`')
        for e in params["min"]:
            mrcalc_min_validate(e)
    if params.get("max", None) is not None:
        if not isinstance(params["max"], list):
            raise StyxValidationError(f'`max` has the wrong type: Received `{type(params.get("max", None))}` expected `list[MrcalcMaxParamsDict] | None`')
        for e in params["max"]:
            mrcalc_max_validate(e)
    if params.get("lt", None) is not None:
        if not isinstance(params["lt"], list):
            raise StyxValidationError(f'`lt` has the wrong type: Received `{type(params.get("lt", None))}` expected `list[MrcalcLtParamsDict] | None`')
        for e in params["lt"]:
            mrcalc_lt_validate(e)
    if params.get("gt", None) is not None:
        if not isinstance(params["gt"], list):
            raise StyxValidationError(f'`gt` has the wrong type: Received `{type(params.get("gt", None))}` expected `list[MrcalcGtParamsDict] | None`')
        for e in params["gt"]:
            mrcalc_gt_validate(e)
    if params.get("le", None) is not None:
        if not isinstance(params["le"], list):
            raise StyxValidationError(f'`le` has the wrong type: Received `{type(params.get("le", None))}` expected `list[MrcalcLeParamsDict] | None`')
        for e in params["le"]:
            mrcalc_le_validate(e)
    if params.get("ge", None) is not None:
        if not isinstance(params["ge"], list):
            raise StyxValidationError(f'`ge` has the wrong type: Received `{type(params.get("ge", None))}` expected `list[MrcalcGeParamsDict] | None`')
        for e in params["ge"]:
            mrcalc_ge_validate(e)
    if params.get("eq", None) is not None:
        if not isinstance(params["eq"], list):
            raise StyxValidationError(f'`eq` has the wrong type: Received `{type(params.get("eq", None))}` expected `list[MrcalcEqParamsDict] | None`')
        for e in params["eq"]:
            mrcalc_eq_validate(e)
    if params.get("neq", None) is not None:
        if not isinstance(params["neq"], list):
            raise StyxValidationError(f'`neq` has the wrong type: Received `{type(params.get("neq", None))}` expected `list[MrcalcNeqParamsDict] | None`')
        for e in params["neq"]:
            mrcalc_neq_validate(e)
    if params.get("if", None) is not None:
        if not isinstance(params["if"], list):
            raise StyxValidationError(f'`if` has the wrong type: Received `{type(params.get("if", None))}` expected `list[MrcalcIfParamsDict] | None`')
        for e in params["if"]:
            mrcalc_if_validate(e)
    if params.get("replace", None) is not None:
        if not isinstance(params["replace"], list):
            raise StyxValidationError(f'`replace` has the wrong type: Received `{type(params.get("replace", None))}` expected `list[MrcalcReplaceParamsDict] | None`')
        for e in params["replace"]:
            mrcalc_replace_validate(e)
    if params.get("sqrt", None) is not None:
        if not isinstance(params["sqrt"], list):
            raise StyxValidationError(f'`sqrt` has the wrong type: Received `{type(params.get("sqrt", None))}` expected `list[MrcalcSqrtParamsDict] | None`')
        for e in params["sqrt"]:
            mrcalc_sqrt_validate(e)
    if params.get("pow", None) is not None:
        if not isinstance(params["pow"], list):
            raise StyxValidationError(f'`pow` has the wrong type: Received `{type(params.get("pow", None))}` expected `list[MrcalcPowParamsDict] | None`')
        for e in params["pow"]:
            mrcalc_pow_validate(e)
    if params.get("round", None) is not None:
        if not isinstance(params["round"], list):
            raise StyxValidationError(f'`round` has the wrong type: Received `{type(params.get("round", None))}` expected `list[MrcalcRoundParamsDict] | None`')
        for e in params["round"]:
            mrcalc_round_validate(e)
    if params.get("ceil", None) is not None:
        if not isinstance(params["ceil"], list):
            raise StyxValidationError(f'`ceil` has the wrong type: Received `{type(params.get("ceil", None))}` expected `list[MrcalcCeilParamsDict] | None`')
        for e in params["ceil"]:
            mrcalc_ceil_validate(e)
    if params.get("floor", None) is not None:
        if not isinstance(params["floor"], list):
            raise StyxValidationError(f'`floor` has the wrong type: Received `{type(params.get("floor", None))}` expected `list[MrcalcFloorParamsDict] | None`')
        for e in params["floor"]:
            mrcalc_floor_validate(e)
    if params.get("not", None) is not None:
        if not isinstance(params["not"], list):
            raise StyxValidationError(f'`not` has the wrong type: Received `{type(params.get("not", None))}` expected `list[MrcalcNotParamsDict] | None`')
        for e in params["not"]:
            mrcalc_not_validate(e)
    if params.get("and", None) is not None:
        if not isinstance(params["and"], list):
            raise StyxValidationError(f'`and` has the wrong type: Received `{type(params.get("and", None))}` expected `list[MrcalcAndParamsDict] | None`')
        for e in params["and"]:
            mrcalc_and_validate(e)
    if params.get("or", None) is not None:
        if not isinstance(params["or"], list):
            raise StyxValidationError(f'`or` has the wrong type: Received `{type(params.get("or", None))}` expected `list[MrcalcOrParamsDict] | None`')
        for e in params["or"]:
            mrcalc_or_validate(e)
    if params.get("xor", None) is not None:
        if not isinstance(params["xor"], list):
            raise StyxValidationError(f'`xor` has the wrong type: Received `{type(params.get("xor", None))}` expected `list[MrcalcXorParamsDict] | None`')
        for e in params["xor"]:
            mrcalc_xor_validate(e)
    if params.get("isnan", None) is not None:
        if not isinstance(params["isnan"], list):
            raise StyxValidationError(f'`isnan` has the wrong type: Received `{type(params.get("isnan", None))}` expected `list[MrcalcIsnanParamsDict] | None`')
        for e in params["isnan"]:
            mrcalc_isnan_validate(e)
    if params.get("isinf", None) is not None:
        if not isinstance(params["isinf"], list):
            raise StyxValidationError(f'`isinf` has the wrong type: Received `{type(params.get("isinf", None))}` expected `list[MrcalcIsinfParamsDict] | None`')
        for e in params["isinf"]:
            mrcalc_isinf_validate(e)
    if params.get("finite", None) is not None:
        if not isinstance(params["finite"], list):
            raise StyxValidationError(f'`finite` has the wrong type: Received `{type(params.get("finite", None))}` expected `list[MrcalcFiniteParamsDict] | None`')
        for e in params["finite"]:
            mrcalc_finite_validate(e)
    if params.get("complex", None) is not None:
        if not isinstance(params["complex"], list):
            raise StyxValidationError(f'`complex` has the wrong type: Received `{type(params.get("complex", None))}` expected `list[MrcalcComplexParamsDict] | None`')
        for e in params["complex"]:
            mrcalc_complex_validate(e)
    if params.get("polar", None) is not None:
        if not isinstance(params["polar"], list):
            raise StyxValidationError(f'`polar` has the wrong type: Received `{type(params.get("polar", None))}` expected `list[MrcalcPolarParamsDict] | None`')
        for e in params["polar"]:
            mrcalc_polar_validate(e)
    if params.get("real", None) is not None:
        if not isinstance(params["real"], list):
            raise StyxValidationError(f'`real` has the wrong type: Received `{type(params.get("real", None))}` expected `list[MrcalcRealParamsDict] | None`')
        for e in params["real"]:
            mrcalc_real_validate(e)
    if params.get("imag", None) is not None:
        if not isinstance(params["imag"], list):
            raise StyxValidationError(f'`imag` has the wrong type: Received `{type(params.get("imag", None))}` expected `list[MrcalcImagParamsDict] | None`')
        for e in params["imag"]:
            mrcalc_imag_validate(e)
    if params.get("phase", None) is not None:
        if not isinstance(params["phase"], list):
            raise StyxValidationError(f'`phase` has the wrong type: Received `{type(params.get("phase", None))}` expected `list[MrcalcPhaseParamsDict] | None`')
        for e in params["phase"]:
            mrcalc_phase_validate(e)
    if params.get("conj", None) is not None:
        if not isinstance(params["conj"], list):
            raise StyxValidationError(f'`conj` has the wrong type: Received `{type(params.get("conj", None))}` expected `list[MrcalcConjParamsDict] | None`')
        for e in params["conj"]:
            mrcalc_conj_validate(e)
    if params.get("proj", None) is not None:
        if not isinstance(params["proj"], list):
            raise StyxValidationError(f'`proj` has the wrong type: Received `{type(params.get("proj", None))}` expected `list[MrcalcProjParamsDict] | None`')
        for e in params["proj"]:
            mrcalc_proj_validate(e)
    if params.get("exp", None) is not None:
        if not isinstance(params["exp"], list):
            raise StyxValidationError(f'`exp` has the wrong type: Received `{type(params.get("exp", None))}` expected `list[MrcalcExpParamsDict] | None`')
        for e in params["exp"]:
            mrcalc_exp_validate(e)
    if params.get("log", None) is not None:
        if not isinstance(params["log"], list):
            raise StyxValidationError(f'`log` has the wrong type: Received `{type(params.get("log", None))}` expected `list[MrcalcLogParamsDict] | None`')
        for e in params["log"]:
            mrcalc_log_validate(e)
    if params.get("log10", None) is not None:
        if not isinstance(params["log10"], list):
            raise StyxValidationError(f'`log10` has the wrong type: Received `{type(params.get("log10", None))}` expected `list[MrcalcLog10ParamsDict] | None`')
        for e in params["log10"]:
            mrcalc_log10_validate(e)
    if params.get("cos", None) is not None:
        if not isinstance(params["cos"], list):
            raise StyxValidationError(f'`cos` has the wrong type: Received `{type(params.get("cos", None))}` expected `list[MrcalcCosParamsDict] | None`')
        for e in params["cos"]:
            mrcalc_cos_validate(e)
    if params.get("sin", None) is not None:
        if not isinstance(params["sin"], list):
            raise StyxValidationError(f'`sin` has the wrong type: Received `{type(params.get("sin", None))}` expected `list[MrcalcSinParamsDict] | None`')
        for e in params["sin"]:
            mrcalc_sin_validate(e)
    if params.get("tan", None) is not None:
        if not isinstance(params["tan"], list):
            raise StyxValidationError(f'`tan` has the wrong type: Received `{type(params.get("tan", None))}` expected `list[MrcalcTanParamsDict] | None`')
        for e in params["tan"]:
            mrcalc_tan_validate(e)
    if params.get("acos", None) is not None:
        if not isinstance(params["acos"], list):
            raise StyxValidationError(f'`acos` has the wrong type: Received `{type(params.get("acos", None))}` expected `list[MrcalcAcosParamsDict] | None`')
        for e in params["acos"]:
            mrcalc_acos_validate(e)
    if params.get("asin", None) is not None:
        if not isinstance(params["asin"], list):
            raise StyxValidationError(f'`asin` has the wrong type: Received `{type(params.get("asin", None))}` expected `list[MrcalcAsinParamsDict] | None`')
        for e in params["asin"]:
            mrcalc_asin_validate(e)
    if params.get("atan", None) is not None:
        if not isinstance(params["atan"], list):
            raise StyxValidationError(f'`atan` has the wrong type: Received `{type(params.get("atan", None))}` expected `list[MrcalcAtanParamsDict] | None`')
        for e in params["atan"]:
            mrcalc_atan_validate(e)
    if params.get("cosh", None) is not None:
        if not isinstance(params["cosh"], list):
            raise StyxValidationError(f'`cosh` has the wrong type: Received `{type(params.get("cosh", None))}` expected `list[MrcalcCoshParamsDict] | None`')
        for e in params["cosh"]:
            mrcalc_cosh_validate(e)
    if params.get("sinh", None) is not None:
        if not isinstance(params["sinh"], list):
            raise StyxValidationError(f'`sinh` has the wrong type: Received `{type(params.get("sinh", None))}` expected `list[MrcalcSinhParamsDict] | None`')
        for e in params["sinh"]:
            mrcalc_sinh_validate(e)
    if params.get("tanh", None) is not None:
        if not isinstance(params["tanh"], list):
            raise StyxValidationError(f'`tanh` has the wrong type: Received `{type(params.get("tanh", None))}` expected `list[MrcalcTanhParamsDict] | None`')
        for e in params["tanh"]:
            mrcalc_tanh_validate(e)
    if params.get("acosh", None) is not None:
        if not isinstance(params["acosh"], list):
            raise StyxValidationError(f'`acosh` has the wrong type: Received `{type(params.get("acosh", None))}` expected `list[MrcalcAcoshParamsDict] | None`')
        for e in params["acosh"]:
            mrcalc_acosh_validate(e)
    if params.get("asinh", None) is not None:
        if not isinstance(params["asinh"], list):
            raise StyxValidationError(f'`asinh` has the wrong type: Received `{type(params.get("asinh", None))}` expected `list[MrcalcAsinhParamsDict] | None`')
        for e in params["asinh"]:
            mrcalc_asinh_validate(e)
    if params.get("atanh", None) is not None:
        if not isinstance(params["atanh"], list):
            raise StyxValidationError(f'`atanh` has the wrong type: Received `{type(params.get("atanh", None))}` expected `list[MrcalcAtanhParamsDict] | None`')
        for e in params["atanh"]:
            mrcalc_atanh_validate(e)
    if params.get("datatype", None) is not None:
        if not isinstance(params["datatype"], str):
            raise StyxValidationError(f'`datatype` has the wrong type: Received `{type(params.get("datatype", None))}` expected `str | None`')
    if params.get("info", False) is None:
        raise StyxValidationError("`info` must not be None")
    if not isinstance(params["info"], bool):
        raise StyxValidationError(f'`info` has the wrong type: Received `{type(params.get("info", False))}` expected `bool`')
    if params.get("quiet", False) is None:
        raise StyxValidationError("`quiet` must not be None")
    if not isinstance(params["quiet"], bool):
        raise StyxValidationError(f'`quiet` has the wrong type: Received `{type(params.get("quiet", False))}` expected `bool`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("force", False) is None:
        raise StyxValidationError("`force` must not be None")
    if not isinstance(params["force"], bool):
        raise StyxValidationError(f'`force` has the wrong type: Received `{type(params.get("force", False))}` expected `bool`')
    if params.get("nthreads", None) is not None:
        if not isinstance(params["nthreads"], int):
            raise StyxValidationError(f'`nthreads` has the wrong type: Received `{type(params.get("nthreads", None))}` expected `int | None`')
    if params.get("config", None) is not None:
        if not isinstance(params["config"], list):
            raise StyxValidationError(f'`config` has the wrong type: Received `{type(params.get("config", None))}` expected `list[MrcalcConfigParamsDict] | None`')
        for e in params["config"]:
            mrcalc_config_validate(e)
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("operand", None) is None:
        raise StyxValidationError("`operand` must not be None")
    if not isinstance(params["operand"], list):
        raise StyxValidationError(f'`operand` has the wrong type: Received `{type(params.get("operand", None))}` expected `list[typing.Union[MrcalcVariousStringParamsDictTagged, MrcalcVariousFileParamsDictTagged]]`')
    for e in params["operand"]:
        if not isinstance(e, dict):
            raise StyxValidationError(f'Params object has the wrong type \'{type(e)}\'')
        if "@type" not in e:
            raise StyxValidationError("Params object is missing `@type`")
        if e["@type"] not in ["VariousString", "VariousFile"]:
            raise StyxValidationError("Parameter `operand`s `@type` must be one of [\"VariousString\", \"VariousFile\"]")
        mrcalc_operand_validate_dyn_fn(e["@type"])(e)


def mrcalc_cargs(
    params: MrcalcParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mrcalc")
    if params.get("abs", None) is not None:
        cargs.extend([a for c in [mrcalc_abs_cargs(s, execution) for s in params.get("abs", None)] for a in c])
    if params.get("neg", None) is not None:
        cargs.extend([a for c in [mrcalc_neg_cargs(s, execution) for s in params.get("neg", None)] for a in c])
    if params.get("add", None) is not None:
        cargs.extend([a for c in [mrcalc_add_cargs(s, execution) for s in params.get("add", None)] for a in c])
    if params.get("subtract", None) is not None:
        cargs.extend([a for c in [mrcalc_subtract_cargs(s, execution) for s in params.get("subtract", None)] for a in c])
    if params.get("multiply", None) is not None:
        cargs.extend([a for c in [mrcalc_multiply_cargs(s, execution) for s in params.get("multiply", None)] for a in c])
    if params.get("divide", None) is not None:
        cargs.extend([a for c in [mrcalc_divide_cargs(s, execution) for s in params.get("divide", None)] for a in c])
    if params.get("min", None) is not None:
        cargs.extend([a for c in [mrcalc_min_cargs(s, execution) for s in params.get("min", None)] for a in c])
    if params.get("max", None) is not None:
        cargs.extend([a for c in [mrcalc_max_cargs(s, execution) for s in params.get("max", None)] for a in c])
    if params.get("lt", None) is not None:
        cargs.extend([a for c in [mrcalc_lt_cargs(s, execution) for s in params.get("lt", None)] for a in c])
    if params.get("gt", None) is not None:
        cargs.extend([a for c in [mrcalc_gt_cargs(s, execution) for s in params.get("gt", None)] for a in c])
    if params.get("le", None) is not None:
        cargs.extend([a for c in [mrcalc_le_cargs(s, execution) for s in params.get("le", None)] for a in c])
    if params.get("ge", None) is not None:
        cargs.extend([a for c in [mrcalc_ge_cargs(s, execution) for s in params.get("ge", None)] for a in c])
    if params.get("eq", None) is not None:
        cargs.extend([a for c in [mrcalc_eq_cargs(s, execution) for s in params.get("eq", None)] for a in c])
    if params.get("neq", None) is not None:
        cargs.extend([a for c in [mrcalc_neq_cargs(s, execution) for s in params.get("neq", None)] for a in c])
    if params.get("if", None) is not None:
        cargs.extend([a for c in [mrcalc_if_cargs(s, execution) for s in params.get("if", None)] for a in c])
    if params.get("replace", None) is not None:
        cargs.extend([a for c in [mrcalc_replace_cargs(s, execution) for s in params.get("replace", None)] for a in c])
    if params.get("sqrt", None) is not None:
        cargs.extend([a for c in [mrcalc_sqrt_cargs(s, execution) for s in params.get("sqrt", None)] for a in c])
    if params.get("pow", None) is not None:
        cargs.extend([a for c in [mrcalc_pow_cargs(s, execution) for s in params.get("pow", None)] for a in c])
    if params.get("round", None) is not None:
        cargs.extend([a for c in [mrcalc_round_cargs(s, execution) for s in params.get("round", None)] for a in c])
    if params.get("ceil", None) is not None:
        cargs.extend([a for c in [mrcalc_ceil_cargs(s, execution) for s in params.get("ceil", None)] for a in c])
    if params.get("floor", None) is not None:
        cargs.extend([a for c in [mrcalc_floor_cargs(s, execution) for s in params.get("floor", None)] for a in c])
    if params.get("not", None) is not None:
        cargs.extend([a for c in [mrcalc_not_cargs(s, execution) for s in params.get("not", None)] for a in c])
    if params.get("and", None) is not None:
        cargs.extend([a for c in [mrcalc_and_cargs(s, execution) for s in params.get("and", None)] for a in c])
    if params.get("or", None) is not None:
        cargs.extend([a for c in [mrcalc_or_cargs(s, execution) for s in params.get("or", None)] for a in c])
    if params.get("xor", None) is not None:
        cargs.extend([a for c in [mrcalc_xor_cargs(s, execution) for s in params.get("xor", None)] for a in c])
    if params.get("isnan", None) is not None:
        cargs.extend([a for c in [mrcalc_isnan_cargs(s, execution) for s in params.get("isnan", None)] for a in c])
    if params.get("isinf", None) is not None:
        cargs.extend([a for c in [mrcalc_isinf_cargs(s, execution) for s in params.get("isinf", None)] for a in c])
    if params.get("finite", None) is not None:
        cargs.extend([a for c in [mrcalc_finite_cargs(s, execution) for s in params.get("finite", None)] for a in c])
    if params.get("complex", None) is not None:
        cargs.extend([a for c in [mrcalc_complex_cargs(s, execution) for s in params.get("complex", None)] for a in c])
    if params.get("polar", None) is not None:
        cargs.extend([a for c in [mrcalc_polar_cargs(s, execution) for s in params.get("polar", None)] for a in c])
    if params.get("real", None) is not None:
        cargs.extend([a for c in [mrcalc_real_cargs(s, execution) for s in params.get("real", None)] for a in c])
    if params.get("imag", None) is not None:
        cargs.extend([a for c in [mrcalc_imag_cargs(s, execution) for s in params.get("imag", None)] for a in c])
    if params.get("phase", None) is not None:
        cargs.extend([a for c in [mrcalc_phase_cargs(s, execution) for s in params.get("phase", None)] for a in c])
    if params.get("conj", None) is not None:
        cargs.extend([a for c in [mrcalc_conj_cargs(s, execution) for s in params.get("conj", None)] for a in c])
    if params.get("proj", None) is not None:
        cargs.extend([a for c in [mrcalc_proj_cargs(s, execution) for s in params.get("proj", None)] for a in c])
    if params.get("exp", None) is not None:
        cargs.extend([a for c in [mrcalc_exp_cargs(s, execution) for s in params.get("exp", None)] for a in c])
    if params.get("log", None) is not None:
        cargs.extend([a for c in [mrcalc_log_cargs(s, execution) for s in params.get("log", None)] for a in c])
    if params.get("log10", None) is not None:
        cargs.extend([a for c in [mrcalc_log10_cargs(s, execution) for s in params.get("log10", None)] for a in c])
    if params.get("cos", None) is not None:
        cargs.extend([a for c in [mrcalc_cos_cargs(s, execution) for s in params.get("cos", None)] for a in c])
    if params.get("sin", None) is not None:
        cargs.extend([a for c in [mrcalc_sin_cargs(s, execution) for s in params.get("sin", None)] for a in c])
    if params.get("tan", None) is not None:
        cargs.extend([a for c in [mrcalc_tan_cargs(s, execution) for s in params.get("tan", None)] for a in c])
    if params.get("acos", None) is not None:
        cargs.extend([a for c in [mrcalc_acos_cargs(s, execution) for s in params.get("acos", None)] for a in c])
    if params.get("asin", None) is not None:
        cargs.extend([a for c in [mrcalc_asin_cargs(s, execution) for s in params.get("asin", None)] for a in c])
    if params.get("atan", None) is not None:
        cargs.extend([a for c in [mrcalc_atan_cargs(s, execution) for s in params.get("atan", None)] for a in c])
    if params.get("cosh", None) is not None:
        cargs.extend([a for c in [mrcalc_cosh_cargs(s, execution) for s in params.get("cosh", None)] for a in c])
    if params.get("sinh", None) is not None:
        cargs.extend([a for c in [mrcalc_sinh_cargs(s, execution) for s in params.get("sinh", None)] for a in c])
    if params.get("tanh", None) is not None:
        cargs.extend([a for c in [mrcalc_tanh_cargs(s, execution) for s in params.get("tanh", None)] for a in c])
    if params.get("acosh", None) is not None:
        cargs.extend([a for c in [mrcalc_acosh_cargs(s, execution) for s in params.get("acosh", None)] for a in c])
    if params.get("asinh", None) is not None:
        cargs.extend([a for c in [mrcalc_asinh_cargs(s, execution) for s in params.get("asinh", None)] for a in c])
    if params.get("atanh", None) is not None:
        cargs.extend([a for c in [mrcalc_atanh_cargs(s, execution) for s in params.get("atanh", None)] for a in c])
    if params.get("datatype", None) is not None:
        cargs.extend([
            "-datatype",
            params.get("datatype", None)
        ])
    if params.get("info", False):
        cargs.append("-info")
    if params.get("quiet", False):
        cargs.append("-quiet")
    if params.get("debug", False):
        cargs.append("-debug")
    if params.get("force", False):
        cargs.append("-force")
    if params.get("nthreads", None) is not None:
        cargs.extend([
            "-nthreads",
            str(params.get("nthreads", None))
        ])
    if params.get("config", None) is not None:
        cargs.extend([a for c in [mrcalc_config_cargs(s, execution) for s in params.get("config", None)] for a in c])
    if params.get("help", False):
        cargs.append("-help")
    if params.get("version", False):
        cargs.append("-version")
    cargs.extend([a for c in [mrcalc_operand_cargs_dyn_fn(s["@type"])(s, execution) for s in params.get("operand", None)] for a in c])
    return cargs


def mrcalc_outputs(
    params: MrcalcParamsDict,
    execution: Execution,
) -> MrcalcOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MrcalcOutputs(
        root=execution.output_file("."),
    )
    return ret


def mrcalc_execute(
    params: MrcalcParamsDict,
    runner: Runner | None = None,
) -> MrcalcOutputs:
    """
    mrcalc
    
    Apply generic voxel-wise mathematical operations to images.
    
    This command will only compute per-voxel operations. Use 'mrmath' to compute
    summary statistics across images or along image axes.
    
    This command uses a stack-based syntax, with operators (specified using
    options) operating on the top-most entries (i.e. images or values) in the
    stack. Operands (values or images) are pushed onto the stack in the order
    they appear (as arguments) on the command-line, and operators (specified as
    options) operate on and consume the top-most entries in the stack, and push
    their output as a new entry on the stack.
    
    As an additional feature, this command will allow images with different
    dimensions to be processed, provided they satisfy the following conditions:
    for each axis, the dimensions match if they are the same size, or one of
    them has size one. In the latter case, the entire image will be replicated
    along that axis. This allows for example a 4D image of size [ X Y Z N ] to
    be added to a 3D image of size [ X Y Z ], as if it consisted of N copies of
    the 3D image along the 4th axis (the missing dimension is assumed to have
    size 1). Another example would a single-voxel 4D image of size [ 1 1 1 N ],
    multiplied by a 3D image of size [ X Y Z ], which would allow the creation
    of a 4D image where each volume consists of the 3D image scaled by the
    corresponding value for that volume in the single-voxel image.
    
    References:
    
    .
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrcalcOutputs`).
    """
    mrcalc_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRCALC_METADATA)
    params = execution.params(params)
    cargs = mrcalc_cargs(params, execution)
    ret = mrcalc_outputs(params, execution)
    execution.run(cargs)
    return ret


def mrcalc(
    operand: list[typing.Union[MrcalcVariousStringParamsDictTagged, MrcalcVariousFileParamsDictTagged]],
    abs_: list[MrcalcAbsParamsDict] | None = None,
    neg: list[MrcalcNegParamsDict] | None = None,
    add: list[MrcalcAddParamsDict] | None = None,
    subtract: list[MrcalcSubtractParamsDict] | None = None,
    multiply: list[MrcalcMultiplyParamsDict] | None = None,
    divide: list[MrcalcDivideParamsDict] | None = None,
    min_: list[MrcalcMinParamsDict] | None = None,
    max_: list[MrcalcMaxParamsDict] | None = None,
    lt: list[MrcalcLtParamsDict] | None = None,
    gt: list[MrcalcGtParamsDict] | None = None,
    le: list[MrcalcLeParamsDict] | None = None,
    ge: list[MrcalcGeParamsDict] | None = None,
    eq: list[MrcalcEqParamsDict] | None = None,
    neq: list[MrcalcNeqParamsDict] | None = None,
    if_: list[MrcalcIfParamsDict] | None = None,
    replace: list[MrcalcReplaceParamsDict] | None = None,
    sqrt: list[MrcalcSqrtParamsDict] | None = None,
    pow_: list[MrcalcPowParamsDict] | None = None,
    round_: list[MrcalcRoundParamsDict] | None = None,
    ceil: list[MrcalcCeilParamsDict] | None = None,
    floor: list[MrcalcFloorParamsDict] | None = None,
    not_: list[MrcalcNotParamsDict] | None = None,
    and_: list[MrcalcAndParamsDict] | None = None,
    or_: list[MrcalcOrParamsDict] | None = None,
    xor: list[MrcalcXorParamsDict] | None = None,
    isnan: list[MrcalcIsnanParamsDict] | None = None,
    isinf: list[MrcalcIsinfParamsDict] | None = None,
    finite: list[MrcalcFiniteParamsDict] | None = None,
    complex_: list[MrcalcComplexParamsDict] | None = None,
    polar: list[MrcalcPolarParamsDict] | None = None,
    real: list[MrcalcRealParamsDict] | None = None,
    imag: list[MrcalcImagParamsDict] | None = None,
    phase: list[MrcalcPhaseParamsDict] | None = None,
    conj: list[MrcalcConjParamsDict] | None = None,
    proj: list[MrcalcProjParamsDict] | None = None,
    exp: list[MrcalcExpParamsDict] | None = None,
    log: list[MrcalcLogParamsDict] | None = None,
    log10: list[MrcalcLog10ParamsDict] | None = None,
    cos: list[MrcalcCosParamsDict] | None = None,
    sin: list[MrcalcSinParamsDict] | None = None,
    tan: list[MrcalcTanParamsDict] | None = None,
    acos: list[MrcalcAcosParamsDict] | None = None,
    asin: list[MrcalcAsinParamsDict] | None = None,
    atan: list[MrcalcAtanParamsDict] | None = None,
    cosh: list[MrcalcCoshParamsDict] | None = None,
    sinh: list[MrcalcSinhParamsDict] | None = None,
    tanh: list[MrcalcTanhParamsDict] | None = None,
    acosh: list[MrcalcAcoshParamsDict] | None = None,
    asinh: list[MrcalcAsinhParamsDict] | None = None,
    atanh: list[MrcalcAtanhParamsDict] | None = None,
    datatype: str | None = None,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[MrcalcConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> MrcalcOutputs:
    """
    mrcalc
    
    Apply generic voxel-wise mathematical operations to images.
    
    This command will only compute per-voxel operations. Use 'mrmath' to compute
    summary statistics across images or along image axes.
    
    This command uses a stack-based syntax, with operators (specified using
    options) operating on the top-most entries (i.e. images or values) in the
    stack. Operands (values or images) are pushed onto the stack in the order
    they appear (as arguments) on the command-line, and operators (specified as
    options) operate on and consume the top-most entries in the stack, and push
    their output as a new entry on the stack.
    
    As an additional feature, this command will allow images with different
    dimensions to be processed, provided they satisfy the following conditions:
    for each axis, the dimensions match if they are the same size, or one of
    them has size one. In the latter case, the entire image will be replicated
    along that axis. This allows for example a 4D image of size [ X Y Z N ] to
    be added to a 3D image of size [ X Y Z ], as if it consisted of N copies of
    the 3D image along the 4th axis (the missing dimension is assumed to have
    size 1). Another example would a single-voxel 4D image of size [ 1 1 1 N ],
    multiplied by a 3D image of size [ X Y Z ], which would allow the creation
    of a 4D image where each volume consists of the 3D image scaled by the
    corresponding value for that volume in the single-voxel image.
    
    References:
    
    .
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        operand: an input image, intensity value, or the special keywords\
            'rand' (random number between 0 and 1) or 'randn' (random number from\
            unit std.dev. normal distribution) or the mathematical constants 'e'\
            and 'pi'.
        abs_: |%1| : return absolute value (magnitude) of real or complex\
            number.
        neg: -%1 : negative value.
        add: (%1 + %2) : add values.
        subtract: (%1 - %2) : subtract nth operand from (n-1)th.
        multiply: (%1 * %2) : multiply values.
        divide: (%1 / %2) : divide (n-1)th operand by nth.
        min_: min (%1, %2) : smallest of last two operands.
        max_: max (%1, %2) : greatest of last two operands.
        lt: (%1 < %2) : less-than operator (true=1, false=0).
        gt: (%1 > %2) : greater-than operator (true=1, false=0).
        le: (%1 <= %2) : less-than-or-equal-to operator (true=1, false=0).
        ge: (%1 >= %2) : greater-than-or-equal-to operator (true=1, false=0).
        eq: (%1 == %2) : equal-to operator (true=1, false=0).
        neq: (%1 != %2) : not-equal-to operator (true=1, false=0).
        if_: (%1 ? %2 : %3) : if first operand is true (non-zero), return\
            second operand, otherwise return third operand.
        replace: (%1, %2 -> %3) : Wherever first operand is equal to the second\
            operand, replace with third operand.
        sqrt: sqrt (%1) : square root.
        pow_: %1^%2 : raise (n-1)th operand to nth power.
        round_: round (%1) : round to nearest integer.
        ceil: ceil (%1) : round up to nearest integer.
        floor: floor (%1) : round down to nearest integer.
        not_: !%1 : NOT operator: true (1) if operand is false (i.e. zero).
        and_: (%1 && %2) : AND operator: true (1) if both operands are true\
            (i.e. non-zero).
        or_: (%1 || %2) : OR operator: true (1) if either operand is true (i.e.\
            non-zero).
        xor: (%1 ^^ %2) : XOR operator: true (1) if only one of the operands is\
            true (i.e. non-zero).
        isnan: isnan (%1) : true (1) if operand is not-a-number (NaN).
        isinf: isinf (%1) : true (1) if operand is infinite (Inf).
        finite: finite (%1) : true (1) if operand is finite (i.e. not NaN or\
            Inf).
        complex_: (%1 + %2 i) : create complex number using the last two\
            operands as real,imaginary components.
        polar: (%1 /_ %2) : create complex number using the last two operands\
            as magnitude,phase components (phase in radians).
        real: real (%1) : real part of complex number.
        imag: imag (%1) : imaginary part of complex number.
        phase: phase (%1) : phase of complex number (use -abs for magnitude).
        conj: conj (%1) : complex conjugate.
        proj: proj (%1) : projection onto the Riemann sphere.
        exp: exp (%1) : exponential function.
        log: log (%1) : natural logarithm.
        log10: log10 (%1) : common logarithm.
        cos: cos (%1) : cosine.
        sin: sin (%1) : sine.
        tan: tan (%1) : tangent.
        acos: acos (%1) : inverse cosine.
        asin: asin (%1) : inverse sine.
        atan: atan (%1) : inverse tangent.
        cosh: cosh (%1) : hyperbolic cosine.
        sinh: sinh (%1) : hyperbolic sine.
        tanh: tanh (%1) : hyperbolic tangent.
        acosh: acosh (%1) : inverse hyperbolic cosine.
        asinh: asinh (%1) : inverse hyperbolic sine.
        atanh: atanh (%1) : inverse hyperbolic tangent.
        datatype: specify output image data type. Valid choices are: float32,\
            float32le, float32be, float64, float64le, float64be, int64, uint64,\
            int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le,\
            int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be,\
            cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be,\
            int8, uint8, bit.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrcalcOutputs`).
    """
    params = mrcalc_params(
        abs_=abs_,
        neg=neg,
        add=add,
        subtract=subtract,
        multiply=multiply,
        divide=divide,
        min_=min_,
        max_=max_,
        lt=lt,
        gt=gt,
        le=le,
        ge=ge,
        eq=eq,
        neq=neq,
        if_=if_,
        replace=replace,
        sqrt=sqrt,
        pow_=pow_,
        round_=round_,
        ceil=ceil,
        floor=floor,
        not_=not_,
        and_=and_,
        or_=or_,
        xor=xor,
        isnan=isnan,
        isinf=isinf,
        finite=finite,
        complex_=complex_,
        polar=polar,
        real=real,
        imag=imag,
        phase=phase,
        conj=conj,
        proj=proj,
        exp=exp,
        log=log,
        log10=log10,
        cos=cos,
        sin=sin,
        tan=tan,
        acos=acos,
        asin=asin,
        atan=atan,
        cosh=cosh,
        sinh=sinh,
        tanh=tanh,
        acosh=acosh,
        asinh=asinh,
        atanh=atanh,
        datatype=datatype,
        info=info,
        quiet=quiet,
        debug=debug,
        force=force,
        nthreads=nthreads,
        config=config,
        help_=help_,
        version=version,
        operand=operand,
    )
    return mrcalc_execute(params, runner)


__all__ = [
    "MRCALC_METADATA",
    "MrcalcAbsParamsDict",
    "MrcalcAbsParamsDictTagged",
    "MrcalcAcosParamsDict",
    "MrcalcAcosParamsDictTagged",
    "MrcalcAcoshParamsDict",
    "MrcalcAcoshParamsDictTagged",
    "MrcalcAddParamsDict",
    "MrcalcAddParamsDictTagged",
    "MrcalcAndParamsDict",
    "MrcalcAndParamsDictTagged",
    "MrcalcAsinParamsDict",
    "MrcalcAsinParamsDictTagged",
    "MrcalcAsinhParamsDict",
    "MrcalcAsinhParamsDictTagged",
    "MrcalcAtanParamsDict",
    "MrcalcAtanParamsDictTagged",
    "MrcalcAtanhParamsDict",
    "MrcalcAtanhParamsDictTagged",
    "MrcalcCeilParamsDict",
    "MrcalcCeilParamsDictTagged",
    "MrcalcComplexParamsDict",
    "MrcalcComplexParamsDictTagged",
    "MrcalcConfigParamsDict",
    "MrcalcConfigParamsDictTagged",
    "MrcalcConjParamsDict",
    "MrcalcConjParamsDictTagged",
    "MrcalcCosParamsDict",
    "MrcalcCosParamsDictTagged",
    "MrcalcCoshParamsDict",
    "MrcalcCoshParamsDictTagged",
    "MrcalcDivideParamsDict",
    "MrcalcDivideParamsDictTagged",
    "MrcalcEqParamsDict",
    "MrcalcEqParamsDictTagged",
    "MrcalcExpParamsDict",
    "MrcalcExpParamsDictTagged",
    "MrcalcFiniteParamsDict",
    "MrcalcFiniteParamsDictTagged",
    "MrcalcFloorParamsDict",
    "MrcalcFloorParamsDictTagged",
    "MrcalcGeParamsDict",
    "MrcalcGeParamsDictTagged",
    "MrcalcGtParamsDict",
    "MrcalcGtParamsDictTagged",
    "MrcalcIfParamsDict",
    "MrcalcIfParamsDictTagged",
    "MrcalcImagParamsDict",
    "MrcalcImagParamsDictTagged",
    "MrcalcIsinfParamsDict",
    "MrcalcIsinfParamsDictTagged",
    "MrcalcIsnanParamsDict",
    "MrcalcIsnanParamsDictTagged",
    "MrcalcLeParamsDict",
    "MrcalcLeParamsDictTagged",
    "MrcalcLog10ParamsDict",
    "MrcalcLog10ParamsDictTagged",
    "MrcalcLogParamsDict",
    "MrcalcLogParamsDictTagged",
    "MrcalcLtParamsDict",
    "MrcalcLtParamsDictTagged",
    "MrcalcMaxParamsDict",
    "MrcalcMaxParamsDictTagged",
    "MrcalcMinParamsDict",
    "MrcalcMinParamsDictTagged",
    "MrcalcMultiplyParamsDict",
    "MrcalcMultiplyParamsDictTagged",
    "MrcalcNegParamsDict",
    "MrcalcNegParamsDictTagged",
    "MrcalcNeqParamsDict",
    "MrcalcNeqParamsDictTagged",
    "MrcalcNotParamsDict",
    "MrcalcNotParamsDictTagged",
    "MrcalcOrParamsDict",
    "MrcalcOrParamsDictTagged",
    "MrcalcOutputs",
    "MrcalcParamsDict",
    "MrcalcParamsDictTagged",
    "MrcalcPhaseParamsDict",
    "MrcalcPhaseParamsDictTagged",
    "MrcalcPolarParamsDict",
    "MrcalcPolarParamsDictTagged",
    "MrcalcPowParamsDict",
    "MrcalcPowParamsDictTagged",
    "MrcalcProjParamsDict",
    "MrcalcProjParamsDictTagged",
    "MrcalcRealParamsDict",
    "MrcalcRealParamsDictTagged",
    "MrcalcReplaceParamsDict",
    "MrcalcReplaceParamsDictTagged",
    "MrcalcRoundParamsDict",
    "MrcalcRoundParamsDictTagged",
    "MrcalcSinParamsDict",
    "MrcalcSinParamsDictTagged",
    "MrcalcSinhParamsDict",
    "MrcalcSinhParamsDictTagged",
    "MrcalcSqrtParamsDict",
    "MrcalcSqrtParamsDictTagged",
    "MrcalcSubtractParamsDict",
    "MrcalcSubtractParamsDictTagged",
    "MrcalcTanParamsDict",
    "MrcalcTanParamsDictTagged",
    "MrcalcTanhParamsDict",
    "MrcalcTanhParamsDictTagged",
    "MrcalcVariousFileParamsDict",
    "MrcalcVariousFileParamsDictTagged",
    "MrcalcVariousStringParamsDict",
    "MrcalcVariousStringParamsDictTagged",
    "MrcalcXorParamsDict",
    "MrcalcXorParamsDictTagged",
    "mrcalc",
    "mrcalc_abs",
    "mrcalc_acos",
    "mrcalc_acosh",
    "mrcalc_add",
    "mrcalc_and",
    "mrcalc_asin",
    "mrcalc_asinh",
    "mrcalc_atan",
    "mrcalc_atanh",
    "mrcalc_ceil",
    "mrcalc_complex",
    "mrcalc_config",
    "mrcalc_conj",
    "mrcalc_cos",
    "mrcalc_cosh",
    "mrcalc_divide",
    "mrcalc_eq",
    "mrcalc_execute",
    "mrcalc_exp",
    "mrcalc_finite",
    "mrcalc_floor",
    "mrcalc_ge",
    "mrcalc_gt",
    "mrcalc_if",
    "mrcalc_imag",
    "mrcalc_isinf",
    "mrcalc_isnan",
    "mrcalc_le",
    "mrcalc_log",
    "mrcalc_log10",
    "mrcalc_lt",
    "mrcalc_max",
    "mrcalc_min",
    "mrcalc_multiply",
    "mrcalc_neg",
    "mrcalc_neq",
    "mrcalc_not",
    "mrcalc_or",
    "mrcalc_params",
    "mrcalc_phase",
    "mrcalc_polar",
    "mrcalc_pow",
    "mrcalc_proj",
    "mrcalc_real",
    "mrcalc_replace",
    "mrcalc_round",
    "mrcalc_sin",
    "mrcalc_sinh",
    "mrcalc_sqrt",
    "mrcalc_subtract",
    "mrcalc_tan",
    "mrcalc_tanh",
    "mrcalc_various_file",
    "mrcalc_various_string",
    "mrcalc_xor",
]
