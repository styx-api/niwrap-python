# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRTRANSFORM_METADATA = Metadata(
    id="3eb2d0d1d0da497152ef0293f2b94667de8b3275.boutiques",
    name="mrtransform",
    package="mrtrix",
    container_image_tag="mrtrix3/mrtrix3:3.0.4",
)


_MrtransformFslgradParamsDictNoTag = typing.TypedDict('_MrtransformFslgradParamsDictNoTag', {
    "bvecs": InputPathType,
    "bvals": InputPathType,
})
MrtransformFslgradParamsDictTagged = typing.TypedDict('MrtransformFslgradParamsDictTagged', {
    "@type": typing.Literal["fslgrad"],
    "bvecs": InputPathType,
    "bvals": InputPathType,
})
MrtransformFslgradParamsDict = _MrtransformFslgradParamsDictNoTag | MrtransformFslgradParamsDictTagged


_MrtransformExportGradFslParamsDictNoTag = typing.TypedDict('_MrtransformExportGradFslParamsDictNoTag', {
    "bvecs_path": str,
    "bvals_path": str,
})
MrtransformExportGradFslParamsDictTagged = typing.TypedDict('MrtransformExportGradFslParamsDictTagged', {
    "@type": typing.Literal["export_grad_fsl"],
    "bvecs_path": str,
    "bvals_path": str,
})
MrtransformExportGradFslParamsDict = _MrtransformExportGradFslParamsDictNoTag | MrtransformExportGradFslParamsDictTagged


_MrtransformVariousStringParamsDictNoTag = typing.TypedDict('_MrtransformVariousStringParamsDictNoTag', {
    "obj": str,
})
MrtransformVariousStringParamsDictTagged = typing.TypedDict('MrtransformVariousStringParamsDictTagged', {
    "@type": typing.Literal["VariousString"],
    "obj": str,
})
MrtransformVariousStringParamsDict = _MrtransformVariousStringParamsDictNoTag | MrtransformVariousStringParamsDictTagged


_MrtransformVariousFileParamsDictNoTag = typing.TypedDict('_MrtransformVariousFileParamsDictNoTag', {
    "obj": InputPathType,
})
MrtransformVariousFileParamsDictTagged = typing.TypedDict('MrtransformVariousFileParamsDictTagged', {
    "@type": typing.Literal["VariousFile"],
    "obj": InputPathType,
})
MrtransformVariousFileParamsDict = _MrtransformVariousFileParamsDictNoTag | MrtransformVariousFileParamsDictTagged


_MrtransformConfigParamsDictNoTag = typing.TypedDict('_MrtransformConfigParamsDictNoTag', {
    "key": str,
    "value": str,
})
MrtransformConfigParamsDictTagged = typing.TypedDict('MrtransformConfigParamsDictTagged', {
    "@type": typing.Literal["config"],
    "key": str,
    "value": str,
})
MrtransformConfigParamsDict = _MrtransformConfigParamsDictNoTag | MrtransformConfigParamsDictTagged


_MrtransformParamsDictNoTag = typing.TypedDict('_MrtransformParamsDictNoTag', {
    "linear": typing.NotRequired[InputPathType | None],
    "flip": typing.NotRequired[list[int] | None],
    "inverse": bool,
    "half": bool,
    "replace": typing.NotRequired[InputPathType | None],
    "identity": bool,
    "template": typing.NotRequired[InputPathType | None],
    "midway_space": bool,
    "interp": typing.NotRequired[str | None],
    "oversample": typing.NotRequired[list[int] | None],
    "warp": typing.NotRequired[InputPathType | None],
    "warp_full": typing.NotRequired[InputPathType | None],
    "from": typing.NotRequired[int | None],
    "modulate": typing.NotRequired[str | None],
    "directions": typing.NotRequired[InputPathType | None],
    "reorient_fod": typing.NotRequired[str | None],
    "grad": typing.NotRequired[InputPathType | None],
    "fslgrad": typing.NotRequired[MrtransformFslgradParamsDict | None],
    "export_grad_mrtrix": typing.NotRequired[str | None],
    "export_grad_fsl": typing.NotRequired[MrtransformExportGradFslParamsDict | None],
    "datatype": typing.NotRequired[str | None],
    "strides": typing.NotRequired[typing.Union[MrtransformVariousStringParamsDictTagged, MrtransformVariousFileParamsDictTagged] | None],
    "nan": bool,
    "no_reorientation": bool,
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[MrtransformConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "input": InputPathType,
    "output": str,
})
MrtransformParamsDictTagged = typing.TypedDict('MrtransformParamsDictTagged', {
    "@type": typing.Literal["mrtrix/mrtransform"],
    "linear": typing.NotRequired[InputPathType | None],
    "flip": typing.NotRequired[list[int] | None],
    "inverse": bool,
    "half": bool,
    "replace": typing.NotRequired[InputPathType | None],
    "identity": bool,
    "template": typing.NotRequired[InputPathType | None],
    "midway_space": bool,
    "interp": typing.NotRequired[str | None],
    "oversample": typing.NotRequired[list[int] | None],
    "warp": typing.NotRequired[InputPathType | None],
    "warp_full": typing.NotRequired[InputPathType | None],
    "from": typing.NotRequired[int | None],
    "modulate": typing.NotRequired[str | None],
    "directions": typing.NotRequired[InputPathType | None],
    "reorient_fod": typing.NotRequired[str | None],
    "grad": typing.NotRequired[InputPathType | None],
    "fslgrad": typing.NotRequired[MrtransformFslgradParamsDict | None],
    "export_grad_mrtrix": typing.NotRequired[str | None],
    "export_grad_fsl": typing.NotRequired[MrtransformExportGradFslParamsDict | None],
    "datatype": typing.NotRequired[str | None],
    "strides": typing.NotRequired[typing.Union[MrtransformVariousStringParamsDictTagged, MrtransformVariousFileParamsDictTagged] | None],
    "nan": bool,
    "no_reorientation": bool,
    "info": bool,
    "quiet": bool,
    "debug": bool,
    "force": bool,
    "nthreads": typing.NotRequired[int | None],
    "config": typing.NotRequired[list[MrtransformConfigParamsDict] | None],
    "help": bool,
    "version": bool,
    "input": InputPathType,
    "output": str,
})
MrtransformParamsDict = _MrtransformParamsDictNoTag | MrtransformParamsDictTagged


def mrtransform_strides_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "VariousString": mrtransform_various_string_cargs,
        "VariousFile": mrtransform_various_file_cargs,
    }.get(t)


def mrtransform_strides_validate_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get validate params function by command type.
    
    Args:
        t: Command type.
    Returns:
        Validate params function.
    """
    return {
        "VariousString": mrtransform_various_string_validate,
        "VariousFile": mrtransform_various_file_validate,
    }.get(t)


def mrtransform_fslgrad(
    bvecs: InputPathType,
    bvals: InputPathType,
) -> MrtransformFslgradParamsDictTagged:
    """
    Build parameters.
    
    Args:
        bvecs: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
        bvals: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fslgrad",
        "bvecs": bvecs,
        "bvals": bvals,
    }
    return params


def mrtransform_fslgrad_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrtransformFslgradParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("bvecs", None) is None:
        raise StyxValidationError("`bvecs` must not be None")
    if not isinstance(params["bvecs"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvecs` has the wrong type: Received `{type(params.get("bvecs", None))}` expected `InputPathType`')
    if params.get("bvals", None) is None:
        raise StyxValidationError("`bvals` must not be None")
    if not isinstance(params["bvals"], (pathlib.Path, str)):
        raise StyxValidationError(f'`bvals` has the wrong type: Received `{type(params.get("bvals", None))}` expected `InputPathType`')


def mrtransform_fslgrad_cargs(
    params: MrtransformFslgradParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-fslgrad")
    cargs.append(execution.input_file(params.get("bvecs", None)))
    cargs.append(execution.input_file(params.get("bvals", None)))
    return cargs


class MrtransformExportGradFslOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MrtransformExportGradFslParamsDict | None(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    bvecs_path: OutputPathType
    """export the diffusion-weighted gradient table to files in FSL (bvecs /
    bvals) format"""
    bvals_path: OutputPathType
    """export the diffusion-weighted gradient table to files in FSL (bvecs /
    bvals) format"""


def mrtransform_export_grad_fsl(
    bvecs_path: str,
    bvals_path: str,
) -> MrtransformExportGradFslParamsDictTagged:
    """
    Build parameters.
    
    Args:
        bvecs_path: export the diffusion-weighted gradient table to files in\
            FSL (bvecs / bvals) format.
        bvals_path: export the diffusion-weighted gradient table to files in\
            FSL (bvecs / bvals) format.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "export_grad_fsl",
        "bvecs_path": bvecs_path,
        "bvals_path": bvals_path,
    }
    return params


def mrtransform_export_grad_fsl_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrtransformExportGradFslParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("bvecs_path", None) is None:
        raise StyxValidationError("`bvecs_path` must not be None")
    if not isinstance(params["bvecs_path"], str):
        raise StyxValidationError(f'`bvecs_path` has the wrong type: Received `{type(params.get("bvecs_path", None))}` expected `str`')
    if params.get("bvals_path", None) is None:
        raise StyxValidationError("`bvals_path` must not be None")
    if not isinstance(params["bvals_path"], str):
        raise StyxValidationError(f'`bvals_path` has the wrong type: Received `{type(params.get("bvals_path", None))}` expected `str`')


def mrtransform_export_grad_fsl_cargs(
    params: MrtransformExportGradFslParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-export_grad_fsl")
    cargs.append(params.get("bvecs_path", None))
    cargs.append(params.get("bvals_path", None))
    return cargs


def mrtransform_export_grad_fsl_outputs(
    params: MrtransformExportGradFslParamsDict,
    execution: Execution,
) -> MrtransformExportGradFslOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MrtransformExportGradFslOutputs(
        root=execution.output_file("."),
        bvecs_path=execution.output_file(params.get("bvecs_path", None)),
        bvals_path=execution.output_file(params.get("bvals_path", None)),
    )
    return ret


def mrtransform_various_string(
    obj: str,
) -> MrtransformVariousStringParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: String object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousString",
        "obj": obj,
    }
    return params


def mrtransform_various_string_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrtransformVariousStringParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], str):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `str`')


def mrtransform_various_string_cargs(
    params: MrtransformVariousStringParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(params.get("obj", None))
    return cargs


def mrtransform_various_file(
    obj: InputPathType,
) -> MrtransformVariousFileParamsDictTagged:
    """
    Build parameters.
    
    Args:
        obj: File object.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "VariousFile",
        "obj": obj,
    }
    return params


def mrtransform_various_file_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrtransformVariousFileParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("obj", None) is None:
        raise StyxValidationError("`obj` must not be None")
    if not isinstance(params["obj"], (pathlib.Path, str)):
        raise StyxValidationError(f'`obj` has the wrong type: Received `{type(params.get("obj", None))}` expected `InputPathType`')


def mrtransform_various_file_cargs(
    params: MrtransformVariousFileParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("obj", None)))
    return cargs


def mrtransform_config(
    key: str,
    value: str,
) -> MrtransformConfigParamsDictTagged:
    """
    Build parameters.
    
    Args:
        key: temporarily set the value of an MRtrix config file entry.
        value: temporarily set the value of an MRtrix config file entry.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "config",
        "key": key,
        "value": value,
    }
    return params


def mrtransform_config_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrtransformConfigParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("key", None) is None:
        raise StyxValidationError("`key` must not be None")
    if not isinstance(params["key"], str):
        raise StyxValidationError(f'`key` has the wrong type: Received `{type(params.get("key", None))}` expected `str`')
    if params.get("value", None) is None:
        raise StyxValidationError("`value` must not be None")
    if not isinstance(params["value"], str):
        raise StyxValidationError(f'`value` has the wrong type: Received `{type(params.get("value", None))}` expected `str`')


def mrtransform_config_cargs(
    params: MrtransformConfigParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("-config")
    cargs.append(params.get("key", None))
    cargs.append(params.get("value", None))
    return cargs


class MrtransformOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MrtransformParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output: OutputPathType
    """the output image."""
    export_grad_mrtrix: OutputPathType | None
    """export the diffusion-weighted gradient table to file in MRtrix format """
    export_grad_fsl: MrtransformExportGradFslOutputs | None
    """Outputs from `mrtransform_export_grad_fsl_outputs`."""


def mrtransform_params(
    input_: InputPathType,
    output: str,
    linear: InputPathType | None = None,
    flip: list[int] | None = None,
    inverse: bool = False,
    half: bool = False,
    replace: InputPathType | None = None,
    identity: bool = False,
    template: InputPathType | None = None,
    midway_space: bool = False,
    interp: str | None = None,
    oversample: list[int] | None = None,
    warp: InputPathType | None = None,
    warp_full: InputPathType | None = None,
    from_: int | None = None,
    modulate: str | None = None,
    directions: InputPathType | None = None,
    reorient_fod: str | None = None,
    grad: InputPathType | None = None,
    fslgrad: MrtransformFslgradParamsDict | None = None,
    export_grad_mrtrix: str | None = None,
    export_grad_fsl: MrtransformExportGradFslParamsDict | None = None,
    datatype: str | None = None,
    strides: typing.Union[MrtransformVariousStringParamsDictTagged, MrtransformVariousFileParamsDictTagged] | None = None,
    nan: bool = False,
    no_reorientation: bool = False,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[MrtransformConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
) -> MrtransformParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_: input image to be transformed.
        output: the output image.
        linear: specify a linear transform to apply, in the form of a 3x4 or\
            4x4 ascii file. Note the standard 'reverse' convention is used, where\
            the transform maps points in the template image to the moving image.\
            Note that the reverse convention is still assumed even if no -template\
            image is supplied.
        flip: flip the specified axes, provided as a comma-separated list of\
            indices (0:x, 1:y, 2:z).
        inverse: apply the inverse transformation.
        half: apply the matrix square root of the transformation. This can be\
            combined with the inverse option.
        replace: replace the linear transform of the original image by that\
            specified, rather than applying it to the original image. The specified\
            transform can be either a template image, or a 3x4 or 4x4 ascii file.
        identity: set the header transform of the image to the identity matrix.
        template: reslice the input image to match the specified template image\
            grid.
        midway_space: reslice the input image to the midway space. Requires\
            either the -template or -warp option. If used with -template and\
            -linear option the input image will be resliced onto the grid halfway\
            between the input and template. If used with the -warp option the input\
            will be warped to the midway space defined by the grid of the input\
            warp (i.e. half way between image1 and image2).
        interp: set the interpolation method to use when reslicing (choices:\
            nearest, linear, cubic, sinc. Default: cubic).
        oversample: set the amount of over-sampling (in the target space) to\
            perform when regridding. This is particularly relevant when downsamping\
            a high-resolution image to a low-resolution image, to avoid aliasing\
            artefacts. This can consist of a single integer, or a comma-separated\
            list of 3 integers if different oversampling factors are desired along\
            the different axes. Default is determined from ratio of voxel\
            dimensions (disabled for nearest-neighbour interpolation).
        warp: apply a non-linear 4D deformation field to warp the input image.\
            Each voxel in the deformation field must define the scanner space\
            position that will be used to interpolate the input image during\
            warping (i.e. pull-back/reverse warp convention). If the -template\
            image is also supplied the deformation field will be resliced first to\
            the template image grid. If no -template option is supplied then the\
            output image will have the same image grid as the deformation field.\
            This option can be used in combination with the -affine option, in\
            which case the affine will be applied first).
        warp_full: warp the input image using a 5D warp file output from\
            mrregister. Any linear transforms in the warp image header will also be\
            applied. The -warp_full option must be used in combination with either\
            the -template option or the -midway_space option. If a -template image\
            is supplied then the full warp will be used. By default the\
            image1->image2 transform will be applied, however the -from 2 option\
            can be used to apply the image2->image1 transform. Use the\
            -midway_space option to warp the input image to the midway space. The\
            -from option can also be used to define which warp to use when\
            transforming to midway space.
        from_: used to define which space the input image is when using the\
            -warp_mid option. Use -from 1 to warp from image1 or -from 2 to warp\
            from image2.
        modulate: Valid choices are: fod and jac.\
            fod: modulate FODs during reorientation to preserve the apparent\
            fibre density across fibre bundle widths before and after the\
            transformation.\
            jac: modulate the image intensity with the determinant of the\
            Jacobian of the warp of linear transformation to preserve the total\
            intensity before and after the transformation.
        directions: directions defining the number and orientation of the\
            apodised point spread functions used in FOD reorientation (Default: 300\
            directions).
        reorient_fod: specify whether to perform FOD reorientation. This is\
            required if the number of volumes in the 4th dimension corresponds to\
            the number of coefficients in an antipodally symmetric spherical\
            harmonic series with lmax >= 2 (i.e. 6, 15, 28, 45, 66 volumes).
        grad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in a text file. This should be supplied as a 4xN text file\
            with each line is in the format [ X Y Z b ], where [ X Y Z ] describe\
            the direction of the applied gradient, and b gives the b-value in units\
            of s/mm^2. If a diffusion gradient scheme is present in the input image\
            header, the data provided with this option will be instead used.
        fslgrad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
        export_grad_mrtrix: export the diffusion-weighted gradient table to\
            file in MRtrix format.
        export_grad_fsl: export the diffusion-weighted gradient table to files\
            in FSL (bvecs / bvals) format.
        datatype: specify output image data type. Valid choices are: float32,\
            float32le, float32be, float64, float64le, float64be, int64, uint64,\
            int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le,\
            int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be,\
            cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be,\
            int8, uint8, bit.
        strides: specify the strides of the output data in memory; either as a\
            comma-separated list of (signed) integers, or as a template image from\
            which the strides shall be extracted and used. The actual strides\
            produced will depend on whether the output image format can support it.
        nan: Use NaN as the out of bounds value (Default: 0.0).
        no_reorientation: deprecated, use -reorient_fod instead.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "mrtrix/mrtransform",
        "inverse": inverse,
        "half": half,
        "identity": identity,
        "midway_space": midway_space,
        "nan": nan,
        "no_reorientation": no_reorientation,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help_,
        "version": version,
        "input": input_,
        "output": output,
    }
    if linear is not None:
        params["linear"] = linear
    if flip is not None:
        params["flip"] = flip
    if replace is not None:
        params["replace"] = replace
    if template is not None:
        params["template"] = template
    if interp is not None:
        params["interp"] = interp
    if oversample is not None:
        params["oversample"] = oversample
    if warp is not None:
        params["warp"] = warp
    if warp_full is not None:
        params["warp_full"] = warp_full
    if from_ is not None:
        params["from"] = from_
    if modulate is not None:
        params["modulate"] = modulate
    if directions is not None:
        params["directions"] = directions
    if reorient_fod is not None:
        params["reorient_fod"] = reorient_fod
    if grad is not None:
        params["grad"] = grad
    if fslgrad is not None:
        params["fslgrad"] = fslgrad
    if export_grad_mrtrix is not None:
        params["export_grad_mrtrix"] = export_grad_mrtrix
    if export_grad_fsl is not None:
        params["export_grad_fsl"] = export_grad_fsl
    if datatype is not None:
        params["datatype"] = datatype
    if strides is not None:
        params["strides"] = strides
    if nthreads is not None:
        params["nthreads"] = nthreads
    if config is not None:
        params["config"] = config
    return params


def mrtransform_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrtransformParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("linear", None) is not None:
        if not isinstance(params["linear"], (pathlib.Path, str)):
            raise StyxValidationError(f'`linear` has the wrong type: Received `{type(params.get("linear", None))}` expected `InputPathType | None`')
    if params.get("flip", None) is not None:
        if not isinstance(params["flip"], list):
            raise StyxValidationError(f'`flip` has the wrong type: Received `{type(params.get("flip", None))}` expected `list[int] | None`')
        for e in params["flip"]:
            if not isinstance(e, int):
                raise StyxValidationError(f'`flip` has the wrong type: Received `{type(params.get("flip", None))}` expected `list[int] | None`')
    if params.get("inverse", False) is None:
        raise StyxValidationError("`inverse` must not be None")
    if not isinstance(params["inverse"], bool):
        raise StyxValidationError(f'`inverse` has the wrong type: Received `{type(params.get("inverse", False))}` expected `bool`')
    if params.get("half", False) is None:
        raise StyxValidationError("`half` must not be None")
    if not isinstance(params["half"], bool):
        raise StyxValidationError(f'`half` has the wrong type: Received `{type(params.get("half", False))}` expected `bool`')
    if params.get("replace", None) is not None:
        if not isinstance(params["replace"], (pathlib.Path, str)):
            raise StyxValidationError(f'`replace` has the wrong type: Received `{type(params.get("replace", None))}` expected `InputPathType | None`')
    if params.get("identity", False) is None:
        raise StyxValidationError("`identity` must not be None")
    if not isinstance(params["identity"], bool):
        raise StyxValidationError(f'`identity` has the wrong type: Received `{type(params.get("identity", False))}` expected `bool`')
    if params.get("template", None) is not None:
        if not isinstance(params["template"], (pathlib.Path, str)):
            raise StyxValidationError(f'`template` has the wrong type: Received `{type(params.get("template", None))}` expected `InputPathType | None`')
    if params.get("midway_space", False) is None:
        raise StyxValidationError("`midway_space` must not be None")
    if not isinstance(params["midway_space"], bool):
        raise StyxValidationError(f'`midway_space` has the wrong type: Received `{type(params.get("midway_space", False))}` expected `bool`')
    if params.get("interp", None) is not None:
        if not isinstance(params["interp"], str):
            raise StyxValidationError(f'`interp` has the wrong type: Received `{type(params.get("interp", None))}` expected `str | None`')
    if params.get("oversample", None) is not None:
        if not isinstance(params["oversample"], list):
            raise StyxValidationError(f'`oversample` has the wrong type: Received `{type(params.get("oversample", None))}` expected `list[int] | None`')
        for e in params["oversample"]:
            if not isinstance(e, int):
                raise StyxValidationError(f'`oversample` has the wrong type: Received `{type(params.get("oversample", None))}` expected `list[int] | None`')
    if params.get("warp", None) is not None:
        if not isinstance(params["warp"], (pathlib.Path, str)):
            raise StyxValidationError(f'`warp` has the wrong type: Received `{type(params.get("warp", None))}` expected `InputPathType | None`')
    if params.get("warp_full", None) is not None:
        if not isinstance(params["warp_full"], (pathlib.Path, str)):
            raise StyxValidationError(f'`warp_full` has the wrong type: Received `{type(params.get("warp_full", None))}` expected `InputPathType | None`')
    if params.get("from", None) is not None:
        if not isinstance(params["from"], int):
            raise StyxValidationError(f'`from` has the wrong type: Received `{type(params.get("from", None))}` expected `int | None`')
    if params.get("modulate", None) is not None:
        if not isinstance(params["modulate"], str):
            raise StyxValidationError(f'`modulate` has the wrong type: Received `{type(params.get("modulate", None))}` expected `str | None`')
    if params.get("directions", None) is not None:
        if not isinstance(params["directions"], (pathlib.Path, str)):
            raise StyxValidationError(f'`directions` has the wrong type: Received `{type(params.get("directions", None))}` expected `InputPathType | None`')
    if params.get("reorient_fod", None) is not None:
        if not isinstance(params["reorient_fod"], str):
            raise StyxValidationError(f'`reorient_fod` has the wrong type: Received `{type(params.get("reorient_fod", None))}` expected `str | None`')
    if params.get("grad", None) is not None:
        if not isinstance(params["grad"], (pathlib.Path, str)):
            raise StyxValidationError(f'`grad` has the wrong type: Received `{type(params.get("grad", None))}` expected `InputPathType | None`')
    if params.get("fslgrad", None) is not None:
        mrtransform_fslgrad_validate(params["fslgrad"])
    if params.get("export_grad_mrtrix", None) is not None:
        if not isinstance(params["export_grad_mrtrix"], str):
            raise StyxValidationError(f'`export_grad_mrtrix` has the wrong type: Received `{type(params.get("export_grad_mrtrix", None))}` expected `str | None`')
    if params.get("export_grad_fsl", None) is not None:
        mrtransform_export_grad_fsl_validate(params["export_grad_fsl"])
    if params.get("datatype", None) is not None:
        if not isinstance(params["datatype"], str):
            raise StyxValidationError(f'`datatype` has the wrong type: Received `{type(params.get("datatype", None))}` expected `str | None`')
    if params.get("strides", None) is not None:
        if not isinstance(params["strides"], dict):
            raise StyxValidationError(f'Params object has the wrong type \'{type(params["strides"])}\'')
        if "@type" not in params["strides"]:
            raise StyxValidationError("Params object is missing `@type`")
        if params["strides"]["@type"] not in ["VariousString", "VariousFile"]:
            raise StyxValidationError("Parameter `strides`s `@type` must be one of [\"VariousString\", \"VariousFile\"]")
        mrtransform_strides_validate_dyn_fn(params["strides"]["@type"])(params["strides"])
    if params.get("nan", False) is None:
        raise StyxValidationError("`nan` must not be None")
    if not isinstance(params["nan"], bool):
        raise StyxValidationError(f'`nan` has the wrong type: Received `{type(params.get("nan", False))}` expected `bool`')
    if params.get("no_reorientation", False) is None:
        raise StyxValidationError("`no_reorientation` must not be None")
    if not isinstance(params["no_reorientation"], bool):
        raise StyxValidationError(f'`no_reorientation` has the wrong type: Received `{type(params.get("no_reorientation", False))}` expected `bool`')
    if params.get("info", False) is None:
        raise StyxValidationError("`info` must not be None")
    if not isinstance(params["info"], bool):
        raise StyxValidationError(f'`info` has the wrong type: Received `{type(params.get("info", False))}` expected `bool`')
    if params.get("quiet", False) is None:
        raise StyxValidationError("`quiet` must not be None")
    if not isinstance(params["quiet"], bool):
        raise StyxValidationError(f'`quiet` has the wrong type: Received `{type(params.get("quiet", False))}` expected `bool`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("force", False) is None:
        raise StyxValidationError("`force` must not be None")
    if not isinstance(params["force"], bool):
        raise StyxValidationError(f'`force` has the wrong type: Received `{type(params.get("force", False))}` expected `bool`')
    if params.get("nthreads", None) is not None:
        if not isinstance(params["nthreads"], int):
            raise StyxValidationError(f'`nthreads` has the wrong type: Received `{type(params.get("nthreads", None))}` expected `int | None`')
    if params.get("config", None) is not None:
        if not isinstance(params["config"], list):
            raise StyxValidationError(f'`config` has the wrong type: Received `{type(params.get("config", None))}` expected `list[MrtransformConfigParamsDict] | None`')
        for e in params["config"]:
            mrtransform_config_validate(e)
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("input", None) is None:
        raise StyxValidationError("`input` must not be None")
    if not isinstance(params["input"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input` has the wrong type: Received `{type(params.get("input", None))}` expected `InputPathType`')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')


def mrtransform_cargs(
    params: MrtransformParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mrtransform")
    if params.get("linear", None) is not None:
        cargs.extend([
            "-linear",
            execution.input_file(params.get("linear", None))
        ])
    if params.get("flip", None) is not None:
        cargs.extend([
            "-flip",
            ",".join(map(str, params.get("flip", None)))
        ])
    if params.get("inverse", False):
        cargs.append("-inverse")
    if params.get("half", False):
        cargs.append("-half")
    if params.get("replace", None) is not None:
        cargs.extend([
            "-replace",
            execution.input_file(params.get("replace", None))
        ])
    if params.get("identity", False):
        cargs.append("-identity")
    if params.get("template", None) is not None:
        cargs.extend([
            "-template",
            execution.input_file(params.get("template", None))
        ])
    if params.get("midway_space", False):
        cargs.append("-midway_space")
    if params.get("interp", None) is not None:
        cargs.extend([
            "-interp",
            params.get("interp", None)
        ])
    if params.get("oversample", None) is not None:
        cargs.extend([
            "-oversample",
            ",".join(map(str, params.get("oversample", None)))
        ])
    if params.get("warp", None) is not None:
        cargs.extend([
            "-warp",
            execution.input_file(params.get("warp", None))
        ])
    if params.get("warp_full", None) is not None:
        cargs.extend([
            "-warp_full",
            execution.input_file(params.get("warp_full", None))
        ])
    if params.get("from", None) is not None:
        cargs.extend([
            "-from",
            str(params.get("from", None))
        ])
    if params.get("modulate", None) is not None:
        cargs.extend([
            "-modulate",
            params.get("modulate", None)
        ])
    if params.get("directions", None) is not None:
        cargs.extend([
            "-directions",
            execution.input_file(params.get("directions", None))
        ])
    if params.get("reorient_fod", None) is not None:
        cargs.extend([
            "-reorient_fod",
            params.get("reorient_fod", None)
        ])
    if params.get("grad", None) is not None:
        cargs.extend([
            "-grad",
            execution.input_file(params.get("grad", None))
        ])
    if params.get("fslgrad", None) is not None:
        cargs.extend(mrtransform_fslgrad_cargs(params.get("fslgrad", None), execution))
    if params.get("export_grad_mrtrix", None) is not None:
        cargs.extend([
            "-export_grad_mrtrix",
            params.get("export_grad_mrtrix", None)
        ])
    if params.get("export_grad_fsl", None) is not None:
        cargs.extend(mrtransform_export_grad_fsl_cargs(params.get("export_grad_fsl", None), execution))
    if params.get("datatype", None) is not None:
        cargs.extend([
            "-datatype",
            params.get("datatype", None)
        ])
    if params.get("strides", None) is not None:
        cargs.extend([
            "-strides",
            *mrtransform_strides_cargs_dyn_fn(params.get("strides", None)["@type"])(params.get("strides", None), execution)
        ])
    if params.get("nan", False):
        cargs.append("-nan")
    if params.get("no_reorientation", False):
        cargs.append("-no_reorientation")
    if params.get("info", False):
        cargs.append("-info")
    if params.get("quiet", False):
        cargs.append("-quiet")
    if params.get("debug", False):
        cargs.append("-debug")
    if params.get("force", False):
        cargs.append("-force")
    if params.get("nthreads", None) is not None:
        cargs.extend([
            "-nthreads",
            str(params.get("nthreads", None))
        ])
    if params.get("config", None) is not None:
        cargs.extend([a for c in [mrtransform_config_cargs(s, execution) for s in params.get("config", None)] for a in c])
    if params.get("help", False):
        cargs.append("-help")
    if params.get("version", False):
        cargs.append("-version")
    cargs.append(execution.input_file(params.get("input", None)))
    cargs.append(params.get("output", None))
    return cargs


def mrtransform_outputs(
    params: MrtransformParamsDict,
    execution: Execution,
) -> MrtransformOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MrtransformOutputs(
        root=execution.output_file("."),
        output=execution.output_file(params.get("output", None)),
        export_grad_mrtrix=execution.output_file(params.get("export_grad_mrtrix", None)) if (params.get("export_grad_mrtrix") is not None) else None,
        export_grad_fsl=mrtransform_export_grad_fsl_outputs(params.get("export_grad_fsl"), execution) if params.get("export_grad_fsl") else None,
    )
    return ret


def mrtransform_execute(
    params: MrtransformParamsDict,
    runner: Runner | None = None,
) -> MrtransformOutputs:
    """
    mrtransform
    
    Apply spatial transformations to an image.
    
    If a linear transform is applied without a template image the command will
    modify the image header transform matrix
    
    FOD reorientation (with apodised point spread functions) can be performed if
    the number of volumes in the 4th dimension equals the number of coefficients
    in an antipodally symmetric spherical harmonic series (e.g. 6, 15, 28 etc).
    For such data, the -reorient_fod yes/no option must be used to specify if
    reorientation is required.
    
    The output image intensity can be modulated using the (local or global)
    volume change if a linear or nonlinear transformation is applied. 'FOD'
    modulation preserves the apparent fibre density across the fibre bundle
    width and can only be applied if FOD reorientation is used. Alternatively,
    non-directional scaling by the Jacobian determinant can be applied to any
    image type.
    
    If a DW scheme is contained in the header (or specified separately), and the
    number of directions matches the number of volumes in the images, any
    transformation applied using the -linear option will also be applied to the
    directions.
    
    When the -template option is used to specify the target image grid, the
    image provided via this option will not influence the axis data strides of
    the output image; these are determined based on the input image, or the
    input to the -strides option.
    
    References:
    
    * If FOD reorientation is being performed:
    Raffelt, D.; Tournier, J.-D.; Crozier, S.; Connelly, A. & Salvado, O.
    Reorientation of fiber orientation distributions using apodized point spread
    functions. Magnetic Resonance in Medicine, 2012, 67, 844-855
    
    * If FOD modulation is being performed:
    Raffelt, D.; Tournier, J.-D.; Rose, S.; Ridgway, G.R.; Henderson, R.;
    Crozier, S.; Salvado, O.; Connelly, A.; Apparent Fibre Density: a novel
    measure for the analysis of diffusion-weighted magnetic resonance images.
    NeuroImage, 2012, 15;59(4), 3976-94.
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrtransformOutputs`).
    """
    mrtransform_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRTRANSFORM_METADATA)
    params = execution.params(params)
    cargs = mrtransform_cargs(params, execution)
    ret = mrtransform_outputs(params, execution)
    execution.run(cargs)
    return ret


def mrtransform(
    input_: InputPathType,
    output: str,
    linear: InputPathType | None = None,
    flip: list[int] | None = None,
    inverse: bool = False,
    half: bool = False,
    replace: InputPathType | None = None,
    identity: bool = False,
    template: InputPathType | None = None,
    midway_space: bool = False,
    interp: str | None = None,
    oversample: list[int] | None = None,
    warp: InputPathType | None = None,
    warp_full: InputPathType | None = None,
    from_: int | None = None,
    modulate: str | None = None,
    directions: InputPathType | None = None,
    reorient_fod: str | None = None,
    grad: InputPathType | None = None,
    fslgrad: MrtransformFslgradParamsDict | None = None,
    export_grad_mrtrix: str | None = None,
    export_grad_fsl: MrtransformExportGradFslParamsDict | None = None,
    datatype: str | None = None,
    strides: typing.Union[MrtransformVariousStringParamsDictTagged, MrtransformVariousFileParamsDictTagged] | None = None,
    nan: bool = False,
    no_reorientation: bool = False,
    info: bool = False,
    quiet: bool = False,
    debug: bool = False,
    force: bool = False,
    nthreads: int | None = None,
    config: list[MrtransformConfigParamsDict] | None = None,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> MrtransformOutputs:
    """
    mrtransform
    
    Apply spatial transformations to an image.
    
    If a linear transform is applied without a template image the command will
    modify the image header transform matrix
    
    FOD reorientation (with apodised point spread functions) can be performed if
    the number of volumes in the 4th dimension equals the number of coefficients
    in an antipodally symmetric spherical harmonic series (e.g. 6, 15, 28 etc).
    For such data, the -reorient_fod yes/no option must be used to specify if
    reorientation is required.
    
    The output image intensity can be modulated using the (local or global)
    volume change if a linear or nonlinear transformation is applied. 'FOD'
    modulation preserves the apparent fibre density across the fibre bundle
    width and can only be applied if FOD reorientation is used. Alternatively,
    non-directional scaling by the Jacobian determinant can be applied to any
    image type.
    
    If a DW scheme is contained in the header (or specified separately), and the
    number of directions matches the number of volumes in the images, any
    transformation applied using the -linear option will also be applied to the
    directions.
    
    When the -template option is used to specify the target image grid, the
    image provided via this option will not influence the axis data strides of
    the output image; these are determined based on the input image, or the
    input to the -strides option.
    
    References:
    
    * If FOD reorientation is being performed:
    Raffelt, D.; Tournier, J.-D.; Crozier, S.; Connelly, A. & Salvado, O.
    Reorientation of fiber orientation distributions using apodized point spread
    functions. Magnetic Resonance in Medicine, 2012, 67, 844-855
    
    * If FOD modulation is being performed:
    Raffelt, D.; Tournier, J.-D.; Rose, S.; Ridgway, G.R.; Henderson, R.;
    Crozier, S.; Salvado, O.; Connelly, A.; Apparent Fibre Density: a novel
    measure for the analysis of diffusion-weighted magnetic resonance images.
    NeuroImage, 2012, 15;59(4), 3976-94.
    
    Author: MRTrix3 Developers
    
    URL: https://www.mrtrix.org/
    
    Args:
        input_: input image to be transformed.
        output: the output image.
        linear: specify a linear transform to apply, in the form of a 3x4 or\
            4x4 ascii file. Note the standard 'reverse' convention is used, where\
            the transform maps points in the template image to the moving image.\
            Note that the reverse convention is still assumed even if no -template\
            image is supplied.
        flip: flip the specified axes, provided as a comma-separated list of\
            indices (0:x, 1:y, 2:z).
        inverse: apply the inverse transformation.
        half: apply the matrix square root of the transformation. This can be\
            combined with the inverse option.
        replace: replace the linear transform of the original image by that\
            specified, rather than applying it to the original image. The specified\
            transform can be either a template image, or a 3x4 or 4x4 ascii file.
        identity: set the header transform of the image to the identity matrix.
        template: reslice the input image to match the specified template image\
            grid.
        midway_space: reslice the input image to the midway space. Requires\
            either the -template or -warp option. If used with -template and\
            -linear option the input image will be resliced onto the grid halfway\
            between the input and template. If used with the -warp option the input\
            will be warped to the midway space defined by the grid of the input\
            warp (i.e. half way between image1 and image2).
        interp: set the interpolation method to use when reslicing (choices:\
            nearest, linear, cubic, sinc. Default: cubic).
        oversample: set the amount of over-sampling (in the target space) to\
            perform when regridding. This is particularly relevant when downsamping\
            a high-resolution image to a low-resolution image, to avoid aliasing\
            artefacts. This can consist of a single integer, or a comma-separated\
            list of 3 integers if different oversampling factors are desired along\
            the different axes. Default is determined from ratio of voxel\
            dimensions (disabled for nearest-neighbour interpolation).
        warp: apply a non-linear 4D deformation field to warp the input image.\
            Each voxel in the deformation field must define the scanner space\
            position that will be used to interpolate the input image during\
            warping (i.e. pull-back/reverse warp convention). If the -template\
            image is also supplied the deformation field will be resliced first to\
            the template image grid. If no -template option is supplied then the\
            output image will have the same image grid as the deformation field.\
            This option can be used in combination with the -affine option, in\
            which case the affine will be applied first).
        warp_full: warp the input image using a 5D warp file output from\
            mrregister. Any linear transforms in the warp image header will also be\
            applied. The -warp_full option must be used in combination with either\
            the -template option or the -midway_space option. If a -template image\
            is supplied then the full warp will be used. By default the\
            image1->image2 transform will be applied, however the -from 2 option\
            can be used to apply the image2->image1 transform. Use the\
            -midway_space option to warp the input image to the midway space. The\
            -from option can also be used to define which warp to use when\
            transforming to midway space.
        from_: used to define which space the input image is when using the\
            -warp_mid option. Use -from 1 to warp from image1 or -from 2 to warp\
            from image2.
        modulate: Valid choices are: fod and jac.\
            fod: modulate FODs during reorientation to preserve the apparent\
            fibre density across fibre bundle widths before and after the\
            transformation.\
            jac: modulate the image intensity with the determinant of the\
            Jacobian of the warp of linear transformation to preserve the total\
            intensity before and after the transformation.
        directions: directions defining the number and orientation of the\
            apodised point spread functions used in FOD reorientation (Default: 300\
            directions).
        reorient_fod: specify whether to perform FOD reorientation. This is\
            required if the number of volumes in the 4th dimension corresponds to\
            the number of coefficients in an antipodally symmetric spherical\
            harmonic series with lmax >= 2 (i.e. 6, 15, 28, 45, 66 volumes).
        grad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in a text file. This should be supplied as a 4xN text file\
            with each line is in the format [ X Y Z b ], where [ X Y Z ] describe\
            the direction of the applied gradient, and b gives the b-value in units\
            of s/mm^2. If a diffusion gradient scheme is present in the input image\
            header, the data provided with this option will be instead used.
        fslgrad: Provide the diffusion-weighted gradient scheme used in the\
            acquisition in FSL bvecs/bvals format files. If a diffusion gradient\
            scheme is present in the input image header, the data provided with\
            this option will be instead used.
        export_grad_mrtrix: export the diffusion-weighted gradient table to\
            file in MRtrix format.
        export_grad_fsl: export the diffusion-weighted gradient table to files\
            in FSL (bvecs / bvals) format.
        datatype: specify output image data type. Valid choices are: float32,\
            float32le, float32be, float64, float64le, float64be, int64, uint64,\
            int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le,\
            int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be,\
            cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be,\
            int8, uint8, bit.
        strides: specify the strides of the output data in memory; either as a\
            comma-separated list of (signed) integers, or as a template image from\
            which the strides shall be extracted and used. The actual strides\
            produced will depend on whether the output image format can support it.
        nan: Use NaN as the out of bounds value (Default: 0.0).
        no_reorientation: deprecated, use -reorient_fod instead.
        info: display information messages.
        quiet: do not display information messages or progress status;\
            alternatively, this can be achieved by setting the MRTRIX_QUIET\
            environment variable to a non-empty string.
        debug: display debugging messages.
        force: force overwrite of output files (caution: using the same file as\
            input and output might cause unexpected behaviour).
        nthreads: use this number of threads in multi-threaded applications\
            (set to 0 to disable multi-threading).
        config: temporarily set the value of an MRtrix config file entry.
        help_: display this information page and exit.
        version: display version information and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrtransformOutputs`).
    """
    params = mrtransform_params(
        linear=linear,
        flip=flip,
        inverse=inverse,
        half=half,
        replace=replace,
        identity=identity,
        template=template,
        midway_space=midway_space,
        interp=interp,
        oversample=oversample,
        warp=warp,
        warp_full=warp_full,
        from_=from_,
        modulate=modulate,
        directions=directions,
        reorient_fod=reorient_fod,
        grad=grad,
        fslgrad=fslgrad,
        export_grad_mrtrix=export_grad_mrtrix,
        export_grad_fsl=export_grad_fsl,
        datatype=datatype,
        strides=strides,
        nan=nan,
        no_reorientation=no_reorientation,
        info=info,
        quiet=quiet,
        debug=debug,
        force=force,
        nthreads=nthreads,
        config=config,
        help_=help_,
        version=version,
        input_=input_,
        output=output,
    )
    return mrtransform_execute(params, runner)


__all__ = [
    "MRTRANSFORM_METADATA",
    "MrtransformConfigParamsDict",
    "MrtransformConfigParamsDictTagged",
    "MrtransformExportGradFslOutputs",
    "MrtransformExportGradFslParamsDict",
    "MrtransformExportGradFslParamsDictTagged",
    "MrtransformFslgradParamsDict",
    "MrtransformFslgradParamsDictTagged",
    "MrtransformOutputs",
    "MrtransformParamsDict",
    "MrtransformParamsDictTagged",
    "MrtransformVariousFileParamsDict",
    "MrtransformVariousFileParamsDictTagged",
    "MrtransformVariousStringParamsDict",
    "MrtransformVariousStringParamsDictTagged",
    "mrtransform",
    "mrtransform_config",
    "mrtransform_execute",
    "mrtransform_export_grad_fsl",
    "mrtransform_fslgrad",
    "mrtransform_params",
    "mrtransform_various_file",
    "mrtransform_various_string",
]
