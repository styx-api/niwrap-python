# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

DCMDRLE_FS_METADATA = Metadata(
    id="f1d616215cb1ba8369eba24de9e2bdabd7a39054.boutiques",
    name="dcmdrle.fs",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_DcmdrleFsParamsDictNoTag = typing.TypedDict('_DcmdrleFsParamsDictNoTag', {
    "input_file": InputPathType,
    "output_file": str,
    "help": bool,
    "version": bool,
    "arguments": bool,
    "quiet": bool,
    "verbose": bool,
    "debug": bool,
    "log_level": typing.NotRequired[str | None],
    "log_config": typing.NotRequired[InputPathType | None],
    "read_file": bool,
    "read_file_only": bool,
    "read_dataset": bool,
    "uid_default": bool,
    "uid_always": bool,
    "byte_order_default": bool,
    "byte_order_reverse": bool,
    "write_file": bool,
    "write_dataset": bool,
    "write_xfer_little": bool,
    "write_xfer_big": bool,
    "write_xfer_implicit": bool,
    "enable_new_vr": bool,
    "disable_new_vr": bool,
    "group_length_recalc": bool,
    "group_length_create": bool,
    "group_length_remove": bool,
    "length_explicit": bool,
    "length_undefined": bool,
    "padding_retain": bool,
    "padding_off": bool,
    "padding_create": typing.NotRequired[str | None],
})
DcmdrleFsParamsDictTagged = typing.TypedDict('DcmdrleFsParamsDictTagged', {
    "@type": typing.Literal["freesurfer/dcmdrle.fs"],
    "input_file": InputPathType,
    "output_file": str,
    "help": bool,
    "version": bool,
    "arguments": bool,
    "quiet": bool,
    "verbose": bool,
    "debug": bool,
    "log_level": typing.NotRequired[str | None],
    "log_config": typing.NotRequired[InputPathType | None],
    "read_file": bool,
    "read_file_only": bool,
    "read_dataset": bool,
    "uid_default": bool,
    "uid_always": bool,
    "byte_order_default": bool,
    "byte_order_reverse": bool,
    "write_file": bool,
    "write_dataset": bool,
    "write_xfer_little": bool,
    "write_xfer_big": bool,
    "write_xfer_implicit": bool,
    "enable_new_vr": bool,
    "disable_new_vr": bool,
    "group_length_recalc": bool,
    "group_length_create": bool,
    "group_length_remove": bool,
    "length_explicit": bool,
    "length_undefined": bool,
    "padding_retain": bool,
    "padding_off": bool,
    "padding_create": typing.NotRequired[str | None],
})
DcmdrleFsParamsDict = _DcmdrleFsParamsDictNoTag | DcmdrleFsParamsDictTagged


class DcmdrleFsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `DcmdrleFsParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType
    """Output DICOM file."""


def dcmdrle_fs_params(
    input_file: InputPathType,
    output_file: str,
    help_: bool = False,
    version: bool = False,
    arguments: bool = False,
    quiet: bool = False,
    verbose: bool = False,
    debug: bool = False,
    log_level: str | None = None,
    log_config: InputPathType | None = None,
    read_file: bool = False,
    read_file_only: bool = False,
    read_dataset: bool = False,
    uid_default: bool = False,
    uid_always: bool = False,
    byte_order_default: bool = False,
    byte_order_reverse: bool = False,
    write_file: bool = False,
    write_dataset: bool = False,
    write_xfer_little: bool = False,
    write_xfer_big: bool = False,
    write_xfer_implicit: bool = False,
    enable_new_vr: bool = False,
    disable_new_vr: bool = False,
    group_length_recalc: bool = False,
    group_length_create: bool = False,
    group_length_remove: bool = False,
    length_explicit: bool = False,
    length_undefined: bool = False,
    padding_retain: bool = False,
    padding_off: bool = False,
    padding_create: str | None = None,
) -> DcmdrleFsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_file: DICOM input filename to be converted.
        output_file: DICOM output filename.
        help_: Print help text and exit.
        version: Print version information and exit.
        arguments: Print expanded command line arguments.
        quiet: Quiet mode, print no warnings and errors.
        verbose: Verbose mode, print processing details.
        debug: Debug mode, print debug information.
        log_level: Set logger level.
        log_config: Use config file for the logger.
        read_file: Read file format or data set (default).
        read_file_only: Read file format only.
        read_dataset: Read data set without file meta information.
        uid_default: Keep same SOP Instance UID (default).
        uid_always: Always assign new UID.
        byte_order_default: Most significant byte first (default).
        byte_order_reverse: Least significant byte first.
        write_file: Write file format (default).
        write_dataset: Write data set without file meta information.
        write_xfer_little: Write with explicit VR little endian (default).
        write_xfer_big: Write with explicit VR big endian TS.
        write_xfer_implicit: Write with implicit VR little endian TS.
        enable_new_vr: Enable support for new VRs (UN/UT) (default).
        disable_new_vr: Disable support for new VRs, convert to OB.
        group_length_recalc: Recalculate group lengths if present (default).
        group_length_create: Always write with group length elements.
        group_length_remove: Always write without group length elements.
        length_explicit: Write with explicit lengths (default).
        length_undefined: Write with undefined lengths.
        padding_retain: Do not change padding.
        padding_off: No padding (implicit if --write-dataset).
        padding_create: Align file on multiple of file-pad bytes and items on\
            multiple of item-pad bytes.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/dcmdrle.fs",
        "input_file": input_file,
        "output_file": output_file,
        "help": help_,
        "version": version,
        "arguments": arguments,
        "quiet": quiet,
        "verbose": verbose,
        "debug": debug,
        "read_file": read_file,
        "read_file_only": read_file_only,
        "read_dataset": read_dataset,
        "uid_default": uid_default,
        "uid_always": uid_always,
        "byte_order_default": byte_order_default,
        "byte_order_reverse": byte_order_reverse,
        "write_file": write_file,
        "write_dataset": write_dataset,
        "write_xfer_little": write_xfer_little,
        "write_xfer_big": write_xfer_big,
        "write_xfer_implicit": write_xfer_implicit,
        "enable_new_vr": enable_new_vr,
        "disable_new_vr": disable_new_vr,
        "group_length_recalc": group_length_recalc,
        "group_length_create": group_length_create,
        "group_length_remove": group_length_remove,
        "length_explicit": length_explicit,
        "length_undefined": length_undefined,
        "padding_retain": padding_retain,
        "padding_off": padding_off,
    }
    if log_level is not None:
        params["log_level"] = log_level
    if log_config is not None:
        params["log_config"] = log_config
    if padding_create is not None:
        params["padding_create"] = padding_create
    return params


def dcmdrle_fs_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `DcmdrleFsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input_file", None) is None:
        raise StyxValidationError("`input_file` must not be None")
    if not isinstance(params["input_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input_file` has the wrong type: Received `{type(params.get("input_file", None))}` expected `InputPathType`')
    if params.get("output_file", None) is None:
        raise StyxValidationError("`output_file` must not be None")
    if not isinstance(params["output_file"], str):
        raise StyxValidationError(f'`output_file` has the wrong type: Received `{type(params.get("output_file", None))}` expected `str`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("arguments", False) is None:
        raise StyxValidationError("`arguments` must not be None")
    if not isinstance(params["arguments"], bool):
        raise StyxValidationError(f'`arguments` has the wrong type: Received `{type(params.get("arguments", False))}` expected `bool`')
    if params.get("quiet", False) is None:
        raise StyxValidationError("`quiet` must not be None")
    if not isinstance(params["quiet"], bool):
        raise StyxValidationError(f'`quiet` has the wrong type: Received `{type(params.get("quiet", False))}` expected `bool`')
    if params.get("verbose", False) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], bool):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", False))}` expected `bool`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("log_level", None) is not None:
        if not isinstance(params["log_level"], str):
            raise StyxValidationError(f'`log_level` has the wrong type: Received `{type(params.get("log_level", None))}` expected `str | None`')
    if params.get("log_config", None) is not None:
        if not isinstance(params["log_config"], (pathlib.Path, str)):
            raise StyxValidationError(f'`log_config` has the wrong type: Received `{type(params.get("log_config", None))}` expected `InputPathType | None`')
    if params.get("read_file", False) is None:
        raise StyxValidationError("`read_file` must not be None")
    if not isinstance(params["read_file"], bool):
        raise StyxValidationError(f'`read_file` has the wrong type: Received `{type(params.get("read_file", False))}` expected `bool`')
    if params.get("read_file_only", False) is None:
        raise StyxValidationError("`read_file_only` must not be None")
    if not isinstance(params["read_file_only"], bool):
        raise StyxValidationError(f'`read_file_only` has the wrong type: Received `{type(params.get("read_file_only", False))}` expected `bool`')
    if params.get("read_dataset", False) is None:
        raise StyxValidationError("`read_dataset` must not be None")
    if not isinstance(params["read_dataset"], bool):
        raise StyxValidationError(f'`read_dataset` has the wrong type: Received `{type(params.get("read_dataset", False))}` expected `bool`')
    if params.get("uid_default", False) is None:
        raise StyxValidationError("`uid_default` must not be None")
    if not isinstance(params["uid_default"], bool):
        raise StyxValidationError(f'`uid_default` has the wrong type: Received `{type(params.get("uid_default", False))}` expected `bool`')
    if params.get("uid_always", False) is None:
        raise StyxValidationError("`uid_always` must not be None")
    if not isinstance(params["uid_always"], bool):
        raise StyxValidationError(f'`uid_always` has the wrong type: Received `{type(params.get("uid_always", False))}` expected `bool`')
    if params.get("byte_order_default", False) is None:
        raise StyxValidationError("`byte_order_default` must not be None")
    if not isinstance(params["byte_order_default"], bool):
        raise StyxValidationError(f'`byte_order_default` has the wrong type: Received `{type(params.get("byte_order_default", False))}` expected `bool`')
    if params.get("byte_order_reverse", False) is None:
        raise StyxValidationError("`byte_order_reverse` must not be None")
    if not isinstance(params["byte_order_reverse"], bool):
        raise StyxValidationError(f'`byte_order_reverse` has the wrong type: Received `{type(params.get("byte_order_reverse", False))}` expected `bool`')
    if params.get("write_file", False) is None:
        raise StyxValidationError("`write_file` must not be None")
    if not isinstance(params["write_file"], bool):
        raise StyxValidationError(f'`write_file` has the wrong type: Received `{type(params.get("write_file", False))}` expected `bool`')
    if params.get("write_dataset", False) is None:
        raise StyxValidationError("`write_dataset` must not be None")
    if not isinstance(params["write_dataset"], bool):
        raise StyxValidationError(f'`write_dataset` has the wrong type: Received `{type(params.get("write_dataset", False))}` expected `bool`')
    if params.get("write_xfer_little", False) is None:
        raise StyxValidationError("`write_xfer_little` must not be None")
    if not isinstance(params["write_xfer_little"], bool):
        raise StyxValidationError(f'`write_xfer_little` has the wrong type: Received `{type(params.get("write_xfer_little", False))}` expected `bool`')
    if params.get("write_xfer_big", False) is None:
        raise StyxValidationError("`write_xfer_big` must not be None")
    if not isinstance(params["write_xfer_big"], bool):
        raise StyxValidationError(f'`write_xfer_big` has the wrong type: Received `{type(params.get("write_xfer_big", False))}` expected `bool`')
    if params.get("write_xfer_implicit", False) is None:
        raise StyxValidationError("`write_xfer_implicit` must not be None")
    if not isinstance(params["write_xfer_implicit"], bool):
        raise StyxValidationError(f'`write_xfer_implicit` has the wrong type: Received `{type(params.get("write_xfer_implicit", False))}` expected `bool`')
    if params.get("enable_new_vr", False) is None:
        raise StyxValidationError("`enable_new_vr` must not be None")
    if not isinstance(params["enable_new_vr"], bool):
        raise StyxValidationError(f'`enable_new_vr` has the wrong type: Received `{type(params.get("enable_new_vr", False))}` expected `bool`')
    if params.get("disable_new_vr", False) is None:
        raise StyxValidationError("`disable_new_vr` must not be None")
    if not isinstance(params["disable_new_vr"], bool):
        raise StyxValidationError(f'`disable_new_vr` has the wrong type: Received `{type(params.get("disable_new_vr", False))}` expected `bool`')
    if params.get("group_length_recalc", False) is None:
        raise StyxValidationError("`group_length_recalc` must not be None")
    if not isinstance(params["group_length_recalc"], bool):
        raise StyxValidationError(f'`group_length_recalc` has the wrong type: Received `{type(params.get("group_length_recalc", False))}` expected `bool`')
    if params.get("group_length_create", False) is None:
        raise StyxValidationError("`group_length_create` must not be None")
    if not isinstance(params["group_length_create"], bool):
        raise StyxValidationError(f'`group_length_create` has the wrong type: Received `{type(params.get("group_length_create", False))}` expected `bool`')
    if params.get("group_length_remove", False) is None:
        raise StyxValidationError("`group_length_remove` must not be None")
    if not isinstance(params["group_length_remove"], bool):
        raise StyxValidationError(f'`group_length_remove` has the wrong type: Received `{type(params.get("group_length_remove", False))}` expected `bool`')
    if params.get("length_explicit", False) is None:
        raise StyxValidationError("`length_explicit` must not be None")
    if not isinstance(params["length_explicit"], bool):
        raise StyxValidationError(f'`length_explicit` has the wrong type: Received `{type(params.get("length_explicit", False))}` expected `bool`')
    if params.get("length_undefined", False) is None:
        raise StyxValidationError("`length_undefined` must not be None")
    if not isinstance(params["length_undefined"], bool):
        raise StyxValidationError(f'`length_undefined` has the wrong type: Received `{type(params.get("length_undefined", False))}` expected `bool`')
    if params.get("padding_retain", False) is None:
        raise StyxValidationError("`padding_retain` must not be None")
    if not isinstance(params["padding_retain"], bool):
        raise StyxValidationError(f'`padding_retain` has the wrong type: Received `{type(params.get("padding_retain", False))}` expected `bool`')
    if params.get("padding_off", False) is None:
        raise StyxValidationError("`padding_off` must not be None")
    if not isinstance(params["padding_off"], bool):
        raise StyxValidationError(f'`padding_off` has the wrong type: Received `{type(params.get("padding_off", False))}` expected `bool`')
    if params.get("padding_create", None) is not None:
        if not isinstance(params["padding_create"], str):
            raise StyxValidationError(f'`padding_create` has the wrong type: Received `{type(params.get("padding_create", None))}` expected `str | None`')


def dcmdrle_fs_cargs(
    params: DcmdrleFsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("dcmdrle.fs")
    cargs.append(execution.input_file(params.get("input_file", None)))
    cargs.append(params.get("output_file", None))
    if params.get("help", False):
        cargs.append("-h")
    if params.get("version", False):
        cargs.append("--version")
    if params.get("arguments", False):
        cargs.append("--arguments")
    if params.get("quiet", False):
        cargs.append("-q")
    if params.get("verbose", False):
        cargs.append("-v")
    if params.get("debug", False):
        cargs.append("-d")
    if params.get("log_level", None) is not None:
        cargs.extend([
            "-ll",
            params.get("log_level", None)
        ])
    if params.get("log_config", None) is not None:
        cargs.extend([
            "-lc",
            execution.input_file(params.get("log_config", None))
        ])
    if params.get("read_file", False):
        cargs.append("+f")
    if params.get("read_file_only", False):
        cargs.append("+fo")
    if params.get("read_dataset", False):
        cargs.append("-f")
    if params.get("uid_default", False):
        cargs.append("+ud")
    if params.get("uid_always", False):
        cargs.append("+ua")
    if params.get("byte_order_default", False):
        cargs.append("+bd")
    if params.get("byte_order_reverse", False):
        cargs.append("+br")
    if params.get("write_file", False):
        cargs.append("+F")
    if params.get("write_dataset", False):
        cargs.append("-F")
    if params.get("write_xfer_little", False):
        cargs.append("+te")
    if params.get("write_xfer_big", False):
        cargs.append("+tb")
    if params.get("write_xfer_implicit", False):
        cargs.append("+ti")
    if params.get("enable_new_vr", False):
        cargs.append("+u")
    if params.get("disable_new_vr", False):
        cargs.append("-u")
    if params.get("group_length_recalc", False):
        cargs.append("+g=")
    if params.get("group_length_create", False):
        cargs.append("+g")
    if params.get("group_length_remove", False):
        cargs.append("-g")
    if params.get("length_explicit", False):
        cargs.append("+e")
    if params.get("length_undefined", False):
        cargs.append("-e")
    if params.get("padding_retain", False):
        cargs.append("-p=")
    if params.get("padding_off", False):
        cargs.append("-p")
    if params.get("padding_create", None) is not None:
        cargs.extend([
            "+p",
            params.get("padding_create", None)
        ])
    return cargs


def dcmdrle_fs_outputs(
    params: DcmdrleFsParamsDict,
    execution: Execution,
) -> DcmdrleFsOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = DcmdrleFsOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(params.get("output_file", None)),
    )
    return ret


def dcmdrle_fs_execute(
    params: DcmdrleFsParamsDict,
    runner: Runner | None = None,
) -> DcmdrleFsOutputs:
    """
    dcmdrle.fs
    
    Decodes RLE-compressed DICOM files.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DcmdrleFsOutputs`).
    """
    dcmdrle_fs_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(DCMDRLE_FS_METADATA)
    params = execution.params(params)
    cargs = dcmdrle_fs_cargs(params, execution)
    ret = dcmdrle_fs_outputs(params, execution)
    execution.run(cargs)
    return ret


def dcmdrle_fs(
    input_file: InputPathType,
    output_file: str,
    help_: bool = False,
    version: bool = False,
    arguments: bool = False,
    quiet: bool = False,
    verbose: bool = False,
    debug: bool = False,
    log_level: str | None = None,
    log_config: InputPathType | None = None,
    read_file: bool = False,
    read_file_only: bool = False,
    read_dataset: bool = False,
    uid_default: bool = False,
    uid_always: bool = False,
    byte_order_default: bool = False,
    byte_order_reverse: bool = False,
    write_file: bool = False,
    write_dataset: bool = False,
    write_xfer_little: bool = False,
    write_xfer_big: bool = False,
    write_xfer_implicit: bool = False,
    enable_new_vr: bool = False,
    disable_new_vr: bool = False,
    group_length_recalc: bool = False,
    group_length_create: bool = False,
    group_length_remove: bool = False,
    length_explicit: bool = False,
    length_undefined: bool = False,
    padding_retain: bool = False,
    padding_off: bool = False,
    padding_create: str | None = None,
    runner: Runner | None = None,
) -> DcmdrleFsOutputs:
    """
    dcmdrle.fs
    
    Decodes RLE-compressed DICOM files.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        input_file: DICOM input filename to be converted.
        output_file: DICOM output filename.
        help_: Print help text and exit.
        version: Print version information and exit.
        arguments: Print expanded command line arguments.
        quiet: Quiet mode, print no warnings and errors.
        verbose: Verbose mode, print processing details.
        debug: Debug mode, print debug information.
        log_level: Set logger level.
        log_config: Use config file for the logger.
        read_file: Read file format or data set (default).
        read_file_only: Read file format only.
        read_dataset: Read data set without file meta information.
        uid_default: Keep same SOP Instance UID (default).
        uid_always: Always assign new UID.
        byte_order_default: Most significant byte first (default).
        byte_order_reverse: Least significant byte first.
        write_file: Write file format (default).
        write_dataset: Write data set without file meta information.
        write_xfer_little: Write with explicit VR little endian (default).
        write_xfer_big: Write with explicit VR big endian TS.
        write_xfer_implicit: Write with implicit VR little endian TS.
        enable_new_vr: Enable support for new VRs (UN/UT) (default).
        disable_new_vr: Disable support for new VRs, convert to OB.
        group_length_recalc: Recalculate group lengths if present (default).
        group_length_create: Always write with group length elements.
        group_length_remove: Always write without group length elements.
        length_explicit: Write with explicit lengths (default).
        length_undefined: Write with undefined lengths.
        padding_retain: Do not change padding.
        padding_off: No padding (implicit if --write-dataset).
        padding_create: Align file on multiple of file-pad bytes and items on\
            multiple of item-pad bytes.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DcmdrleFsOutputs`).
    """
    params = dcmdrle_fs_params(
        input_file=input_file,
        output_file=output_file,
        help_=help_,
        version=version,
        arguments=arguments,
        quiet=quiet,
        verbose=verbose,
        debug=debug,
        log_level=log_level,
        log_config=log_config,
        read_file=read_file,
        read_file_only=read_file_only,
        read_dataset=read_dataset,
        uid_default=uid_default,
        uid_always=uid_always,
        byte_order_default=byte_order_default,
        byte_order_reverse=byte_order_reverse,
        write_file=write_file,
        write_dataset=write_dataset,
        write_xfer_little=write_xfer_little,
        write_xfer_big=write_xfer_big,
        write_xfer_implicit=write_xfer_implicit,
        enable_new_vr=enable_new_vr,
        disable_new_vr=disable_new_vr,
        group_length_recalc=group_length_recalc,
        group_length_create=group_length_create,
        group_length_remove=group_length_remove,
        length_explicit=length_explicit,
        length_undefined=length_undefined,
        padding_retain=padding_retain,
        padding_off=padding_off,
        padding_create=padding_create,
    )
    return dcmdrle_fs_execute(params, runner)


__all__ = [
    "DCMDRLE_FS_METADATA",
    "DcmdrleFsOutputs",
    "DcmdrleFsParamsDict",
    "DcmdrleFsParamsDictTagged",
    "dcmdrle_fs",
    "dcmdrle_fs_execute",
    "dcmdrle_fs_params",
]
