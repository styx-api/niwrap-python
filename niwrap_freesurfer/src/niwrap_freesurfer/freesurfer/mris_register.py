# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRIS_REGISTER_METADATA = Metadata(
    id="f1a50485fb71fe5710129f5740432530f72f08f4.boutiques",
    name="mris_register",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MrisRegisterParamsDictNoTag = typing.TypedDict('_MrisRegisterParamsDictNoTag', {
    "surf_fname": InputPathType,
    "target": InputPathType,
    "out_fname": str,
    "one_flag": bool,
    "addframe": typing.NotRequired[str | None],
    "annot_name": typing.NotRequired[str | None],
    "curvature_fname": typing.NotRequired[InputPathType | None],
    "canonical_name": typing.NotRequired[str | None],
    "inflated": bool,
    "inflated_name": typing.NotRequired[str | None],
    "label_file": typing.NotRequired[str | None],
    "orig_name": typing.NotRequired[str | None],
    "overlay_values": typing.NotRequired[str | None],
    "overlay_dir": typing.NotRequired[str | None],
    "starting_reg_fname": typing.NotRequired[InputPathType | None],
    "jacobian_fname": typing.NotRequired[str | None],
    "n_averages": typing.NotRequired[float | None],
    "adaptive": bool,
    "l_area": typing.NotRequired[float | None],
    "l_corr": typing.NotRequired[float | None],
    "curvature_flag": bool,
    "l_dist": typing.NotRequired[float | None],
    "dt_value": typing.NotRequired[float | None],
    "dt_decrease": typing.NotRequired[float | None],
    "dt_increase": typing.NotRequired[float | None],
    "l_external": typing.NotRequired[float | None],
    "error_ratio": typing.NotRequired[float | None],
    "initial_flag": bool,
    "l_laplacian": typing.NotRequired[float | None],
    "line_min": bool,
    "momentum": typing.NotRequired[float | None],
    "max_degrees": typing.NotRequired[float | None],
    "median": bool,
    "min_degrees": typing.NotRequired[float | None],
    "multi_scale": typing.NotRequired[float | None],
    "n_iterations": typing.NotRequired[float | None],
    "n_angles": typing.NotRequired[float | None],
    "neighborhood_size": typing.NotRequired[float | None],
    "l_nlarea": typing.NotRequired[float | None],
    "no_curv": bool,
    "no_normalization": bool,
    "no_rotation": bool,
    "no_sulc": bool,
    "num_surfaces": typing.NotRequired[float | None],
    "overlay_corr": typing.NotRequired[float | None],
    "max_passes": typing.NotRequired[float | None],
    "l_parea": typing.NotRequired[float | None],
    "remove_negative": typing.NotRequired[float | None],
    "reverse": bool,
    "rotate_values": typing.NotRequired[str | None],
    "registration_file": typing.NotRequired[InputPathType | None],
    "scale": typing.NotRequired[float | None],
    "search_flag": bool,
    "spring_value": typing.NotRequired[float | None],
    "tolerance": typing.NotRequired[float | None],
    "topology_flag": bool,
    "vnum": typing.NotRequired[str | None],
    "vsmooth": bool,
    "write_iterations": typing.NotRequired[float | None],
    "gdiag_no": typing.NotRequired[float | None],
    "vector_flag": bool,
    "threads": typing.NotRequired[float | None],
    "version_flag": bool,
})
MrisRegisterParamsDictTagged = typing.TypedDict('MrisRegisterParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mris_register"],
    "surf_fname": InputPathType,
    "target": InputPathType,
    "out_fname": str,
    "one_flag": bool,
    "addframe": typing.NotRequired[str | None],
    "annot_name": typing.NotRequired[str | None],
    "curvature_fname": typing.NotRequired[InputPathType | None],
    "canonical_name": typing.NotRequired[str | None],
    "inflated": bool,
    "inflated_name": typing.NotRequired[str | None],
    "label_file": typing.NotRequired[str | None],
    "orig_name": typing.NotRequired[str | None],
    "overlay_values": typing.NotRequired[str | None],
    "overlay_dir": typing.NotRequired[str | None],
    "starting_reg_fname": typing.NotRequired[InputPathType | None],
    "jacobian_fname": typing.NotRequired[str | None],
    "n_averages": typing.NotRequired[float | None],
    "adaptive": bool,
    "l_area": typing.NotRequired[float | None],
    "l_corr": typing.NotRequired[float | None],
    "curvature_flag": bool,
    "l_dist": typing.NotRequired[float | None],
    "dt_value": typing.NotRequired[float | None],
    "dt_decrease": typing.NotRequired[float | None],
    "dt_increase": typing.NotRequired[float | None],
    "l_external": typing.NotRequired[float | None],
    "error_ratio": typing.NotRequired[float | None],
    "initial_flag": bool,
    "l_laplacian": typing.NotRequired[float | None],
    "line_min": bool,
    "momentum": typing.NotRequired[float | None],
    "max_degrees": typing.NotRequired[float | None],
    "median": bool,
    "min_degrees": typing.NotRequired[float | None],
    "multi_scale": typing.NotRequired[float | None],
    "n_iterations": typing.NotRequired[float | None],
    "n_angles": typing.NotRequired[float | None],
    "neighborhood_size": typing.NotRequired[float | None],
    "l_nlarea": typing.NotRequired[float | None],
    "no_curv": bool,
    "no_normalization": bool,
    "no_rotation": bool,
    "no_sulc": bool,
    "num_surfaces": typing.NotRequired[float | None],
    "overlay_corr": typing.NotRequired[float | None],
    "max_passes": typing.NotRequired[float | None],
    "l_parea": typing.NotRequired[float | None],
    "remove_negative": typing.NotRequired[float | None],
    "reverse": bool,
    "rotate_values": typing.NotRequired[str | None],
    "registration_file": typing.NotRequired[InputPathType | None],
    "scale": typing.NotRequired[float | None],
    "search_flag": bool,
    "spring_value": typing.NotRequired[float | None],
    "tolerance": typing.NotRequired[float | None],
    "topology_flag": bool,
    "vnum": typing.NotRequired[str | None],
    "vsmooth": bool,
    "write_iterations": typing.NotRequired[float | None],
    "gdiag_no": typing.NotRequired[float | None],
    "vector_flag": bool,
    "threads": typing.NotRequired[float | None],
    "version_flag": bool,
})
MrisRegisterParamsDict = _MrisRegisterParamsDictNoTag | MrisRegisterParamsDictTagged


class MrisRegisterOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MrisRegisterParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_surface_file: OutputPathType
    """Output surface file after registration."""
    jacobian_output: OutputPathType | None
    """Jacobian output file if specified."""


def mris_register_params(
    surf_fname: InputPathType,
    target: InputPathType,
    out_fname: str,
    one_flag: bool = False,
    addframe: str | None = None,
    annot_name: str | None = None,
    curvature_fname: InputPathType | None = None,
    canonical_name: str | None = None,
    inflated: bool = False,
    inflated_name: str | None = None,
    label_file: str | None = None,
    orig_name: str | None = None,
    overlay_values: str | None = None,
    overlay_dir: str | None = None,
    starting_reg_fname: InputPathType | None = None,
    jacobian_fname: str | None = None,
    n_averages: float | None = None,
    adaptive: bool = False,
    l_area: float | None = None,
    l_corr: float | None = None,
    curvature_flag: bool = False,
    l_dist: float | None = None,
    dt_value: float | None = None,
    dt_decrease: float | None = None,
    dt_increase: float | None = None,
    l_external: float | None = None,
    error_ratio: float | None = None,
    initial_flag: bool = False,
    l_laplacian: float | None = None,
    line_min: bool = False,
    momentum: float | None = None,
    max_degrees: float | None = None,
    median: bool = False,
    min_degrees: float | None = None,
    multi_scale: float | None = None,
    n_iterations: float | None = None,
    n_angles: float | None = None,
    neighborhood_size: float | None = None,
    l_nlarea: float | None = None,
    no_curv: bool = False,
    no_normalization: bool = False,
    no_rotation: bool = False,
    no_sulc: bool = False,
    num_surfaces: float | None = None,
    overlay_corr: float | None = None,
    max_passes: float | None = None,
    l_parea: float | None = None,
    remove_negative: float | None = None,
    reverse: bool = False,
    rotate_values: str | None = None,
    registration_file: InputPathType | None = None,
    scale: float | None = None,
    search_flag: bool = False,
    spring_value: float | None = None,
    tolerance: float | None = None,
    topology_flag: bool = False,
    vnum: str | None = None,
    vsmooth: bool = False,
    write_iterations: float | None = None,
    gdiag_no: float | None = None,
    vector_flag: bool = False,
    threads: float | None = None,
    version_flag: bool = False,
) -> MrisRegisterParamsDictTagged:
    """
    Build parameters.
    
    Args:
        surf_fname: Surface to register, often {hemi}.sphere.
        target: The data to register to. A template file for average surface or\
            a single-subject's surface.
        out_fname: Output surface file to capture registration. Example:\
            {hemi}.sphere.reg.
        one_flag: Treats target argument as a single subject's surface not a\
            template file.
        addframe: Add field with location in the atlas.
        annot_name: Zeroes medial wall using annotation.
        curvature_fname: Curvature file name.
        canonical_name: Use surface for canonical properties.
        inflated: Use inflated surface for initial alignment.
        inflated_name: Uses this name for inflated surface for initial\
            alignment.
        label_file: Specify a manual label to align with atlas label.
        orig_name: Use this for original properties.
        overlay_values: Adds a variable to the atlas from overlay file,\
            smoothing it specified number of times.
        overlay_dir: Changes overlay path.
        starting_reg_fname: Start registration with coordinates from file.
        jacobian_fname: Write out jacobian of mapping to the specified file.
        n_averages: Set the number of averages.
        adaptive: Use adaptive time step integration.
        l_area: Sets l_area parameter.
        l_corr: Sets the l_corr parameter.
        curvature_flag: Use smoothwm curvature for final alignment.
        l_dist: Specify distance term.
        dt_value: Sets momentum with specified dt.
        dt_decrease: Set decrease for dt.
        dt_increase: Set increase for dt.
        l_external: Sets l_external parameter.
        error_ratio: Sets error ratio.
        initial_flag: Use initial registration.
        l_laplacian: Sets l_laplacian.
        line_min: Integrate using line minimization.
        momentum: Chooses integration_type = INTEGRATE_MOMENTUM and sets\
            momentum value.
        max_degrees: Set max angle for search.
        median: Uses median normalization (instead of mean).
        min_degrees: Set min angle for search.
        multi_scale: Use multi_scale scales for morphing.
        n_iterations: Sets number of iterations.
        n_angles: Set number of angles/search per scale.
        neighborhood_size: Use neighborhood size specified.
        l_nlarea: Sets l_nlarea parameter.
        no_curv: Do not use smoothwm curvature for final alignment.
        no_normalization: Disables normalization.
        no_rotation: Disables initial rigid alignment.
        no_sulc: Disables initial sulc alignment.
        num_surfaces: Use specified number of surfaces/curvatures for\
            alignment.
        overlay_corr: Sets overlay correlation coefficient.
        max_passes: Limit unfolding to specified passes.
        l_parea: Sets l_parea parameter.
        remove_negative: Remove negative triangles with iterative smoothing if\
            non-zero.
        reverse: Mirror image reverse brain before morphing.
        rotate_values: Rotates brain by specified angles.
        registration_file: Extract rotational components from registration\
            file.
        scale: Scales distances by the specified value.
        search_flag: Integrate with binary search line minimization.
        spring_value: Sets the spring parameter.
        tolerance: Specifies tolerance.
        topology_flag: Preserves the topology of positive area triangles.
        vnum: Set neighborhood parameters.
        vsmooth: Use space/time varying smoothness weighting.
        write_iterations: Set number of write iterations.
        gdiag_no: Supplies a vertex number for diagnostics.
        vector_flag: Prints help for Multiframe mode, listing field names and\
            numbers.
        threads: Set number of OMP threads.
        version_flag: Print the version number.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mris_register",
        "surf_fname": surf_fname,
        "target": target,
        "out_fname": out_fname,
        "one_flag": one_flag,
        "inflated": inflated,
        "adaptive": adaptive,
        "curvature_flag": curvature_flag,
        "initial_flag": initial_flag,
        "line_min": line_min,
        "median": median,
        "no_curv": no_curv,
        "no_normalization": no_normalization,
        "no_rotation": no_rotation,
        "no_sulc": no_sulc,
        "reverse": reverse,
        "search_flag": search_flag,
        "topology_flag": topology_flag,
        "vsmooth": vsmooth,
        "vector_flag": vector_flag,
        "version_flag": version_flag,
    }
    if addframe is not None:
        params["addframe"] = addframe
    if annot_name is not None:
        params["annot_name"] = annot_name
    if curvature_fname is not None:
        params["curvature_fname"] = curvature_fname
    if canonical_name is not None:
        params["canonical_name"] = canonical_name
    if inflated_name is not None:
        params["inflated_name"] = inflated_name
    if label_file is not None:
        params["label_file"] = label_file
    if orig_name is not None:
        params["orig_name"] = orig_name
    if overlay_values is not None:
        params["overlay_values"] = overlay_values
    if overlay_dir is not None:
        params["overlay_dir"] = overlay_dir
    if starting_reg_fname is not None:
        params["starting_reg_fname"] = starting_reg_fname
    if jacobian_fname is not None:
        params["jacobian_fname"] = jacobian_fname
    if n_averages is not None:
        params["n_averages"] = n_averages
    if l_area is not None:
        params["l_area"] = l_area
    if l_corr is not None:
        params["l_corr"] = l_corr
    if l_dist is not None:
        params["l_dist"] = l_dist
    if dt_value is not None:
        params["dt_value"] = dt_value
    if dt_decrease is not None:
        params["dt_decrease"] = dt_decrease
    if dt_increase is not None:
        params["dt_increase"] = dt_increase
    if l_external is not None:
        params["l_external"] = l_external
    if error_ratio is not None:
        params["error_ratio"] = error_ratio
    if l_laplacian is not None:
        params["l_laplacian"] = l_laplacian
    if momentum is not None:
        params["momentum"] = momentum
    if max_degrees is not None:
        params["max_degrees"] = max_degrees
    if min_degrees is not None:
        params["min_degrees"] = min_degrees
    if multi_scale is not None:
        params["multi_scale"] = multi_scale
    if n_iterations is not None:
        params["n_iterations"] = n_iterations
    if n_angles is not None:
        params["n_angles"] = n_angles
    if neighborhood_size is not None:
        params["neighborhood_size"] = neighborhood_size
    if l_nlarea is not None:
        params["l_nlarea"] = l_nlarea
    if num_surfaces is not None:
        params["num_surfaces"] = num_surfaces
    if overlay_corr is not None:
        params["overlay_corr"] = overlay_corr
    if max_passes is not None:
        params["max_passes"] = max_passes
    if l_parea is not None:
        params["l_parea"] = l_parea
    if remove_negative is not None:
        params["remove_negative"] = remove_negative
    if rotate_values is not None:
        params["rotate_values"] = rotate_values
    if registration_file is not None:
        params["registration_file"] = registration_file
    if scale is not None:
        params["scale"] = scale
    if spring_value is not None:
        params["spring_value"] = spring_value
    if tolerance is not None:
        params["tolerance"] = tolerance
    if vnum is not None:
        params["vnum"] = vnum
    if write_iterations is not None:
        params["write_iterations"] = write_iterations
    if gdiag_no is not None:
        params["gdiag_no"] = gdiag_no
    if threads is not None:
        params["threads"] = threads
    return params


def mris_register_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrisRegisterParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("surf_fname", None) is None:
        raise StyxValidationError("`surf_fname` must not be None")
    if not isinstance(params["surf_fname"], (pathlib.Path, str)):
        raise StyxValidationError(f'`surf_fname` has the wrong type: Received `{type(params.get("surf_fname", None))}` expected `InputPathType`')
    if params.get("target", None) is None:
        raise StyxValidationError("`target` must not be None")
    if not isinstance(params["target"], (pathlib.Path, str)):
        raise StyxValidationError(f'`target` has the wrong type: Received `{type(params.get("target", None))}` expected `InputPathType`')
    if params.get("out_fname", None) is None:
        raise StyxValidationError("`out_fname` must not be None")
    if not isinstance(params["out_fname"], str):
        raise StyxValidationError(f'`out_fname` has the wrong type: Received `{type(params.get("out_fname", None))}` expected `str`')
    if params.get("one_flag", False) is None:
        raise StyxValidationError("`one_flag` must not be None")
    if not isinstance(params["one_flag"], bool):
        raise StyxValidationError(f'`one_flag` has the wrong type: Received `{type(params.get("one_flag", False))}` expected `bool`')
    if params.get("addframe", None) is not None:
        if not isinstance(params["addframe"], str):
            raise StyxValidationError(f'`addframe` has the wrong type: Received `{type(params.get("addframe", None))}` expected `str | None`')
    if params.get("annot_name", None) is not None:
        if not isinstance(params["annot_name"], str):
            raise StyxValidationError(f'`annot_name` has the wrong type: Received `{type(params.get("annot_name", None))}` expected `str | None`')
    if params.get("curvature_fname", None) is not None:
        if not isinstance(params["curvature_fname"], (pathlib.Path, str)):
            raise StyxValidationError(f'`curvature_fname` has the wrong type: Received `{type(params.get("curvature_fname", None))}` expected `InputPathType | None`')
    if params.get("canonical_name", None) is not None:
        if not isinstance(params["canonical_name"], str):
            raise StyxValidationError(f'`canonical_name` has the wrong type: Received `{type(params.get("canonical_name", None))}` expected `str | None`')
    if params.get("inflated", False) is None:
        raise StyxValidationError("`inflated` must not be None")
    if not isinstance(params["inflated"], bool):
        raise StyxValidationError(f'`inflated` has the wrong type: Received `{type(params.get("inflated", False))}` expected `bool`')
    if params.get("inflated_name", None) is not None:
        if not isinstance(params["inflated_name"], str):
            raise StyxValidationError(f'`inflated_name` has the wrong type: Received `{type(params.get("inflated_name", None))}` expected `str | None`')
    if params.get("label_file", None) is not None:
        if not isinstance(params["label_file"], str):
            raise StyxValidationError(f'`label_file` has the wrong type: Received `{type(params.get("label_file", None))}` expected `str | None`')
    if params.get("orig_name", None) is not None:
        if not isinstance(params["orig_name"], str):
            raise StyxValidationError(f'`orig_name` has the wrong type: Received `{type(params.get("orig_name", None))}` expected `str | None`')
    if params.get("overlay_values", None) is not None:
        if not isinstance(params["overlay_values"], str):
            raise StyxValidationError(f'`overlay_values` has the wrong type: Received `{type(params.get("overlay_values", None))}` expected `str | None`')
    if params.get("overlay_dir", None) is not None:
        if not isinstance(params["overlay_dir"], str):
            raise StyxValidationError(f'`overlay_dir` has the wrong type: Received `{type(params.get("overlay_dir", None))}` expected `str | None`')
    if params.get("starting_reg_fname", None) is not None:
        if not isinstance(params["starting_reg_fname"], (pathlib.Path, str)):
            raise StyxValidationError(f'`starting_reg_fname` has the wrong type: Received `{type(params.get("starting_reg_fname", None))}` expected `InputPathType | None`')
    if params.get("jacobian_fname", None) is not None:
        if not isinstance(params["jacobian_fname"], str):
            raise StyxValidationError(f'`jacobian_fname` has the wrong type: Received `{type(params.get("jacobian_fname", None))}` expected `str | None`')
    if params.get("n_averages", None) is not None:
        if not isinstance(params["n_averages"], (float, int)):
            raise StyxValidationError(f'`n_averages` has the wrong type: Received `{type(params.get("n_averages", None))}` expected `float | None`')
    if params.get("adaptive", False) is None:
        raise StyxValidationError("`adaptive` must not be None")
    if not isinstance(params["adaptive"], bool):
        raise StyxValidationError(f'`adaptive` has the wrong type: Received `{type(params.get("adaptive", False))}` expected `bool`')
    if params.get("l_area", None) is not None:
        if not isinstance(params["l_area"], (float, int)):
            raise StyxValidationError(f'`l_area` has the wrong type: Received `{type(params.get("l_area", None))}` expected `float | None`')
    if params.get("l_corr", None) is not None:
        if not isinstance(params["l_corr"], (float, int)):
            raise StyxValidationError(f'`l_corr` has the wrong type: Received `{type(params.get("l_corr", None))}` expected `float | None`')
    if params.get("curvature_flag", False) is None:
        raise StyxValidationError("`curvature_flag` must not be None")
    if not isinstance(params["curvature_flag"], bool):
        raise StyxValidationError(f'`curvature_flag` has the wrong type: Received `{type(params.get("curvature_flag", False))}` expected `bool`')
    if params.get("l_dist", None) is not None:
        if not isinstance(params["l_dist"], (float, int)):
            raise StyxValidationError(f'`l_dist` has the wrong type: Received `{type(params.get("l_dist", None))}` expected `float | None`')
    if params.get("dt_value", None) is not None:
        if not isinstance(params["dt_value"], (float, int)):
            raise StyxValidationError(f'`dt_value` has the wrong type: Received `{type(params.get("dt_value", None))}` expected `float | None`')
    if params.get("dt_decrease", None) is not None:
        if not isinstance(params["dt_decrease"], (float, int)):
            raise StyxValidationError(f'`dt_decrease` has the wrong type: Received `{type(params.get("dt_decrease", None))}` expected `float | None`')
    if params.get("dt_increase", None) is not None:
        if not isinstance(params["dt_increase"], (float, int)):
            raise StyxValidationError(f'`dt_increase` has the wrong type: Received `{type(params.get("dt_increase", None))}` expected `float | None`')
    if params.get("l_external", None) is not None:
        if not isinstance(params["l_external"], (float, int)):
            raise StyxValidationError(f'`l_external` has the wrong type: Received `{type(params.get("l_external", None))}` expected `float | None`')
    if params.get("error_ratio", None) is not None:
        if not isinstance(params["error_ratio"], (float, int)):
            raise StyxValidationError(f'`error_ratio` has the wrong type: Received `{type(params.get("error_ratio", None))}` expected `float | None`')
    if params.get("initial_flag", False) is None:
        raise StyxValidationError("`initial_flag` must not be None")
    if not isinstance(params["initial_flag"], bool):
        raise StyxValidationError(f'`initial_flag` has the wrong type: Received `{type(params.get("initial_flag", False))}` expected `bool`')
    if params.get("l_laplacian", None) is not None:
        if not isinstance(params["l_laplacian"], (float, int)):
            raise StyxValidationError(f'`l_laplacian` has the wrong type: Received `{type(params.get("l_laplacian", None))}` expected `float | None`')
    if params.get("line_min", False) is None:
        raise StyxValidationError("`line_min` must not be None")
    if not isinstance(params["line_min"], bool):
        raise StyxValidationError(f'`line_min` has the wrong type: Received `{type(params.get("line_min", False))}` expected `bool`')
    if params.get("momentum", None) is not None:
        if not isinstance(params["momentum"], (float, int)):
            raise StyxValidationError(f'`momentum` has the wrong type: Received `{type(params.get("momentum", None))}` expected `float | None`')
    if params.get("max_degrees", None) is not None:
        if not isinstance(params["max_degrees"], (float, int)):
            raise StyxValidationError(f'`max_degrees` has the wrong type: Received `{type(params.get("max_degrees", None))}` expected `float | None`')
    if params.get("median", False) is None:
        raise StyxValidationError("`median` must not be None")
    if not isinstance(params["median"], bool):
        raise StyxValidationError(f'`median` has the wrong type: Received `{type(params.get("median", False))}` expected `bool`')
    if params.get("min_degrees", None) is not None:
        if not isinstance(params["min_degrees"], (float, int)):
            raise StyxValidationError(f'`min_degrees` has the wrong type: Received `{type(params.get("min_degrees", None))}` expected `float | None`')
    if params.get("multi_scale", None) is not None:
        if not isinstance(params["multi_scale"], (float, int)):
            raise StyxValidationError(f'`multi_scale` has the wrong type: Received `{type(params.get("multi_scale", None))}` expected `float | None`')
    if params.get("n_iterations", None) is not None:
        if not isinstance(params["n_iterations"], (float, int)):
            raise StyxValidationError(f'`n_iterations` has the wrong type: Received `{type(params.get("n_iterations", None))}` expected `float | None`')
    if params.get("n_angles", None) is not None:
        if not isinstance(params["n_angles"], (float, int)):
            raise StyxValidationError(f'`n_angles` has the wrong type: Received `{type(params.get("n_angles", None))}` expected `float | None`')
    if params.get("neighborhood_size", None) is not None:
        if not isinstance(params["neighborhood_size"], (float, int)):
            raise StyxValidationError(f'`neighborhood_size` has the wrong type: Received `{type(params.get("neighborhood_size", None))}` expected `float | None`')
    if params.get("l_nlarea", None) is not None:
        if not isinstance(params["l_nlarea"], (float, int)):
            raise StyxValidationError(f'`l_nlarea` has the wrong type: Received `{type(params.get("l_nlarea", None))}` expected `float | None`')
    if params.get("no_curv", False) is None:
        raise StyxValidationError("`no_curv` must not be None")
    if not isinstance(params["no_curv"], bool):
        raise StyxValidationError(f'`no_curv` has the wrong type: Received `{type(params.get("no_curv", False))}` expected `bool`')
    if params.get("no_normalization", False) is None:
        raise StyxValidationError("`no_normalization` must not be None")
    if not isinstance(params["no_normalization"], bool):
        raise StyxValidationError(f'`no_normalization` has the wrong type: Received `{type(params.get("no_normalization", False))}` expected `bool`')
    if params.get("no_rotation", False) is None:
        raise StyxValidationError("`no_rotation` must not be None")
    if not isinstance(params["no_rotation"], bool):
        raise StyxValidationError(f'`no_rotation` has the wrong type: Received `{type(params.get("no_rotation", False))}` expected `bool`')
    if params.get("no_sulc", False) is None:
        raise StyxValidationError("`no_sulc` must not be None")
    if not isinstance(params["no_sulc"], bool):
        raise StyxValidationError(f'`no_sulc` has the wrong type: Received `{type(params.get("no_sulc", False))}` expected `bool`')
    if params.get("num_surfaces", None) is not None:
        if not isinstance(params["num_surfaces"], (float, int)):
            raise StyxValidationError(f'`num_surfaces` has the wrong type: Received `{type(params.get("num_surfaces", None))}` expected `float | None`')
    if params.get("overlay_corr", None) is not None:
        if not isinstance(params["overlay_corr"], (float, int)):
            raise StyxValidationError(f'`overlay_corr` has the wrong type: Received `{type(params.get("overlay_corr", None))}` expected `float | None`')
    if params.get("max_passes", None) is not None:
        if not isinstance(params["max_passes"], (float, int)):
            raise StyxValidationError(f'`max_passes` has the wrong type: Received `{type(params.get("max_passes", None))}` expected `float | None`')
    if params.get("l_parea", None) is not None:
        if not isinstance(params["l_parea"], (float, int)):
            raise StyxValidationError(f'`l_parea` has the wrong type: Received `{type(params.get("l_parea", None))}` expected `float | None`')
    if params.get("remove_negative", None) is not None:
        if not isinstance(params["remove_negative"], (float, int)):
            raise StyxValidationError(f'`remove_negative` has the wrong type: Received `{type(params.get("remove_negative", None))}` expected `float | None`')
    if params.get("reverse", False) is None:
        raise StyxValidationError("`reverse` must not be None")
    if not isinstance(params["reverse"], bool):
        raise StyxValidationError(f'`reverse` has the wrong type: Received `{type(params.get("reverse", False))}` expected `bool`')
    if params.get("rotate_values", None) is not None:
        if not isinstance(params["rotate_values"], str):
            raise StyxValidationError(f'`rotate_values` has the wrong type: Received `{type(params.get("rotate_values", None))}` expected `str | None`')
    if params.get("registration_file", None) is not None:
        if not isinstance(params["registration_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`registration_file` has the wrong type: Received `{type(params.get("registration_file", None))}` expected `InputPathType | None`')
    if params.get("scale", None) is not None:
        if not isinstance(params["scale"], (float, int)):
            raise StyxValidationError(f'`scale` has the wrong type: Received `{type(params.get("scale", None))}` expected `float | None`')
    if params.get("search_flag", False) is None:
        raise StyxValidationError("`search_flag` must not be None")
    if not isinstance(params["search_flag"], bool):
        raise StyxValidationError(f'`search_flag` has the wrong type: Received `{type(params.get("search_flag", False))}` expected `bool`')
    if params.get("spring_value", None) is not None:
        if not isinstance(params["spring_value"], (float, int)):
            raise StyxValidationError(f'`spring_value` has the wrong type: Received `{type(params.get("spring_value", None))}` expected `float | None`')
    if params.get("tolerance", None) is not None:
        if not isinstance(params["tolerance"], (float, int)):
            raise StyxValidationError(f'`tolerance` has the wrong type: Received `{type(params.get("tolerance", None))}` expected `float | None`')
    if params.get("topology_flag", False) is None:
        raise StyxValidationError("`topology_flag` must not be None")
    if not isinstance(params["topology_flag"], bool):
        raise StyxValidationError(f'`topology_flag` has the wrong type: Received `{type(params.get("topology_flag", False))}` expected `bool`')
    if params.get("vnum", None) is not None:
        if not isinstance(params["vnum"], str):
            raise StyxValidationError(f'`vnum` has the wrong type: Received `{type(params.get("vnum", None))}` expected `str | None`')
    if params.get("vsmooth", False) is None:
        raise StyxValidationError("`vsmooth` must not be None")
    if not isinstance(params["vsmooth"], bool):
        raise StyxValidationError(f'`vsmooth` has the wrong type: Received `{type(params.get("vsmooth", False))}` expected `bool`')
    if params.get("write_iterations", None) is not None:
        if not isinstance(params["write_iterations"], (float, int)):
            raise StyxValidationError(f'`write_iterations` has the wrong type: Received `{type(params.get("write_iterations", None))}` expected `float | None`')
    if params.get("gdiag_no", None) is not None:
        if not isinstance(params["gdiag_no"], (float, int)):
            raise StyxValidationError(f'`gdiag_no` has the wrong type: Received `{type(params.get("gdiag_no", None))}` expected `float | None`')
    if params.get("vector_flag", False) is None:
        raise StyxValidationError("`vector_flag` must not be None")
    if not isinstance(params["vector_flag"], bool):
        raise StyxValidationError(f'`vector_flag` has the wrong type: Received `{type(params.get("vector_flag", False))}` expected `bool`')
    if params.get("threads", None) is not None:
        if not isinstance(params["threads"], (float, int)):
            raise StyxValidationError(f'`threads` has the wrong type: Received `{type(params.get("threads", None))}` expected `float | None`')
    if params.get("version_flag", False) is None:
        raise StyxValidationError("`version_flag` must not be None")
    if not isinstance(params["version_flag"], bool):
        raise StyxValidationError(f'`version_flag` has the wrong type: Received `{type(params.get("version_flag", False))}` expected `bool`')


def mris_register_cargs(
    params: MrisRegisterParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mris_register")
    cargs.append(execution.input_file(params.get("surf_fname", None)))
    cargs.append(execution.input_file(params.get("target", None)))
    cargs.append(params.get("out_fname", None))
    if params.get("one_flag", False):
        cargs.append("-1")
    if params.get("addframe", None) is not None:
        cargs.extend([
            "-addframe",
            params.get("addframe", None)
        ])
    if params.get("annot_name", None) is not None:
        cargs.extend([
            "-annot",
            params.get("annot_name", None)
        ])
    if params.get("curvature_fname", None) is not None:
        cargs.extend([
            "-C",
            execution.input_file(params.get("curvature_fname", None))
        ])
    if params.get("canonical_name", None) is not None:
        cargs.extend([
            "-canon",
            params.get("canonical_name", None)
        ])
    if params.get("inflated", False):
        cargs.append("-inflated")
    if params.get("inflated_name", None) is not None:
        cargs.extend([
            "-infname",
            params.get("inflated_name", None)
        ])
    if params.get("label_file", None) is not None:
        cargs.extend([
            "-L",
            params.get("label_file", None)
        ])
    if params.get("orig_name", None) is not None:
        cargs.extend([
            "-O",
            params.get("orig_name", None)
        ])
    if params.get("overlay_values", None) is not None:
        cargs.extend([
            "-overlay",
            params.get("overlay_values", None)
        ])
    if params.get("overlay_dir", None) is not None:
        cargs.extend([
            "-overlay-dir",
            params.get("overlay_dir", None)
        ])
    if params.get("starting_reg_fname", None) is not None:
        cargs.extend([
            "-sreg",
            execution.input_file(params.get("starting_reg_fname", None))
        ])
    if params.get("jacobian_fname", None) is not None:
        cargs.extend([
            "-jacobian",
            params.get("jacobian_fname", None)
        ])
    if params.get("n_averages", None) is not None:
        cargs.extend([
            "-A",
            str(params.get("n_averages", None))
        ])
    if params.get("adaptive", False):
        cargs.append("-adaptive")
    if params.get("l_area", None) is not None:
        cargs.extend([
            "-area",
            str(params.get("l_area", None))
        ])
    if params.get("l_corr", None) is not None:
        cargs.extend([
            "-corr",
            str(params.get("l_corr", None))
        ])
    if params.get("curvature_flag", False):
        cargs.append("-curv")
    if params.get("l_dist", None) is not None:
        cargs.extend([
            "-dist",
            str(params.get("l_dist", None))
        ])
    if params.get("dt_value", None) is not None:
        cargs.extend([
            "-dt",
            str(params.get("dt_value", None))
        ])
    if params.get("dt_decrease", None) is not None:
        cargs.extend([
            "-dt_dec",
            str(params.get("dt_decrease", None))
        ])
    if params.get("dt_increase", None) is not None:
        cargs.extend([
            "-dt_inc",
            str(params.get("dt_increase", None))
        ])
    if params.get("l_external", None) is not None:
        cargs.extend([
            "-E",
            str(params.get("l_external", None))
        ])
    if params.get("error_ratio", None) is not None:
        cargs.extend([
            "-error_ratio",
            str(params.get("error_ratio", None))
        ])
    if params.get("initial_flag", False):
        cargs.append("-init")
    if params.get("l_laplacian", None) is not None:
        cargs.extend([
            "-lap",
            str(params.get("l_laplacian", None))
        ])
    if params.get("line_min", False):
        cargs.append("-lm")
    if params.get("momentum", None) is not None:
        cargs.extend([
            "-M",
            str(params.get("momentum", None))
        ])
    if params.get("max_degrees", None) is not None:
        cargs.extend([
            "-max_degrees",
            str(params.get("max_degrees", None))
        ])
    if params.get("median", False):
        cargs.append("-median")
    if params.get("min_degrees", None) is not None:
        cargs.extend([
            "-min_degrees",
            str(params.get("min_degrees", None))
        ])
    if params.get("multi_scale", None) is not None:
        cargs.extend([
            "-multi_scale",
            str(params.get("multi_scale", None))
        ])
    if params.get("n_iterations", None) is not None:
        cargs.extend([
            "-N",
            str(params.get("n_iterations", None))
        ])
    if params.get("n_angles", None) is not None:
        cargs.extend([
            "-nangles",
            str(params.get("n_angles", None))
        ])
    if params.get("neighborhood_size", None) is not None:
        cargs.extend([
            "-nbrs",
            str(params.get("neighborhood_size", None))
        ])
    if params.get("l_nlarea", None) is not None:
        cargs.extend([
            "-nlarea",
            str(params.get("l_nlarea", None))
        ])
    if params.get("no_curv", False):
        cargs.append("-nocurv")
    if params.get("no_normalization", False):
        cargs.append("-nonorm")
    if params.get("no_rotation", False):
        cargs.append("-norot")
    if params.get("no_sulc", False):
        cargs.append("-nosulc")
    if params.get("num_surfaces", None) is not None:
        cargs.extend([
            "-nsurfaces",
            str(params.get("num_surfaces", None))
        ])
    if params.get("overlay_corr", None) is not None:
        cargs.extend([
            "-ocorr",
            str(params.get("overlay_corr", None))
        ])
    if params.get("max_passes", None) is not None:
        cargs.extend([
            "-P",
            str(params.get("max_passes", None))
        ])
    if params.get("l_parea", None) is not None:
        cargs.extend([
            "-parea",
            str(params.get("l_parea", None))
        ])
    if params.get("remove_negative", None) is not None:
        cargs.extend([
            "-remove_negative",
            str(params.get("remove_negative", None))
        ])
    if params.get("reverse", False):
        cargs.append("-reverse")
    if params.get("rotate_values", None) is not None:
        cargs.extend([
            "-rotate",
            params.get("rotate_values", None)
        ])
    if params.get("registration_file", None) is not None:
        cargs.extend([
            "-reg",
            execution.input_file(params.get("registration_file", None))
        ])
    if params.get("scale", None) is not None:
        cargs.extend([
            "-S",
            str(params.get("scale", None))
        ])
    if params.get("search_flag", False):
        cargs.append("-search")
    if params.get("spring_value", None) is not None:
        cargs.extend([
            "-spring",
            str(params.get("spring_value", None))
        ])
    if params.get("tolerance", None) is not None:
        cargs.extend([
            "-tol",
            str(params.get("tolerance", None))
        ])
    if params.get("topology_flag", False):
        cargs.append("-topology")
    if params.get("vnum", None) is not None:
        cargs.extend([
            "-vnum",
            params.get("vnum", None)
        ])
    if params.get("vsmooth", False):
        cargs.append("-vsmooth")
    if params.get("write_iterations", None) is not None:
        cargs.extend([
            "-W",
            str(params.get("write_iterations", None))
        ])
    if params.get("gdiag_no", None) is not None:
        cargs.extend([
            "-V",
            str(params.get("gdiag_no", None))
        ])
    if params.get("vector_flag", False):
        cargs.append("-vector")
    if params.get("threads", None) is not None:
        cargs.extend([
            "-threads",
            str(params.get("threads", None))
        ])
    if params.get("version_flag", False):
        cargs.append("--version")
    return cargs


def mris_register_outputs(
    params: MrisRegisterParamsDict,
    execution: Execution,
) -> MrisRegisterOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MrisRegisterOutputs(
        root=execution.output_file("."),
        output_surface_file=execution.output_file(params.get("out_fname", None)),
        jacobian_output=execution.output_file(params.get("jacobian_fname", None)) if (params.get("jacobian_fname") is not None) else None,
    )
    return ret


def mris_register_execute(
    params: MrisRegisterParamsDict,
    runner: Runner | None = None,
) -> MrisRegisterOutputs:
    """
    mris_register
    
    This program registers a surface to an average surface template.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrisRegisterOutputs`).
    """
    mris_register_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRIS_REGISTER_METADATA)
    params = execution.params(params)
    cargs = mris_register_cargs(params, execution)
    ret = mris_register_outputs(params, execution)
    execution.run(cargs)
    return ret


def mris_register(
    surf_fname: InputPathType,
    target: InputPathType,
    out_fname: str,
    one_flag: bool = False,
    addframe: str | None = None,
    annot_name: str | None = None,
    curvature_fname: InputPathType | None = None,
    canonical_name: str | None = None,
    inflated: bool = False,
    inflated_name: str | None = None,
    label_file: str | None = None,
    orig_name: str | None = None,
    overlay_values: str | None = None,
    overlay_dir: str | None = None,
    starting_reg_fname: InputPathType | None = None,
    jacobian_fname: str | None = None,
    n_averages: float | None = None,
    adaptive: bool = False,
    l_area: float | None = None,
    l_corr: float | None = None,
    curvature_flag: bool = False,
    l_dist: float | None = None,
    dt_value: float | None = None,
    dt_decrease: float | None = None,
    dt_increase: float | None = None,
    l_external: float | None = None,
    error_ratio: float | None = None,
    initial_flag: bool = False,
    l_laplacian: float | None = None,
    line_min: bool = False,
    momentum: float | None = None,
    max_degrees: float | None = None,
    median: bool = False,
    min_degrees: float | None = None,
    multi_scale: float | None = None,
    n_iterations: float | None = None,
    n_angles: float | None = None,
    neighborhood_size: float | None = None,
    l_nlarea: float | None = None,
    no_curv: bool = False,
    no_normalization: bool = False,
    no_rotation: bool = False,
    no_sulc: bool = False,
    num_surfaces: float | None = None,
    overlay_corr: float | None = None,
    max_passes: float | None = None,
    l_parea: float | None = None,
    remove_negative: float | None = None,
    reverse: bool = False,
    rotate_values: str | None = None,
    registration_file: InputPathType | None = None,
    scale: float | None = None,
    search_flag: bool = False,
    spring_value: float | None = None,
    tolerance: float | None = None,
    topology_flag: bool = False,
    vnum: str | None = None,
    vsmooth: bool = False,
    write_iterations: float | None = None,
    gdiag_no: float | None = None,
    vector_flag: bool = False,
    threads: float | None = None,
    version_flag: bool = False,
    runner: Runner | None = None,
) -> MrisRegisterOutputs:
    """
    mris_register
    
    This program registers a surface to an average surface template.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        surf_fname: Surface to register, often {hemi}.sphere.
        target: The data to register to. A template file for average surface or\
            a single-subject's surface.
        out_fname: Output surface file to capture registration. Example:\
            {hemi}.sphere.reg.
        one_flag: Treats target argument as a single subject's surface not a\
            template file.
        addframe: Add field with location in the atlas.
        annot_name: Zeroes medial wall using annotation.
        curvature_fname: Curvature file name.
        canonical_name: Use surface for canonical properties.
        inflated: Use inflated surface for initial alignment.
        inflated_name: Uses this name for inflated surface for initial\
            alignment.
        label_file: Specify a manual label to align with atlas label.
        orig_name: Use this for original properties.
        overlay_values: Adds a variable to the atlas from overlay file,\
            smoothing it specified number of times.
        overlay_dir: Changes overlay path.
        starting_reg_fname: Start registration with coordinates from file.
        jacobian_fname: Write out jacobian of mapping to the specified file.
        n_averages: Set the number of averages.
        adaptive: Use adaptive time step integration.
        l_area: Sets l_area parameter.
        l_corr: Sets the l_corr parameter.
        curvature_flag: Use smoothwm curvature for final alignment.
        l_dist: Specify distance term.
        dt_value: Sets momentum with specified dt.
        dt_decrease: Set decrease for dt.
        dt_increase: Set increase for dt.
        l_external: Sets l_external parameter.
        error_ratio: Sets error ratio.
        initial_flag: Use initial registration.
        l_laplacian: Sets l_laplacian.
        line_min: Integrate using line minimization.
        momentum: Chooses integration_type = INTEGRATE_MOMENTUM and sets\
            momentum value.
        max_degrees: Set max angle for search.
        median: Uses median normalization (instead of mean).
        min_degrees: Set min angle for search.
        multi_scale: Use multi_scale scales for morphing.
        n_iterations: Sets number of iterations.
        n_angles: Set number of angles/search per scale.
        neighborhood_size: Use neighborhood size specified.
        l_nlarea: Sets l_nlarea parameter.
        no_curv: Do not use smoothwm curvature for final alignment.
        no_normalization: Disables normalization.
        no_rotation: Disables initial rigid alignment.
        no_sulc: Disables initial sulc alignment.
        num_surfaces: Use specified number of surfaces/curvatures for\
            alignment.
        overlay_corr: Sets overlay correlation coefficient.
        max_passes: Limit unfolding to specified passes.
        l_parea: Sets l_parea parameter.
        remove_negative: Remove negative triangles with iterative smoothing if\
            non-zero.
        reverse: Mirror image reverse brain before morphing.
        rotate_values: Rotates brain by specified angles.
        registration_file: Extract rotational components from registration\
            file.
        scale: Scales distances by the specified value.
        search_flag: Integrate with binary search line minimization.
        spring_value: Sets the spring parameter.
        tolerance: Specifies tolerance.
        topology_flag: Preserves the topology of positive area triangles.
        vnum: Set neighborhood parameters.
        vsmooth: Use space/time varying smoothness weighting.
        write_iterations: Set number of write iterations.
        gdiag_no: Supplies a vertex number for diagnostics.
        vector_flag: Prints help for Multiframe mode, listing field names and\
            numbers.
        threads: Set number of OMP threads.
        version_flag: Print the version number.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrisRegisterOutputs`).
    """
    params = mris_register_params(
        surf_fname=surf_fname,
        target=target,
        out_fname=out_fname,
        one_flag=one_flag,
        addframe=addframe,
        annot_name=annot_name,
        curvature_fname=curvature_fname,
        canonical_name=canonical_name,
        inflated=inflated,
        inflated_name=inflated_name,
        label_file=label_file,
        orig_name=orig_name,
        overlay_values=overlay_values,
        overlay_dir=overlay_dir,
        starting_reg_fname=starting_reg_fname,
        jacobian_fname=jacobian_fname,
        n_averages=n_averages,
        adaptive=adaptive,
        l_area=l_area,
        l_corr=l_corr,
        curvature_flag=curvature_flag,
        l_dist=l_dist,
        dt_value=dt_value,
        dt_decrease=dt_decrease,
        dt_increase=dt_increase,
        l_external=l_external,
        error_ratio=error_ratio,
        initial_flag=initial_flag,
        l_laplacian=l_laplacian,
        line_min=line_min,
        momentum=momentum,
        max_degrees=max_degrees,
        median=median,
        min_degrees=min_degrees,
        multi_scale=multi_scale,
        n_iterations=n_iterations,
        n_angles=n_angles,
        neighborhood_size=neighborhood_size,
        l_nlarea=l_nlarea,
        no_curv=no_curv,
        no_normalization=no_normalization,
        no_rotation=no_rotation,
        no_sulc=no_sulc,
        num_surfaces=num_surfaces,
        overlay_corr=overlay_corr,
        max_passes=max_passes,
        l_parea=l_parea,
        remove_negative=remove_negative,
        reverse=reverse,
        rotate_values=rotate_values,
        registration_file=registration_file,
        scale=scale,
        search_flag=search_flag,
        spring_value=spring_value,
        tolerance=tolerance,
        topology_flag=topology_flag,
        vnum=vnum,
        vsmooth=vsmooth,
        write_iterations=write_iterations,
        gdiag_no=gdiag_no,
        vector_flag=vector_flag,
        threads=threads,
        version_flag=version_flag,
    )
    return mris_register_execute(params, runner)


__all__ = [
    "MRIS_REGISTER_METADATA",
    "MrisRegisterOutputs",
    "MrisRegisterParamsDict",
    "MrisRegisterParamsDictTagged",
    "mris_register",
    "mris_register_execute",
    "mris_register_params",
]
