# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_SEG_OVERLAP_METADATA = Metadata(
    id="f3b538b50d90585bf0105d4b48845c49b1607b96.boutiques",
    name="mri_seg_overlap",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriSegOverlapParamsDictNoTag = typing.TypedDict('_MriSegOverlapParamsDictNoTag', {
    "vol1": InputPathType,
    "vol2": InputPathType,
    "out_file": typing.NotRequired[str | None],
    "measures": typing.NotRequired[list[str] | None],
    "labels": typing.NotRequired[list[str] | None],
    "label_names": typing.NotRequired[list[str] | None],
    "label_file": typing.NotRequired[InputPathType | None],
    "no_names_flag": bool,
    "seg_flag": bool,
    "quiet_flag": bool,
})
MriSegOverlapParamsDictTagged = typing.TypedDict('MriSegOverlapParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_seg_overlap"],
    "vol1": InputPathType,
    "vol2": InputPathType,
    "out_file": typing.NotRequired[str | None],
    "measures": typing.NotRequired[list[str] | None],
    "labels": typing.NotRequired[list[str] | None],
    "label_names": typing.NotRequired[list[str] | None],
    "label_file": typing.NotRequired[InputPathType | None],
    "no_names_flag": bool,
    "seg_flag": bool,
    "quiet_flag": bool,
})
MriSegOverlapParamsDict = _MriSegOverlapParamsDictNoTag | MriSegOverlapParamsDictTagged


class MriSegOverlapOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriSegOverlapParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    overlap_report: OutputPathType | None
    """Detailed overlap report saved to a JSON file."""


def mri_seg_overlap_params(
    vol1: InputPathType,
    vol2: InputPathType,
    out_file: str | None = None,
    measures: list[str] | None = None,
    labels: list[str] | None = None,
    label_names: list[str] | None = None,
    label_file: InputPathType | None = None,
    no_names_flag: bool = False,
    seg_flag: bool = False,
    quiet_flag: bool = False,
) -> MriSegOverlapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        vol1: First segmentation volume input.
        vol2: Second segmentation volume input.
        out_file: Save detailed overlap report to a JSON file.
        measures: List of measures to compute. Options include: dice, jaccard,\
            voldiff.
        labels: Space-separated list of label values to include.
        label_names: Custom label names corresponding to the values specified\
            with the --labels flag.
        label_file: Text file specifying the label values to include. Must be\
            in the format of a freesurfer lookup-table.
        no_names_flag: Do not report label names.
        seg_flag: Compute overlap between the major segmentation structures.
        quiet_flag: Quiet mode - do not print results to stdout.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_seg_overlap",
        "vol1": vol1,
        "vol2": vol2,
        "no_names_flag": no_names_flag,
        "seg_flag": seg_flag,
        "quiet_flag": quiet_flag,
    }
    if out_file is not None:
        params["out_file"] = out_file
    if measures is not None:
        params["measures"] = measures
    if labels is not None:
        params["labels"] = labels
    if label_names is not None:
        params["label_names"] = label_names
    if label_file is not None:
        params["label_file"] = label_file
    return params


def mri_seg_overlap_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriSegOverlapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("vol1", None) is None:
        raise StyxValidationError("`vol1` must not be None")
    if not isinstance(params["vol1"], (pathlib.Path, str)):
        raise StyxValidationError(f'`vol1` has the wrong type: Received `{type(params.get("vol1", None))}` expected `InputPathType`')
    if params.get("vol2", None) is None:
        raise StyxValidationError("`vol2` must not be None")
    if not isinstance(params["vol2"], (pathlib.Path, str)):
        raise StyxValidationError(f'`vol2` has the wrong type: Received `{type(params.get("vol2", None))}` expected `InputPathType`')
    if params.get("out_file", None) is not None:
        if not isinstance(params["out_file"], str):
            raise StyxValidationError(f'`out_file` has the wrong type: Received `{type(params.get("out_file", None))}` expected `str | None`')
    if params.get("measures", None) is not None:
        if not isinstance(params["measures"], list):
            raise StyxValidationError(f'`measures` has the wrong type: Received `{type(params.get("measures", None))}` expected `list[str] | None`')
        for e in params["measures"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`measures` has the wrong type: Received `{type(params.get("measures", None))}` expected `list[str] | None`')
    if params.get("labels", None) is not None:
        if not isinstance(params["labels"], list):
            raise StyxValidationError(f'`labels` has the wrong type: Received `{type(params.get("labels", None))}` expected `list[str] | None`')
        for e in params["labels"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`labels` has the wrong type: Received `{type(params.get("labels", None))}` expected `list[str] | None`')
    if params.get("label_names", None) is not None:
        if not isinstance(params["label_names"], list):
            raise StyxValidationError(f'`label_names` has the wrong type: Received `{type(params.get("label_names", None))}` expected `list[str] | None`')
        for e in params["label_names"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`label_names` has the wrong type: Received `{type(params.get("label_names", None))}` expected `list[str] | None`')
    if params.get("label_file", None) is not None:
        if not isinstance(params["label_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`label_file` has the wrong type: Received `{type(params.get("label_file", None))}` expected `InputPathType | None`')
    if params.get("no_names_flag", False) is None:
        raise StyxValidationError("`no_names_flag` must not be None")
    if not isinstance(params["no_names_flag"], bool):
        raise StyxValidationError(f'`no_names_flag` has the wrong type: Received `{type(params.get("no_names_flag", False))}` expected `bool`')
    if params.get("seg_flag", False) is None:
        raise StyxValidationError("`seg_flag` must not be None")
    if not isinstance(params["seg_flag"], bool):
        raise StyxValidationError(f'`seg_flag` has the wrong type: Received `{type(params.get("seg_flag", False))}` expected `bool`')
    if params.get("quiet_flag", False) is None:
        raise StyxValidationError("`quiet_flag` must not be None")
    if not isinstance(params["quiet_flag"], bool):
        raise StyxValidationError(f'`quiet_flag` has the wrong type: Received `{type(params.get("quiet_flag", False))}` expected `bool`')


def mri_seg_overlap_cargs(
    params: MriSegOverlapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_seg_overlap")
    cargs.append(execution.input_file(params.get("vol1", None)))
    cargs.append(execution.input_file(params.get("vol2", None)))
    if params.get("out_file", None) is not None:
        cargs.extend([
            "-o",
            params.get("out_file", None)
        ])
    if params.get("measures", None) is not None:
        cargs.extend([
            "-m",
            *params.get("measures", None)
        ])
    if params.get("labels", None) is not None:
        cargs.extend([
            "-l",
            *params.get("labels", None)
        ])
    if params.get("label_names", None) is not None:
        cargs.extend([
            "-n",
            *params.get("label_names", None)
        ])
    if params.get("label_file", None) is not None:
        cargs.extend([
            "-f",
            execution.input_file(params.get("label_file", None))
        ])
    if params.get("no_names_flag", False):
        cargs.append("-x")
    if params.get("seg_flag", False):
        cargs.append("-s")
    if params.get("quiet_flag", False):
        cargs.append("-q")
    return cargs


def mri_seg_overlap_outputs(
    params: MriSegOverlapParamsDict,
    execution: Execution,
) -> MriSegOverlapOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriSegOverlapOutputs(
        root=execution.output_file("."),
        overlap_report=execution.output_file(params.get("out_file", None)) if (params.get("out_file") is not None) else None,
    )
    return ret


def mri_seg_overlap_execute(
    params: MriSegOverlapParamsDict,
    runner: Runner | None = None,
) -> MriSegOverlapOutputs:
    """
    mri_seg_overlap
    
    Compute the structural overlap between two segmentation volumes.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriSegOverlapOutputs`).
    """
    mri_seg_overlap_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_SEG_OVERLAP_METADATA)
    params = execution.params(params)
    cargs = mri_seg_overlap_cargs(params, execution)
    ret = mri_seg_overlap_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_seg_overlap(
    vol1: InputPathType,
    vol2: InputPathType,
    out_file: str | None = None,
    measures: list[str] | None = None,
    labels: list[str] | None = None,
    label_names: list[str] | None = None,
    label_file: InputPathType | None = None,
    no_names_flag: bool = False,
    seg_flag: bool = False,
    quiet_flag: bool = False,
    runner: Runner | None = None,
) -> MriSegOverlapOutputs:
    """
    mri_seg_overlap
    
    Compute the structural overlap between two segmentation volumes.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        vol1: First segmentation volume input.
        vol2: Second segmentation volume input.
        out_file: Save detailed overlap report to a JSON file.
        measures: List of measures to compute. Options include: dice, jaccard,\
            voldiff.
        labels: Space-separated list of label values to include.
        label_names: Custom label names corresponding to the values specified\
            with the --labels flag.
        label_file: Text file specifying the label values to include. Must be\
            in the format of a freesurfer lookup-table.
        no_names_flag: Do not report label names.
        seg_flag: Compute overlap between the major segmentation structures.
        quiet_flag: Quiet mode - do not print results to stdout.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriSegOverlapOutputs`).
    """
    params = mri_seg_overlap_params(
        vol1=vol1,
        vol2=vol2,
        out_file=out_file,
        measures=measures,
        labels=labels,
        label_names=label_names,
        label_file=label_file,
        no_names_flag=no_names_flag,
        seg_flag=seg_flag,
        quiet_flag=quiet_flag,
    )
    return mri_seg_overlap_execute(params, runner)


__all__ = [
    "MRI_SEG_OVERLAP_METADATA",
    "MriSegOverlapOutputs",
    "MriSegOverlapParamsDict",
    "MriSegOverlapParamsDictTagged",
    "mri_seg_overlap",
    "mri_seg_overlap_execute",
    "mri_seg_overlap_params",
]
