# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

DMRI_MATCH_METADATA = Metadata(
    id="3e19241fdc2d436026c2b1e5858939e139f1083c.boutiques",
    name="dmri_match",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_DmriMatchParamsDictNoTag = typing.TypedDict('_DmriMatchParamsDictNoTag', {
    "parcellation1": InputPathType,
    "parcellation2": InputPathType,
    "num_clusters": float,
    "clustering_path1": InputPathType,
    "clustering_path2": InputPathType,
    "labels": bool,
    "euclidean": bool,
    "bounding_box": bool,
    "symmetry": bool,
    "inter_hemi_ratio_removal": typing.NotRequired[str | None],
    "output": str,
})
DmriMatchParamsDictTagged = typing.TypedDict('DmriMatchParamsDictTagged', {
    "@type": typing.Literal["freesurfer/dmri_match"],
    "parcellation1": InputPathType,
    "parcellation2": InputPathType,
    "num_clusters": float,
    "clustering_path1": InputPathType,
    "clustering_path2": InputPathType,
    "labels": bool,
    "euclidean": bool,
    "bounding_box": bool,
    "symmetry": bool,
    "inter_hemi_ratio_removal": typing.NotRequired[str | None],
    "output": str,
})
DmriMatchParamsDict = _DmriMatchParamsDictNoTag | DmriMatchParamsDictTagged


class DmriMatchOutputs(typing.NamedTuple):
    """
    Output object returned when calling `DmriMatchParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType
    """Output file from dmri_match"""


def dmri_match_params(
    parcellation1: InputPathType,
    parcellation2: InputPathType,
    num_clusters: float,
    clustering_path1: InputPathType,
    clustering_path2: InputPathType,
    output: str,
    labels: bool = False,
    euclidean: bool = False,
    bounding_box: bool = False,
    symmetry: bool = False,
    inter_hemi_ratio_removal: str | None = None,
) -> DmriMatchParamsDictTagged:
    """
    Build parameters.
    
    Args:
        parcellation1: First parcellation input file.
        parcellation2: Second parcellation input file.
        num_clusters: Number of clusters.
        clustering_path1: First clustering path.
        clustering_path2: Second clustering path.
        output: Output file.
        labels: Use labels (no additional input expected).
        euclidean: Use Euclidean distance for matching.
        bounding_box: Use bounding box constraint (no additional input\
            expected).
        symmetry: Use symmetry constraint (no additional input expected).
        inter_hemi_ratio_removal: Inter-hemispheric ratio cluster removal\
            constraint.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/dmri_match",
        "parcellation1": parcellation1,
        "parcellation2": parcellation2,
        "num_clusters": num_clusters,
        "clustering_path1": clustering_path1,
        "clustering_path2": clustering_path2,
        "labels": labels,
        "euclidean": euclidean,
        "bounding_box": bounding_box,
        "symmetry": symmetry,
        "output": output,
    }
    if inter_hemi_ratio_removal is not None:
        params["inter_hemi_ratio_removal"] = inter_hemi_ratio_removal
    return params


def dmri_match_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `DmriMatchParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("parcellation1", None) is None:
        raise StyxValidationError("`parcellation1` must not be None")
    if not isinstance(params["parcellation1"], (pathlib.Path, str)):
        raise StyxValidationError(f'`parcellation1` has the wrong type: Received `{type(params.get("parcellation1", None))}` expected `InputPathType`')
    if params.get("parcellation2", None) is None:
        raise StyxValidationError("`parcellation2` must not be None")
    if not isinstance(params["parcellation2"], (pathlib.Path, str)):
        raise StyxValidationError(f'`parcellation2` has the wrong type: Received `{type(params.get("parcellation2", None))}` expected `InputPathType`')
    if params.get("num_clusters", None) is None:
        raise StyxValidationError("`num_clusters` must not be None")
    if not isinstance(params["num_clusters"], (float, int)):
        raise StyxValidationError(f'`num_clusters` has the wrong type: Received `{type(params.get("num_clusters", None))}` expected `float`')
    if params.get("clustering_path1", None) is None:
        raise StyxValidationError("`clustering_path1` must not be None")
    if not isinstance(params["clustering_path1"], (pathlib.Path, str)):
        raise StyxValidationError(f'`clustering_path1` has the wrong type: Received `{type(params.get("clustering_path1", None))}` expected `InputPathType`')
    if params.get("clustering_path2", None) is None:
        raise StyxValidationError("`clustering_path2` must not be None")
    if not isinstance(params["clustering_path2"], (pathlib.Path, str)):
        raise StyxValidationError(f'`clustering_path2` has the wrong type: Received `{type(params.get("clustering_path2", None))}` expected `InputPathType`')
    if params.get("labels", False) is None:
        raise StyxValidationError("`labels` must not be None")
    if not isinstance(params["labels"], bool):
        raise StyxValidationError(f'`labels` has the wrong type: Received `{type(params.get("labels", False))}` expected `bool`')
    if params.get("euclidean", False) is None:
        raise StyxValidationError("`euclidean` must not be None")
    if not isinstance(params["euclidean"], bool):
        raise StyxValidationError(f'`euclidean` has the wrong type: Received `{type(params.get("euclidean", False))}` expected `bool`')
    if params.get("bounding_box", False) is None:
        raise StyxValidationError("`bounding_box` must not be None")
    if not isinstance(params["bounding_box"], bool):
        raise StyxValidationError(f'`bounding_box` has the wrong type: Received `{type(params.get("bounding_box", False))}` expected `bool`')
    if params.get("symmetry", False) is None:
        raise StyxValidationError("`symmetry` must not be None")
    if not isinstance(params["symmetry"], bool):
        raise StyxValidationError(f'`symmetry` has the wrong type: Received `{type(params.get("symmetry", False))}` expected `bool`')
    if params.get("inter_hemi_ratio_removal", None) is not None:
        if not isinstance(params["inter_hemi_ratio_removal"], str):
            raise StyxValidationError(f'`inter_hemi_ratio_removal` has the wrong type: Received `{type(params.get("inter_hemi_ratio_removal", None))}` expected `str | None`')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')


def dmri_match_cargs(
    params: DmriMatchParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("dmri_match")
    cargs.extend([
        "-s1",
        execution.input_file(params.get("parcellation1", None))
    ])
    cargs.extend([
        "-s2",
        execution.input_file(params.get("parcellation2", None))
    ])
    cargs.extend([
        "-c",
        str(params.get("num_clusters", None))
    ])
    cargs.extend([
        "-h1",
        execution.input_file(params.get("clustering_path1", None))
    ])
    cargs.extend([
        "-h2",
        execution.input_file(params.get("clustering_path2", None))
    ])
    if params.get("labels", False):
        cargs.append("-labels")
    if params.get("euclidean", False):
        cargs.append("-euclid")
    if params.get("bounding_box", False):
        cargs.append("-bb")
    if params.get("symmetry", False):
        cargs.append("-sym")
    if params.get("inter_hemi_ratio_removal", None) is not None:
        cargs.append(params.get("inter_hemi_ratio_removal", None))
    cargs.extend([
        "-o",
        params.get("output", None)
    ])
    return cargs


def dmri_match_outputs(
    params: DmriMatchParamsDict,
    execution: Execution,
) -> DmriMatchOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = DmriMatchOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(params.get("output", None)),
    )
    return ret


def dmri_match_execute(
    params: DmriMatchParamsDict,
    runner: Runner | None = None,
) -> DmriMatchOutputs:
    """
    dmri_match
    
    Tool for matching diffusion MRI parcellations.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DmriMatchOutputs`).
    """
    dmri_match_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(DMRI_MATCH_METADATA)
    params = execution.params(params)
    cargs = dmri_match_cargs(params, execution)
    ret = dmri_match_outputs(params, execution)
    execution.run(cargs)
    return ret


def dmri_match(
    parcellation1: InputPathType,
    parcellation2: InputPathType,
    num_clusters: float,
    clustering_path1: InputPathType,
    clustering_path2: InputPathType,
    output: str,
    labels: bool = False,
    euclidean: bool = False,
    bounding_box: bool = False,
    symmetry: bool = False,
    inter_hemi_ratio_removal: str | None = None,
    runner: Runner | None = None,
) -> DmriMatchOutputs:
    """
    dmri_match
    
    Tool for matching diffusion MRI parcellations.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        parcellation1: First parcellation input file.
        parcellation2: Second parcellation input file.
        num_clusters: Number of clusters.
        clustering_path1: First clustering path.
        clustering_path2: Second clustering path.
        output: Output file.
        labels: Use labels (no additional input expected).
        euclidean: Use Euclidean distance for matching.
        bounding_box: Use bounding box constraint (no additional input\
            expected).
        symmetry: Use symmetry constraint (no additional input expected).
        inter_hemi_ratio_removal: Inter-hemispheric ratio cluster removal\
            constraint.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DmriMatchOutputs`).
    """
    params = dmri_match_params(
        parcellation1=parcellation1,
        parcellation2=parcellation2,
        num_clusters=num_clusters,
        clustering_path1=clustering_path1,
        clustering_path2=clustering_path2,
        labels=labels,
        euclidean=euclidean,
        bounding_box=bounding_box,
        symmetry=symmetry,
        inter_hemi_ratio_removal=inter_hemi_ratio_removal,
        output=output,
    )
    return dmri_match_execute(params, runner)


__all__ = [
    "DMRI_MATCH_METADATA",
    "DmriMatchOutputs",
    "DmriMatchParamsDict",
    "DmriMatchParamsDictTagged",
    "dmri_match",
    "dmri_match_execute",
    "dmri_match_params",
]
