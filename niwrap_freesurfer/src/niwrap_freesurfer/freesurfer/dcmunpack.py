# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

DCMUNPACK_METADATA = Metadata(
    id="a172d3fb8225abb3caf4f7ee8805cdf0967017f5.boutiques",
    name="dcmunpack",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_DcmunpackParamsDictNoTag = typing.TypedDict('_DcmunpackParamsDictNoTag', {
    "src": str,
    "targ": typing.NotRequired[str | None],
    "run": typing.NotRequired[str | None],
    "auto_runseq": typing.NotRequired[str | None],
    "keep_scouts": bool,
    "scanonly": typing.NotRequired[str | None],
    "one_per_dir": bool,
    "ext": typing.NotRequired[str | None],
    "pre": typing.NotRequired[str | None],
    "pat": typing.NotRequired[str | None],
    "no_infodump": bool,
    "generic": bool,
    "copy_only": bool,
    "no_convert": bool,
    "force_update": bool,
    "max": bool,
    "base": bool,
    "key_string": typing.NotRequired[str | None],
    "index_out": typing.NotRequired[str | None],
    "index_in": typing.NotRequired[str | None],
    "it_dicom": bool,
    "no_exit_on_error": bool,
    "run_skip": typing.NotRequired[str | None],
    "no_rescale_dicom": bool,
    "rescale_dicom": bool,
    "no_dwi": bool,
    "iid": typing.NotRequired[list[float] | None],
    "ijd": typing.NotRequired[list[float] | None],
    "ikd": typing.NotRequired[list[float] | None],
    "extra_info": bool,
    "first_dicom": bool,
    "no_dcm2niix": bool,
    "phase": bool,
    "fips": typing.NotRequired[str | None],
    "fips_run": typing.NotRequired[str | None],
    "xml_only": bool,
    "log": typing.NotRequired[str | None],
    "debug": bool,
})
DcmunpackParamsDictTagged = typing.TypedDict('DcmunpackParamsDictTagged', {
    "@type": typing.Literal["freesurfer/dcmunpack"],
    "src": str,
    "targ": typing.NotRequired[str | None],
    "run": typing.NotRequired[str | None],
    "auto_runseq": typing.NotRequired[str | None],
    "keep_scouts": bool,
    "scanonly": typing.NotRequired[str | None],
    "one_per_dir": bool,
    "ext": typing.NotRequired[str | None],
    "pre": typing.NotRequired[str | None],
    "pat": typing.NotRequired[str | None],
    "no_infodump": bool,
    "generic": bool,
    "copy_only": bool,
    "no_convert": bool,
    "force_update": bool,
    "max": bool,
    "base": bool,
    "key_string": typing.NotRequired[str | None],
    "index_out": typing.NotRequired[str | None],
    "index_in": typing.NotRequired[str | None],
    "it_dicom": bool,
    "no_exit_on_error": bool,
    "run_skip": typing.NotRequired[str | None],
    "no_rescale_dicom": bool,
    "rescale_dicom": bool,
    "no_dwi": bool,
    "iid": typing.NotRequired[list[float] | None],
    "ijd": typing.NotRequired[list[float] | None],
    "ikd": typing.NotRequired[list[float] | None],
    "extra_info": bool,
    "first_dicom": bool,
    "no_dcm2niix": bool,
    "phase": bool,
    "fips": typing.NotRequired[str | None],
    "fips_run": typing.NotRequired[str | None],
    "xml_only": bool,
    "log": typing.NotRequired[str | None],
    "debug": bool,
})
DcmunpackParamsDict = _DcmunpackParamsDictNoTag | DcmunpackParamsDictTagged


class DcmunpackOutputs(typing.NamedTuple):
    """
    Output object returned when calling `DcmunpackParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def dcmunpack_params(
    src: str,
    targ: str | None = None,
    run: str | None = None,
    auto_runseq: str | None = None,
    keep_scouts: bool = False,
    scanonly: str | None = None,
    one_per_dir: bool = False,
    ext: str | None = None,
    pre: str | None = None,
    pat: str | None = None,
    no_infodump: bool = False,
    generic: bool = False,
    copy_only: bool = False,
    no_convert: bool = False,
    force_update: bool = False,
    max_: bool = False,
    base: bool = False,
    key_string: str | None = None,
    index_out: str | None = None,
    index_in: str | None = None,
    it_dicom: bool = False,
    no_exit_on_error: bool = False,
    run_skip: str | None = None,
    no_rescale_dicom: bool = False,
    rescale_dicom: bool = False,
    no_dwi: bool = False,
    iid: list[float] | None = None,
    ijd: list[float] | None = None,
    ikd: list[float] | None = None,
    extra_info: bool = False,
    first_dicom: bool = False,
    no_dcm2niix: bool = False,
    phase: bool = False,
    fips: str | None = None,
    fips_run: str | None = None,
    xml_only: bool = False,
    log: str | None = None,
    debug: bool = False,
) -> DcmunpackParamsDictTagged:
    """
    Build parameters.
    
    Args:
        src: Dicom source directory. You can specify more than one.
        targ: Output directory. Do not need to include when just getting\
            information about what is in the directory.
        run: Specify unpacking rules for a given run (series). Eg, "-run 3 bold\
            nii f.nii".
        auto_runseq: Save all scans in the targetdir as runo.seqname.format.
        keep_scouts: Unpack series with 'scout' or 'setter' in the name.
        scanonly: Only scan the directory and put result in file.
        one_per_dir: Assume that there is only one dicom series in each subdir.
        ext: Input extension (eg, dcm).
        pre: Input prefix (i.e., input file name init string).
        pat: Input pattern (i.e., string that occurs in the middle of file\
            name).
        no_infodump: Do not create the fname-infodump.dat file.
        generic: Do not use FSFAST hierarchy.
        copy_only: Only copy dicom files to output directory (implies\
            -no-convert).
        no_convert: Do not convert to output format.
        force_update: Convert even if output is newer than the input dicom.
        max_: Print out max in given dicom file.
        base: Report filename without path.
        key_string: Put keystring before each run line (good for searching).
        index_out: Save index of files to index.out.dat (for re-use).
        index_in: Read index of files (can make things much faster on 2nd run).
        it_dicom: Add -it dicom to mri_convert cmd line.
        no_exit_on_error: Continue to unpack data even if there is an error in\
            conversion.
        run_skip: Skip a given run (good when using -auto-runseq).
        no_rescale_dicom: Turn off DICOM rescaling based on tags (0028,1052)\
            (0028,1053).
        rescale_dicom: Turn DICOM rescaling on.
        no_dwi: Turn off trying to read DWI parameters.
        iid: Set -iid to mri_convert.
        ijd: Set -ijd to mri_convert.
        ikd: Set -ikd to mri_convert.
        extra_info: Add session info to each line of the info file (pat, date,\
            man, scan, field, serno).
        first_dicom: Copy first dicom file into output folder.
        no_dcm2niix: Turn off dcm2niix conversion.
        phase: Add the string _phase to volumes that are phase images based on\
            ImageType.
        fips: Fips parameters: project, site, birnid, visit.
        fips_run: Fips-run parameters: run paradigm.
        xml_only: For fips, only create xml file, do not convert to output.
        log: Log output to a file.
        debug: Enable debug mode.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/dcmunpack",
        "src": src,
        "keep_scouts": keep_scouts,
        "one_per_dir": one_per_dir,
        "no_infodump": no_infodump,
        "generic": generic,
        "copy_only": copy_only,
        "no_convert": no_convert,
        "force_update": force_update,
        "max": max_,
        "base": base,
        "it_dicom": it_dicom,
        "no_exit_on_error": no_exit_on_error,
        "no_rescale_dicom": no_rescale_dicom,
        "rescale_dicom": rescale_dicom,
        "no_dwi": no_dwi,
        "extra_info": extra_info,
        "first_dicom": first_dicom,
        "no_dcm2niix": no_dcm2niix,
        "phase": phase,
        "xml_only": xml_only,
        "debug": debug,
    }
    if targ is not None:
        params["targ"] = targ
    if run is not None:
        params["run"] = run
    if auto_runseq is not None:
        params["auto_runseq"] = auto_runseq
    if scanonly is not None:
        params["scanonly"] = scanonly
    if ext is not None:
        params["ext"] = ext
    if pre is not None:
        params["pre"] = pre
    if pat is not None:
        params["pat"] = pat
    if key_string is not None:
        params["key_string"] = key_string
    if index_out is not None:
        params["index_out"] = index_out
    if index_in is not None:
        params["index_in"] = index_in
    if run_skip is not None:
        params["run_skip"] = run_skip
    if iid is not None:
        params["iid"] = iid
    if ijd is not None:
        params["ijd"] = ijd
    if ikd is not None:
        params["ikd"] = ikd
    if fips is not None:
        params["fips"] = fips
    if fips_run is not None:
        params["fips_run"] = fips_run
    if log is not None:
        params["log"] = log
    return params


def dcmunpack_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `DcmunpackParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("src", None) is None:
        raise StyxValidationError("`src` must not be None")
    if not isinstance(params["src"], str):
        raise StyxValidationError(f'`src` has the wrong type: Received `{type(params.get("src", None))}` expected `str`')
    if params.get("targ", None) is not None:
        if not isinstance(params["targ"], str):
            raise StyxValidationError(f'`targ` has the wrong type: Received `{type(params.get("targ", None))}` expected `str | None`')
    if params.get("run", None) is not None:
        if not isinstance(params["run"], str):
            raise StyxValidationError(f'`run` has the wrong type: Received `{type(params.get("run", None))}` expected `str | None`')
    if params.get("auto_runseq", None) is not None:
        if not isinstance(params["auto_runseq"], str):
            raise StyxValidationError(f'`auto_runseq` has the wrong type: Received `{type(params.get("auto_runseq", None))}` expected `str | None`')
    if params.get("keep_scouts", False) is None:
        raise StyxValidationError("`keep_scouts` must not be None")
    if not isinstance(params["keep_scouts"], bool):
        raise StyxValidationError(f'`keep_scouts` has the wrong type: Received `{type(params.get("keep_scouts", False))}` expected `bool`')
    if params.get("scanonly", None) is not None:
        if not isinstance(params["scanonly"], str):
            raise StyxValidationError(f'`scanonly` has the wrong type: Received `{type(params.get("scanonly", None))}` expected `str | None`')
    if params.get("one_per_dir", False) is None:
        raise StyxValidationError("`one_per_dir` must not be None")
    if not isinstance(params["one_per_dir"], bool):
        raise StyxValidationError(f'`one_per_dir` has the wrong type: Received `{type(params.get("one_per_dir", False))}` expected `bool`')
    if params.get("ext", None) is not None:
        if not isinstance(params["ext"], str):
            raise StyxValidationError(f'`ext` has the wrong type: Received `{type(params.get("ext", None))}` expected `str | None`')
    if params.get("pre", None) is not None:
        if not isinstance(params["pre"], str):
            raise StyxValidationError(f'`pre` has the wrong type: Received `{type(params.get("pre", None))}` expected `str | None`')
    if params.get("pat", None) is not None:
        if not isinstance(params["pat"], str):
            raise StyxValidationError(f'`pat` has the wrong type: Received `{type(params.get("pat", None))}` expected `str | None`')
    if params.get("no_infodump", False) is None:
        raise StyxValidationError("`no_infodump` must not be None")
    if not isinstance(params["no_infodump"], bool):
        raise StyxValidationError(f'`no_infodump` has the wrong type: Received `{type(params.get("no_infodump", False))}` expected `bool`')
    if params.get("generic", False) is None:
        raise StyxValidationError("`generic` must not be None")
    if not isinstance(params["generic"], bool):
        raise StyxValidationError(f'`generic` has the wrong type: Received `{type(params.get("generic", False))}` expected `bool`')
    if params.get("copy_only", False) is None:
        raise StyxValidationError("`copy_only` must not be None")
    if not isinstance(params["copy_only"], bool):
        raise StyxValidationError(f'`copy_only` has the wrong type: Received `{type(params.get("copy_only", False))}` expected `bool`')
    if params.get("no_convert", False) is None:
        raise StyxValidationError("`no_convert` must not be None")
    if not isinstance(params["no_convert"], bool):
        raise StyxValidationError(f'`no_convert` has the wrong type: Received `{type(params.get("no_convert", False))}` expected `bool`')
    if params.get("force_update", False) is None:
        raise StyxValidationError("`force_update` must not be None")
    if not isinstance(params["force_update"], bool):
        raise StyxValidationError(f'`force_update` has the wrong type: Received `{type(params.get("force_update", False))}` expected `bool`')
    if params.get("max", False) is None:
        raise StyxValidationError("`max` must not be None")
    if not isinstance(params["max"], bool):
        raise StyxValidationError(f'`max` has the wrong type: Received `{type(params.get("max", False))}` expected `bool`')
    if params.get("base", False) is None:
        raise StyxValidationError("`base` must not be None")
    if not isinstance(params["base"], bool):
        raise StyxValidationError(f'`base` has the wrong type: Received `{type(params.get("base", False))}` expected `bool`')
    if params.get("key_string", None) is not None:
        if not isinstance(params["key_string"], str):
            raise StyxValidationError(f'`key_string` has the wrong type: Received `{type(params.get("key_string", None))}` expected `str | None`')
    if params.get("index_out", None) is not None:
        if not isinstance(params["index_out"], str):
            raise StyxValidationError(f'`index_out` has the wrong type: Received `{type(params.get("index_out", None))}` expected `str | None`')
    if params.get("index_in", None) is not None:
        if not isinstance(params["index_in"], str):
            raise StyxValidationError(f'`index_in` has the wrong type: Received `{type(params.get("index_in", None))}` expected `str | None`')
    if params.get("it_dicom", False) is None:
        raise StyxValidationError("`it_dicom` must not be None")
    if not isinstance(params["it_dicom"], bool):
        raise StyxValidationError(f'`it_dicom` has the wrong type: Received `{type(params.get("it_dicom", False))}` expected `bool`')
    if params.get("no_exit_on_error", False) is None:
        raise StyxValidationError("`no_exit_on_error` must not be None")
    if not isinstance(params["no_exit_on_error"], bool):
        raise StyxValidationError(f'`no_exit_on_error` has the wrong type: Received `{type(params.get("no_exit_on_error", False))}` expected `bool`')
    if params.get("run_skip", None) is not None:
        if not isinstance(params["run_skip"], str):
            raise StyxValidationError(f'`run_skip` has the wrong type: Received `{type(params.get("run_skip", None))}` expected `str | None`')
    if params.get("no_rescale_dicom", False) is None:
        raise StyxValidationError("`no_rescale_dicom` must not be None")
    if not isinstance(params["no_rescale_dicom"], bool):
        raise StyxValidationError(f'`no_rescale_dicom` has the wrong type: Received `{type(params.get("no_rescale_dicom", False))}` expected `bool`')
    if params.get("rescale_dicom", False) is None:
        raise StyxValidationError("`rescale_dicom` must not be None")
    if not isinstance(params["rescale_dicom"], bool):
        raise StyxValidationError(f'`rescale_dicom` has the wrong type: Received `{type(params.get("rescale_dicom", False))}` expected `bool`')
    if params.get("no_dwi", False) is None:
        raise StyxValidationError("`no_dwi` must not be None")
    if not isinstance(params["no_dwi"], bool):
        raise StyxValidationError(f'`no_dwi` has the wrong type: Received `{type(params.get("no_dwi", False))}` expected `bool`')
    if params.get("iid", None) is not None:
        if not isinstance(params["iid"], list):
            raise StyxValidationError(f'`iid` has the wrong type: Received `{type(params.get("iid", None))}` expected `list[float] | None`')
        for e in params["iid"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`iid` has the wrong type: Received `{type(params.get("iid", None))}` expected `list[float] | None`')
    if params.get("ijd", None) is not None:
        if not isinstance(params["ijd"], list):
            raise StyxValidationError(f'`ijd` has the wrong type: Received `{type(params.get("ijd", None))}` expected `list[float] | None`')
        for e in params["ijd"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`ijd` has the wrong type: Received `{type(params.get("ijd", None))}` expected `list[float] | None`')
    if params.get("ikd", None) is not None:
        if not isinstance(params["ikd"], list):
            raise StyxValidationError(f'`ikd` has the wrong type: Received `{type(params.get("ikd", None))}` expected `list[float] | None`')
        for e in params["ikd"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`ikd` has the wrong type: Received `{type(params.get("ikd", None))}` expected `list[float] | None`')
    if params.get("extra_info", False) is None:
        raise StyxValidationError("`extra_info` must not be None")
    if not isinstance(params["extra_info"], bool):
        raise StyxValidationError(f'`extra_info` has the wrong type: Received `{type(params.get("extra_info", False))}` expected `bool`')
    if params.get("first_dicom", False) is None:
        raise StyxValidationError("`first_dicom` must not be None")
    if not isinstance(params["first_dicom"], bool):
        raise StyxValidationError(f'`first_dicom` has the wrong type: Received `{type(params.get("first_dicom", False))}` expected `bool`')
    if params.get("no_dcm2niix", False) is None:
        raise StyxValidationError("`no_dcm2niix` must not be None")
    if not isinstance(params["no_dcm2niix"], bool):
        raise StyxValidationError(f'`no_dcm2niix` has the wrong type: Received `{type(params.get("no_dcm2niix", False))}` expected `bool`')
    if params.get("phase", False) is None:
        raise StyxValidationError("`phase` must not be None")
    if not isinstance(params["phase"], bool):
        raise StyxValidationError(f'`phase` has the wrong type: Received `{type(params.get("phase", False))}` expected `bool`')
    if params.get("fips", None) is not None:
        if not isinstance(params["fips"], str):
            raise StyxValidationError(f'`fips` has the wrong type: Received `{type(params.get("fips", None))}` expected `str | None`')
    if params.get("fips_run", None) is not None:
        if not isinstance(params["fips_run"], str):
            raise StyxValidationError(f'`fips_run` has the wrong type: Received `{type(params.get("fips_run", None))}` expected `str | None`')
    if params.get("xml_only", False) is None:
        raise StyxValidationError("`xml_only` must not be None")
    if not isinstance(params["xml_only"], bool):
        raise StyxValidationError(f'`xml_only` has the wrong type: Received `{type(params.get("xml_only", False))}` expected `bool`')
    if params.get("log", None) is not None:
        if not isinstance(params["log"], str):
            raise StyxValidationError(f'`log` has the wrong type: Received `{type(params.get("log", None))}` expected `str | None`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')


def dcmunpack_cargs(
    params: DcmunpackParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("dcmunpack")
    cargs.extend([
        "-src",
        params.get("src", None)
    ])
    if params.get("targ", None) is not None:
        cargs.extend([
            "-targ",
            params.get("targ", None)
        ])
    if params.get("run", None) is not None:
        cargs.extend([
            "-run",
            params.get("run", None)
        ])
    if params.get("auto_runseq", None) is not None:
        cargs.extend([
            "-auto-runseq",
            params.get("auto_runseq", None)
        ])
    if params.get("keep_scouts", False):
        cargs.append("-keep-scouts")
    if params.get("scanonly", None) is not None:
        cargs.extend([
            "-scanonly",
            params.get("scanonly", None)
        ])
    if params.get("one_per_dir", False):
        cargs.append("-one-per-dir")
    if params.get("ext", None) is not None:
        cargs.extend([
            "-ext",
            params.get("ext", None)
        ])
    if params.get("pre", None) is not None:
        cargs.extend([
            "-pre",
            params.get("pre", None)
        ])
    if params.get("pat", None) is not None:
        cargs.extend([
            "-pat",
            params.get("pat", None)
        ])
    if params.get("no_infodump", False):
        cargs.append("-no-infodump")
    if params.get("generic", False):
        cargs.append("-generic")
    if params.get("copy_only", False):
        cargs.append("-copy-only")
    if params.get("no_convert", False):
        cargs.append("-no-convert")
    if params.get("force_update", False):
        cargs.append("-force-update")
    if params.get("max", False):
        cargs.append("-max")
    if params.get("base", False):
        cargs.append("-base")
    if params.get("key_string", None) is not None:
        cargs.extend([
            "-key",
            params.get("key_string", None)
        ])
    if params.get("index_out", None) is not None:
        cargs.extend([
            "-index-out",
            params.get("index_out", None)
        ])
    if params.get("index_in", None) is not None:
        cargs.extend([
            "-index-in",
            params.get("index_in", None)
        ])
    if params.get("it_dicom", False):
        cargs.append("-itdicom")
    if params.get("no_exit_on_error", False):
        cargs.append("-no-exit-on-error")
    if params.get("run_skip", None) is not None:
        cargs.extend([
            "-run-skip",
            params.get("run_skip", None)
        ])
    if params.get("no_rescale_dicom", False):
        cargs.append("-no-rescale-dicom")
    if params.get("rescale_dicom", False):
        cargs.append("-rescale-dicom")
    if params.get("no_dwi", False):
        cargs.append("-no-dwi")
    if params.get("iid", None) is not None:
        cargs.extend([
            "-iid",
            *map(str, params.get("iid", None))
        ])
    if params.get("ijd", None) is not None:
        cargs.extend([
            "-ijd",
            *map(str, params.get("ijd", None))
        ])
    if params.get("ikd", None) is not None:
        cargs.extend([
            "-ikd",
            *map(str, params.get("ikd", None))
        ])
    if params.get("extra_info", False):
        cargs.append("-extra-info")
    if params.get("first_dicom", False):
        cargs.append("-first-dicom")
    if params.get("no_dcm2niix", False):
        cargs.append("-no-dcm2niix")
    if params.get("phase", False):
        cargs.append("-phase")
    if params.get("fips", None) is not None:
        cargs.extend([
            "-fips",
            params.get("fips", None)
        ])
    if params.get("fips_run", None) is not None:
        cargs.extend([
            "-fips-run",
            params.get("fips_run", None)
        ])
    if params.get("xml_only", False):
        cargs.append("-xml-only")
    if params.get("log", None) is not None:
        cargs.extend([
            "-log",
            params.get("log", None)
        ])
    if params.get("debug", False):
        cargs.append("-debug")
    return cargs


def dcmunpack_outputs(
    params: DcmunpackParamsDict,
    execution: Execution,
) -> DcmunpackOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = DcmunpackOutputs(
        root=execution.output_file("."),
    )
    return ret


def dcmunpack_execute(
    params: DcmunpackParamsDict,
    runner: Runner | None = None,
) -> DcmunpackOutputs:
    """
    dcmunpack
    
    Sorts and converts a directory of DICOM files (Siemens, GE, Philips) into an
    output hierarchy with nifti (nii), mgh, mgz, or analyze output formats.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DcmunpackOutputs`).
    """
    dcmunpack_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(DCMUNPACK_METADATA)
    params = execution.params(params)
    cargs = dcmunpack_cargs(params, execution)
    ret = dcmunpack_outputs(params, execution)
    execution.run(cargs)
    return ret


def dcmunpack(
    src: str,
    targ: str | None = None,
    run: str | None = None,
    auto_runseq: str | None = None,
    keep_scouts: bool = False,
    scanonly: str | None = None,
    one_per_dir: bool = False,
    ext: str | None = None,
    pre: str | None = None,
    pat: str | None = None,
    no_infodump: bool = False,
    generic: bool = False,
    copy_only: bool = False,
    no_convert: bool = False,
    force_update: bool = False,
    max_: bool = False,
    base: bool = False,
    key_string: str | None = None,
    index_out: str | None = None,
    index_in: str | None = None,
    it_dicom: bool = False,
    no_exit_on_error: bool = False,
    run_skip: str | None = None,
    no_rescale_dicom: bool = False,
    rescale_dicom: bool = False,
    no_dwi: bool = False,
    iid: list[float] | None = None,
    ijd: list[float] | None = None,
    ikd: list[float] | None = None,
    extra_info: bool = False,
    first_dicom: bool = False,
    no_dcm2niix: bool = False,
    phase: bool = False,
    fips: str | None = None,
    fips_run: str | None = None,
    xml_only: bool = False,
    log: str | None = None,
    debug: bool = False,
    runner: Runner | None = None,
) -> DcmunpackOutputs:
    """
    dcmunpack
    
    Sorts and converts a directory of DICOM files (Siemens, GE, Philips) into an
    output hierarchy with nifti (nii), mgh, mgz, or analyze output formats.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        src: Dicom source directory. You can specify more than one.
        targ: Output directory. Do not need to include when just getting\
            information about what is in the directory.
        run: Specify unpacking rules for a given run (series). Eg, "-run 3 bold\
            nii f.nii".
        auto_runseq: Save all scans in the targetdir as runo.seqname.format.
        keep_scouts: Unpack series with 'scout' or 'setter' in the name.
        scanonly: Only scan the directory and put result in file.
        one_per_dir: Assume that there is only one dicom series in each subdir.
        ext: Input extension (eg, dcm).
        pre: Input prefix (i.e., input file name init string).
        pat: Input pattern (i.e., string that occurs in the middle of file\
            name).
        no_infodump: Do not create the fname-infodump.dat file.
        generic: Do not use FSFAST hierarchy.
        copy_only: Only copy dicom files to output directory (implies\
            -no-convert).
        no_convert: Do not convert to output format.
        force_update: Convert even if output is newer than the input dicom.
        max_: Print out max in given dicom file.
        base: Report filename without path.
        key_string: Put keystring before each run line (good for searching).
        index_out: Save index of files to index.out.dat (for re-use).
        index_in: Read index of files (can make things much faster on 2nd run).
        it_dicom: Add -it dicom to mri_convert cmd line.
        no_exit_on_error: Continue to unpack data even if there is an error in\
            conversion.
        run_skip: Skip a given run (good when using -auto-runseq).
        no_rescale_dicom: Turn off DICOM rescaling based on tags (0028,1052)\
            (0028,1053).
        rescale_dicom: Turn DICOM rescaling on.
        no_dwi: Turn off trying to read DWI parameters.
        iid: Set -iid to mri_convert.
        ijd: Set -ijd to mri_convert.
        ikd: Set -ikd to mri_convert.
        extra_info: Add session info to each line of the info file (pat, date,\
            man, scan, field, serno).
        first_dicom: Copy first dicom file into output folder.
        no_dcm2niix: Turn off dcm2niix conversion.
        phase: Add the string _phase to volumes that are phase images based on\
            ImageType.
        fips: Fips parameters: project, site, birnid, visit.
        fips_run: Fips-run parameters: run paradigm.
        xml_only: For fips, only create xml file, do not convert to output.
        log: Log output to a file.
        debug: Enable debug mode.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DcmunpackOutputs`).
    """
    params = dcmunpack_params(
        src=src,
        targ=targ,
        run=run,
        auto_runseq=auto_runseq,
        keep_scouts=keep_scouts,
        scanonly=scanonly,
        one_per_dir=one_per_dir,
        ext=ext,
        pre=pre,
        pat=pat,
        no_infodump=no_infodump,
        generic=generic,
        copy_only=copy_only,
        no_convert=no_convert,
        force_update=force_update,
        max_=max_,
        base=base,
        key_string=key_string,
        index_out=index_out,
        index_in=index_in,
        it_dicom=it_dicom,
        no_exit_on_error=no_exit_on_error,
        run_skip=run_skip,
        no_rescale_dicom=no_rescale_dicom,
        rescale_dicom=rescale_dicom,
        no_dwi=no_dwi,
        iid=iid,
        ijd=ijd,
        ikd=ikd,
        extra_info=extra_info,
        first_dicom=first_dicom,
        no_dcm2niix=no_dcm2niix,
        phase=phase,
        fips=fips,
        fips_run=fips_run,
        xml_only=xml_only,
        log=log,
        debug=debug,
    )
    return dcmunpack_execute(params, runner)


__all__ = [
    "DCMUNPACK_METADATA",
    "DcmunpackOutputs",
    "DcmunpackParamsDict",
    "DcmunpackParamsDictTagged",
    "dcmunpack",
    "dcmunpack_execute",
    "dcmunpack_params",
]
