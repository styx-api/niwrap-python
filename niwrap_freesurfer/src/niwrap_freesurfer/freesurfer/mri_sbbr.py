# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_SBBR_METADATA = Metadata(
    id="f31466d75bb8746da707f689b11c907a72c713e3.boutiques",
    name="mri_sbbr",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriSbbrParamsDictNoTag = typing.TypedDict('_MriSbbrParamsDictNoTag', {
    "template_volume": InputPathType,
    "surface_file": InputPathType,
    "init_reg_file": InputPathType,
    "t1": bool,
    "t2": bool,
    "optimization_type": typing.NotRequired[float | None],
    "distance_in": typing.NotRequired[float | None],
    "distance_out": typing.NotRequired[float | None],
    "slope": typing.NotRequired[float | None],
    "ftol": typing.NotRequired[float | None],
    "linmintol": typing.NotRequired[float | None],
    "niters_max": typing.NotRequired[float | None],
    "search": typing.NotRequired[str | None],
    "search1d": typing.NotRequired[str | None],
    "parameter_set": typing.NotRequired[str | None],
    "increment": typing.NotRequired[float | None],
    "slice_number": typing.NotRequired[float | None],
    "threads": typing.NotRequired[float | None],
    "output_registration": typing.NotRequired[str | None],
    "inverted_output_registration": typing.NotRequired[str | None],
    "output_surface": typing.NotRequired[str | None],
    "debug": bool,
    "diagnostic": bool,
    "check_options": bool,
})
MriSbbrParamsDictTagged = typing.TypedDict('MriSbbrParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_sbbr"],
    "template_volume": InputPathType,
    "surface_file": InputPathType,
    "init_reg_file": InputPathType,
    "t1": bool,
    "t2": bool,
    "optimization_type": typing.NotRequired[float | None],
    "distance_in": typing.NotRequired[float | None],
    "distance_out": typing.NotRequired[float | None],
    "slope": typing.NotRequired[float | None],
    "ftol": typing.NotRequired[float | None],
    "linmintol": typing.NotRequired[float | None],
    "niters_max": typing.NotRequired[float | None],
    "search": typing.NotRequired[str | None],
    "search1d": typing.NotRequired[str | None],
    "parameter_set": typing.NotRequired[str | None],
    "increment": typing.NotRequired[float | None],
    "slice_number": typing.NotRequired[float | None],
    "threads": typing.NotRequired[float | None],
    "output_registration": typing.NotRequired[str | None],
    "inverted_output_registration": typing.NotRequired[str | None],
    "output_surface": typing.NotRequired[str | None],
    "debug": bool,
    "diagnostic": bool,
    "check_options": bool,
})
MriSbbrParamsDict = _MriSbbrParamsDictNoTag | MriSbbrParamsDictTagged


class MriSbbrOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriSbbrParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mri_sbbr_params(
    template_volume: InputPathType,
    surface_file: InputPathType,
    init_reg_file: InputPathType,
    t1: bool = False,
    t2: bool = False,
    optimization_type: float | None = None,
    distance_in: float | None = None,
    distance_out: float | None = None,
    slope: float | None = None,
    ftol: float | None = None,
    linmintol: float | None = None,
    niters_max: float | None = None,
    search: str | None = None,
    search1d: str | None = None,
    parameter_set: str | None = None,
    increment: float | None = None,
    slice_number: float | None = None,
    threads: float | None = None,
    output_registration: str | None = None,
    inverted_output_registration: str | None = None,
    output_surface: str | None = None,
    debug: bool = False,
    diagnostic: bool = False,
    check_options: bool = False,
) -> MriSbbrParamsDictTagged:
    """
    Build parameters.
    
    Args:
        template_volume: Template volume file.
        surface_file: Surface file.
        init_reg_file: Initial registration file.
        t1: Use T1-weighted image.
        t2: Use T2-weighted image.
        optimization_type: Optimization type; choose 1, 2, or 3 (default is 1,\
            6 dof).
        distance_in: Distance in mm into surface (default 1.0).
        distance_out: Distance in mm out of surface (default 2.0).
        slope: BBR slope (default 0.5).
        ftol: Tolerance for fitting (default 1.000000e-08).
        linmintol: Linear minimization tolerance (default 0.0).
        niters_max: Maximum number of iterations (default 10).
        search: Brute force search through parameter space.
        search1d: 1D search through parameter space.
        parameter_set: Set initial parameter.
        increment: Face number increment (default 1).
        slice_number: Slice number (defaults to 0).
        threads: Number of threads.
        output_registration: Output registration file.
        inverted_output_registration: Inverted output registration file.
        output_surface: Output surface in slice coordinates.
        debug: Turn on debugging.
        diagnostic: Turn on diagnostics.
        check_options: Don't run anything, just check options and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_sbbr",
        "template_volume": template_volume,
        "surface_file": surface_file,
        "init_reg_file": init_reg_file,
        "t1": t1,
        "t2": t2,
        "debug": debug,
        "diagnostic": diagnostic,
        "check_options": check_options,
    }
    if optimization_type is not None:
        params["optimization_type"] = optimization_type
    if distance_in is not None:
        params["distance_in"] = distance_in
    if distance_out is not None:
        params["distance_out"] = distance_out
    if slope is not None:
        params["slope"] = slope
    if ftol is not None:
        params["ftol"] = ftol
    if linmintol is not None:
        params["linmintol"] = linmintol
    if niters_max is not None:
        params["niters_max"] = niters_max
    if search is not None:
        params["search"] = search
    if search1d is not None:
        params["search1d"] = search1d
    if parameter_set is not None:
        params["parameter_set"] = parameter_set
    if increment is not None:
        params["increment"] = increment
    if slice_number is not None:
        params["slice_number"] = slice_number
    if threads is not None:
        params["threads"] = threads
    if output_registration is not None:
        params["output_registration"] = output_registration
    if inverted_output_registration is not None:
        params["inverted_output_registration"] = inverted_output_registration
    if output_surface is not None:
        params["output_surface"] = output_surface
    return params


def mri_sbbr_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriSbbrParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("template_volume", None) is None:
        raise StyxValidationError("`template_volume` must not be None")
    if not isinstance(params["template_volume"], (pathlib.Path, str)):
        raise StyxValidationError(f'`template_volume` has the wrong type: Received `{type(params.get("template_volume", None))}` expected `InputPathType`')
    if params.get("surface_file", None) is None:
        raise StyxValidationError("`surface_file` must not be None")
    if not isinstance(params["surface_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`surface_file` has the wrong type: Received `{type(params.get("surface_file", None))}` expected `InputPathType`')
    if params.get("init_reg_file", None) is None:
        raise StyxValidationError("`init_reg_file` must not be None")
    if not isinstance(params["init_reg_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`init_reg_file` has the wrong type: Received `{type(params.get("init_reg_file", None))}` expected `InputPathType`')
    if params.get("t1", False) is None:
        raise StyxValidationError("`t1` must not be None")
    if not isinstance(params["t1"], bool):
        raise StyxValidationError(f'`t1` has the wrong type: Received `{type(params.get("t1", False))}` expected `bool`')
    if params.get("t2", False) is None:
        raise StyxValidationError("`t2` must not be None")
    if not isinstance(params["t2"], bool):
        raise StyxValidationError(f'`t2` has the wrong type: Received `{type(params.get("t2", False))}` expected `bool`')
    if params.get("optimization_type", None) is not None:
        if not isinstance(params["optimization_type"], (float, int)):
            raise StyxValidationError(f'`optimization_type` has the wrong type: Received `{type(params.get("optimization_type", None))}` expected `float | None`')
    if params.get("distance_in", None) is not None:
        if not isinstance(params["distance_in"], (float, int)):
            raise StyxValidationError(f'`distance_in` has the wrong type: Received `{type(params.get("distance_in", None))}` expected `float | None`')
    if params.get("distance_out", None) is not None:
        if not isinstance(params["distance_out"], (float, int)):
            raise StyxValidationError(f'`distance_out` has the wrong type: Received `{type(params.get("distance_out", None))}` expected `float | None`')
    if params.get("slope", None) is not None:
        if not isinstance(params["slope"], (float, int)):
            raise StyxValidationError(f'`slope` has the wrong type: Received `{type(params.get("slope", None))}` expected `float | None`')
    if params.get("ftol", None) is not None:
        if not isinstance(params["ftol"], (float, int)):
            raise StyxValidationError(f'`ftol` has the wrong type: Received `{type(params.get("ftol", None))}` expected `float | None`')
    if params.get("linmintol", None) is not None:
        if not isinstance(params["linmintol"], (float, int)):
            raise StyxValidationError(f'`linmintol` has the wrong type: Received `{type(params.get("linmintol", None))}` expected `float | None`')
    if params.get("niters_max", None) is not None:
        if not isinstance(params["niters_max"], (float, int)):
            raise StyxValidationError(f'`niters_max` has the wrong type: Received `{type(params.get("niters_max", None))}` expected `float | None`')
    if params.get("search", None) is not None:
        if not isinstance(params["search"], str):
            raise StyxValidationError(f'`search` has the wrong type: Received `{type(params.get("search", None))}` expected `str | None`')
    if params.get("search1d", None) is not None:
        if not isinstance(params["search1d"], str):
            raise StyxValidationError(f'`search1d` has the wrong type: Received `{type(params.get("search1d", None))}` expected `str | None`')
    if params.get("parameter_set", None) is not None:
        if not isinstance(params["parameter_set"], str):
            raise StyxValidationError(f'`parameter_set` has the wrong type: Received `{type(params.get("parameter_set", None))}` expected `str | None`')
    if params.get("increment", None) is not None:
        if not isinstance(params["increment"], (float, int)):
            raise StyxValidationError(f'`increment` has the wrong type: Received `{type(params.get("increment", None))}` expected `float | None`')
    if params.get("slice_number", None) is not None:
        if not isinstance(params["slice_number"], (float, int)):
            raise StyxValidationError(f'`slice_number` has the wrong type: Received `{type(params.get("slice_number", None))}` expected `float | None`')
    if params.get("threads", None) is not None:
        if not isinstance(params["threads"], (float, int)):
            raise StyxValidationError(f'`threads` has the wrong type: Received `{type(params.get("threads", None))}` expected `float | None`')
    if params.get("output_registration", None) is not None:
        if not isinstance(params["output_registration"], str):
            raise StyxValidationError(f'`output_registration` has the wrong type: Received `{type(params.get("output_registration", None))}` expected `str | None`')
    if params.get("inverted_output_registration", None) is not None:
        if not isinstance(params["inverted_output_registration"], str):
            raise StyxValidationError(f'`inverted_output_registration` has the wrong type: Received `{type(params.get("inverted_output_registration", None))}` expected `str | None`')
    if params.get("output_surface", None) is not None:
        if not isinstance(params["output_surface"], str):
            raise StyxValidationError(f'`output_surface` has the wrong type: Received `{type(params.get("output_surface", None))}` expected `str | None`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("diagnostic", False) is None:
        raise StyxValidationError("`diagnostic` must not be None")
    if not isinstance(params["diagnostic"], bool):
        raise StyxValidationError(f'`diagnostic` has the wrong type: Received `{type(params.get("diagnostic", False))}` expected `bool`')
    if params.get("check_options", False) is None:
        raise StyxValidationError("`check_options` must not be None")
    if not isinstance(params["check_options"], bool):
        raise StyxValidationError(f'`check_options` has the wrong type: Received `{type(params.get("check_options", False))}` expected `bool`')


def mri_sbbr_cargs(
    params: MriSbbrParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_sbbr")
    cargs.extend([
        "--mov",
        execution.input_file(params.get("template_volume", None))
    ])
    cargs.extend([
        "--surf",
        execution.input_file(params.get("surface_file", None))
    ])
    cargs.extend([
        "--init-reg",
        execution.input_file(params.get("init_reg_file", None))
    ])
    if params.get("t1", False):
        cargs.append("--t1")
    if params.get("t2", False):
        cargs.append("--t2")
    if params.get("optimization_type", None) is not None:
        cargs.extend([
            "--opt",
            str(params.get("optimization_type", None))
        ])
    if params.get("distance_in", None) is not None:
        cargs.extend([
            "--din",
            str(params.get("distance_in", None))
        ])
    if params.get("distance_out", None) is not None:
        cargs.extend([
            "--dout",
            str(params.get("distance_out", None))
        ])
    if params.get("slope", None) is not None:
        cargs.extend([
            "--slope",
            str(params.get("slope", None))
        ])
    if params.get("ftol", None) is not None:
        cargs.extend([
            "--ftol",
            str(params.get("ftol", None))
        ])
    if params.get("linmintol", None) is not None:
        cargs.extend([
            "--linmintol",
            str(params.get("linmintol", None))
        ])
    if params.get("niters_max", None) is not None:
        cargs.extend([
            "--niters-max",
            str(params.get("niters_max", None))
        ])
    if params.get("search", None) is not None:
        cargs.extend([
            "--search",
            params.get("search", None)
        ])
    if params.get("search1d", None) is not None:
        cargs.extend([
            "--search1d",
            params.get("search1d", None)
        ])
    if params.get("parameter_set", None) is not None:
        cargs.extend([
            "--p",
            params.get("parameter_set", None)
        ])
    if params.get("increment", None) is not None:
        cargs.extend([
            "--inc",
            str(params.get("increment", None))
        ])
    if params.get("slice_number", None) is not None:
        cargs.extend([
            "--slice",
            str(params.get("slice_number", None))
        ])
    if params.get("threads", None) is not None:
        cargs.extend([
            "--threads",
            str(params.get("threads", None))
        ])
    if params.get("output_registration", None) is not None:
        cargs.extend([
            "--reg",
            params.get("output_registration", None)
        ])
    if params.get("inverted_output_registration", None) is not None:
        cargs.extend([
            "--reg-inv",
            params.get("inverted_output_registration", None)
        ])
    if params.get("output_surface", None) is not None:
        cargs.extend([
            "--out-surf",
            params.get("output_surface", None)
        ])
    if params.get("debug", False):
        cargs.append("--debug")
    if params.get("diagnostic", False):
        cargs.append("--diag")
    if params.get("check_options", False):
        cargs.append("--checkopts")
    return cargs


def mri_sbbr_outputs(
    params: MriSbbrParamsDict,
    execution: Execution,
) -> MriSbbrOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriSbbrOutputs(
        root=execution.output_file("."),
    )
    return ret


def mri_sbbr_execute(
    params: MriSbbrParamsDict,
    runner: Runner | None = None,
) -> MriSbbrOutputs:
    """
    mri_sbbr
    
    Special implementation of boundary-based registration for a single slice.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriSbbrOutputs`).
    """
    mri_sbbr_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_SBBR_METADATA)
    params = execution.params(params)
    cargs = mri_sbbr_cargs(params, execution)
    ret = mri_sbbr_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_sbbr(
    template_volume: InputPathType,
    surface_file: InputPathType,
    init_reg_file: InputPathType,
    t1: bool = False,
    t2: bool = False,
    optimization_type: float | None = None,
    distance_in: float | None = None,
    distance_out: float | None = None,
    slope: float | None = None,
    ftol: float | None = None,
    linmintol: float | None = None,
    niters_max: float | None = None,
    search: str | None = None,
    search1d: str | None = None,
    parameter_set: str | None = None,
    increment: float | None = None,
    slice_number: float | None = None,
    threads: float | None = None,
    output_registration: str | None = None,
    inverted_output_registration: str | None = None,
    output_surface: str | None = None,
    debug: bool = False,
    diagnostic: bool = False,
    check_options: bool = False,
    runner: Runner | None = None,
) -> MriSbbrOutputs:
    """
    mri_sbbr
    
    Special implementation of boundary-based registration for a single slice.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        template_volume: Template volume file.
        surface_file: Surface file.
        init_reg_file: Initial registration file.
        t1: Use T1-weighted image.
        t2: Use T2-weighted image.
        optimization_type: Optimization type; choose 1, 2, or 3 (default is 1,\
            6 dof).
        distance_in: Distance in mm into surface (default 1.0).
        distance_out: Distance in mm out of surface (default 2.0).
        slope: BBR slope (default 0.5).
        ftol: Tolerance for fitting (default 1.000000e-08).
        linmintol: Linear minimization tolerance (default 0.0).
        niters_max: Maximum number of iterations (default 10).
        search: Brute force search through parameter space.
        search1d: 1D search through parameter space.
        parameter_set: Set initial parameter.
        increment: Face number increment (default 1).
        slice_number: Slice number (defaults to 0).
        threads: Number of threads.
        output_registration: Output registration file.
        inverted_output_registration: Inverted output registration file.
        output_surface: Output surface in slice coordinates.
        debug: Turn on debugging.
        diagnostic: Turn on diagnostics.
        check_options: Don't run anything, just check options and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriSbbrOutputs`).
    """
    params = mri_sbbr_params(
        template_volume=template_volume,
        surface_file=surface_file,
        init_reg_file=init_reg_file,
        t1=t1,
        t2=t2,
        optimization_type=optimization_type,
        distance_in=distance_in,
        distance_out=distance_out,
        slope=slope,
        ftol=ftol,
        linmintol=linmintol,
        niters_max=niters_max,
        search=search,
        search1d=search1d,
        parameter_set=parameter_set,
        increment=increment,
        slice_number=slice_number,
        threads=threads,
        output_registration=output_registration,
        inverted_output_registration=inverted_output_registration,
        output_surface=output_surface,
        debug=debug,
        diagnostic=diagnostic,
        check_options=check_options,
    )
    return mri_sbbr_execute(params, runner)


__all__ = [
    "MRI_SBBR_METADATA",
    "MriSbbrOutputs",
    "MriSbbrParamsDict",
    "MriSbbrParamsDictTagged",
    "mri_sbbr",
    "mri_sbbr_execute",
    "mri_sbbr_params",
]
