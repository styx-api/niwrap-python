# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRIS_CURVATURE_METADATA = Metadata(
    id="e92c22042bd610ff8fb2a3672334f4c3c5724995.boutiques",
    name="mris_curvature",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MrisCurvatureParamsDictNoTag = typing.TypedDict('_MrisCurvatureParamsDictNoTag', {
    "save_curvature_files": bool,
    "max_principal_curvature": bool,
    "mgh_output_format": bool,
    "min_principal_curvature": bool,
    "iterative_averages": typing.NotRequired[float | None],
    "neighborhood_size": typing.NotRequired[float | None],
    "random_seed": typing.NotRequired[float | None],
    "curvatures": typing.NotRequired[str | None],
    "H_curvature": typing.NotRequired[str | None],
    "K_curvature": typing.NotRequired[str | None],
    "k1_curvature": typing.NotRequired[str | None],
    "k2_curvature": typing.NotRequired[str | None],
    "k1k2_curvature": typing.NotRequired[str | None],
    "input_surface": InputPathType,
})
MrisCurvatureParamsDictTagged = typing.TypedDict('MrisCurvatureParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mris_curvature"],
    "save_curvature_files": bool,
    "max_principal_curvature": bool,
    "mgh_output_format": bool,
    "min_principal_curvature": bool,
    "iterative_averages": typing.NotRequired[float | None],
    "neighborhood_size": typing.NotRequired[float | None],
    "random_seed": typing.NotRequired[float | None],
    "curvatures": typing.NotRequired[str | None],
    "H_curvature": typing.NotRequired[str | None],
    "K_curvature": typing.NotRequired[str | None],
    "k1_curvature": typing.NotRequired[str | None],
    "k2_curvature": typing.NotRequired[str | None],
    "k1k2_curvature": typing.NotRequired[str | None],
    "input_surface": InputPathType,
})
MrisCurvatureParamsDict = _MrisCurvatureParamsDictNoTag | MrisCurvatureParamsDictTagged


class MrisCurvatureOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MrisCurvatureParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mris_curvature_params(
    input_surface: InputPathType,
    save_curvature_files: bool = False,
    max_principal_curvature: bool = False,
    mgh_output_format: bool = False,
    min_principal_curvature: bool = False,
    iterative_averages: float | None = None,
    neighborhood_size: float | None = None,
    random_seed: float | None = None,
    curvatures: str | None = None,
    h_curvature: str | None = None,
    k_curvature: str | None = None,
    k1_curvature: str | None = None,
    k2_curvature: str | None = None,
    k1k2_curvature: str | None = None,
) -> MrisCurvatureParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_surface: Input surface file.
        save_curvature_files: Save curvature files (will only generate screen\
            output without this option).
        max_principal_curvature: Save 1st (max) principal curvature in\
            ?h.<surface>.max file.
        mgh_output_format: Save outputs in .mgz format.
        min_principal_curvature: Save 2nd (min) principal curvature in\
            ?h.<surface>.min file.
        iterative_averages: Perform <avgs> iterative averages of curvature\
            measure before saving.
        neighborhood_size: Set neighborhood size to nbrs.
        random_seed: Set random number generator to seed N.
        curvatures: Stand-alone option to save H (mean), K (gaussian), k1, and\
            k2 curvatures to stem.{curvname}.mgz.
        h_curvature: Stand-alone option to save H mean curvature to stem.H.mgz.
        k_curvature: Stand-alone option to save K gaussian curvature to\
            stem.K.mgz.
        k1_curvature: Stand-alone option to save k1 (primary principle)\
            curvature to stem.k1.mgz.
        k2_curvature: Stand-alone option to save k2 (secondary principle)\
            curvature to stem.k2.mgz.
        k1k2_curvature: Stand-alone option to save k1 and k2 curvature to\
            stem.{k1,k2}.mgz.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mris_curvature",
        "save_curvature_files": save_curvature_files,
        "max_principal_curvature": max_principal_curvature,
        "mgh_output_format": mgh_output_format,
        "min_principal_curvature": min_principal_curvature,
        "input_surface": input_surface,
    }
    if iterative_averages is not None:
        params["iterative_averages"] = iterative_averages
    if neighborhood_size is not None:
        params["neighborhood_size"] = neighborhood_size
    if random_seed is not None:
        params["random_seed"] = random_seed
    if curvatures is not None:
        params["curvatures"] = curvatures
    if h_curvature is not None:
        params["H_curvature"] = h_curvature
    if k_curvature is not None:
        params["K_curvature"] = k_curvature
    if k1_curvature is not None:
        params["k1_curvature"] = k1_curvature
    if k2_curvature is not None:
        params["k2_curvature"] = k2_curvature
    if k1k2_curvature is not None:
        params["k1k2_curvature"] = k1k2_curvature
    return params


def mris_curvature_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrisCurvatureParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("save_curvature_files", False) is None:
        raise StyxValidationError("`save_curvature_files` must not be None")
    if not isinstance(params["save_curvature_files"], bool):
        raise StyxValidationError(f'`save_curvature_files` has the wrong type: Received `{type(params.get("save_curvature_files", False))}` expected `bool`')
    if params.get("max_principal_curvature", False) is None:
        raise StyxValidationError("`max_principal_curvature` must not be None")
    if not isinstance(params["max_principal_curvature"], bool):
        raise StyxValidationError(f'`max_principal_curvature` has the wrong type: Received `{type(params.get("max_principal_curvature", False))}` expected `bool`')
    if params.get("mgh_output_format", False) is None:
        raise StyxValidationError("`mgh_output_format` must not be None")
    if not isinstance(params["mgh_output_format"], bool):
        raise StyxValidationError(f'`mgh_output_format` has the wrong type: Received `{type(params.get("mgh_output_format", False))}` expected `bool`')
    if params.get("min_principal_curvature", False) is None:
        raise StyxValidationError("`min_principal_curvature` must not be None")
    if not isinstance(params["min_principal_curvature"], bool):
        raise StyxValidationError(f'`min_principal_curvature` has the wrong type: Received `{type(params.get("min_principal_curvature", False))}` expected `bool`')
    if params.get("iterative_averages", None) is not None:
        if not isinstance(params["iterative_averages"], (float, int)):
            raise StyxValidationError(f'`iterative_averages` has the wrong type: Received `{type(params.get("iterative_averages", None))}` expected `float | None`')
    if params.get("neighborhood_size", None) is not None:
        if not isinstance(params["neighborhood_size"], (float, int)):
            raise StyxValidationError(f'`neighborhood_size` has the wrong type: Received `{type(params.get("neighborhood_size", None))}` expected `float | None`')
    if params.get("random_seed", None) is not None:
        if not isinstance(params["random_seed"], (float, int)):
            raise StyxValidationError(f'`random_seed` has the wrong type: Received `{type(params.get("random_seed", None))}` expected `float | None`')
    if params.get("curvatures", None) is not None:
        if not isinstance(params["curvatures"], str):
            raise StyxValidationError(f'`curvatures` has the wrong type: Received `{type(params.get("curvatures", None))}` expected `str | None`')
    if params.get("H_curvature", None) is not None:
        if not isinstance(params["H_curvature"], str):
            raise StyxValidationError(f'`H_curvature` has the wrong type: Received `{type(params.get("H_curvature", None))}` expected `str | None`')
    if params.get("K_curvature", None) is not None:
        if not isinstance(params["K_curvature"], str):
            raise StyxValidationError(f'`K_curvature` has the wrong type: Received `{type(params.get("K_curvature", None))}` expected `str | None`')
    if params.get("k1_curvature", None) is not None:
        if not isinstance(params["k1_curvature"], str):
            raise StyxValidationError(f'`k1_curvature` has the wrong type: Received `{type(params.get("k1_curvature", None))}` expected `str | None`')
    if params.get("k2_curvature", None) is not None:
        if not isinstance(params["k2_curvature"], str):
            raise StyxValidationError(f'`k2_curvature` has the wrong type: Received `{type(params.get("k2_curvature", None))}` expected `str | None`')
    if params.get("k1k2_curvature", None) is not None:
        if not isinstance(params["k1k2_curvature"], str):
            raise StyxValidationError(f'`k1k2_curvature` has the wrong type: Received `{type(params.get("k1k2_curvature", None))}` expected `str | None`')
    if params.get("input_surface", None) is None:
        raise StyxValidationError("`input_surface` must not be None")
    if not isinstance(params["input_surface"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input_surface` has the wrong type: Received `{type(params.get("input_surface", None))}` expected `InputPathType`')


def mris_curvature_cargs(
    params: MrisCurvatureParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mris_curvature")
    if params.get("save_curvature_files", False):
        cargs.append("-w")
    if params.get("max_principal_curvature", False):
        cargs.append("-max")
    if params.get("mgh_output_format", False):
        cargs.append("-mgh")
    if params.get("min_principal_curvature", False):
        cargs.append("-min")
    if params.get("iterative_averages", None) is not None:
        cargs.extend([
            "-a",
            str(params.get("iterative_averages", None))
        ])
    if params.get("neighborhood_size", None) is not None:
        cargs.extend([
            "-nbrs",
            str(params.get("neighborhood_size", None))
        ])
    if params.get("random_seed", None) is not None:
        cargs.extend([
            "-seed",
            str(params.get("random_seed", None))
        ])
    if params.get("curvatures", None) is not None:
        cargs.extend([
            "-curvs",
            params.get("curvatures", None)
        ])
    if params.get("H_curvature", None) is not None:
        cargs.extend([
            "-H",
            params.get("H_curvature", None)
        ])
    if params.get("K_curvature", None) is not None:
        cargs.extend([
            "-K",
            params.get("K_curvature", None)
        ])
    if params.get("k1_curvature", None) is not None:
        cargs.extend([
            "-k1",
            params.get("k1_curvature", None)
        ])
    if params.get("k2_curvature", None) is not None:
        cargs.extend([
            "-k2",
            params.get("k2_curvature", None)
        ])
    if params.get("k1k2_curvature", None) is not None:
        cargs.extend([
            "-k1k2",
            params.get("k1k2_curvature", None)
        ])
    cargs.append(execution.input_file(params.get("input_surface", None)))
    return cargs


def mris_curvature_outputs(
    params: MrisCurvatureParamsDict,
    execution: Execution,
) -> MrisCurvatureOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MrisCurvatureOutputs(
        root=execution.output_file("."),
    )
    return ret


def mris_curvature_execute(
    params: MrisCurvatureParamsDict,
    runner: Runner | None = None,
) -> MrisCurvatureOutputs:
    """
    mris_curvature
    
    Compute the second fundamental form of a cortical surface to generate mean
    and Gaussian curvature.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrisCurvatureOutputs`).
    """
    mris_curvature_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRIS_CURVATURE_METADATA)
    params = execution.params(params)
    cargs = mris_curvature_cargs(params, execution)
    ret = mris_curvature_outputs(params, execution)
    execution.run(cargs)
    return ret


def mris_curvature(
    input_surface: InputPathType,
    save_curvature_files: bool = False,
    max_principal_curvature: bool = False,
    mgh_output_format: bool = False,
    min_principal_curvature: bool = False,
    iterative_averages: float | None = None,
    neighborhood_size: float | None = None,
    random_seed: float | None = None,
    curvatures: str | None = None,
    h_curvature: str | None = None,
    k_curvature: str | None = None,
    k1_curvature: str | None = None,
    k2_curvature: str | None = None,
    k1k2_curvature: str | None = None,
    runner: Runner | None = None,
) -> MrisCurvatureOutputs:
    """
    mris_curvature
    
    Compute the second fundamental form of a cortical surface to generate mean
    and Gaussian curvature.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        input_surface: Input surface file.
        save_curvature_files: Save curvature files (will only generate screen\
            output without this option).
        max_principal_curvature: Save 1st (max) principal curvature in\
            ?h.<surface>.max file.
        mgh_output_format: Save outputs in .mgz format.
        min_principal_curvature: Save 2nd (min) principal curvature in\
            ?h.<surface>.min file.
        iterative_averages: Perform <avgs> iterative averages of curvature\
            measure before saving.
        neighborhood_size: Set neighborhood size to nbrs.
        random_seed: Set random number generator to seed N.
        curvatures: Stand-alone option to save H (mean), K (gaussian), k1, and\
            k2 curvatures to stem.{curvname}.mgz.
        h_curvature: Stand-alone option to save H mean curvature to stem.H.mgz.
        k_curvature: Stand-alone option to save K gaussian curvature to\
            stem.K.mgz.
        k1_curvature: Stand-alone option to save k1 (primary principle)\
            curvature to stem.k1.mgz.
        k2_curvature: Stand-alone option to save k2 (secondary principle)\
            curvature to stem.k2.mgz.
        k1k2_curvature: Stand-alone option to save k1 and k2 curvature to\
            stem.{k1,k2}.mgz.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrisCurvatureOutputs`).
    """
    params = mris_curvature_params(
        save_curvature_files=save_curvature_files,
        max_principal_curvature=max_principal_curvature,
        mgh_output_format=mgh_output_format,
        min_principal_curvature=min_principal_curvature,
        iterative_averages=iterative_averages,
        neighborhood_size=neighborhood_size,
        random_seed=random_seed,
        curvatures=curvatures,
        h_curvature=h_curvature,
        k_curvature=k_curvature,
        k1_curvature=k1_curvature,
        k2_curvature=k2_curvature,
        k1k2_curvature=k1k2_curvature,
        input_surface=input_surface,
    )
    return mris_curvature_execute(params, runner)


__all__ = [
    "MRIS_CURVATURE_METADATA",
    "MrisCurvatureOutputs",
    "MrisCurvatureParamsDict",
    "MrisCurvatureParamsDictTagged",
    "mris_curvature",
    "mris_curvature_execute",
    "mris_curvature_params",
]
