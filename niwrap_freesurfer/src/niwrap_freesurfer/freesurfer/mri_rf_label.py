# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_RF_LABEL_METADATA = Metadata(
    id="d8817c141ee26baedd9256746100982c4e3248cf.boutiques",
    name="mri_rf_label",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriRfLabelParamsDictNoTag = typing.TypedDict('_MriRfLabelParamsDictNoTag', {
    "input_volumes": list[InputPathType],
    "transform_file": InputPathType,
    "gcafile": InputPathType,
    "output_volume": str,
    "cross_sequence_flag": bool,
    "nogibbs_flag": bool,
    "wm_path": typing.NotRequired[InputPathType | None],
    "conform_flag": bool,
    "normpd_flag": bool,
    "gca_tl": typing.NotRequired[InputPathType | None],
    "debug_voxel": typing.NotRequired[list[float] | None],
    "debug_node": typing.NotRequired[list[float] | None],
    "debug_label": typing.NotRequired[float | None],
    "tr": typing.NotRequired[float | None],
    "te": typing.NotRequired[float | None],
    "alpha": typing.NotRequired[float | None],
    "example": typing.NotRequired[list[InputPathType] | None],
    "pthresh": typing.NotRequired[float | None],
    "niter": typing.NotRequired[float | None],
    "novar_flag": bool,
    "regularize": typing.NotRequired[float | None],
    "nohippo_flag": bool,
    "fwm": typing.NotRequired[InputPathType | None],
    "mri_vol": typing.NotRequired[InputPathType | None],
    "heq": typing.NotRequired[InputPathType | None],
    "renorm": typing.NotRequired[InputPathType | None],
    "flash_flag": bool,
    "flash_params": typing.NotRequired[InputPathType | None],
    "renormalize": typing.NotRequired[list[float] | None],
    "set_input": typing.NotRequired[InputPathType | None],
    "histogram_flag": bool,
    "cond_density_mean": typing.NotRequired[float | None],
    "snapshots": typing.NotRequired[list[str] | None],
    "mask": typing.NotRequired[InputPathType | None],
    "expand": typing.NotRequired[float | None],
    "max_iter": typing.NotRequired[float | None],
    "filter_mode": typing.NotRequired[list[float] | None],
    "longitudinal_vol": typing.NotRequired[InputPathType | None],
    "longitudinal_lta": typing.NotRequired[InputPathType | None],
    "relabel_unlikely_flag": typing.NotRequired[list[float] | None],
})
MriRfLabelParamsDictTagged = typing.TypedDict('MriRfLabelParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_rf_label"],
    "input_volumes": list[InputPathType],
    "transform_file": InputPathType,
    "gcafile": InputPathType,
    "output_volume": str,
    "cross_sequence_flag": bool,
    "nogibbs_flag": bool,
    "wm_path": typing.NotRequired[InputPathType | None],
    "conform_flag": bool,
    "normpd_flag": bool,
    "gca_tl": typing.NotRequired[InputPathType | None],
    "debug_voxel": typing.NotRequired[list[float] | None],
    "debug_node": typing.NotRequired[list[float] | None],
    "debug_label": typing.NotRequired[float | None],
    "tr": typing.NotRequired[float | None],
    "te": typing.NotRequired[float | None],
    "alpha": typing.NotRequired[float | None],
    "example": typing.NotRequired[list[InputPathType] | None],
    "pthresh": typing.NotRequired[float | None],
    "niter": typing.NotRequired[float | None],
    "novar_flag": bool,
    "regularize": typing.NotRequired[float | None],
    "nohippo_flag": bool,
    "fwm": typing.NotRequired[InputPathType | None],
    "mri_vol": typing.NotRequired[InputPathType | None],
    "heq": typing.NotRequired[InputPathType | None],
    "renorm": typing.NotRequired[InputPathType | None],
    "flash_flag": bool,
    "flash_params": typing.NotRequired[InputPathType | None],
    "renormalize": typing.NotRequired[list[float] | None],
    "set_input": typing.NotRequired[InputPathType | None],
    "histogram_flag": bool,
    "cond_density_mean": typing.NotRequired[float | None],
    "snapshots": typing.NotRequired[list[str] | None],
    "mask": typing.NotRequired[InputPathType | None],
    "expand": typing.NotRequired[float | None],
    "max_iter": typing.NotRequired[float | None],
    "filter_mode": typing.NotRequired[list[float] | None],
    "longitudinal_vol": typing.NotRequired[InputPathType | None],
    "longitudinal_lta": typing.NotRequired[InputPathType | None],
    "relabel_unlikely_flag": typing.NotRequired[list[float] | None],
})
MriRfLabelParamsDict = _MriRfLabelParamsDictNoTag | MriRfLabelParamsDictTagged


class MriRfLabelOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriRfLabelParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    outvol: OutputPathType
    """Output volume from mri_ca_label"""


def mri_rf_label_params(
    input_volumes: list[InputPathType],
    transform_file: InputPathType,
    gcafile: InputPathType,
    output_volume: str,
    cross_sequence_flag: bool = False,
    nogibbs_flag: bool = False,
    wm_path: InputPathType | None = None,
    conform_flag: bool = False,
    normpd_flag: bool = False,
    gca_tl: InputPathType | None = None,
    debug_voxel: list[float] | None = None,
    debug_node: list[float] | None = None,
    debug_label: float | None = None,
    tr: float | None = None,
    te: float | None = None,
    alpha: float | None = None,
    example: list[InputPathType] | None = None,
    pthresh: float | None = None,
    niter: float | None = None,
    novar_flag: bool = False,
    regularize: float | None = None,
    nohippo_flag: bool = False,
    fwm: InputPathType | None = None,
    mri_vol: InputPathType | None = None,
    heq: InputPathType | None = None,
    renorm: InputPathType | None = None,
    flash_flag: bool = False,
    flash_params: InputPathType | None = None,
    renormalize: list[float] | None = None,
    set_input: InputPathType | None = None,
    histogram_flag: bool = False,
    cond_density_mean: float | None = None,
    snapshots: list[str] | None = None,
    mask: InputPathType | None = None,
    expand: float | None = None,
    max_iter: float | None = None,
    filter_mode: list[float] | None = None,
    longitudinal_vol: InputPathType | None = None,
    longitudinal_lta: InputPathType | None = None,
    relabel_unlikely_flag: list[float] | None = None,
) -> MriRfLabelParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_volumes: Input volume(s).
        transform_file: Transform file.
        gcafile: GCA file.
        output_volume: Output volume.
        cross_sequence_flag: Label a volume acquired with a sequence different\
            than atlas.
        nogibbs_flag: Disable gibbs priors.
        wm_path: Use WM segmentation from provided file.
        conform_flag: Interpolate volume to be isotropic 1mm^3.
        normpd_flag: Normalize PD image to GCA means.
        gca_tl: Use file to label the thin temporal lobe.
        debug_voxel: Debug voxel at specified coordinates.
        debug_node: Debug node at specified coordinates.
        debug_label: Debug label at specified index.
        tr: Set TR in msec.
        te: Set TE in msec.
        alpha: Set alpha in radians.
        example: Use T1 (mri_vol) and segmentation as example.
        pthresh: Use p threshold for adaptive renormalization.
        niter: Apply max likelihood for n iterations.
        novar_flag: Do not use variance in classification.
        regularize: Regularize variance to be sigma+nC(noise).
        nohippo_flag: Do not auto-edit hippocampus.
        fwm: Use fixed white matter segmentation from wm.
        mri_vol: Write most likely MR volume to specified file.
        heq: Use histogram equalization from specified volume.
        renorm: Renormalize using predicted intensity values.
        flash_flag: Use FLASH forward model to predict intensity values.
        flash_params: Use FLASH forward model and tissue params from file.
        renormalize: Renorm class means iter times after initial label with\
            window of wsize.
        set_input: Set input volume.
        histogram_flag: Use GCA to histogram normalize input image.
        cond_density_mean: Mean filter n times to conditional densities.
        snapshots: Write snapshots of gibbs process every n times to filename.
        mask: Use mri_vol to mask final labeling.
        expand: Expand.
        max_iter: Set max iterations.
        filter_mode: Filter labeled volume with threshold t mode filter f times.
        longitudinal_vol: Longitudinal processing: mri_vol is label from tp1,\
            LTA is registration from tp1 to current data.
        longitudinal_lta: Longitudinal LTA registration.
        relabel_unlikely_flag: Reclassify voxels using a Gaussian window to\
            recomute priors and likelihoods.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_rf_label",
        "input_volumes": input_volumes,
        "transform_file": transform_file,
        "gcafile": gcafile,
        "output_volume": output_volume,
        "cross_sequence_flag": cross_sequence_flag,
        "nogibbs_flag": nogibbs_flag,
        "conform_flag": conform_flag,
        "normpd_flag": normpd_flag,
        "novar_flag": novar_flag,
        "nohippo_flag": nohippo_flag,
        "flash_flag": flash_flag,
        "histogram_flag": histogram_flag,
    }
    if wm_path is not None:
        params["wm_path"] = wm_path
    if gca_tl is not None:
        params["gca_tl"] = gca_tl
    if debug_voxel is not None:
        params["debug_voxel"] = debug_voxel
    if debug_node is not None:
        params["debug_node"] = debug_node
    if debug_label is not None:
        params["debug_label"] = debug_label
    if tr is not None:
        params["tr"] = tr
    if te is not None:
        params["te"] = te
    if alpha is not None:
        params["alpha"] = alpha
    if example is not None:
        params["example"] = example
    if pthresh is not None:
        params["pthresh"] = pthresh
    if niter is not None:
        params["niter"] = niter
    if regularize is not None:
        params["regularize"] = regularize
    if fwm is not None:
        params["fwm"] = fwm
    if mri_vol is not None:
        params["mri_vol"] = mri_vol
    if heq is not None:
        params["heq"] = heq
    if renorm is not None:
        params["renorm"] = renorm
    if flash_params is not None:
        params["flash_params"] = flash_params
    if renormalize is not None:
        params["renormalize"] = renormalize
    if set_input is not None:
        params["set_input"] = set_input
    if cond_density_mean is not None:
        params["cond_density_mean"] = cond_density_mean
    if snapshots is not None:
        params["snapshots"] = snapshots
    if mask is not None:
        params["mask"] = mask
    if expand is not None:
        params["expand"] = expand
    if max_iter is not None:
        params["max_iter"] = max_iter
    if filter_mode is not None:
        params["filter_mode"] = filter_mode
    if longitudinal_vol is not None:
        params["longitudinal_vol"] = longitudinal_vol
    if longitudinal_lta is not None:
        params["longitudinal_lta"] = longitudinal_lta
    if relabel_unlikely_flag is not None:
        params["relabel_unlikely_flag"] = relabel_unlikely_flag
    return params


def mri_rf_label_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriRfLabelParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input_volumes", None) is None:
        raise StyxValidationError("`input_volumes` must not be None")
    if not isinstance(params["input_volumes"], list):
        raise StyxValidationError(f'`input_volumes` has the wrong type: Received `{type(params.get("input_volumes", None))}` expected `list[InputPathType]`')
    for e in params["input_volumes"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`input_volumes` has the wrong type: Received `{type(params.get("input_volumes", None))}` expected `list[InputPathType]`')
    if params.get("transform_file", None) is None:
        raise StyxValidationError("`transform_file` must not be None")
    if not isinstance(params["transform_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`transform_file` has the wrong type: Received `{type(params.get("transform_file", None))}` expected `InputPathType`')
    if params.get("gcafile", None) is None:
        raise StyxValidationError("`gcafile` must not be None")
    if not isinstance(params["gcafile"], (pathlib.Path, str)):
        raise StyxValidationError(f'`gcafile` has the wrong type: Received `{type(params.get("gcafile", None))}` expected `InputPathType`')
    if params.get("output_volume", None) is None:
        raise StyxValidationError("`output_volume` must not be None")
    if not isinstance(params["output_volume"], str):
        raise StyxValidationError(f'`output_volume` has the wrong type: Received `{type(params.get("output_volume", None))}` expected `str`')
    if params.get("cross_sequence_flag", False) is None:
        raise StyxValidationError("`cross_sequence_flag` must not be None")
    if not isinstance(params["cross_sequence_flag"], bool):
        raise StyxValidationError(f'`cross_sequence_flag` has the wrong type: Received `{type(params.get("cross_sequence_flag", False))}` expected `bool`')
    if params.get("nogibbs_flag", False) is None:
        raise StyxValidationError("`nogibbs_flag` must not be None")
    if not isinstance(params["nogibbs_flag"], bool):
        raise StyxValidationError(f'`nogibbs_flag` has the wrong type: Received `{type(params.get("nogibbs_flag", False))}` expected `bool`')
    if params.get("wm_path", None) is not None:
        if not isinstance(params["wm_path"], (pathlib.Path, str)):
            raise StyxValidationError(f'`wm_path` has the wrong type: Received `{type(params.get("wm_path", None))}` expected `InputPathType | None`')
    if params.get("conform_flag", False) is None:
        raise StyxValidationError("`conform_flag` must not be None")
    if not isinstance(params["conform_flag"], bool):
        raise StyxValidationError(f'`conform_flag` has the wrong type: Received `{type(params.get("conform_flag", False))}` expected `bool`')
    if params.get("normpd_flag", False) is None:
        raise StyxValidationError("`normpd_flag` must not be None")
    if not isinstance(params["normpd_flag"], bool):
        raise StyxValidationError(f'`normpd_flag` has the wrong type: Received `{type(params.get("normpd_flag", False))}` expected `bool`')
    if params.get("gca_tl", None) is not None:
        if not isinstance(params["gca_tl"], (pathlib.Path, str)):
            raise StyxValidationError(f'`gca_tl` has the wrong type: Received `{type(params.get("gca_tl", None))}` expected `InputPathType | None`')
    if params.get("debug_voxel", None) is not None:
        if not isinstance(params["debug_voxel"], list):
            raise StyxValidationError(f'`debug_voxel` has the wrong type: Received `{type(params.get("debug_voxel", None))}` expected `list[float] | None`')
        if len(params["debug_voxel"]) != 3:
            raise StyxValidationError("Parameter `debug_voxel` must contain exactly 3 elements")
        for e in params["debug_voxel"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`debug_voxel` has the wrong type: Received `{type(params.get("debug_voxel", None))}` expected `list[float] | None`')
    if params.get("debug_node", None) is not None:
        if not isinstance(params["debug_node"], list):
            raise StyxValidationError(f'`debug_node` has the wrong type: Received `{type(params.get("debug_node", None))}` expected `list[float] | None`')
        if len(params["debug_node"]) != 3:
            raise StyxValidationError("Parameter `debug_node` must contain exactly 3 elements")
        for e in params["debug_node"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`debug_node` has the wrong type: Received `{type(params.get("debug_node", None))}` expected `list[float] | None`')
    if params.get("debug_label", None) is not None:
        if not isinstance(params["debug_label"], (float, int)):
            raise StyxValidationError(f'`debug_label` has the wrong type: Received `{type(params.get("debug_label", None))}` expected `float | None`')
    if params.get("tr", None) is not None:
        if not isinstance(params["tr"], (float, int)):
            raise StyxValidationError(f'`tr` has the wrong type: Received `{type(params.get("tr", None))}` expected `float | None`')
    if params.get("te", None) is not None:
        if not isinstance(params["te"], (float, int)):
            raise StyxValidationError(f'`te` has the wrong type: Received `{type(params.get("te", None))}` expected `float | None`')
    if params.get("alpha", None) is not None:
        if not isinstance(params["alpha"], (float, int)):
            raise StyxValidationError(f'`alpha` has the wrong type: Received `{type(params.get("alpha", None))}` expected `float | None`')
    if params.get("example", None) is not None:
        if not isinstance(params["example"], list):
            raise StyxValidationError(f'`example` has the wrong type: Received `{type(params.get("example", None))}` expected `list[InputPathType] | None`')
        for e in params["example"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`example` has the wrong type: Received `{type(params.get("example", None))}` expected `list[InputPathType] | None`')
    if params.get("pthresh", None) is not None:
        if not isinstance(params["pthresh"], (float, int)):
            raise StyxValidationError(f'`pthresh` has the wrong type: Received `{type(params.get("pthresh", None))}` expected `float | None`')
    if params.get("niter", None) is not None:
        if not isinstance(params["niter"], (float, int)):
            raise StyxValidationError(f'`niter` has the wrong type: Received `{type(params.get("niter", None))}` expected `float | None`')
    if params.get("novar_flag", False) is None:
        raise StyxValidationError("`novar_flag` must not be None")
    if not isinstance(params["novar_flag"], bool):
        raise StyxValidationError(f'`novar_flag` has the wrong type: Received `{type(params.get("novar_flag", False))}` expected `bool`')
    if params.get("regularize", None) is not None:
        if not isinstance(params["regularize"], (float, int)):
            raise StyxValidationError(f'`regularize` has the wrong type: Received `{type(params.get("regularize", None))}` expected `float | None`')
    if params.get("nohippo_flag", False) is None:
        raise StyxValidationError("`nohippo_flag` must not be None")
    if not isinstance(params["nohippo_flag"], bool):
        raise StyxValidationError(f'`nohippo_flag` has the wrong type: Received `{type(params.get("nohippo_flag", False))}` expected `bool`')
    if params.get("fwm", None) is not None:
        if not isinstance(params["fwm"], (pathlib.Path, str)):
            raise StyxValidationError(f'`fwm` has the wrong type: Received `{type(params.get("fwm", None))}` expected `InputPathType | None`')
    if params.get("mri_vol", None) is not None:
        if not isinstance(params["mri_vol"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mri_vol` has the wrong type: Received `{type(params.get("mri_vol", None))}` expected `InputPathType | None`')
    if params.get("heq", None) is not None:
        if not isinstance(params["heq"], (pathlib.Path, str)):
            raise StyxValidationError(f'`heq` has the wrong type: Received `{type(params.get("heq", None))}` expected `InputPathType | None`')
    if params.get("renorm", None) is not None:
        if not isinstance(params["renorm"], (pathlib.Path, str)):
            raise StyxValidationError(f'`renorm` has the wrong type: Received `{type(params.get("renorm", None))}` expected `InputPathType | None`')
    if params.get("flash_flag", False) is None:
        raise StyxValidationError("`flash_flag` must not be None")
    if not isinstance(params["flash_flag"], bool):
        raise StyxValidationError(f'`flash_flag` has the wrong type: Received `{type(params.get("flash_flag", False))}` expected `bool`')
    if params.get("flash_params", None) is not None:
        if not isinstance(params["flash_params"], (pathlib.Path, str)):
            raise StyxValidationError(f'`flash_params` has the wrong type: Received `{type(params.get("flash_params", None))}` expected `InputPathType | None`')
    if params.get("renormalize", None) is not None:
        if not isinstance(params["renormalize"], list):
            raise StyxValidationError(f'`renormalize` has the wrong type: Received `{type(params.get("renormalize", None))}` expected `list[float] | None`')
        for e in params["renormalize"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`renormalize` has the wrong type: Received `{type(params.get("renormalize", None))}` expected `list[float] | None`')
    if params.get("set_input", None) is not None:
        if not isinstance(params["set_input"], (pathlib.Path, str)):
            raise StyxValidationError(f'`set_input` has the wrong type: Received `{type(params.get("set_input", None))}` expected `InputPathType | None`')
    if params.get("histogram_flag", False) is None:
        raise StyxValidationError("`histogram_flag` must not be None")
    if not isinstance(params["histogram_flag"], bool):
        raise StyxValidationError(f'`histogram_flag` has the wrong type: Received `{type(params.get("histogram_flag", False))}` expected `bool`')
    if params.get("cond_density_mean", None) is not None:
        if not isinstance(params["cond_density_mean"], (float, int)):
            raise StyxValidationError(f'`cond_density_mean` has the wrong type: Received `{type(params.get("cond_density_mean", None))}` expected `float | None`')
    if params.get("snapshots", None) is not None:
        if not isinstance(params["snapshots"], list):
            raise StyxValidationError(f'`snapshots` has the wrong type: Received `{type(params.get("snapshots", None))}` expected `list[str] | None`')
        if len(params["snapshots"]) != 2:
            raise StyxValidationError("Parameter `snapshots` must contain exactly 2 elements")
        for e in params["snapshots"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`snapshots` has the wrong type: Received `{type(params.get("snapshots", None))}` expected `list[str] | None`')
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType | None`')
    if params.get("expand", None) is not None:
        if not isinstance(params["expand"], (float, int)):
            raise StyxValidationError(f'`expand` has the wrong type: Received `{type(params.get("expand", None))}` expected `float | None`')
    if params.get("max_iter", None) is not None:
        if not isinstance(params["max_iter"], (float, int)):
            raise StyxValidationError(f'`max_iter` has the wrong type: Received `{type(params.get("max_iter", None))}` expected `float | None`')
    if params.get("filter_mode", None) is not None:
        if not isinstance(params["filter_mode"], list):
            raise StyxValidationError(f'`filter_mode` has the wrong type: Received `{type(params.get("filter_mode", None))}` expected `list[float] | None`')
        if len(params["filter_mode"]) != 2:
            raise StyxValidationError("Parameter `filter_mode` must contain exactly 2 elements")
        for e in params["filter_mode"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`filter_mode` has the wrong type: Received `{type(params.get("filter_mode", None))}` expected `list[float] | None`')
    if params.get("longitudinal_vol", None) is not None:
        if not isinstance(params["longitudinal_vol"], (pathlib.Path, str)):
            raise StyxValidationError(f'`longitudinal_vol` has the wrong type: Received `{type(params.get("longitudinal_vol", None))}` expected `InputPathType | None`')
    if params.get("longitudinal_lta", None) is not None:
        if not isinstance(params["longitudinal_lta"], (pathlib.Path, str)):
            raise StyxValidationError(f'`longitudinal_lta` has the wrong type: Received `{type(params.get("longitudinal_lta", None))}` expected `InputPathType | None`')
    if params.get("relabel_unlikely_flag", None) is not None:
        if not isinstance(params["relabel_unlikely_flag"], list):
            raise StyxValidationError(f'`relabel_unlikely_flag` has the wrong type: Received `{type(params.get("relabel_unlikely_flag", None))}` expected `list[float] | None`')
        if len(params["relabel_unlikely_flag"]) != 4:
            raise StyxValidationError("Parameter `relabel_unlikely_flag` must contain exactly 4 elements")
        for e in params["relabel_unlikely_flag"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`relabel_unlikely_flag` has the wrong type: Received `{type(params.get("relabel_unlikely_flag", None))}` expected `list[float] | None`')


def mri_rf_label_cargs(
    params: MriRfLabelParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_rf_label")
    cargs.extend([execution.input_file(f) for f in params.get("input_volumes", None)])
    cargs.append(execution.input_file(params.get("transform_file", None)))
    cargs.append(execution.input_file(params.get("gcafile", None)))
    cargs.append(params.get("output_volume", None))
    if params.get("cross_sequence_flag", False):
        cargs.append("-cross-sequence")
    if params.get("nogibbs_flag", False):
        cargs.append("-nogibbs")
    if params.get("wm_path", None) is not None:
        cargs.extend([
            "-wm",
            execution.input_file(params.get("wm_path", None))
        ])
    if params.get("conform_flag", False):
        cargs.append("-conform")
    if params.get("normpd_flag", False):
        cargs.append("-normpd")
    if params.get("gca_tl", None) is not None:
        cargs.extend([
            "-tl",
            execution.input_file(params.get("gca_tl", None))
        ])
    if params.get("debug_voxel", None) is not None:
        cargs.extend([
            "-debug_voxel",
            *map(str, params.get("debug_voxel", None))
        ])
    if params.get("debug_node", None) is not None:
        cargs.extend([
            "-debug_node",
            *map(str, params.get("debug_node", None))
        ])
    if params.get("debug_label", None) is not None:
        cargs.extend([
            "-debug_label",
            str(params.get("debug_label", None))
        ])
    if params.get("tr", None) is not None:
        cargs.extend([
            "-tr",
            str(params.get("tr", None))
        ])
    if params.get("te", None) is not None:
        cargs.extend([
            "-te",
            str(params.get("te", None))
        ])
    if params.get("alpha", None) is not None:
        cargs.extend([
            "-alpha",
            str(params.get("alpha", None))
        ])
    if params.get("example", None) is not None:
        cargs.extend([
            "-example",
            *[execution.input_file(f) for f in params.get("example", None)]
        ])
    if params.get("pthresh", None) is not None:
        cargs.extend([
            "-pthresh",
            str(params.get("pthresh", None))
        ])
    if params.get("niter", None) is not None:
        cargs.extend([
            "-niter",
            str(params.get("niter", None))
        ])
    if params.get("novar_flag", False):
        cargs.append("-novar")
    if params.get("regularize", None) is not None:
        cargs.extend([
            "-regularize",
            str(params.get("regularize", None))
        ])
    if params.get("nohippo_flag", False):
        cargs.append("-nohippo")
    if params.get("fwm", None) is not None:
        cargs.extend([
            "-fwm",
            execution.input_file(params.get("fwm", None))
        ])
    if params.get("mri_vol", None) is not None:
        cargs.extend([
            "-mri",
            execution.input_file(params.get("mri_vol", None))
        ])
    if params.get("heq", None) is not None:
        cargs.extend([
            "-heq",
            execution.input_file(params.get("heq", None))
        ])
    if params.get("renorm", None) is not None:
        cargs.extend([
            "-renorm",
            execution.input_file(params.get("renorm", None))
        ])
    if params.get("flash_flag", False):
        cargs.append("-flash")
    if params.get("flash_params", None) is not None:
        cargs.extend([
            "-flash_params",
            execution.input_file(params.get("flash_params", None))
        ])
    if params.get("renormalize", None) is not None:
        cargs.extend([
            "-renormalize",
            *map(str, params.get("renormalize", None))
        ])
    if params.get("set_input", None) is not None:
        cargs.extend([
            "-r",
            execution.input_file(params.get("set_input", None))
        ])
    if params.get("histogram_flag", False):
        cargs.append("-h")
    if params.get("cond_density_mean", None) is not None:
        cargs.extend([
            "-a",
            str(params.get("cond_density_mean", None))
        ])
    if params.get("snapshots", None) is not None:
        cargs.extend([
            "-w",
            *params.get("snapshots", None)
        ])
    if params.get("mask", None) is not None:
        cargs.extend([
            "-m",
            execution.input_file(params.get("mask", None))
        ])
    if params.get("expand", None) is not None:
        cargs.extend([
            "-e",
            str(params.get("expand", None))
        ])
    if params.get("max_iter", None) is not None:
        cargs.extend([
            "-n",
            str(params.get("max_iter", None))
        ])
    if params.get("filter_mode", None) is not None:
        cargs.extend([
            "-f",
            *map(str, params.get("filter_mode", None))
        ])
    if params.get("longitudinal_vol", None) is not None:
        cargs.extend([
            "-L",
            execution.input_file(params.get("longitudinal_vol", None))
        ])
    if params.get("longitudinal_lta", None) is not None:
        cargs.append(execution.input_file(params.get("longitudinal_lta", None)))
    if params.get("relabel_unlikely_flag", None) is not None:
        cargs.extend([
            "-RELABEL_UNLIKELY",
            *map(str, params.get("relabel_unlikely_flag", None))
        ])
    return cargs


def mri_rf_label_outputs(
    params: MriRfLabelParamsDict,
    execution: Execution,
) -> MriRfLabelOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriRfLabelOutputs(
        root=execution.output_file("."),
        outvol=execution.output_file(params.get("output_volume", None)),
    )
    return ret


def mri_rf_label_execute(
    params: MriRfLabelParamsDict,
    runner: Runner | None = None,
) -> MriRfLabelOutputs:
    """
    mri_rf_label
    
    MRI automatic tissue labeling using a Gaussian Classifier Atlas (GCA).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriRfLabelOutputs`).
    """
    mri_rf_label_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_RF_LABEL_METADATA)
    params = execution.params(params)
    cargs = mri_rf_label_cargs(params, execution)
    ret = mri_rf_label_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_rf_label(
    input_volumes: list[InputPathType],
    transform_file: InputPathType,
    gcafile: InputPathType,
    output_volume: str,
    cross_sequence_flag: bool = False,
    nogibbs_flag: bool = False,
    wm_path: InputPathType | None = None,
    conform_flag: bool = False,
    normpd_flag: bool = False,
    gca_tl: InputPathType | None = None,
    debug_voxel: list[float] | None = None,
    debug_node: list[float] | None = None,
    debug_label: float | None = None,
    tr: float | None = None,
    te: float | None = None,
    alpha: float | None = None,
    example: list[InputPathType] | None = None,
    pthresh: float | None = None,
    niter: float | None = None,
    novar_flag: bool = False,
    regularize: float | None = None,
    nohippo_flag: bool = False,
    fwm: InputPathType | None = None,
    mri_vol: InputPathType | None = None,
    heq: InputPathType | None = None,
    renorm: InputPathType | None = None,
    flash_flag: bool = False,
    flash_params: InputPathType | None = None,
    renormalize: list[float] | None = None,
    set_input: InputPathType | None = None,
    histogram_flag: bool = False,
    cond_density_mean: float | None = None,
    snapshots: list[str] | None = None,
    mask: InputPathType | None = None,
    expand: float | None = None,
    max_iter: float | None = None,
    filter_mode: list[float] | None = None,
    longitudinal_vol: InputPathType | None = None,
    longitudinal_lta: InputPathType | None = None,
    relabel_unlikely_flag: list[float] | None = None,
    runner: Runner | None = None,
) -> MriRfLabelOutputs:
    """
    mri_rf_label
    
    MRI automatic tissue labeling using a Gaussian Classifier Atlas (GCA).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        input_volumes: Input volume(s).
        transform_file: Transform file.
        gcafile: GCA file.
        output_volume: Output volume.
        cross_sequence_flag: Label a volume acquired with a sequence different\
            than atlas.
        nogibbs_flag: Disable gibbs priors.
        wm_path: Use WM segmentation from provided file.
        conform_flag: Interpolate volume to be isotropic 1mm^3.
        normpd_flag: Normalize PD image to GCA means.
        gca_tl: Use file to label the thin temporal lobe.
        debug_voxel: Debug voxel at specified coordinates.
        debug_node: Debug node at specified coordinates.
        debug_label: Debug label at specified index.
        tr: Set TR in msec.
        te: Set TE in msec.
        alpha: Set alpha in radians.
        example: Use T1 (mri_vol) and segmentation as example.
        pthresh: Use p threshold for adaptive renormalization.
        niter: Apply max likelihood for n iterations.
        novar_flag: Do not use variance in classification.
        regularize: Regularize variance to be sigma+nC(noise).
        nohippo_flag: Do not auto-edit hippocampus.
        fwm: Use fixed white matter segmentation from wm.
        mri_vol: Write most likely MR volume to specified file.
        heq: Use histogram equalization from specified volume.
        renorm: Renormalize using predicted intensity values.
        flash_flag: Use FLASH forward model to predict intensity values.
        flash_params: Use FLASH forward model and tissue params from file.
        renormalize: Renorm class means iter times after initial label with\
            window of wsize.
        set_input: Set input volume.
        histogram_flag: Use GCA to histogram normalize input image.
        cond_density_mean: Mean filter n times to conditional densities.
        snapshots: Write snapshots of gibbs process every n times to filename.
        mask: Use mri_vol to mask final labeling.
        expand: Expand.
        max_iter: Set max iterations.
        filter_mode: Filter labeled volume with threshold t mode filter f times.
        longitudinal_vol: Longitudinal processing: mri_vol is label from tp1,\
            LTA is registration from tp1 to current data.
        longitudinal_lta: Longitudinal LTA registration.
        relabel_unlikely_flag: Reclassify voxels using a Gaussian window to\
            recomute priors and likelihoods.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriRfLabelOutputs`).
    """
    params = mri_rf_label_params(
        input_volumes=input_volumes,
        transform_file=transform_file,
        gcafile=gcafile,
        output_volume=output_volume,
        cross_sequence_flag=cross_sequence_flag,
        nogibbs_flag=nogibbs_flag,
        wm_path=wm_path,
        conform_flag=conform_flag,
        normpd_flag=normpd_flag,
        gca_tl=gca_tl,
        debug_voxel=debug_voxel,
        debug_node=debug_node,
        debug_label=debug_label,
        tr=tr,
        te=te,
        alpha=alpha,
        example=example,
        pthresh=pthresh,
        niter=niter,
        novar_flag=novar_flag,
        regularize=regularize,
        nohippo_flag=nohippo_flag,
        fwm=fwm,
        mri_vol=mri_vol,
        heq=heq,
        renorm=renorm,
        flash_flag=flash_flag,
        flash_params=flash_params,
        renormalize=renormalize,
        set_input=set_input,
        histogram_flag=histogram_flag,
        cond_density_mean=cond_density_mean,
        snapshots=snapshots,
        mask=mask,
        expand=expand,
        max_iter=max_iter,
        filter_mode=filter_mode,
        longitudinal_vol=longitudinal_vol,
        longitudinal_lta=longitudinal_lta,
        relabel_unlikely_flag=relabel_unlikely_flag,
    )
    return mri_rf_label_execute(params, runner)


__all__ = [
    "MRI_RF_LABEL_METADATA",
    "MriRfLabelOutputs",
    "MriRfLabelParamsDict",
    "MriRfLabelParamsDictTagged",
    "mri_rf_label",
    "mri_rf_label_execute",
    "mri_rf_label_params",
]
