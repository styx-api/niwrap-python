# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

OPTSEQ2_METADATA = Metadata(
    id="604a56ca2527f0a6a85cab4ef77dd22f8fa8bd55.boutiques",
    name="optseq2",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_Optseq2ParamsDictNoTag = typing.TypedDict('_Optseq2ParamsDictNoTag', {
    "ntp": float,
    "tr": float,
    "tprescan": float,
    "psdwin": list[float],
    "event": typing.NotRequired[list[str] | None],
    "repvar": typing.NotRequired[str | None],
    "polyfit": typing.NotRequired[float | None],
    "tnullmin": typing.NotRequired[float | None],
    "tnullmax": typing.NotRequired[float | None],
    "nsearch": typing.NotRequired[float | None],
    "tsearch": typing.NotRequired[float | None],
    "first_order_cb": typing.NotRequired[float | None],
    "ar1": typing.NotRequired[float | None],
    "penalize": typing.NotRequired[list[float] | None],
    "evc": typing.NotRequired[list[float] | None],
    "cmtx": typing.NotRequired[InputPathType | None],
    "cost": typing.NotRequired[str | None],
    "sumdelays": bool,
    "seed": typing.NotRequired[float | None],
    "nkeep": typing.NotRequired[float | None],
    "outstem": typing.NotRequired[str | None],
    "mtxstem": typing.NotRequired[str | None],
    "cmtxfile": typing.NotRequired[str | None],
    "summaryfile": typing.NotRequired[str | None],
    "logfile": typing.NotRequired[str | None],
    "pctupdate": typing.NotRequired[float | None],
    "sviterfile": typing.NotRequired[str | None],
    "instem": typing.NotRequired[str | None],
    "input_schedule": typing.NotRequired[list[str] | None],
    "nosearch": bool,
    "help": bool,
    "version": bool,
})
Optseq2ParamsDictTagged = typing.TypedDict('Optseq2ParamsDictTagged', {
    "@type": typing.Literal["freesurfer/optseq2"],
    "ntp": float,
    "tr": float,
    "tprescan": float,
    "psdwin": list[float],
    "event": typing.NotRequired[list[str] | None],
    "repvar": typing.NotRequired[str | None],
    "polyfit": typing.NotRequired[float | None],
    "tnullmin": typing.NotRequired[float | None],
    "tnullmax": typing.NotRequired[float | None],
    "nsearch": typing.NotRequired[float | None],
    "tsearch": typing.NotRequired[float | None],
    "first_order_cb": typing.NotRequired[float | None],
    "ar1": typing.NotRequired[float | None],
    "penalize": typing.NotRequired[list[float] | None],
    "evc": typing.NotRequired[list[float] | None],
    "cmtx": typing.NotRequired[InputPathType | None],
    "cost": typing.NotRequired[str | None],
    "sumdelays": bool,
    "seed": typing.NotRequired[float | None],
    "nkeep": typing.NotRequired[float | None],
    "outstem": typing.NotRequired[str | None],
    "mtxstem": typing.NotRequired[str | None],
    "cmtxfile": typing.NotRequired[str | None],
    "summaryfile": typing.NotRequired[str | None],
    "logfile": typing.NotRequired[str | None],
    "pctupdate": typing.NotRequired[float | None],
    "sviterfile": typing.NotRequired[str | None],
    "instem": typing.NotRequired[str | None],
    "input_schedule": typing.NotRequired[list[str] | None],
    "nosearch": bool,
    "help": bool,
    "version": bool,
})
Optseq2ParamsDict = _Optseq2ParamsDictNoTag | Optseq2ParamsDictTagged


class Optseq2Outputs(typing.NamedTuple):
    """
    Output object returned when calling `Optseq2ParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_schedules: OutputPathType | None
    """Output schedules"""
    output_design_matrices: OutputPathType | None
    """Output FIR design matrices"""
    output_contrast_matrix: OutputPathType | None
    """Output contrast matrix"""
    output_summary: OutputPathType | None
    """Output search summary"""
    output_log: OutputPathType | None
    """Output log file"""
    output_sviter: OutputPathType | None
    """Output per-iteration information"""


def optseq2_params(
    ntp: float,
    tr: float,
    tprescan: float,
    psdwin: list[float],
    event: list[str] | None = None,
    repvar: str | None = None,
    polyfit: float | None = None,
    tnullmin: float | None = None,
    tnullmax: float | None = None,
    nsearch: float | None = None,
    tsearch: float | None = None,
    first_order_cb: float | None = None,
    ar1: float | None = None,
    penalize: list[float] | None = None,
    evc: list[float] | None = None,
    cmtx: InputPathType | None = None,
    cost: str | None = None,
    sumdelays: bool = False,
    seed: float | None = None,
    nkeep: float | None = None,
    outstem: str | None = None,
    mtxstem: str | None = None,
    cmtxfile: str | None = None,
    summaryfile: str | None = None,
    logfile: str | None = None,
    pctupdate: float | None = None,
    sviterfile: str | None = None,
    instem: str | None = None,
    input_schedule: list[str] | None = None,
    nosearch: bool = False,
    help_: bool = False,
    version: bool = False,
) -> Optseq2ParamsDictTagged:
    """
    Build parameters.
    
    Args:
        ntp: Number of time points to be acquired during the scan.
        tr: Temporal resolution of acquisition in seconds.
        tprescan: Start events t seconds before first acquisition.
        psdwin: Post-stimulus window specifications: minimum PSD, maximum PSD,\
            and optional dPSD.
        event: Event type specification with label, duration, and number of\
            repetitions.
        repvar: Allow number of repetitions of event types to vary by\
            percentage, optionally per event.
        polyfit: Add polynomial regressors as nuisance variables of specified\
            order.
        tnullmin: Minimum duration of null time between stimuli in seconds.
        tnullmax: Maximum duration of null time between stimuli in seconds.
        nsearch: Search over a specified number of iterations for schedules.
        tsearch: Search for schedules over a specified number of hours.
        first_order_cb: Pre-optimize first order counter-balancing.
        ar1: Optimize assuming whitening with AR1 parameter.
        penalize: Penalize for presentations being too close with parameters\
            alpha, T, and dtmin.
        evc: Contrast of event types with weights.
        cmtx: Load contrast from ASCII matrix file.
        cost: Specify cost function and its parameters.
        sumdelays: Sum delays when forming contrast matrix.
        seed: Initialize random number generator with seed value.
        nkeep: Number of best schedules to keep.
        outstem: Output stem for saved schedules.
        mtxstem: Output stem for saved design matrices.
        cmtxfile: File for saving contrast matrix.
        summaryfile: File for saving search summary.
        logfile: File for saving log information.
        pctupdate: Percentage interval after which progress is logged.
        sviterfile: File to save information from each iteration.
        instem: Initialize with input schedules that match instem-RRR.par.
        input_schedule: Input schedule files.
        nosearch: Do not perform search for optimal schedules.
        help_: Print help page.
        version: Print version string.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/optseq2",
        "ntp": ntp,
        "tr": tr,
        "tprescan": tprescan,
        "psdwin": psdwin,
        "sumdelays": sumdelays,
        "nosearch": nosearch,
        "help": help_,
        "version": version,
    }
    if event is not None:
        params["event"] = event
    if repvar is not None:
        params["repvar"] = repvar
    if polyfit is not None:
        params["polyfit"] = polyfit
    if tnullmin is not None:
        params["tnullmin"] = tnullmin
    if tnullmax is not None:
        params["tnullmax"] = tnullmax
    if nsearch is not None:
        params["nsearch"] = nsearch
    if tsearch is not None:
        params["tsearch"] = tsearch
    if first_order_cb is not None:
        params["first_order_cb"] = first_order_cb
    if ar1 is not None:
        params["ar1"] = ar1
    if penalize is not None:
        params["penalize"] = penalize
    if evc is not None:
        params["evc"] = evc
    if cmtx is not None:
        params["cmtx"] = cmtx
    if cost is not None:
        params["cost"] = cost
    if seed is not None:
        params["seed"] = seed
    if nkeep is not None:
        params["nkeep"] = nkeep
    if outstem is not None:
        params["outstem"] = outstem
    if mtxstem is not None:
        params["mtxstem"] = mtxstem
    if cmtxfile is not None:
        params["cmtxfile"] = cmtxfile
    if summaryfile is not None:
        params["summaryfile"] = summaryfile
    if logfile is not None:
        params["logfile"] = logfile
    if pctupdate is not None:
        params["pctupdate"] = pctupdate
    if sviterfile is not None:
        params["sviterfile"] = sviterfile
    if instem is not None:
        params["instem"] = instem
    if input_schedule is not None:
        params["input_schedule"] = input_schedule
    return params


def optseq2_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `Optseq2ParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("ntp", None) is None:
        raise StyxValidationError("`ntp` must not be None")
    if not isinstance(params["ntp"], (float, int)):
        raise StyxValidationError(f'`ntp` has the wrong type: Received `{type(params.get("ntp", None))}` expected `float`')
    if params.get("tr", None) is None:
        raise StyxValidationError("`tr` must not be None")
    if not isinstance(params["tr"], (float, int)):
        raise StyxValidationError(f'`tr` has the wrong type: Received `{type(params.get("tr", None))}` expected `float`')
    if params.get("tprescan", None) is None:
        raise StyxValidationError("`tprescan` must not be None")
    if not isinstance(params["tprescan"], (float, int)):
        raise StyxValidationError(f'`tprescan` has the wrong type: Received `{type(params.get("tprescan", None))}` expected `float`')
    if params.get("psdwin", None) is None:
        raise StyxValidationError("`psdwin` must not be None")
    if not isinstance(params["psdwin"], list):
        raise StyxValidationError(f'`psdwin` has the wrong type: Received `{type(params.get("psdwin", None))}` expected `list[float]`')
    if not (2 <= len(params["psdwin"]) <= 3):
        raise StyxValidationError("Parameter `psdwin` must contain between 2 and 3 elements (inclusive)")
    for e in params["psdwin"]:
        if not isinstance(e, (float, int)):
            raise StyxValidationError(f'`psdwin` has the wrong type: Received `{type(params.get("psdwin", None))}` expected `list[float]`')
    if params.get("event", None) is not None:
        if not isinstance(params["event"], list):
            raise StyxValidationError(f'`event` has the wrong type: Received `{type(params.get("event", None))}` expected `list[str] | None`')
        if len(params["event"]) != 3:
            raise StyxValidationError("Parameter `event` must contain exactly 3 elements")
        for e in params["event"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`event` has the wrong type: Received `{type(params.get("event", None))}` expected `list[str] | None`')
    if params.get("repvar", None) is not None:
        if not isinstance(params["repvar"], str):
            raise StyxValidationError(f'`repvar` has the wrong type: Received `{type(params.get("repvar", None))}` expected `str | None`')
    if params.get("polyfit", None) is not None:
        if not isinstance(params["polyfit"], (float, int)):
            raise StyxValidationError(f'`polyfit` has the wrong type: Received `{type(params.get("polyfit", None))}` expected `float | None`')
    if params.get("tnullmin", None) is not None:
        if not isinstance(params["tnullmin"], (float, int)):
            raise StyxValidationError(f'`tnullmin` has the wrong type: Received `{type(params.get("tnullmin", None))}` expected `float | None`')
    if params.get("tnullmax", None) is not None:
        if not isinstance(params["tnullmax"], (float, int)):
            raise StyxValidationError(f'`tnullmax` has the wrong type: Received `{type(params.get("tnullmax", None))}` expected `float | None`')
    if params.get("nsearch", None) is not None:
        if not isinstance(params["nsearch"], (float, int)):
            raise StyxValidationError(f'`nsearch` has the wrong type: Received `{type(params.get("nsearch", None))}` expected `float | None`')
    if params.get("tsearch", None) is not None:
        if not isinstance(params["tsearch"], (float, int)):
            raise StyxValidationError(f'`tsearch` has the wrong type: Received `{type(params.get("tsearch", None))}` expected `float | None`')
    if params.get("first_order_cb", None) is not None:
        if not isinstance(params["first_order_cb"], (float, int)):
            raise StyxValidationError(f'`first_order_cb` has the wrong type: Received `{type(params.get("first_order_cb", None))}` expected `float | None`')
    if params.get("ar1", None) is not None:
        if not isinstance(params["ar1"], (float, int)):
            raise StyxValidationError(f'`ar1` has the wrong type: Received `{type(params.get("ar1", None))}` expected `float | None`')
        if not (-1 <= params["ar1"] <= 1):
            raise StyxValidationError("Parameter `ar1` must be between -1 and 1 (inclusive)")
    if params.get("penalize", None) is not None:
        if not isinstance(params["penalize"], list):
            raise StyxValidationError(f'`penalize` has the wrong type: Received `{type(params.get("penalize", None))}` expected `list[float] | None`')
        if len(params["penalize"]) != 3:
            raise StyxValidationError("Parameter `penalize` must contain exactly 3 elements")
        for e in params["penalize"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`penalize` has the wrong type: Received `{type(params.get("penalize", None))}` expected `list[float] | None`')
    if params.get("evc", None) is not None:
        if not isinstance(params["evc"], list):
            raise StyxValidationError(f'`evc` has the wrong type: Received `{type(params.get("evc", None))}` expected `list[float] | None`')
        for e in params["evc"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`evc` has the wrong type: Received `{type(params.get("evc", None))}` expected `list[float] | None`')
    if params.get("cmtx", None) is not None:
        if not isinstance(params["cmtx"], (pathlib.Path, str)):
            raise StyxValidationError(f'`cmtx` has the wrong type: Received `{type(params.get("cmtx", None))}` expected `InputPathType | None`')
    if params.get("cost", None) is not None:
        if not isinstance(params["cost"], str):
            raise StyxValidationError(f'`cost` has the wrong type: Received `{type(params.get("cost", None))}` expected `str | None`')
    if params.get("sumdelays", False) is None:
        raise StyxValidationError("`sumdelays` must not be None")
    if not isinstance(params["sumdelays"], bool):
        raise StyxValidationError(f'`sumdelays` has the wrong type: Received `{type(params.get("sumdelays", False))}` expected `bool`')
    if params.get("seed", None) is not None:
        if not isinstance(params["seed"], (float, int)):
            raise StyxValidationError(f'`seed` has the wrong type: Received `{type(params.get("seed", None))}` expected `float | None`')
    if params.get("nkeep", None) is not None:
        if not isinstance(params["nkeep"], (float, int)):
            raise StyxValidationError(f'`nkeep` has the wrong type: Received `{type(params.get("nkeep", None))}` expected `float | None`')
    if params.get("outstem", None) is not None:
        if not isinstance(params["outstem"], str):
            raise StyxValidationError(f'`outstem` has the wrong type: Received `{type(params.get("outstem", None))}` expected `str | None`')
    if params.get("mtxstem", None) is not None:
        if not isinstance(params["mtxstem"], str):
            raise StyxValidationError(f'`mtxstem` has the wrong type: Received `{type(params.get("mtxstem", None))}` expected `str | None`')
    if params.get("cmtxfile", None) is not None:
        if not isinstance(params["cmtxfile"], str):
            raise StyxValidationError(f'`cmtxfile` has the wrong type: Received `{type(params.get("cmtxfile", None))}` expected `str | None`')
    if params.get("summaryfile", None) is not None:
        if not isinstance(params["summaryfile"], str):
            raise StyxValidationError(f'`summaryfile` has the wrong type: Received `{type(params.get("summaryfile", None))}` expected `str | None`')
    if params.get("logfile", None) is not None:
        if not isinstance(params["logfile"], str):
            raise StyxValidationError(f'`logfile` has the wrong type: Received `{type(params.get("logfile", None))}` expected `str | None`')
    if params.get("pctupdate", None) is not None:
        if not isinstance(params["pctupdate"], (float, int)):
            raise StyxValidationError(f'`pctupdate` has the wrong type: Received `{type(params.get("pctupdate", None))}` expected `float | None`')
    if params.get("sviterfile", None) is not None:
        if not isinstance(params["sviterfile"], str):
            raise StyxValidationError(f'`sviterfile` has the wrong type: Received `{type(params.get("sviterfile", None))}` expected `str | None`')
    if params.get("instem", None) is not None:
        if not isinstance(params["instem"], str):
            raise StyxValidationError(f'`instem` has the wrong type: Received `{type(params.get("instem", None))}` expected `str | None`')
    if params.get("input_schedule", None) is not None:
        if not isinstance(params["input_schedule"], list):
            raise StyxValidationError(f'`input_schedule` has the wrong type: Received `{type(params.get("input_schedule", None))}` expected `list[str] | None`')
        for e in params["input_schedule"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`input_schedule` has the wrong type: Received `{type(params.get("input_schedule", None))}` expected `list[str] | None`')
    if params.get("nosearch", False) is None:
        raise StyxValidationError("`nosearch` must not be None")
    if not isinstance(params["nosearch"], bool):
        raise StyxValidationError(f'`nosearch` has the wrong type: Received `{type(params.get("nosearch", False))}` expected `bool`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')


def optseq2_cargs(
    params: Optseq2ParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("optseq2")
    cargs.extend([
        "--ntp",
        str(params.get("ntp", None))
    ])
    cargs.extend([
        "--tr",
        str(params.get("tr", None))
    ])
    cargs.extend([
        "--tprescan",
        str(params.get("tprescan", None))
    ])
    cargs.extend([
        "--psdwin",
        *map(str, params.get("psdwin", None))
    ])
    if params.get("event", None) is not None:
        cargs.extend([
            "--ev",
            *params.get("event", None)
        ])
    if params.get("repvar", None) is not None:
        cargs.extend([
            "--repvar",
            params.get("repvar", None)
        ])
    if params.get("polyfit", None) is not None:
        cargs.extend([
            "--polyfit",
            str(params.get("polyfit", None))
        ])
    if params.get("tnullmin", None) is not None:
        cargs.extend([
            "--tnullmin",
            str(params.get("tnullmin", None))
        ])
    if params.get("tnullmax", None) is not None:
        cargs.extend([
            "--tnullmax",
            str(params.get("tnullmax", None))
        ])
    if params.get("nsearch", None) is not None:
        cargs.extend([
            "--nsearch",
            str(params.get("nsearch", None))
        ])
    if params.get("tsearch", None) is not None:
        cargs.extend([
            "--tsearch",
            str(params.get("tsearch", None))
        ])
    if params.get("first_order_cb", None) is not None:
        cargs.extend([
            "--focb",
            str(params.get("first_order_cb", None))
        ])
    if params.get("ar1", None) is not None:
        cargs.extend([
            "--ar1",
            str(params.get("ar1", None))
        ])
    if params.get("penalize", None) is not None:
        cargs.extend([
            "--pen",
            *map(str, params.get("penalize", None))
        ])
    if params.get("evc", None) is not None:
        cargs.extend([
            "--evc",
            *map(str, params.get("evc", None))
        ])
    if params.get("cmtx", None) is not None:
        cargs.extend([
            "--C",
            execution.input_file(params.get("cmtx", None))
        ])
    if params.get("cost", None) is not None:
        cargs.extend([
            "--cost",
            params.get("cost", None)
        ])
    if params.get("sumdelays", False):
        cargs.append("--sumdelays")
    if params.get("seed", None) is not None:
        cargs.extend([
            "--seed",
            str(params.get("seed", None))
        ])
    if params.get("nkeep", None) is not None:
        cargs.extend([
            "--nkeep",
            str(params.get("nkeep", None))
        ])
    if params.get("outstem", None) is not None:
        cargs.extend([
            "--o",
            params.get("outstem", None)
        ])
    if params.get("mtxstem", None) is not None:
        cargs.extend([
            "--mtx",
            params.get("mtxstem", None)
        ])
    if params.get("cmtxfile", None) is not None:
        cargs.extend([
            "--cmtx",
            params.get("cmtxfile", None)
        ])
    if params.get("summaryfile", None) is not None:
        cargs.extend([
            "--sum",
            params.get("summaryfile", None)
        ])
    if params.get("logfile", None) is not None:
        cargs.extend([
            "--log",
            params.get("logfile", None)
        ])
    if params.get("pctupdate", None) is not None:
        cargs.extend([
            "--pctupdate",
            str(params.get("pctupdate", None))
        ])
    if params.get("sviterfile", None) is not None:
        cargs.extend([
            "--sviter",
            params.get("sviterfile", None)
        ])
    if params.get("instem", None) is not None:
        cargs.extend([
            "--i",
            params.get("instem", None)
        ])
    if params.get("input_schedule", None) is not None:
        cargs.extend([
            "--in",
            *params.get("input_schedule", None)
        ])
    if params.get("nosearch", False):
        cargs.append("--nosearch")
    if params.get("help", False):
        cargs.append("--help")
    if params.get("version", False):
        cargs.append("--version")
    return cargs


def optseq2_outputs(
    params: Optseq2ParamsDict,
    execution: Execution,
) -> Optseq2Outputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = Optseq2Outputs(
        root=execution.output_file("."),
        output_schedules=execution.output_file(params.get("outstem", None) + "-RRR.par") if (params.get("outstem") is not None) else None,
        output_design_matrices=execution.output_file(params.get("mtxstem", None) + "_RRR.mat") if (params.get("mtxstem") is not None) else None,
        output_contrast_matrix=execution.output_file(params.get("cmtxfile", None)) if (params.get("cmtxfile") is not None) else None,
        output_summary=execution.output_file(params.get("summaryfile", None)) if (params.get("summaryfile") is not None) else None,
        output_log=execution.output_file(params.get("logfile", None)) if (params.get("logfile") is not None) else None,
        output_sviter=execution.output_file(params.get("sviterfile", None)) if (params.get("sviterfile") is not None) else None,
    )
    return ret


def optseq2_execute(
    params: Optseq2ParamsDict,
    runner: Runner | None = None,
) -> Optseq2Outputs:
    """
    optseq2
    
    Optseq2 is a tool for automatically scheduling events for rapid-presentation
    event-related (RPER) fMRI experiments.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `Optseq2Outputs`).
    """
    optseq2_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(OPTSEQ2_METADATA)
    params = execution.params(params)
    cargs = optseq2_cargs(params, execution)
    ret = optseq2_outputs(params, execution)
    execution.run(cargs)
    return ret


def optseq2(
    ntp: float,
    tr: float,
    tprescan: float,
    psdwin: list[float],
    event: list[str] | None = None,
    repvar: str | None = None,
    polyfit: float | None = None,
    tnullmin: float | None = None,
    tnullmax: float | None = None,
    nsearch: float | None = None,
    tsearch: float | None = None,
    first_order_cb: float | None = None,
    ar1: float | None = None,
    penalize: list[float] | None = None,
    evc: list[float] | None = None,
    cmtx: InputPathType | None = None,
    cost: str | None = None,
    sumdelays: bool = False,
    seed: float | None = None,
    nkeep: float | None = None,
    outstem: str | None = None,
    mtxstem: str | None = None,
    cmtxfile: str | None = None,
    summaryfile: str | None = None,
    logfile: str | None = None,
    pctupdate: float | None = None,
    sviterfile: str | None = None,
    instem: str | None = None,
    input_schedule: list[str] | None = None,
    nosearch: bool = False,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> Optseq2Outputs:
    """
    optseq2
    
    Optseq2 is a tool for automatically scheduling events for rapid-presentation
    event-related (RPER) fMRI experiments.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        ntp: Number of time points to be acquired during the scan.
        tr: Temporal resolution of acquisition in seconds.
        tprescan: Start events t seconds before first acquisition.
        psdwin: Post-stimulus window specifications: minimum PSD, maximum PSD,\
            and optional dPSD.
        event: Event type specification with label, duration, and number of\
            repetitions.
        repvar: Allow number of repetitions of event types to vary by\
            percentage, optionally per event.
        polyfit: Add polynomial regressors as nuisance variables of specified\
            order.
        tnullmin: Minimum duration of null time between stimuli in seconds.
        tnullmax: Maximum duration of null time between stimuli in seconds.
        nsearch: Search over a specified number of iterations for schedules.
        tsearch: Search for schedules over a specified number of hours.
        first_order_cb: Pre-optimize first order counter-balancing.
        ar1: Optimize assuming whitening with AR1 parameter.
        penalize: Penalize for presentations being too close with parameters\
            alpha, T, and dtmin.
        evc: Contrast of event types with weights.
        cmtx: Load contrast from ASCII matrix file.
        cost: Specify cost function and its parameters.
        sumdelays: Sum delays when forming contrast matrix.
        seed: Initialize random number generator with seed value.
        nkeep: Number of best schedules to keep.
        outstem: Output stem for saved schedules.
        mtxstem: Output stem for saved design matrices.
        cmtxfile: File for saving contrast matrix.
        summaryfile: File for saving search summary.
        logfile: File for saving log information.
        pctupdate: Percentage interval after which progress is logged.
        sviterfile: File to save information from each iteration.
        instem: Initialize with input schedules that match instem-RRR.par.
        input_schedule: Input schedule files.
        nosearch: Do not perform search for optimal schedules.
        help_: Print help page.
        version: Print version string.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `Optseq2Outputs`).
    """
    params = optseq2_params(
        ntp=ntp,
        tr=tr,
        tprescan=tprescan,
        psdwin=psdwin,
        event=event,
        repvar=repvar,
        polyfit=polyfit,
        tnullmin=tnullmin,
        tnullmax=tnullmax,
        nsearch=nsearch,
        tsearch=tsearch,
        first_order_cb=first_order_cb,
        ar1=ar1,
        penalize=penalize,
        evc=evc,
        cmtx=cmtx,
        cost=cost,
        sumdelays=sumdelays,
        seed=seed,
        nkeep=nkeep,
        outstem=outstem,
        mtxstem=mtxstem,
        cmtxfile=cmtxfile,
        summaryfile=summaryfile,
        logfile=logfile,
        pctupdate=pctupdate,
        sviterfile=sviterfile,
        instem=instem,
        input_schedule=input_schedule,
        nosearch=nosearch,
        help_=help_,
        version=version,
    )
    return optseq2_execute(params, runner)


__all__ = [
    "OPTSEQ2_METADATA",
    "Optseq2Outputs",
    "Optseq2ParamsDict",
    "Optseq2ParamsDictTagged",
    "optseq2",
    "optseq2_execute",
    "optseq2_params",
]
