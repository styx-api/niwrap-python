# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_COREG_METADATA = Metadata(
    id="c7232126a6a4e9a369651775489a2dc9cf0eb95d.boutiques",
    name="mri_coreg",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriCoregParamsDictNoTag = typing.TypedDict('_MriCoregParamsDictNoTag', {
    "movvol": InputPathType,
    "refvol": InputPathType,
    "reg": str,
    "subject": typing.NotRequired[str | None],
    "dof": typing.NotRequired[int | None],
    "zscale": bool,
    "xztrans_yrot": bool,
    "xytrans_zrot": bool,
    "xytrans_zrot_xyscale_xyshear": bool,
    "ref_maskvol": typing.NotRequired[InputPathType | None],
    "no_ref_mask": bool,
    "mov_maskvol": typing.NotRequired[InputPathType | None],
    "threads": typing.NotRequired[int | None],
    "subjects_dir": typing.NotRequired[str | None],
    "regdat": typing.NotRequired[str | None],
    "no_coord_dither": bool,
    "no_intensity_dither": bool,
    "spatial_scales": typing.NotRequired[list[str] | None],
    "trans": typing.NotRequired[list[float] | None],
    "rot": typing.NotRequired[list[float] | None],
    "scale": typing.NotRequired[list[float] | None],
    "shear": typing.NotRequired[list[float] | None],
    "init_reg": typing.NotRequired[InputPathType | None],
    "out_param_file": typing.NotRequired[str | None],
    "out_cost_file": typing.NotRequired[str | None],
    "no_cras0": bool,
    "centroid": bool,
    "ras2ras": bool,
    "nitersmax": typing.NotRequired[int | None],
    "ftol": typing.NotRequired[float | None],
    "linmintol": typing.NotRequired[float | None],
    "seed": typing.NotRequired[int | None],
    "sat": typing.NotRequired[float | None],
    "conf_ref": bool,
    "no_bf": bool,
    "bf_lim": typing.NotRequired[float | None],
    "bf_nsamp": typing.NotRequired[int | None],
    "no_smooth": bool,
    "ref_fwhm": typing.NotRequired[float | None],
    "mov_oob": bool,
    "init_reg_save": typing.NotRequired[InputPathType | None],
    "init_reg_save_only": typing.NotRequired[InputPathType | None],
    "mat2par": typing.NotRequired[InputPathType | None],
    "mat2rot": typing.NotRequired[InputPathType | None],
    "par2mat": typing.NotRequired[str | None],
    "lrrev": typing.NotRequired[InputPathType | None],
    "landmarks": typing.NotRequired[list[str] | None],
    "rms": typing.NotRequired[list[str] | None],
    "movout": typing.NotRequired[InputPathType | None],
    "mov_idither": typing.NotRequired[InputPathType | None],
    "debug": bool,
    "checkopts": bool,
    "version": bool,
})
MriCoregParamsDictTagged = typing.TypedDict('MriCoregParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_coreg"],
    "movvol": InputPathType,
    "refvol": InputPathType,
    "reg": str,
    "subject": typing.NotRequired[str | None],
    "dof": typing.NotRequired[int | None],
    "zscale": bool,
    "xztrans_yrot": bool,
    "xytrans_zrot": bool,
    "xytrans_zrot_xyscale_xyshear": bool,
    "ref_maskvol": typing.NotRequired[InputPathType | None],
    "no_ref_mask": bool,
    "mov_maskvol": typing.NotRequired[InputPathType | None],
    "threads": typing.NotRequired[int | None],
    "subjects_dir": typing.NotRequired[str | None],
    "regdat": typing.NotRequired[str | None],
    "no_coord_dither": bool,
    "no_intensity_dither": bool,
    "spatial_scales": typing.NotRequired[list[str] | None],
    "trans": typing.NotRequired[list[float] | None],
    "rot": typing.NotRequired[list[float] | None],
    "scale": typing.NotRequired[list[float] | None],
    "shear": typing.NotRequired[list[float] | None],
    "init_reg": typing.NotRequired[InputPathType | None],
    "out_param_file": typing.NotRequired[str | None],
    "out_cost_file": typing.NotRequired[str | None],
    "no_cras0": bool,
    "centroid": bool,
    "ras2ras": bool,
    "nitersmax": typing.NotRequired[int | None],
    "ftol": typing.NotRequired[float | None],
    "linmintol": typing.NotRequired[float | None],
    "seed": typing.NotRequired[int | None],
    "sat": typing.NotRequired[float | None],
    "conf_ref": bool,
    "no_bf": bool,
    "bf_lim": typing.NotRequired[float | None],
    "bf_nsamp": typing.NotRequired[int | None],
    "no_smooth": bool,
    "ref_fwhm": typing.NotRequired[float | None],
    "mov_oob": bool,
    "init_reg_save": typing.NotRequired[InputPathType | None],
    "init_reg_save_only": typing.NotRequired[InputPathType | None],
    "mat2par": typing.NotRequired[InputPathType | None],
    "mat2rot": typing.NotRequired[InputPathType | None],
    "par2mat": typing.NotRequired[str | None],
    "lrrev": typing.NotRequired[InputPathType | None],
    "landmarks": typing.NotRequired[list[str] | None],
    "rms": typing.NotRequired[list[str] | None],
    "movout": typing.NotRequired[InputPathType | None],
    "mov_idither": typing.NotRequired[InputPathType | None],
    "debug": bool,
    "checkopts": bool,
    "version": bool,
})
MriCoregParamsDict = _MriCoregParamsDictNoTag | MriCoregParamsDictTagged


class MriCoregOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriCoregParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out_registration: OutputPathType
    """Output registration (LTA format)"""
    out_params: OutputPathType | None
    """File with output parameters"""
    out_cost: OutputPathType | None
    """Final cost value file"""
    saved_init_reg: OutputPathType | None
    """Saved initial registration"""
    saved_init_reg_only: OutputPathType | None
    """Saved initial registration (exit after save)"""
    movout_volume: OutputPathType | None
    """Preprocessed moving volume"""
    mov_idither_volume: OutputPathType | None
    """Moving intensity dither volume"""


def mri_coreg_params(
    movvol: InputPathType,
    refvol: InputPathType,
    reg: str,
    subject: str | None = None,
    dof: int | None = None,
    zscale: bool = False,
    xztrans_yrot: bool = False,
    xytrans_zrot: bool = False,
    xytrans_zrot_xyscale_xyshear: bool = False,
    ref_maskvol: InputPathType | None = None,
    no_ref_mask: bool = False,
    mov_maskvol: InputPathType | None = None,
    threads: int | None = None,
    subjects_dir: str | None = None,
    regdat: str | None = None,
    no_coord_dither: bool = False,
    no_intensity_dither: bool = False,
    spatial_scales: list[str] | None = None,
    trans: list[float] | None = None,
    rot: list[float] | None = None,
    scale: list[float] | None = None,
    shear: list[float] | None = None,
    init_reg: InputPathType | None = None,
    out_param_file: str | None = None,
    out_cost_file: str | None = None,
    no_cras0: bool = False,
    centroid: bool = False,
    ras2ras: bool = False,
    nitersmax: int | None = None,
    ftol: float | None = None,
    linmintol: float | None = None,
    seed: int | None = None,
    sat: float | None = None,
    conf_ref: bool = False,
    no_bf: bool = False,
    bf_lim: float | None = None,
    bf_nsamp: int | None = None,
    no_smooth: bool = False,
    ref_fwhm: float | None = None,
    mov_oob: bool = False,
    init_reg_save: InputPathType | None = None,
    init_reg_save_only: InputPathType | None = None,
    mat2par: InputPathType | None = None,
    mat2rot: InputPathType | None = None,
    par2mat: str | None = None,
    lrrev: InputPathType | None = None,
    landmarks: list[str] | None = None,
    rms: list[str] | None = None,
    movout: InputPathType | None = None,
    mov_idither: InputPathType | None = None,
    debug: bool = False,
    checkopts: bool = False,
    version: bool = False,
) -> MriCoregParamsDictTagged:
    """
    Build parameters.
    
    Args:
        movvol: Source volume (mov).
        refvol: Target volume (ref or targ).
        reg: Output registration file.
        subject: Subject ID, forces --ref-mask aparc+aseg.mgz.
        dof: Degrees of freedom. Default is 6.
        zscale: Enable 7 dof registration with scaling in Z.
        xztrans_yrot: For 2D images: uses shifts in x and z and rotation about\
            y (no scale).
        xytrans_zrot: For 2D images: uses shifts in x and y and rotation about\
            z (no scale).
        xytrans_zrot_xyscale_xyshear: For 2D images: uses shifts in x and y,\
            rotation about z, scale in xy, and xy shear.
        ref_maskvol: Mask reference volume with specified mask volume.
        no_ref_mask: Do not mask reference volume.
        mov_maskvol: Mask moving volume with specified mask volume.
        threads: Number of threads to use.
        subjects_dir: Freesurfer SUBJECTS_DIR.
        regdat: Specify registration data file.
        no_coord_dither: Turn off coordinate dithering.
        no_intensity_dither: Turn off intensity dithering.
        spatial_scales: Set spatial scales.
        trans: Initial translation in mm.
        rot: Initial rotation in degrees.
        scale: Initial scale.
        shear: Initial shear.
        init_reg: Initialize with given registration file.
        out_param_file: Save parameters in specified file.
        out_cost_file: Save final cost value in specified file.
        no_cras0: Do not set translation parameters to align centers of mov and\
            ref.
        centroid: Initialize by aligning centroids of mov and ref.
        ras2ras: Save output LTA as RAS2RAS.
        nitersmax: Set maximum number of iterations.
        ftol: Set function tolerance.
        linmintol: Set line minimum tolerance.
        seed: Set random seed for dithering.
        sat: Set saturation threshold.
        conf_ref: Conform the reference without rescaling.
        no_bf: Do not perform brute force search.
        bf_lim: Set constraint limits for brute force search.
        bf_nsamp: Set number of samples for brute force search.
        no_smooth: Do not apply smoothing to either ref or mov.
        ref_fwhm: Apply smoothing to ref with specified FWHM.
        mov_oob: Count mov voxels that are out-of-bounds as 0.
        init_reg_save: Save initial registration.
        init_reg_save_only: Save initial registration and exit.
        mat2par: Extract parameters out of registration.
        mat2rot: Convert registration to a pure rotation.
        par2mat: Convert parameters to a registration.
        lrrev: Approximate registration if you were to left-right reverse the\
            pixels of the input image.
        landmarks: Convert landmarks to a registration.
        rms: Compute RMS difference between two registrations.
        movout: Save the mov after all preprocessing steps.
        mov_idither: Save the mov intensity dither volume.
        debug: Enable debugging mode.
        checkopts: Check options and exit without running.
        version: Print out version and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_coreg",
        "movvol": movvol,
        "refvol": refvol,
        "reg": reg,
        "zscale": zscale,
        "xztrans_yrot": xztrans_yrot,
        "xytrans_zrot": xytrans_zrot,
        "xytrans_zrot_xyscale_xyshear": xytrans_zrot_xyscale_xyshear,
        "no_ref_mask": no_ref_mask,
        "no_coord_dither": no_coord_dither,
        "no_intensity_dither": no_intensity_dither,
        "no_cras0": no_cras0,
        "centroid": centroid,
        "ras2ras": ras2ras,
        "conf_ref": conf_ref,
        "no_bf": no_bf,
        "no_smooth": no_smooth,
        "mov_oob": mov_oob,
        "debug": debug,
        "checkopts": checkopts,
        "version": version,
    }
    if subject is not None:
        params["subject"] = subject
    if dof is not None:
        params["dof"] = dof
    if ref_maskvol is not None:
        params["ref_maskvol"] = ref_maskvol
    if mov_maskvol is not None:
        params["mov_maskvol"] = mov_maskvol
    if threads is not None:
        params["threads"] = threads
    if subjects_dir is not None:
        params["subjects_dir"] = subjects_dir
    if regdat is not None:
        params["regdat"] = regdat
    if spatial_scales is not None:
        params["spatial_scales"] = spatial_scales
    if trans is not None:
        params["trans"] = trans
    if rot is not None:
        params["rot"] = rot
    if scale is not None:
        params["scale"] = scale
    if shear is not None:
        params["shear"] = shear
    if init_reg is not None:
        params["init_reg"] = init_reg
    if out_param_file is not None:
        params["out_param_file"] = out_param_file
    if out_cost_file is not None:
        params["out_cost_file"] = out_cost_file
    if nitersmax is not None:
        params["nitersmax"] = nitersmax
    if ftol is not None:
        params["ftol"] = ftol
    if linmintol is not None:
        params["linmintol"] = linmintol
    if seed is not None:
        params["seed"] = seed
    if sat is not None:
        params["sat"] = sat
    if bf_lim is not None:
        params["bf_lim"] = bf_lim
    if bf_nsamp is not None:
        params["bf_nsamp"] = bf_nsamp
    if ref_fwhm is not None:
        params["ref_fwhm"] = ref_fwhm
    if init_reg_save is not None:
        params["init_reg_save"] = init_reg_save
    if init_reg_save_only is not None:
        params["init_reg_save_only"] = init_reg_save_only
    if mat2par is not None:
        params["mat2par"] = mat2par
    if mat2rot is not None:
        params["mat2rot"] = mat2rot
    if par2mat is not None:
        params["par2mat"] = par2mat
    if lrrev is not None:
        params["lrrev"] = lrrev
    if landmarks is not None:
        params["landmarks"] = landmarks
    if rms is not None:
        params["rms"] = rms
    if movout is not None:
        params["movout"] = movout
    if mov_idither is not None:
        params["mov_idither"] = mov_idither
    return params


def mri_coreg_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriCoregParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("movvol", None) is None:
        raise StyxValidationError("`movvol` must not be None")
    if not isinstance(params["movvol"], (pathlib.Path, str)):
        raise StyxValidationError(f'`movvol` has the wrong type: Received `{type(params.get("movvol", None))}` expected `InputPathType`')
    if params.get("refvol", None) is None:
        raise StyxValidationError("`refvol` must not be None")
    if not isinstance(params["refvol"], (pathlib.Path, str)):
        raise StyxValidationError(f'`refvol` has the wrong type: Received `{type(params.get("refvol", None))}` expected `InputPathType`')
    if params.get("reg", None) is None:
        raise StyxValidationError("`reg` must not be None")
    if not isinstance(params["reg"], str):
        raise StyxValidationError(f'`reg` has the wrong type: Received `{type(params.get("reg", None))}` expected `str`')
    if params.get("subject", None) is not None:
        if not isinstance(params["subject"], str):
            raise StyxValidationError(f'`subject` has the wrong type: Received `{type(params.get("subject", None))}` expected `str | None`')
    if params.get("dof", None) is not None:
        if not isinstance(params["dof"], int):
            raise StyxValidationError(f'`dof` has the wrong type: Received `{type(params.get("dof", None))}` expected `int | None`')
    if params.get("zscale", False) is None:
        raise StyxValidationError("`zscale` must not be None")
    if not isinstance(params["zscale"], bool):
        raise StyxValidationError(f'`zscale` has the wrong type: Received `{type(params.get("zscale", False))}` expected `bool`')
    if params.get("xztrans_yrot", False) is None:
        raise StyxValidationError("`xztrans_yrot` must not be None")
    if not isinstance(params["xztrans_yrot"], bool):
        raise StyxValidationError(f'`xztrans_yrot` has the wrong type: Received `{type(params.get("xztrans_yrot", False))}` expected `bool`')
    if params.get("xytrans_zrot", False) is None:
        raise StyxValidationError("`xytrans_zrot` must not be None")
    if not isinstance(params["xytrans_zrot"], bool):
        raise StyxValidationError(f'`xytrans_zrot` has the wrong type: Received `{type(params.get("xytrans_zrot", False))}` expected `bool`')
    if params.get("xytrans_zrot_xyscale_xyshear", False) is None:
        raise StyxValidationError("`xytrans_zrot_xyscale_xyshear` must not be None")
    if not isinstance(params["xytrans_zrot_xyscale_xyshear"], bool):
        raise StyxValidationError(f'`xytrans_zrot_xyscale_xyshear` has the wrong type: Received `{type(params.get("xytrans_zrot_xyscale_xyshear", False))}` expected `bool`')
    if params.get("ref_maskvol", None) is not None:
        if not isinstance(params["ref_maskvol"], (pathlib.Path, str)):
            raise StyxValidationError(f'`ref_maskvol` has the wrong type: Received `{type(params.get("ref_maskvol", None))}` expected `InputPathType | None`')
    if params.get("no_ref_mask", False) is None:
        raise StyxValidationError("`no_ref_mask` must not be None")
    if not isinstance(params["no_ref_mask"], bool):
        raise StyxValidationError(f'`no_ref_mask` has the wrong type: Received `{type(params.get("no_ref_mask", False))}` expected `bool`')
    if params.get("mov_maskvol", None) is not None:
        if not isinstance(params["mov_maskvol"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mov_maskvol` has the wrong type: Received `{type(params.get("mov_maskvol", None))}` expected `InputPathType | None`')
    if params.get("threads", None) is not None:
        if not isinstance(params["threads"], int):
            raise StyxValidationError(f'`threads` has the wrong type: Received `{type(params.get("threads", None))}` expected `int | None`')
    if params.get("subjects_dir", None) is not None:
        if not isinstance(params["subjects_dir"], str):
            raise StyxValidationError(f'`subjects_dir` has the wrong type: Received `{type(params.get("subjects_dir", None))}` expected `str | None`')
    if params.get("regdat", None) is not None:
        if not isinstance(params["regdat"], str):
            raise StyxValidationError(f'`regdat` has the wrong type: Received `{type(params.get("regdat", None))}` expected `str | None`')
    if params.get("no_coord_dither", False) is None:
        raise StyxValidationError("`no_coord_dither` must not be None")
    if not isinstance(params["no_coord_dither"], bool):
        raise StyxValidationError(f'`no_coord_dither` has the wrong type: Received `{type(params.get("no_coord_dither", False))}` expected `bool`')
    if params.get("no_intensity_dither", False) is None:
        raise StyxValidationError("`no_intensity_dither` must not be None")
    if not isinstance(params["no_intensity_dither"], bool):
        raise StyxValidationError(f'`no_intensity_dither` has the wrong type: Received `{type(params.get("no_intensity_dither", False))}` expected `bool`')
    if params.get("spatial_scales", None) is not None:
        if not isinstance(params["spatial_scales"], list):
            raise StyxValidationError(f'`spatial_scales` has the wrong type: Received `{type(params.get("spatial_scales", None))}` expected `list[str] | None`')
        if not (1 <= len(params["spatial_scales"]) <= 2):
            raise StyxValidationError("Parameter `spatial_scales` must contain between 1 and 2 elements (inclusive)")
        for e in params["spatial_scales"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`spatial_scales` has the wrong type: Received `{type(params.get("spatial_scales", None))}` expected `list[str] | None`')
    if params.get("trans", None) is not None:
        if not isinstance(params["trans"], list):
            raise StyxValidationError(f'`trans` has the wrong type: Received `{type(params.get("trans", None))}` expected `list[float] | None`')
        if len(params["trans"]) != 3:
            raise StyxValidationError("Parameter `trans` must contain exactly 3 elements")
        for e in params["trans"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`trans` has the wrong type: Received `{type(params.get("trans", None))}` expected `list[float] | None`')
    if params.get("rot", None) is not None:
        if not isinstance(params["rot"], list):
            raise StyxValidationError(f'`rot` has the wrong type: Received `{type(params.get("rot", None))}` expected `list[float] | None`')
        if len(params["rot"]) != 3:
            raise StyxValidationError("Parameter `rot` must contain exactly 3 elements")
        for e in params["rot"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`rot` has the wrong type: Received `{type(params.get("rot", None))}` expected `list[float] | None`')
    if params.get("scale", None) is not None:
        if not isinstance(params["scale"], list):
            raise StyxValidationError(f'`scale` has the wrong type: Received `{type(params.get("scale", None))}` expected `list[float] | None`')
        if len(params["scale"]) != 3:
            raise StyxValidationError("Parameter `scale` must contain exactly 3 elements")
        for e in params["scale"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`scale` has the wrong type: Received `{type(params.get("scale", None))}` expected `list[float] | None`')
    if params.get("shear", None) is not None:
        if not isinstance(params["shear"], list):
            raise StyxValidationError(f'`shear` has the wrong type: Received `{type(params.get("shear", None))}` expected `list[float] | None`')
        if len(params["shear"]) != 3:
            raise StyxValidationError("Parameter `shear` must contain exactly 3 elements")
        for e in params["shear"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`shear` has the wrong type: Received `{type(params.get("shear", None))}` expected `list[float] | None`')
    if params.get("init_reg", None) is not None:
        if not isinstance(params["init_reg"], (pathlib.Path, str)):
            raise StyxValidationError(f'`init_reg` has the wrong type: Received `{type(params.get("init_reg", None))}` expected `InputPathType | None`')
    if params.get("out_param_file", None) is not None:
        if not isinstance(params["out_param_file"], str):
            raise StyxValidationError(f'`out_param_file` has the wrong type: Received `{type(params.get("out_param_file", None))}` expected `str | None`')
    if params.get("out_cost_file", None) is not None:
        if not isinstance(params["out_cost_file"], str):
            raise StyxValidationError(f'`out_cost_file` has the wrong type: Received `{type(params.get("out_cost_file", None))}` expected `str | None`')
    if params.get("no_cras0", False) is None:
        raise StyxValidationError("`no_cras0` must not be None")
    if not isinstance(params["no_cras0"], bool):
        raise StyxValidationError(f'`no_cras0` has the wrong type: Received `{type(params.get("no_cras0", False))}` expected `bool`')
    if params.get("centroid", False) is None:
        raise StyxValidationError("`centroid` must not be None")
    if not isinstance(params["centroid"], bool):
        raise StyxValidationError(f'`centroid` has the wrong type: Received `{type(params.get("centroid", False))}` expected `bool`')
    if params.get("ras2ras", False) is None:
        raise StyxValidationError("`ras2ras` must not be None")
    if not isinstance(params["ras2ras"], bool):
        raise StyxValidationError(f'`ras2ras` has the wrong type: Received `{type(params.get("ras2ras", False))}` expected `bool`')
    if params.get("nitersmax", None) is not None:
        if not isinstance(params["nitersmax"], int):
            raise StyxValidationError(f'`nitersmax` has the wrong type: Received `{type(params.get("nitersmax", None))}` expected `int | None`')
    if params.get("ftol", None) is not None:
        if not isinstance(params["ftol"], (float, int)):
            raise StyxValidationError(f'`ftol` has the wrong type: Received `{type(params.get("ftol", None))}` expected `float | None`')
    if params.get("linmintol", None) is not None:
        if not isinstance(params["linmintol"], (float, int)):
            raise StyxValidationError(f'`linmintol` has the wrong type: Received `{type(params.get("linmintol", None))}` expected `float | None`')
    if params.get("seed", None) is not None:
        if not isinstance(params["seed"], int):
            raise StyxValidationError(f'`seed` has the wrong type: Received `{type(params.get("seed", None))}` expected `int | None`')
    if params.get("sat", None) is not None:
        if not isinstance(params["sat"], (float, int)):
            raise StyxValidationError(f'`sat` has the wrong type: Received `{type(params.get("sat", None))}` expected `float | None`')
    if params.get("conf_ref", False) is None:
        raise StyxValidationError("`conf_ref` must not be None")
    if not isinstance(params["conf_ref"], bool):
        raise StyxValidationError(f'`conf_ref` has the wrong type: Received `{type(params.get("conf_ref", False))}` expected `bool`')
    if params.get("no_bf", False) is None:
        raise StyxValidationError("`no_bf` must not be None")
    if not isinstance(params["no_bf"], bool):
        raise StyxValidationError(f'`no_bf` has the wrong type: Received `{type(params.get("no_bf", False))}` expected `bool`')
    if params.get("bf_lim", None) is not None:
        if not isinstance(params["bf_lim"], (float, int)):
            raise StyxValidationError(f'`bf_lim` has the wrong type: Received `{type(params.get("bf_lim", None))}` expected `float | None`')
    if params.get("bf_nsamp", None) is not None:
        if not isinstance(params["bf_nsamp"], int):
            raise StyxValidationError(f'`bf_nsamp` has the wrong type: Received `{type(params.get("bf_nsamp", None))}` expected `int | None`')
    if params.get("no_smooth", False) is None:
        raise StyxValidationError("`no_smooth` must not be None")
    if not isinstance(params["no_smooth"], bool):
        raise StyxValidationError(f'`no_smooth` has the wrong type: Received `{type(params.get("no_smooth", False))}` expected `bool`')
    if params.get("ref_fwhm", None) is not None:
        if not isinstance(params["ref_fwhm"], (float, int)):
            raise StyxValidationError(f'`ref_fwhm` has the wrong type: Received `{type(params.get("ref_fwhm", None))}` expected `float | None`')
    if params.get("mov_oob", False) is None:
        raise StyxValidationError("`mov_oob` must not be None")
    if not isinstance(params["mov_oob"], bool):
        raise StyxValidationError(f'`mov_oob` has the wrong type: Received `{type(params.get("mov_oob", False))}` expected `bool`')
    if params.get("init_reg_save", None) is not None:
        if not isinstance(params["init_reg_save"], (pathlib.Path, str)):
            raise StyxValidationError(f'`init_reg_save` has the wrong type: Received `{type(params.get("init_reg_save", None))}` expected `InputPathType | None`')
    if params.get("init_reg_save_only", None) is not None:
        if not isinstance(params["init_reg_save_only"], (pathlib.Path, str)):
            raise StyxValidationError(f'`init_reg_save_only` has the wrong type: Received `{type(params.get("init_reg_save_only", None))}` expected `InputPathType | None`')
    if params.get("mat2par", None) is not None:
        if not isinstance(params["mat2par"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mat2par` has the wrong type: Received `{type(params.get("mat2par", None))}` expected `InputPathType | None`')
    if params.get("mat2rot", None) is not None:
        if not isinstance(params["mat2rot"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mat2rot` has the wrong type: Received `{type(params.get("mat2rot", None))}` expected `InputPathType | None`')
    if params.get("par2mat", None) is not None:
        if not isinstance(params["par2mat"], str):
            raise StyxValidationError(f'`par2mat` has the wrong type: Received `{type(params.get("par2mat", None))}` expected `str | None`')
    if params.get("lrrev", None) is not None:
        if not isinstance(params["lrrev"], (pathlib.Path, str)):
            raise StyxValidationError(f'`lrrev` has the wrong type: Received `{type(params.get("lrrev", None))}` expected `InputPathType | None`')
    if params.get("landmarks", None) is not None:
        if not isinstance(params["landmarks"], list):
            raise StyxValidationError(f'`landmarks` has the wrong type: Received `{type(params.get("landmarks", None))}` expected `list[str] | None`')
        if len(params["landmarks"]) < 6:
            raise StyxValidationError("Parameter `landmarks` must contain at least 6 elements")
        for e in params["landmarks"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`landmarks` has the wrong type: Received `{type(params.get("landmarks", None))}` expected `list[str] | None`')
    if params.get("rms", None) is not None:
        if not isinstance(params["rms"], list):
            raise StyxValidationError(f'`rms` has the wrong type: Received `{type(params.get("rms", None))}` expected `list[str] | None`')
        if len(params["rms"]) < 4:
            raise StyxValidationError("Parameter `rms` must contain at least 4 elements")
        for e in params["rms"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`rms` has the wrong type: Received `{type(params.get("rms", None))}` expected `list[str] | None`')
    if params.get("movout", None) is not None:
        if not isinstance(params["movout"], (pathlib.Path, str)):
            raise StyxValidationError(f'`movout` has the wrong type: Received `{type(params.get("movout", None))}` expected `InputPathType | None`')
    if params.get("mov_idither", None) is not None:
        if not isinstance(params["mov_idither"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mov_idither` has the wrong type: Received `{type(params.get("mov_idither", None))}` expected `InputPathType | None`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("checkopts", False) is None:
        raise StyxValidationError("`checkopts` must not be None")
    if not isinstance(params["checkopts"], bool):
        raise StyxValidationError(f'`checkopts` has the wrong type: Received `{type(params.get("checkopts", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')


def mri_coreg_cargs(
    params: MriCoregParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_coreg")
    cargs.extend([
        "-mov",
        execution.input_file(params.get("movvol", None))
    ])
    cargs.extend([
        "-ref",
        execution.input_file(params.get("refvol", None))
    ])
    cargs.extend([
        "-reg",
        params.get("reg", None)
    ])
    if params.get("subject", None) is not None:
        cargs.extend([
            "--s",
            params.get("subject", None)
        ])
    if params.get("dof", None) is not None:
        cargs.extend([
            "--dof",
            str(params.get("dof", None))
        ])
    if params.get("zscale", False):
        cargs.append("--zscale")
    if params.get("xztrans_yrot", False):
        cargs.append("--xztrans+yrot")
    if params.get("xytrans_zrot", False):
        cargs.append("--xytrans+zrot")
    if params.get("xytrans_zrot_xyscale_xyshear", False):
        cargs.append("--xytrans+zrot+xyscale+xyshear")
    if params.get("ref_maskvol", None) is not None:
        cargs.extend([
            "--ref-mask",
            execution.input_file(params.get("ref_maskvol", None))
        ])
    if params.get("no_ref_mask", False):
        cargs.append("--no-ref-mask")
    if params.get("mov_maskvol", None) is not None:
        cargs.extend([
            "--mov-mask",
            execution.input_file(params.get("mov_maskvol", None))
        ])
    if params.get("threads", None) is not None:
        cargs.extend([
            "--threads",
            str(params.get("threads", None))
        ])
    if params.get("subjects_dir", None) is not None:
        cargs.extend([
            "--sd",
            params.get("subjects_dir", None)
        ])
    if params.get("regdat", None) is not None:
        cargs.extend([
            "--regdat",
            params.get("regdat", None)
        ])
    if params.get("no_coord_dither", False):
        cargs.append("--no-coord-dither")
    if params.get("no_intensity_dither", False):
        cargs.append("--no-intensity-dither")
    if params.get("spatial_scales", None) is not None:
        cargs.extend([
            "--sep",
            *params.get("spatial_scales", None)
        ])
    if params.get("trans", None) is not None:
        cargs.extend([
            "--trans",
            *map(str, params.get("trans", None))
        ])
    if params.get("rot", None) is not None:
        cargs.extend([
            "--rot",
            *map(str, params.get("rot", None))
        ])
    if params.get("scale", None) is not None:
        cargs.extend([
            "--scale",
            *map(str, params.get("scale", None))
        ])
    if params.get("shear", None) is not None:
        cargs.extend([
            "--shear",
            *map(str, params.get("shear", None))
        ])
    if params.get("init_reg", None) is not None:
        cargs.extend([
            "--init-reg",
            execution.input_file(params.get("init_reg", None))
        ])
    if params.get("out_param_file", None) is not None:
        cargs.extend([
            "--params",
            params.get("out_param_file", None)
        ])
    if params.get("out_cost_file", None) is not None:
        cargs.extend([
            "--final-cost",
            params.get("out_cost_file", None)
        ])
    if params.get("no_cras0", False):
        cargs.append("--no-cras0")
    if params.get("centroid", False):
        cargs.append("--centroid")
    if params.get("ras2ras", False):
        cargs.append("--ras2ras")
    if params.get("nitersmax", None) is not None:
        cargs.extend([
            "--nitersmax",
            str(params.get("nitersmax", None))
        ])
    if params.get("ftol", None) is not None:
        cargs.extend([
            "--ftol",
            str(params.get("ftol", None))
        ])
    if params.get("linmintol", None) is not None:
        cargs.extend([
            "--linmintol",
            str(params.get("linmintol", None))
        ])
    if params.get("seed", None) is not None:
        cargs.extend([
            "--seed",
            str(params.get("seed", None))
        ])
    if params.get("sat", None) is not None:
        cargs.extend([
            "--sat",
            str(params.get("sat", None))
        ])
    if params.get("conf_ref", False):
        cargs.append("--conf-ref")
    if params.get("no_bf", False):
        cargs.append("--no-bf")
    if params.get("bf_lim", None) is not None:
        cargs.extend([
            "--bf-lim",
            str(params.get("bf_lim", None))
        ])
    if params.get("bf_nsamp", None) is not None:
        cargs.extend([
            "--bf-nsamp",
            str(params.get("bf_nsamp", None))
        ])
    if params.get("no_smooth", False):
        cargs.append("--no-smooth")
    if params.get("ref_fwhm", None) is not None:
        cargs.extend([
            "--ref-fwhm",
            str(params.get("ref_fwhm", None))
        ])
    if params.get("mov_oob", False):
        cargs.append("--mov-oob")
    if params.get("init_reg_save", None) is not None:
        cargs.extend([
            "--init-reg-save",
            execution.input_file(params.get("init_reg_save", None))
        ])
    if params.get("init_reg_save_only", None) is not None:
        cargs.extend([
            "--init-reg-save-only",
            execution.input_file(params.get("init_reg_save_only", None))
        ])
    if params.get("mat2par", None) is not None:
        cargs.extend([
            "--mat2par",
            execution.input_file(params.get("mat2par", None))
        ])
    if params.get("mat2rot", None) is not None:
        cargs.extend([
            "--mat2rot",
            execution.input_file(params.get("mat2rot", None))
        ])
    if params.get("par2mat", None) is not None:
        cargs.extend([
            "--par2mat",
            params.get("par2mat", None)
        ])
    if params.get("lrrev", None) is not None:
        cargs.extend([
            "--lrrev",
            execution.input_file(params.get("lrrev", None))
        ])
    if params.get("landmarks", None) is not None:
        cargs.extend([
            "--landmarks",
            *params.get("landmarks", None)
        ])
    if params.get("rms", None) is not None:
        cargs.extend([
            "--rms",
            *params.get("rms", None)
        ])
    if params.get("movout", None) is not None:
        cargs.extend([
            "--movout",
            execution.input_file(params.get("movout", None))
        ])
    if params.get("mov_idither", None) is not None:
        cargs.extend([
            "--mov-idither",
            execution.input_file(params.get("mov_idither", None))
        ])
    if params.get("debug", False):
        cargs.append("--debug")
    if params.get("checkopts", False):
        cargs.append("--checkopts")
    if params.get("version", False):
        cargs.append("--version")
    return cargs


def mri_coreg_outputs(
    params: MriCoregParamsDict,
    execution: Execution,
) -> MriCoregOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriCoregOutputs(
        root=execution.output_file("."),
        out_registration=execution.output_file(params.get("reg", None)),
        out_params=execution.output_file(params.get("out_param_file", None)) if (params.get("out_param_file") is not None) else None,
        out_cost=execution.output_file(params.get("out_cost_file", None)) if (params.get("out_cost_file") is not None) else None,
        saved_init_reg=execution.output_file(pathlib.Path(params.get("init_reg_save", None)).name) if (params.get("init_reg_save") is not None) else None,
        saved_init_reg_only=execution.output_file(pathlib.Path(params.get("init_reg_save_only", None)).name) if (params.get("init_reg_save_only") is not None) else None,
        movout_volume=execution.output_file(pathlib.Path(params.get("movout", None)).name) if (params.get("movout") is not None) else None,
        mov_idither_volume=execution.output_file(pathlib.Path(params.get("mov_idither", None)).name) if (params.get("mov_idither") is not None) else None,
    )
    return ret


def mri_coreg_execute(
    params: MriCoregParamsDict,
    runner: Runner | None = None,
) -> MriCoregOutputs:
    """
    mri_coreg
    
    mri_coreg performs a linear registration between two volumes using the
    method compatible with spm_coreg.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriCoregOutputs`).
    """
    mri_coreg_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_COREG_METADATA)
    params = execution.params(params)
    cargs = mri_coreg_cargs(params, execution)
    ret = mri_coreg_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_coreg(
    movvol: InputPathType,
    refvol: InputPathType,
    reg: str,
    subject: str | None = None,
    dof: int | None = None,
    zscale: bool = False,
    xztrans_yrot: bool = False,
    xytrans_zrot: bool = False,
    xytrans_zrot_xyscale_xyshear: bool = False,
    ref_maskvol: InputPathType | None = None,
    no_ref_mask: bool = False,
    mov_maskvol: InputPathType | None = None,
    threads: int | None = None,
    subjects_dir: str | None = None,
    regdat: str | None = None,
    no_coord_dither: bool = False,
    no_intensity_dither: bool = False,
    spatial_scales: list[str] | None = None,
    trans: list[float] | None = None,
    rot: list[float] | None = None,
    scale: list[float] | None = None,
    shear: list[float] | None = None,
    init_reg: InputPathType | None = None,
    out_param_file: str | None = None,
    out_cost_file: str | None = None,
    no_cras0: bool = False,
    centroid: bool = False,
    ras2ras: bool = False,
    nitersmax: int | None = None,
    ftol: float | None = None,
    linmintol: float | None = None,
    seed: int | None = None,
    sat: float | None = None,
    conf_ref: bool = False,
    no_bf: bool = False,
    bf_lim: float | None = None,
    bf_nsamp: int | None = None,
    no_smooth: bool = False,
    ref_fwhm: float | None = None,
    mov_oob: bool = False,
    init_reg_save: InputPathType | None = None,
    init_reg_save_only: InputPathType | None = None,
    mat2par: InputPathType | None = None,
    mat2rot: InputPathType | None = None,
    par2mat: str | None = None,
    lrrev: InputPathType | None = None,
    landmarks: list[str] | None = None,
    rms: list[str] | None = None,
    movout: InputPathType | None = None,
    mov_idither: InputPathType | None = None,
    debug: bool = False,
    checkopts: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> MriCoregOutputs:
    """
    mri_coreg
    
    mri_coreg performs a linear registration between two volumes using the
    method compatible with spm_coreg.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        movvol: Source volume (mov).
        refvol: Target volume (ref or targ).
        reg: Output registration file.
        subject: Subject ID, forces --ref-mask aparc+aseg.mgz.
        dof: Degrees of freedom. Default is 6.
        zscale: Enable 7 dof registration with scaling in Z.
        xztrans_yrot: For 2D images: uses shifts in x and z and rotation about\
            y (no scale).
        xytrans_zrot: For 2D images: uses shifts in x and y and rotation about\
            z (no scale).
        xytrans_zrot_xyscale_xyshear: For 2D images: uses shifts in x and y,\
            rotation about z, scale in xy, and xy shear.
        ref_maskvol: Mask reference volume with specified mask volume.
        no_ref_mask: Do not mask reference volume.
        mov_maskvol: Mask moving volume with specified mask volume.
        threads: Number of threads to use.
        subjects_dir: Freesurfer SUBJECTS_DIR.
        regdat: Specify registration data file.
        no_coord_dither: Turn off coordinate dithering.
        no_intensity_dither: Turn off intensity dithering.
        spatial_scales: Set spatial scales.
        trans: Initial translation in mm.
        rot: Initial rotation in degrees.
        scale: Initial scale.
        shear: Initial shear.
        init_reg: Initialize with given registration file.
        out_param_file: Save parameters in specified file.
        out_cost_file: Save final cost value in specified file.
        no_cras0: Do not set translation parameters to align centers of mov and\
            ref.
        centroid: Initialize by aligning centroids of mov and ref.
        ras2ras: Save output LTA as RAS2RAS.
        nitersmax: Set maximum number of iterations.
        ftol: Set function tolerance.
        linmintol: Set line minimum tolerance.
        seed: Set random seed for dithering.
        sat: Set saturation threshold.
        conf_ref: Conform the reference without rescaling.
        no_bf: Do not perform brute force search.
        bf_lim: Set constraint limits for brute force search.
        bf_nsamp: Set number of samples for brute force search.
        no_smooth: Do not apply smoothing to either ref or mov.
        ref_fwhm: Apply smoothing to ref with specified FWHM.
        mov_oob: Count mov voxels that are out-of-bounds as 0.
        init_reg_save: Save initial registration.
        init_reg_save_only: Save initial registration and exit.
        mat2par: Extract parameters out of registration.
        mat2rot: Convert registration to a pure rotation.
        par2mat: Convert parameters to a registration.
        lrrev: Approximate registration if you were to left-right reverse the\
            pixels of the input image.
        landmarks: Convert landmarks to a registration.
        rms: Compute RMS difference between two registrations.
        movout: Save the mov after all preprocessing steps.
        mov_idither: Save the mov intensity dither volume.
        debug: Enable debugging mode.
        checkopts: Check options and exit without running.
        version: Print out version and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriCoregOutputs`).
    """
    params = mri_coreg_params(
        movvol=movvol,
        refvol=refvol,
        reg=reg,
        subject=subject,
        dof=dof,
        zscale=zscale,
        xztrans_yrot=xztrans_yrot,
        xytrans_zrot=xytrans_zrot,
        xytrans_zrot_xyscale_xyshear=xytrans_zrot_xyscale_xyshear,
        ref_maskvol=ref_maskvol,
        no_ref_mask=no_ref_mask,
        mov_maskvol=mov_maskvol,
        threads=threads,
        subjects_dir=subjects_dir,
        regdat=regdat,
        no_coord_dither=no_coord_dither,
        no_intensity_dither=no_intensity_dither,
        spatial_scales=spatial_scales,
        trans=trans,
        rot=rot,
        scale=scale,
        shear=shear,
        init_reg=init_reg,
        out_param_file=out_param_file,
        out_cost_file=out_cost_file,
        no_cras0=no_cras0,
        centroid=centroid,
        ras2ras=ras2ras,
        nitersmax=nitersmax,
        ftol=ftol,
        linmintol=linmintol,
        seed=seed,
        sat=sat,
        conf_ref=conf_ref,
        no_bf=no_bf,
        bf_lim=bf_lim,
        bf_nsamp=bf_nsamp,
        no_smooth=no_smooth,
        ref_fwhm=ref_fwhm,
        mov_oob=mov_oob,
        init_reg_save=init_reg_save,
        init_reg_save_only=init_reg_save_only,
        mat2par=mat2par,
        mat2rot=mat2rot,
        par2mat=par2mat,
        lrrev=lrrev,
        landmarks=landmarks,
        rms=rms,
        movout=movout,
        mov_idither=mov_idither,
        debug=debug,
        checkopts=checkopts,
        version=version,
    )
    return mri_coreg_execute(params, runner)


__all__ = [
    "MRI_COREG_METADATA",
    "MriCoregOutputs",
    "MriCoregParamsDict",
    "MriCoregParamsDictTagged",
    "mri_coreg",
    "mri_coreg_execute",
    "mri_coreg_params",
]
