# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_EASYREG_METADATA = Metadata(
    id="6ec1a94b1d91e7b7c163bd6dbc8035bf8075894c.boutiques",
    name="mri_easyreg",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriEasyregParamsDictNoTag = typing.TypedDict('_MriEasyregParamsDictNoTag', {
    "reference_image": InputPathType,
    "reference_segmentation": typing.NotRequired[InputPathType | None],
    "floating_image": InputPathType,
    "floating_segmentation": typing.NotRequired[InputPathType | None],
    "registered_reference": typing.NotRequired[InputPathType | None],
    "registered_floating": typing.NotRequired[InputPathType | None],
    "forward_field": typing.NotRequired[InputPathType | None],
    "inverse_field": typing.NotRequired[InputPathType | None],
    "affine_only": bool,
    "threads": typing.NotRequired[float | None],
})
MriEasyregParamsDictTagged = typing.TypedDict('MriEasyregParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_easyreg"],
    "reference_image": InputPathType,
    "reference_segmentation": typing.NotRequired[InputPathType | None],
    "floating_image": InputPathType,
    "floating_segmentation": typing.NotRequired[InputPathType | None],
    "registered_reference": typing.NotRequired[InputPathType | None],
    "registered_floating": typing.NotRequired[InputPathType | None],
    "forward_field": typing.NotRequired[InputPathType | None],
    "inverse_field": typing.NotRequired[InputPathType | None],
    "affine_only": bool,
    "threads": typing.NotRequired[float | None],
})
MriEasyregParamsDict = _MriEasyregParamsDictNoTag | MriEasyregParamsDictTagged


class MriEasyregOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriEasyregParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    registered_reference_output: OutputPathType
    """Output registered reference image"""
    registered_floating_output: OutputPathType
    """Output registered floating image"""
    forward_field_output: OutputPathType
    """Output forward field file"""
    inverse_field_output: OutputPathType
    """Output inverse field file"""


def mri_easyreg_params(
    reference_image: InputPathType,
    floating_image: InputPathType,
    reference_segmentation: InputPathType | None = None,
    floating_segmentation: InputPathType | None = None,
    registered_reference: InputPathType | None = None,
    registered_floating: InputPathType | None = None,
    forward_field: InputPathType | None = None,
    inverse_field: InputPathType | None = None,
    affine_only: bool = False,
    threads: float | None = None,
) -> MriEasyregParamsDictTagged:
    """
    Build parameters.
    
    Args:
        reference_image: Reference image.
        floating_image: Floating image.
        reference_segmentation: Reference SynthSeg segmentation (will be\
            created if it does not exist).
        floating_segmentation: Floating SynthSeg segmentation (will be created\
            if it does not exist).
        registered_reference: (optional) Registered reference.
        registered_floating: (optional) Registered floating images (in space of\
            reference).
        forward_field: (optional) Forward field.
        inverse_field: (optional) Inverse field.
        affine_only: (optional) Skips nonlinear part.
        threads: (optional) Number of cores to be used. Default is 1. You can\
            use -1 to use all available cores.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_easyreg",
        "reference_image": reference_image,
        "floating_image": floating_image,
        "affine_only": affine_only,
    }
    if reference_segmentation is not None:
        params["reference_segmentation"] = reference_segmentation
    if floating_segmentation is not None:
        params["floating_segmentation"] = floating_segmentation
    if registered_reference is not None:
        params["registered_reference"] = registered_reference
    if registered_floating is not None:
        params["registered_floating"] = registered_floating
    if forward_field is not None:
        params["forward_field"] = forward_field
    if inverse_field is not None:
        params["inverse_field"] = inverse_field
    if threads is not None:
        params["threads"] = threads
    return params


def mri_easyreg_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriEasyregParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("reference_image", None) is None:
        raise StyxValidationError("`reference_image` must not be None")
    if not isinstance(params["reference_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`reference_image` has the wrong type: Received `{type(params.get("reference_image", None))}` expected `InputPathType`')
    if params.get("reference_segmentation", None) is not None:
        if not isinstance(params["reference_segmentation"], (pathlib.Path, str)):
            raise StyxValidationError(f'`reference_segmentation` has the wrong type: Received `{type(params.get("reference_segmentation", None))}` expected `InputPathType | None`')
    if params.get("floating_image", None) is None:
        raise StyxValidationError("`floating_image` must not be None")
    if not isinstance(params["floating_image"], (pathlib.Path, str)):
        raise StyxValidationError(f'`floating_image` has the wrong type: Received `{type(params.get("floating_image", None))}` expected `InputPathType`')
    if params.get("floating_segmentation", None) is not None:
        if not isinstance(params["floating_segmentation"], (pathlib.Path, str)):
            raise StyxValidationError(f'`floating_segmentation` has the wrong type: Received `{type(params.get("floating_segmentation", None))}` expected `InputPathType | None`')
    if params.get("registered_reference", None) is not None:
        if not isinstance(params["registered_reference"], (pathlib.Path, str)):
            raise StyxValidationError(f'`registered_reference` has the wrong type: Received `{type(params.get("registered_reference", None))}` expected `InputPathType | None`')
    if params.get("registered_floating", None) is not None:
        if not isinstance(params["registered_floating"], (pathlib.Path, str)):
            raise StyxValidationError(f'`registered_floating` has the wrong type: Received `{type(params.get("registered_floating", None))}` expected `InputPathType | None`')
    if params.get("forward_field", None) is not None:
        if not isinstance(params["forward_field"], (pathlib.Path, str)):
            raise StyxValidationError(f'`forward_field` has the wrong type: Received `{type(params.get("forward_field", None))}` expected `InputPathType | None`')
    if params.get("inverse_field", None) is not None:
        if not isinstance(params["inverse_field"], (pathlib.Path, str)):
            raise StyxValidationError(f'`inverse_field` has the wrong type: Received `{type(params.get("inverse_field", None))}` expected `InputPathType | None`')
    if params.get("affine_only", False) is None:
        raise StyxValidationError("`affine_only` must not be None")
    if not isinstance(params["affine_only"], bool):
        raise StyxValidationError(f'`affine_only` has the wrong type: Received `{type(params.get("affine_only", False))}` expected `bool`')
    if params.get("threads", None) is not None:
        if not isinstance(params["threads"], (float, int)):
            raise StyxValidationError(f'`threads` has the wrong type: Received `{type(params.get("threads", None))}` expected `float | None`')


def mri_easyreg_cargs(
    params: MriEasyregParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_easyreg")
    cargs.extend([
        "--ref",
        execution.input_file(params.get("reference_image", None))
    ])
    if params.get("reference_segmentation", None) is not None:
        cargs.extend([
            "--ref_seg",
            execution.input_file(params.get("reference_segmentation", None))
        ])
    cargs.extend([
        "--flo",
        execution.input_file(params.get("floating_image", None))
    ])
    if params.get("floating_segmentation", None) is not None:
        cargs.extend([
            "--flo_seg",
            execution.input_file(params.get("floating_segmentation", None))
        ])
    if params.get("registered_reference", None) is not None:
        cargs.extend([
            "--ref_reg",
            execution.input_file(params.get("registered_reference", None))
        ])
    if params.get("registered_floating", None) is not None:
        cargs.extend([
            "--flo_reg",
            execution.input_file(params.get("registered_floating", None))
        ])
    if params.get("forward_field", None) is not None:
        cargs.extend([
            "--fwd_field",
            execution.input_file(params.get("forward_field", None))
        ])
    if params.get("inverse_field", None) is not None:
        cargs.extend([
            "--bak_field",
            execution.input_file(params.get("inverse_field", None))
        ])
    if params.get("affine_only", False):
        cargs.append("--affine_only")
    if params.get("threads", None) is not None:
        cargs.extend([
            "--threads",
            str(params.get("threads", None))
        ])
    return cargs


def mri_easyreg_outputs(
    params: MriEasyregParamsDict,
    execution: Execution,
) -> MriEasyregOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriEasyregOutputs(
        root=execution.output_file("."),
        registered_reference_output=execution.output_file("registered_reference.nii.gz"),
        registered_floating_output=execution.output_file("registered_floating.nii.gz"),
        forward_field_output=execution.output_file("forward_field.nii.gz"),
        inverse_field_output=execution.output_file("inverse_field.nii.gz"),
    )
    return ret


def mri_easyreg_execute(
    params: MriEasyregParamsDict,
    runner: Runner | None = None,
) -> MriEasyregOutputs:
    """
    mri_easyreg
    
    EasyReg: deep learning registration simple and easy.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriEasyregOutputs`).
    """
    mri_easyreg_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_EASYREG_METADATA)
    params = execution.params(params)
    cargs = mri_easyreg_cargs(params, execution)
    ret = mri_easyreg_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_easyreg(
    reference_image: InputPathType,
    floating_image: InputPathType,
    reference_segmentation: InputPathType | None = None,
    floating_segmentation: InputPathType | None = None,
    registered_reference: InputPathType | None = None,
    registered_floating: InputPathType | None = None,
    forward_field: InputPathType | None = None,
    inverse_field: InputPathType | None = None,
    affine_only: bool = False,
    threads: float | None = None,
    runner: Runner | None = None,
) -> MriEasyregOutputs:
    """
    mri_easyreg
    
    EasyReg: deep learning registration simple and easy.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        reference_image: Reference image.
        floating_image: Floating image.
        reference_segmentation: Reference SynthSeg segmentation (will be\
            created if it does not exist).
        floating_segmentation: Floating SynthSeg segmentation (will be created\
            if it does not exist).
        registered_reference: (optional) Registered reference.
        registered_floating: (optional) Registered floating images (in space of\
            reference).
        forward_field: (optional) Forward field.
        inverse_field: (optional) Inverse field.
        affine_only: (optional) Skips nonlinear part.
        threads: (optional) Number of cores to be used. Default is 1. You can\
            use -1 to use all available cores.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriEasyregOutputs`).
    """
    params = mri_easyreg_params(
        reference_image=reference_image,
        reference_segmentation=reference_segmentation,
        floating_image=floating_image,
        floating_segmentation=floating_segmentation,
        registered_reference=registered_reference,
        registered_floating=registered_floating,
        forward_field=forward_field,
        inverse_field=inverse_field,
        affine_only=affine_only,
        threads=threads,
    )
    return mri_easyreg_execute(params, runner)


__all__ = [
    "MRI_EASYREG_METADATA",
    "MriEasyregOutputs",
    "MriEasyregParamsDict",
    "MriEasyregParamsDictTagged",
    "mri_easyreg",
    "mri_easyreg_execute",
    "mri_easyreg_params",
]
