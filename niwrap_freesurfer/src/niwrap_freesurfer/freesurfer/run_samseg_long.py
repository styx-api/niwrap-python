# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

RUN_SAMSEG_LONG_METADATA = Metadata(
    id="099916b21f2e46fd8082ecf1726ddb1c04fbe330.boutiques",
    name="run_samseg_long",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_RunSamsegLongParamsDictNoTag = typing.TypedDict('_RunSamsegLongParamsDictNoTag', {
    "timepoint": list[InputPathType],
    "output": str,
    "lesion": bool,
    "threshold": typing.NotRequired[float | None],
    "samples": typing.NotRequired[float | None],
    "burnin": typing.NotRequired[float | None],
    "lesion_mask_structure": typing.NotRequired[str | None],
    "lesion_mask_pattern": typing.NotRequired[list[float] | None],
    "mode": typing.NotRequired[list[str] | None],
    "atlas": typing.NotRequired[str | None],
    "deformation_hyperprior": typing.NotRequired[float | None],
    "gmm_hyperprior": typing.NotRequired[float | None],
    "save_warp": bool,
    "save_mesh": bool,
    "save_posteriors": typing.NotRequired[list[str] | None],
    "pallidum_separate": bool,
    "threads": typing.NotRequired[float | None],
    "tp_to_base_transform": typing.NotRequired[list[InputPathType] | None],
    "force_different_resolutions": bool,
    "history": bool,
    "showfigs": bool,
    "movie": bool,
})
RunSamsegLongParamsDictTagged = typing.TypedDict('RunSamsegLongParamsDictTagged', {
    "@type": typing.Literal["freesurfer/run_samseg_long"],
    "timepoint": list[InputPathType],
    "output": str,
    "lesion": bool,
    "threshold": typing.NotRequired[float | None],
    "samples": typing.NotRequired[float | None],
    "burnin": typing.NotRequired[float | None],
    "lesion_mask_structure": typing.NotRequired[str | None],
    "lesion_mask_pattern": typing.NotRequired[list[float] | None],
    "mode": typing.NotRequired[list[str] | None],
    "atlas": typing.NotRequired[str | None],
    "deformation_hyperprior": typing.NotRequired[float | None],
    "gmm_hyperprior": typing.NotRequired[float | None],
    "save_warp": bool,
    "save_mesh": bool,
    "save_posteriors": typing.NotRequired[list[str] | None],
    "pallidum_separate": bool,
    "threads": typing.NotRequired[float | None],
    "tp_to_base_transform": typing.NotRequired[list[InputPathType] | None],
    "force_different_resolutions": bool,
    "history": bool,
    "showfigs": bool,
    "movie": bool,
})
RunSamsegLongParamsDict = _RunSamsegLongParamsDictNoTag | RunSamsegLongParamsDictTagged


class RunSamsegLongOutputs(typing.NamedTuple):
    """
    Output object returned when calling `RunSamsegLongParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def run_samseg_long_params(
    timepoint: list[InputPathType],
    output: str,
    lesion: bool = False,
    threshold: float | None = None,
    samples: float | None = None,
    burnin: float | None = None,
    lesion_mask_structure: str | None = None,
    lesion_mask_pattern: list[float] | None = None,
    mode: list[str] | None = None,
    atlas: str | None = None,
    deformation_hyperprior: float | None = None,
    gmm_hyperprior: float | None = None,
    save_warp: bool = False,
    save_mesh: bool = False,
    save_posteriors: list[str] | None = None,
    pallidum_separate: bool = False,
    threads: float | None = None,
    tp_to_base_transform: list[InputPathType] | None = None,
    force_different_resolutions: bool = False,
    history: bool = False,
    showfigs: bool = False,
    movie: bool = False,
) -> RunSamsegLongParamsDictTagged:
    """
    Build parameters.
    
    Args:
        timepoint: Configure a timepoint with multiple inputs.
        output: Output directory.
        lesion: Enable lesion segmentation (requires tensorflow).
        threshold: Lesion threshold for final segmentation. Requires lesion\
            segmentation.
        samples: Number of samples for lesion segmentation. Requires lesion\
            segmentation.
        burnin: Number of burn-in samples for lesion segmentation. Requires\
            lesion segmentation.
        lesion_mask_structure: Intensity mask brain structure. Requires lesion\
            segmentation.
        lesion_mask_pattern: Lesion mask list: -1 below lesion mask structure\
            mean, +1 above, 0 no mask. Requires lesion segmentation.
        mode: Output basenames for the input image mode.
        atlas: Point to an alternative atlas directory.
        deformation_hyperprior: Strength of the latent deformation hyperprior.
        gmm_hyperprior: Strength of the latent GMM hyperprior.
        save_warp: Save the image->template warp fields.
        save_mesh: Save the final mesh of each timepoint in template space.
        save_posteriors: Save posterior volumes to the 'posteriors'\
            subdirectory.
        pallidum_separate: Move pallidum outside of global white matter class.\
            Use with T2/flair.
        threads: Number of threads to use. Defaults to OMP_NUM_THREADS or 1.
        tp_to_base_transform: Transformation file for each time point to base.
        force_different_resolutions: Force run even if time points have\
            different resolutions.
        history: Save history.
        showfigs: Show figures during run.
        movie: Show history as arrow key controlled time sequence.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/run_samseg_long",
        "timepoint": timepoint,
        "output": output,
        "lesion": lesion,
        "save_warp": save_warp,
        "save_mesh": save_mesh,
        "pallidum_separate": pallidum_separate,
        "force_different_resolutions": force_different_resolutions,
        "history": history,
        "showfigs": showfigs,
        "movie": movie,
    }
    if threshold is not None:
        params["threshold"] = threshold
    if samples is not None:
        params["samples"] = samples
    if burnin is not None:
        params["burnin"] = burnin
    if lesion_mask_structure is not None:
        params["lesion_mask_structure"] = lesion_mask_structure
    if lesion_mask_pattern is not None:
        params["lesion_mask_pattern"] = lesion_mask_pattern
    if mode is not None:
        params["mode"] = mode
    if atlas is not None:
        params["atlas"] = atlas
    if deformation_hyperprior is not None:
        params["deformation_hyperprior"] = deformation_hyperprior
    if gmm_hyperprior is not None:
        params["gmm_hyperprior"] = gmm_hyperprior
    if save_posteriors is not None:
        params["save_posteriors"] = save_posteriors
    if threads is not None:
        params["threads"] = threads
    if tp_to_base_transform is not None:
        params["tp_to_base_transform"] = tp_to_base_transform
    return params


def run_samseg_long_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `RunSamsegLongParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("timepoint", None) is None:
        raise StyxValidationError("`timepoint` must not be None")
    if not isinstance(params["timepoint"], list):
        raise StyxValidationError(f'`timepoint` has the wrong type: Received `{type(params.get("timepoint", None))}` expected `list[InputPathType]`')
    for e in params["timepoint"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`timepoint` has the wrong type: Received `{type(params.get("timepoint", None))}` expected `list[InputPathType]`')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')
    if params.get("lesion", False) is None:
        raise StyxValidationError("`lesion` must not be None")
    if not isinstance(params["lesion"], bool):
        raise StyxValidationError(f'`lesion` has the wrong type: Received `{type(params.get("lesion", False))}` expected `bool`')
    if params.get("threshold", None) is not None:
        if not isinstance(params["threshold"], (float, int)):
            raise StyxValidationError(f'`threshold` has the wrong type: Received `{type(params.get("threshold", None))}` expected `float | None`')
    if params.get("samples", None) is not None:
        if not isinstance(params["samples"], (float, int)):
            raise StyxValidationError(f'`samples` has the wrong type: Received `{type(params.get("samples", None))}` expected `float | None`')
    if params.get("burnin", None) is not None:
        if not isinstance(params["burnin"], (float, int)):
            raise StyxValidationError(f'`burnin` has the wrong type: Received `{type(params.get("burnin", None))}` expected `float | None`')
    if params.get("lesion_mask_structure", None) is not None:
        if not isinstance(params["lesion_mask_structure"], str):
            raise StyxValidationError(f'`lesion_mask_structure` has the wrong type: Received `{type(params.get("lesion_mask_structure", None))}` expected `str | None`')
    if params.get("lesion_mask_pattern", None) is not None:
        if not isinstance(params["lesion_mask_pattern"], list):
            raise StyxValidationError(f'`lesion_mask_pattern` has the wrong type: Received `{type(params.get("lesion_mask_pattern", None))}` expected `list[float] | None`')
        for e in params["lesion_mask_pattern"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`lesion_mask_pattern` has the wrong type: Received `{type(params.get("lesion_mask_pattern", None))}` expected `list[float] | None`')
    if params.get("mode", None) is not None:
        if not isinstance(params["mode"], list):
            raise StyxValidationError(f'`mode` has the wrong type: Received `{type(params.get("mode", None))}` expected `list[str] | None`')
        for e in params["mode"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`mode` has the wrong type: Received `{type(params.get("mode", None))}` expected `list[str] | None`')
    if params.get("atlas", None) is not None:
        if not isinstance(params["atlas"], str):
            raise StyxValidationError(f'`atlas` has the wrong type: Received `{type(params.get("atlas", None))}` expected `str | None`')
    if params.get("deformation_hyperprior", None) is not None:
        if not isinstance(params["deformation_hyperprior"], (float, int)):
            raise StyxValidationError(f'`deformation_hyperprior` has the wrong type: Received `{type(params.get("deformation_hyperprior", None))}` expected `float | None`')
    if params.get("gmm_hyperprior", None) is not None:
        if not isinstance(params["gmm_hyperprior"], (float, int)):
            raise StyxValidationError(f'`gmm_hyperprior` has the wrong type: Received `{type(params.get("gmm_hyperprior", None))}` expected `float | None`')
    if params.get("save_warp", False) is None:
        raise StyxValidationError("`save_warp` must not be None")
    if not isinstance(params["save_warp"], bool):
        raise StyxValidationError(f'`save_warp` has the wrong type: Received `{type(params.get("save_warp", False))}` expected `bool`')
    if params.get("save_mesh", False) is None:
        raise StyxValidationError("`save_mesh` must not be None")
    if not isinstance(params["save_mesh"], bool):
        raise StyxValidationError(f'`save_mesh` has the wrong type: Received `{type(params.get("save_mesh", False))}` expected `bool`')
    if params.get("save_posteriors", None) is not None:
        if not isinstance(params["save_posteriors"], list):
            raise StyxValidationError(f'`save_posteriors` has the wrong type: Received `{type(params.get("save_posteriors", None))}` expected `list[str] | None`')
        for e in params["save_posteriors"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`save_posteriors` has the wrong type: Received `{type(params.get("save_posteriors", None))}` expected `list[str] | None`')
    if params.get("pallidum_separate", False) is None:
        raise StyxValidationError("`pallidum_separate` must not be None")
    if not isinstance(params["pallidum_separate"], bool):
        raise StyxValidationError(f'`pallidum_separate` has the wrong type: Received `{type(params.get("pallidum_separate", False))}` expected `bool`')
    if params.get("threads", None) is not None:
        if not isinstance(params["threads"], (float, int)):
            raise StyxValidationError(f'`threads` has the wrong type: Received `{type(params.get("threads", None))}` expected `float | None`')
    if params.get("tp_to_base_transform", None) is not None:
        if not isinstance(params["tp_to_base_transform"], list):
            raise StyxValidationError(f'`tp_to_base_transform` has the wrong type: Received `{type(params.get("tp_to_base_transform", None))}` expected `list[InputPathType] | None`')
        for e in params["tp_to_base_transform"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`tp_to_base_transform` has the wrong type: Received `{type(params.get("tp_to_base_transform", None))}` expected `list[InputPathType] | None`')
    if params.get("force_different_resolutions", False) is None:
        raise StyxValidationError("`force_different_resolutions` must not be None")
    if not isinstance(params["force_different_resolutions"], bool):
        raise StyxValidationError(f'`force_different_resolutions` has the wrong type: Received `{type(params.get("force_different_resolutions", False))}` expected `bool`')
    if params.get("history", False) is None:
        raise StyxValidationError("`history` must not be None")
    if not isinstance(params["history"], bool):
        raise StyxValidationError(f'`history` has the wrong type: Received `{type(params.get("history", False))}` expected `bool`')
    if params.get("showfigs", False) is None:
        raise StyxValidationError("`showfigs` must not be None")
    if not isinstance(params["showfigs"], bool):
        raise StyxValidationError(f'`showfigs` has the wrong type: Received `{type(params.get("showfigs", False))}` expected `bool`')
    if params.get("movie", False) is None:
        raise StyxValidationError("`movie` must not be None")
    if not isinstance(params["movie"], bool):
        raise StyxValidationError(f'`movie` has the wrong type: Received `{type(params.get("movie", False))}` expected `bool`')


def run_samseg_long_cargs(
    params: RunSamsegLongParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("run_samseg_long")
    cargs.extend([
        "-t",
        *[execution.input_file(f) for f in params.get("timepoint", None)]
    ])
    cargs.extend([
        "-o",
        params.get("output", None)
    ])
    if params.get("lesion", False):
        cargs.append("--lesion")
    if params.get("threshold", None) is not None:
        cargs.extend([
            "--threshold",
            str(params.get("threshold", None))
        ])
    if params.get("samples", None) is not None:
        cargs.extend([
            "--samples",
            str(params.get("samples", None))
        ])
    if params.get("burnin", None) is not None:
        cargs.extend([
            "--burnin",
            str(params.get("burnin", None))
        ])
    if params.get("lesion_mask_structure", None) is not None:
        cargs.extend([
            "--lesion-mask-structure",
            params.get("lesion_mask_structure", None)
        ])
    if params.get("lesion_mask_pattern", None) is not None:
        cargs.extend([
            "--lesion-mask-pattern",
            *map(str, params.get("lesion_mask_pattern", None))
        ])
    if params.get("mode", None) is not None:
        cargs.extend([
            "-m",
            *params.get("mode", None)
        ])
    if params.get("atlas", None) is not None:
        cargs.extend([
            "-a",
            params.get("atlas", None)
        ])
    if params.get("deformation_hyperprior", None) is not None:
        cargs.extend([
            "--deformation-hyperprior",
            str(params.get("deformation_hyperprior", None))
        ])
    if params.get("gmm_hyperprior", None) is not None:
        cargs.extend([
            "--gmm-hyperprior",
            str(params.get("gmm_hyperprior", None))
        ])
    if params.get("save_warp", False):
        cargs.append("--save-warp")
    if params.get("save_mesh", False):
        cargs.append("--save-mesh")
    if params.get("save_posteriors", None) is not None:
        cargs.extend([
            "--save-posteriors",
            *params.get("save_posteriors", None)
        ])
    if params.get("pallidum_separate", False):
        cargs.append("--pallidum-separate")
    if params.get("threads", None) is not None:
        cargs.extend([
            "--threads",
            str(params.get("threads", None))
        ])
    if params.get("tp_to_base_transform", None) is not None:
        cargs.extend([
            "--tp-to-base-transform",
            *[execution.input_file(f) for f in params.get("tp_to_base_transform", None)]
        ])
    if params.get("force_different_resolutions", False):
        cargs.append("--force-different-resolutions")
    if params.get("history", False):
        cargs.append("--history")
    if params.get("showfigs", False):
        cargs.append("--showfigs")
    if params.get("movie", False):
        cargs.append("--movie")
    return cargs


def run_samseg_long_outputs(
    params: RunSamsegLongParamsDict,
    execution: Execution,
) -> RunSamsegLongOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = RunSamsegLongOutputs(
        root=execution.output_file("."),
    )
    return ret


def run_samseg_long_execute(
    params: RunSamsegLongParamsDict,
    runner: Runner | None = None,
) -> RunSamsegLongOutputs:
    """
    run_samseg_long
    
    Longitudinal image segmentation using SAMSEG.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `RunSamsegLongOutputs`).
    """
    run_samseg_long_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(RUN_SAMSEG_LONG_METADATA)
    params = execution.params(params)
    cargs = run_samseg_long_cargs(params, execution)
    ret = run_samseg_long_outputs(params, execution)
    execution.run(cargs)
    return ret


def run_samseg_long(
    timepoint: list[InputPathType],
    output: str,
    lesion: bool = False,
    threshold: float | None = None,
    samples: float | None = None,
    burnin: float | None = None,
    lesion_mask_structure: str | None = None,
    lesion_mask_pattern: list[float] | None = None,
    mode: list[str] | None = None,
    atlas: str | None = None,
    deformation_hyperprior: float | None = None,
    gmm_hyperprior: float | None = None,
    save_warp: bool = False,
    save_mesh: bool = False,
    save_posteriors: list[str] | None = None,
    pallidum_separate: bool = False,
    threads: float | None = None,
    tp_to_base_transform: list[InputPathType] | None = None,
    force_different_resolutions: bool = False,
    history: bool = False,
    showfigs: bool = False,
    movie: bool = False,
    runner: Runner | None = None,
) -> RunSamsegLongOutputs:
    """
    run_samseg_long
    
    Longitudinal image segmentation using SAMSEG.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        timepoint: Configure a timepoint with multiple inputs.
        output: Output directory.
        lesion: Enable lesion segmentation (requires tensorflow).
        threshold: Lesion threshold for final segmentation. Requires lesion\
            segmentation.
        samples: Number of samples for lesion segmentation. Requires lesion\
            segmentation.
        burnin: Number of burn-in samples for lesion segmentation. Requires\
            lesion segmentation.
        lesion_mask_structure: Intensity mask brain structure. Requires lesion\
            segmentation.
        lesion_mask_pattern: Lesion mask list: -1 below lesion mask structure\
            mean, +1 above, 0 no mask. Requires lesion segmentation.
        mode: Output basenames for the input image mode.
        atlas: Point to an alternative atlas directory.
        deformation_hyperprior: Strength of the latent deformation hyperprior.
        gmm_hyperprior: Strength of the latent GMM hyperprior.
        save_warp: Save the image->template warp fields.
        save_mesh: Save the final mesh of each timepoint in template space.
        save_posteriors: Save posterior volumes to the 'posteriors'\
            subdirectory.
        pallidum_separate: Move pallidum outside of global white matter class.\
            Use with T2/flair.
        threads: Number of threads to use. Defaults to OMP_NUM_THREADS or 1.
        tp_to_base_transform: Transformation file for each time point to base.
        force_different_resolutions: Force run even if time points have\
            different resolutions.
        history: Save history.
        showfigs: Show figures during run.
        movie: Show history as arrow key controlled time sequence.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `RunSamsegLongOutputs`).
    """
    params = run_samseg_long_params(
        timepoint=timepoint,
        output=output,
        lesion=lesion,
        threshold=threshold,
        samples=samples,
        burnin=burnin,
        lesion_mask_structure=lesion_mask_structure,
        lesion_mask_pattern=lesion_mask_pattern,
        mode=mode,
        atlas=atlas,
        deformation_hyperprior=deformation_hyperprior,
        gmm_hyperprior=gmm_hyperprior,
        save_warp=save_warp,
        save_mesh=save_mesh,
        save_posteriors=save_posteriors,
        pallidum_separate=pallidum_separate,
        threads=threads,
        tp_to_base_transform=tp_to_base_transform,
        force_different_resolutions=force_different_resolutions,
        history=history,
        showfigs=showfigs,
        movie=movie,
    )
    return run_samseg_long_execute(params, runner)


__all__ = [
    "RUN_SAMSEG_LONG_METADATA",
    "RunSamsegLongOutputs",
    "RunSamsegLongParamsDict",
    "RunSamsegLongParamsDictTagged",
    "run_samseg_long",
    "run_samseg_long_execute",
    "run_samseg_long_params",
]
