# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

SURFREG_METADATA = Metadata(
    id="7926379a00df2da00c284be09c4c92596bd13d58.boutiques",
    name="surfreg",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_SurfregParamsDictNoTag = typing.TypedDict('_SurfregParamsDictNoTag', {
    "subject": str,
    "target": str,
    "cross_hemi": bool,
    "reg_lh": bool,
    "reg_rh": bool,
    "reg_both": bool,
    "no_annot": bool,
    "annot": typing.NotRequired[str | None],
    "aparc": bool,
    "noneg": bool,
    "init_reg": typing.NotRequired[str | None],
    "lta": typing.NotRequired[str | None],
    "init_from_tal": bool,
    "outsurf": typing.NotRequired[str | None],
    "no_set_vol_geom": bool,
    "threads": typing.NotRequired[float | None],
})
SurfregParamsDictTagged = typing.TypedDict('SurfregParamsDictTagged', {
    "@type": typing.Literal["freesurfer/surfreg"],
    "subject": str,
    "target": str,
    "cross_hemi": bool,
    "reg_lh": bool,
    "reg_rh": bool,
    "reg_both": bool,
    "no_annot": bool,
    "annot": typing.NotRequired[str | None],
    "aparc": bool,
    "noneg": bool,
    "init_reg": typing.NotRequired[str | None],
    "lta": typing.NotRequired[str | None],
    "init_from_tal": bool,
    "outsurf": typing.NotRequired[str | None],
    "no_set_vol_geom": bool,
    "threads": typing.NotRequired[float | None],
})
SurfregParamsDict = _SurfregParamsDictNoTag | SurfregParamsDictTagged


class SurfregOutputs(typing.NamedTuple):
    """
    Output object returned when calling `SurfregParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_surface: OutputPathType
    """Output surface registration file"""


def surfreg_params(
    subject: str,
    target: str,
    cross_hemi: bool = False,
    reg_lh: bool = False,
    reg_rh: bool = False,
    reg_both: bool = False,
    no_annot: bool = False,
    annot: str | None = None,
    aparc: bool = False,
    noneg: bool = False,
    init_reg: str | None = None,
    lta: str | None = None,
    init_from_tal: bool = False,
    outsurf: str | None = None,
    no_set_vol_geom: bool = False,
    threads: float | None = None,
) -> SurfregParamsDictTagged:
    """
    Build parameters.
    
    Args:
        subject: Subject to register.
        target: Target average subject to use as a registration target.
        cross_hemi: Perform cross-hemi registration.
        reg_lh: Register left hemisphere only.
        reg_rh: Register right hemisphere only.
        reg_both: Register both left and right hemispheres.
        no_annot: Do not use annot to rip.
        annot: Use specified annotation name.
        aparc: Set annotation name to aparc.annot.
        noneg: Option flag with unspecified behavior in the provided help text.
        init_reg: Initial registration name, default is sphere.
        lta: Apply rotational components of affine registration.
        init_from_tal: Use talaiach.xfm.lta for initial spherical registration.
        outsurf: Output surface name, default depends on the target.
        no_set_vol_geom: Do not set volume geometry and center the sphere.
        threads: Number of threads to run in parallel.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/surfreg",
        "subject": subject,
        "target": target,
        "cross_hemi": cross_hemi,
        "reg_lh": reg_lh,
        "reg_rh": reg_rh,
        "reg_both": reg_both,
        "no_annot": no_annot,
        "aparc": aparc,
        "noneg": noneg,
        "init_from_tal": init_from_tal,
        "no_set_vol_geom": no_set_vol_geom,
    }
    if annot is not None:
        params["annot"] = annot
    if init_reg is not None:
        params["init_reg"] = init_reg
    if lta is not None:
        params["lta"] = lta
    if outsurf is not None:
        params["outsurf"] = outsurf
    if threads is not None:
        params["threads"] = threads
    return params


def surfreg_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `SurfregParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("subject", None) is None:
        raise StyxValidationError("`subject` must not be None")
    if not isinstance(params["subject"], str):
        raise StyxValidationError(f'`subject` has the wrong type: Received `{type(params.get("subject", None))}` expected `str`')
    if params.get("target", None) is None:
        raise StyxValidationError("`target` must not be None")
    if not isinstance(params["target"], str):
        raise StyxValidationError(f'`target` has the wrong type: Received `{type(params.get("target", None))}` expected `str`')
    if params.get("cross_hemi", False) is None:
        raise StyxValidationError("`cross_hemi` must not be None")
    if not isinstance(params["cross_hemi"], bool):
        raise StyxValidationError(f'`cross_hemi` has the wrong type: Received `{type(params.get("cross_hemi", False))}` expected `bool`')
    if params.get("reg_lh", False) is None:
        raise StyxValidationError("`reg_lh` must not be None")
    if not isinstance(params["reg_lh"], bool):
        raise StyxValidationError(f'`reg_lh` has the wrong type: Received `{type(params.get("reg_lh", False))}` expected `bool`')
    if params.get("reg_rh", False) is None:
        raise StyxValidationError("`reg_rh` must not be None")
    if not isinstance(params["reg_rh"], bool):
        raise StyxValidationError(f'`reg_rh` has the wrong type: Received `{type(params.get("reg_rh", False))}` expected `bool`')
    if params.get("reg_both", False) is None:
        raise StyxValidationError("`reg_both` must not be None")
    if not isinstance(params["reg_both"], bool):
        raise StyxValidationError(f'`reg_both` has the wrong type: Received `{type(params.get("reg_both", False))}` expected `bool`')
    if params.get("no_annot", False) is None:
        raise StyxValidationError("`no_annot` must not be None")
    if not isinstance(params["no_annot"], bool):
        raise StyxValidationError(f'`no_annot` has the wrong type: Received `{type(params.get("no_annot", False))}` expected `bool`')
    if params.get("annot", None) is not None:
        if not isinstance(params["annot"], str):
            raise StyxValidationError(f'`annot` has the wrong type: Received `{type(params.get("annot", None))}` expected `str | None`')
    if params.get("aparc", False) is None:
        raise StyxValidationError("`aparc` must not be None")
    if not isinstance(params["aparc"], bool):
        raise StyxValidationError(f'`aparc` has the wrong type: Received `{type(params.get("aparc", False))}` expected `bool`')
    if params.get("noneg", False) is None:
        raise StyxValidationError("`noneg` must not be None")
    if not isinstance(params["noneg"], bool):
        raise StyxValidationError(f'`noneg` has the wrong type: Received `{type(params.get("noneg", False))}` expected `bool`')
    if params.get("init_reg", None) is not None:
        if not isinstance(params["init_reg"], str):
            raise StyxValidationError(f'`init_reg` has the wrong type: Received `{type(params.get("init_reg", None))}` expected `str | None`')
    if params.get("lta", None) is not None:
        if not isinstance(params["lta"], str):
            raise StyxValidationError(f'`lta` has the wrong type: Received `{type(params.get("lta", None))}` expected `str | None`')
    if params.get("init_from_tal", False) is None:
        raise StyxValidationError("`init_from_tal` must not be None")
    if not isinstance(params["init_from_tal"], bool):
        raise StyxValidationError(f'`init_from_tal` has the wrong type: Received `{type(params.get("init_from_tal", False))}` expected `bool`')
    if params.get("outsurf", None) is not None:
        if not isinstance(params["outsurf"], str):
            raise StyxValidationError(f'`outsurf` has the wrong type: Received `{type(params.get("outsurf", None))}` expected `str | None`')
    if params.get("no_set_vol_geom", False) is None:
        raise StyxValidationError("`no_set_vol_geom` must not be None")
    if not isinstance(params["no_set_vol_geom"], bool):
        raise StyxValidationError(f'`no_set_vol_geom` has the wrong type: Received `{type(params.get("no_set_vol_geom", False))}` expected `bool`')
    if params.get("threads", None) is not None:
        if not isinstance(params["threads"], (float, int)):
            raise StyxValidationError(f'`threads` has the wrong type: Received `{type(params.get("threads", None))}` expected `float | None`')


def surfreg_cargs(
    params: SurfregParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("surfreg")
    cargs.extend([
        "--s",
        params.get("subject", None)
    ])
    cargs.extend([
        "--t",
        params.get("target", None)
    ])
    if params.get("cross_hemi", False):
        cargs.append("--xhemi")
    if params.get("reg_lh", False):
        cargs.append("--lh")
    if params.get("reg_rh", False):
        cargs.append("--rh")
    if params.get("reg_both", False):
        cargs.append("--lhrh")
    if params.get("no_annot", False):
        cargs.append("--no-annot")
    if params.get("annot", None) is not None:
        cargs.extend([
            "--annot",
            params.get("annot", None)
        ])
    if params.get("aparc", False):
        cargs.append("--aparc")
    if params.get("noneg", False):
        cargs.append("--noneg")
    if params.get("init_reg", None) is not None:
        cargs.extend([
            "--init-reg",
            params.get("init_reg", None)
        ])
    if params.get("lta", None) is not None:
        cargs.extend([
            "--lta",
            params.get("lta", None)
        ])
    if params.get("init_from_tal", False):
        cargs.append("--init-from-tal")
    if params.get("outsurf", None) is not None:
        cargs.extend([
            "--o",
            params.get("outsurf", None)
        ])
    if params.get("no_set_vol_geom", False):
        cargs.append("--no-set-vol-geom")
    if params.get("threads", None) is not None:
        cargs.extend([
            "--threads",
            str(params.get("threads", None))
        ])
    return cargs


def surfreg_outputs(
    params: SurfregParamsDict,
    execution: Execution,
) -> SurfregOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = SurfregOutputs(
        root=execution.output_file("."),
        output_surface=execution.output_file("subject/surf/hemi.target.sphere.reg"),
    )
    return ret


def surfreg_execute(
    params: SurfregParamsDict,
    runner: Runner | None = None,
) -> SurfregOutputs:
    """
    surfreg
    
    Performs surface registration (mris_register) between a subject and a target
    average subject based on the hemi.reg.template.tif atlas in the average
    subject.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SurfregOutputs`).
    """
    surfreg_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(SURFREG_METADATA)
    params = execution.params(params)
    cargs = surfreg_cargs(params, execution)
    ret = surfreg_outputs(params, execution)
    execution.run(cargs)
    return ret


def surfreg(
    subject: str,
    target: str,
    cross_hemi: bool = False,
    reg_lh: bool = False,
    reg_rh: bool = False,
    reg_both: bool = False,
    no_annot: bool = False,
    annot: str | None = None,
    aparc: bool = False,
    noneg: bool = False,
    init_reg: str | None = None,
    lta: str | None = None,
    init_from_tal: bool = False,
    outsurf: str | None = None,
    no_set_vol_geom: bool = False,
    threads: float | None = None,
    runner: Runner | None = None,
) -> SurfregOutputs:
    """
    surfreg
    
    Performs surface registration (mris_register) between a subject and a target
    average subject based on the hemi.reg.template.tif atlas in the average
    subject.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        subject: Subject to register.
        target: Target average subject to use as a registration target.
        cross_hemi: Perform cross-hemi registration.
        reg_lh: Register left hemisphere only.
        reg_rh: Register right hemisphere only.
        reg_both: Register both left and right hemispheres.
        no_annot: Do not use annot to rip.
        annot: Use specified annotation name.
        aparc: Set annotation name to aparc.annot.
        noneg: Option flag with unspecified behavior in the provided help text.
        init_reg: Initial registration name, default is sphere.
        lta: Apply rotational components of affine registration.
        init_from_tal: Use talaiach.xfm.lta for initial spherical registration.
        outsurf: Output surface name, default depends on the target.
        no_set_vol_geom: Do not set volume geometry and center the sphere.
        threads: Number of threads to run in parallel.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SurfregOutputs`).
    """
    params = surfreg_params(
        subject=subject,
        target=target,
        cross_hemi=cross_hemi,
        reg_lh=reg_lh,
        reg_rh=reg_rh,
        reg_both=reg_both,
        no_annot=no_annot,
        annot=annot,
        aparc=aparc,
        noneg=noneg,
        init_reg=init_reg,
        lta=lta,
        init_from_tal=init_from_tal,
        outsurf=outsurf,
        no_set_vol_geom=no_set_vol_geom,
        threads=threads,
    )
    return surfreg_execute(params, runner)


__all__ = [
    "SURFREG_METADATA",
    "SurfregOutputs",
    "SurfregParamsDict",
    "SurfregParamsDictTagged",
    "surfreg",
    "surfreg_execute",
    "surfreg_params",
]
