# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_CONCATENATE_GCAM_METADATA = Metadata(
    id="4d270f68fa44e05655a7fabaf0aa72b3dba99bba.boutiques",
    name="mri_concatenate_gcam",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriConcatenateGcamParamsDictNoTag = typing.TypedDict('_MriConcatenateGcamParamsDictNoTag', {
    "inputs": list[InputPathType],
    "output": str,
    "source_image": typing.NotRequired[InputPathType | None],
    "target_image": typing.NotRequired[InputPathType | None],
    "reduce": bool,
    "invert": bool,
    "downsample": bool,
})
MriConcatenateGcamParamsDictTagged = typing.TypedDict('MriConcatenateGcamParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_concatenate_gcam"],
    "inputs": list[InputPathType],
    "output": str,
    "source_image": typing.NotRequired[InputPathType | None],
    "target_image": typing.NotRequired[InputPathType | None],
    "reduce": bool,
    "invert": bool,
    "downsample": bool,
})
MriConcatenateGcamParamsDict = _MriConcatenateGcamParamsDictNoTag | MriConcatenateGcamParamsDictTagged


class MriConcatenateGcamOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriConcatenateGcamParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType
    """Composite LTA or M3Z transform, depending on input."""


def mri_concatenate_gcam_params(
    inputs: list[InputPathType],
    output: str,
    source_image: InputPathType | None = None,
    target_image: InputPathType | None = None,
    reduce: bool = False,
    invert: bool = False,
    downsample: bool = False,
) -> MriConcatenateGcamParamsDictTagged:
    """
    Build parameters.
    
    Args:
        inputs: Combination of input LTAs and M3Zs.
        output: Concatenated output transform, saved as an LTA or M3Z depending\
            on the input transforms.
        source_image: Change source image geometry of output M3Z, useful for\
            GCAM inversion if the path of the original source volume changed.
        target_image: Change destination image geometry of output M3Z.
        reduce: Reduce output LTA to single LT.
        invert: Invert the output transform.
        downsample: Downsample output M3Z to spacing of 2; by default, the\
            output spacing is that of the rightmost input M3Z.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_concatenate_gcam",
        "inputs": inputs,
        "output": output,
        "reduce": reduce,
        "invert": invert,
        "downsample": downsample,
    }
    if source_image is not None:
        params["source_image"] = source_image
    if target_image is not None:
        params["target_image"] = target_image
    return params


def mri_concatenate_gcam_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriConcatenateGcamParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("inputs", None) is None:
        raise StyxValidationError("`inputs` must not be None")
    if not isinstance(params["inputs"], list):
        raise StyxValidationError(f'`inputs` has the wrong type: Received `{type(params.get("inputs", None))}` expected `list[InputPathType]`')
    for e in params["inputs"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`inputs` has the wrong type: Received `{type(params.get("inputs", None))}` expected `list[InputPathType]`')
    if params.get("output", None) is None:
        raise StyxValidationError("`output` must not be None")
    if not isinstance(params["output"], str):
        raise StyxValidationError(f'`output` has the wrong type: Received `{type(params.get("output", None))}` expected `str`')
    if params.get("source_image", None) is not None:
        if not isinstance(params["source_image"], (pathlib.Path, str)):
            raise StyxValidationError(f'`source_image` has the wrong type: Received `{type(params.get("source_image", None))}` expected `InputPathType | None`')
    if params.get("target_image", None) is not None:
        if not isinstance(params["target_image"], (pathlib.Path, str)):
            raise StyxValidationError(f'`target_image` has the wrong type: Received `{type(params.get("target_image", None))}` expected `InputPathType | None`')
    if params.get("reduce", False) is None:
        raise StyxValidationError("`reduce` must not be None")
    if not isinstance(params["reduce"], bool):
        raise StyxValidationError(f'`reduce` has the wrong type: Received `{type(params.get("reduce", False))}` expected `bool`')
    if params.get("invert", False) is None:
        raise StyxValidationError("`invert` must not be None")
    if not isinstance(params["invert"], bool):
        raise StyxValidationError(f'`invert` has the wrong type: Received `{type(params.get("invert", False))}` expected `bool`')
    if params.get("downsample", False) is None:
        raise StyxValidationError("`downsample` must not be None")
    if not isinstance(params["downsample"], bool):
        raise StyxValidationError(f'`downsample` has the wrong type: Received `{type(params.get("downsample", False))}` expected `bool`')


def mri_concatenate_gcam_cargs(
    params: MriConcatenateGcamParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_concatenate_gcam")
    cargs.extend([execution.input_file(f) for f in params.get("inputs", None)])
    cargs.append(params.get("output", None))
    if params.get("source_image", None) is not None:
        cargs.extend([
            "-s",
            execution.input_file(params.get("source_image", None))
        ])
    if params.get("target_image", None) is not None:
        cargs.extend([
            "-t",
            execution.input_file(params.get("target_image", None))
        ])
    if params.get("reduce", False):
        cargs.append("-r")
    if params.get("invert", False):
        cargs.append("-i")
    if params.get("downsample", False):
        cargs.append("-d")
    return cargs


def mri_concatenate_gcam_outputs(
    params: MriConcatenateGcamParamsDict,
    execution: Execution,
) -> MriConcatenateGcamOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriConcatenateGcamOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(params.get("output", None)),
    )
    return ret


def mri_concatenate_gcam_execute(
    params: MriConcatenateGcamParamsDict,
    runner: Runner | None = None,
) -> MriConcatenateGcamOutputs:
    """
    mri_concatenate_gcam
    
    Concatenate a combination of input LTAs (linear transform array) and GCAMs
    (Gaussian classifier atlas, M3Z).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriConcatenateGcamOutputs`).
    """
    mri_concatenate_gcam_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_CONCATENATE_GCAM_METADATA)
    params = execution.params(params)
    cargs = mri_concatenate_gcam_cargs(params, execution)
    ret = mri_concatenate_gcam_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_concatenate_gcam(
    inputs: list[InputPathType],
    output: str,
    source_image: InputPathType | None = None,
    target_image: InputPathType | None = None,
    reduce: bool = False,
    invert: bool = False,
    downsample: bool = False,
    runner: Runner | None = None,
) -> MriConcatenateGcamOutputs:
    """
    mri_concatenate_gcam
    
    Concatenate a combination of input LTAs (linear transform array) and GCAMs
    (Gaussian classifier atlas, M3Z).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        inputs: Combination of input LTAs and M3Zs.
        output: Concatenated output transform, saved as an LTA or M3Z depending\
            on the input transforms.
        source_image: Change source image geometry of output M3Z, useful for\
            GCAM inversion if the path of the original source volume changed.
        target_image: Change destination image geometry of output M3Z.
        reduce: Reduce output LTA to single LT.
        invert: Invert the output transform.
        downsample: Downsample output M3Z to spacing of 2; by default, the\
            output spacing is that of the rightmost input M3Z.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriConcatenateGcamOutputs`).
    """
    params = mri_concatenate_gcam_params(
        inputs=inputs,
        output=output,
        source_image=source_image,
        target_image=target_image,
        reduce=reduce,
        invert=invert,
        downsample=downsample,
    )
    return mri_concatenate_gcam_execute(params, runner)


__all__ = [
    "MRI_CONCATENATE_GCAM_METADATA",
    "MriConcatenateGcamOutputs",
    "MriConcatenateGcamParamsDict",
    "MriConcatenateGcamParamsDictTagged",
    "mri_concatenate_gcam",
    "mri_concatenate_gcam_execute",
    "mri_concatenate_gcam_params",
]
