# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

FSL_RIGID_REGISTER_METADATA = Metadata(
    id="abd62e6795a7fb22e18676b3f84f7431ec93f8c9.boutiques",
    name="fsl_rigid_register",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_FslRigidRegisterParamsDictNoTag = typing.TypedDict('_FslRigidRegisterParamsDictNoTag', {
    "refvol": InputPathType,
    "inputvol": InputPathType,
    "outputvol": str,
    "fslmat": typing.NotRequired[str | None],
    "regmat": typing.NotRequired[str | None],
    "xfmmat": typing.NotRequired[str | None],
    "ltamat": typing.NotRequired[str | None],
    "noinitgeom": bool,
    "applyxfm": typing.NotRequired[InputPathType | None],
    "applyinitxfm": bool,
    "initxfm": typing.NotRequired[InputPathType | None],
    "maxangle": typing.NotRequired[float | None],
    "interp": typing.NotRequired[str | None],
    "dof": typing.NotRequired[float | None],
    "bins": typing.NotRequired[float | None],
    "cost": typing.NotRequired[str | None],
    "tmpdir": typing.NotRequired[str | None],
    "nocleanup": bool,
    "cleanup": bool,
    "subject": typing.NotRequired[str | None],
    "version": bool,
    "help": bool,
})
FslRigidRegisterParamsDictTagged = typing.TypedDict('FslRigidRegisterParamsDictTagged', {
    "@type": typing.Literal["freesurfer/fsl_rigid_register"],
    "refvol": InputPathType,
    "inputvol": InputPathType,
    "outputvol": str,
    "fslmat": typing.NotRequired[str | None],
    "regmat": typing.NotRequired[str | None],
    "xfmmat": typing.NotRequired[str | None],
    "ltamat": typing.NotRequired[str | None],
    "noinitgeom": bool,
    "applyxfm": typing.NotRequired[InputPathType | None],
    "applyinitxfm": bool,
    "initxfm": typing.NotRequired[InputPathType | None],
    "maxangle": typing.NotRequired[float | None],
    "interp": typing.NotRequired[str | None],
    "dof": typing.NotRequired[float | None],
    "bins": typing.NotRequired[float | None],
    "cost": typing.NotRequired[str | None],
    "tmpdir": typing.NotRequired[str | None],
    "nocleanup": bool,
    "cleanup": bool,
    "subject": typing.NotRequired[str | None],
    "version": bool,
    "help": bool,
})
FslRigidRegisterParamsDict = _FslRigidRegisterParamsDictNoTag | FslRigidRegisterParamsDictTagged


class FslRigidRegisterOutputs(typing.NamedTuple):
    """
    Output object returned when calling `FslRigidRegisterParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    fslmat_output: OutputPathType
    """The registration matrix in FSL format."""


def fsl_rigid_register_params(
    refvol: InputPathType,
    inputvol: InputPathType,
    outputvol: str,
    fslmat: str | None = None,
    regmat: str | None = None,
    xfmmat: str | None = None,
    ltamat: str | None = None,
    noinitgeom: bool = False,
    applyxfm: InputPathType | None = None,
    applyinitxfm: bool = False,
    initxfm: InputPathType | None = None,
    maxangle: float | None = None,
    interp: str | None = None,
    dof: float | None = None,
    bins: float | None = None,
    cost: str | None = None,
    tmpdir: str | None = None,
    nocleanup: bool = False,
    cleanup: bool = False,
    subject: str | None = None,
    version: bool = False,
    help_: bool = False,
) -> FslRigidRegisterParamsDictTagged:
    """
    Build parameters.
    
    Args:
        refvol: Reference/Target volume.
        inputvol: Input/Moveable volume.
        outputvol: Input resampled to reference.
        fslmat: Specifies explicitly where to store the FSL registration\
            matrix.
        regmat: Get registration matrix in register.dat file format.
        xfmmat: Get registration matrix as MNI xfm file.
        ltamat: Get registration matrix as MGH lta file.
        noinitgeom: Do not initialize matrix based on geometry.
        applyxfm: Apply a transformation file to the input without\
            registration.
        applyinitxfm: Apply initial transformation to the input without\
            registration.
        initxfm: Use this as an initial matrix for registration.
        maxangle: Only search over +/- max angle degrees.
        interp: Interpolation method: trilinear, nearestneighbour, sinc.
        dof: Use degrees of freedom instead of 6.
        bins: Number of bins to use (default 256).
        cost: Objective function: mutualinfo, corratio (default), normcorr,\
            normmi, leastsq.
        tmpdir: Specify temporary directory.
        nocleanup: Do not delete temporary files.
        cleanup: Delete temporary files (default).
        subject: Only puts it in the register.dat file.
        version: Print version and exit.
        help_: Print help and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/fsl_rigid_register",
        "refvol": refvol,
        "inputvol": inputvol,
        "outputvol": outputvol,
        "noinitgeom": noinitgeom,
        "applyinitxfm": applyinitxfm,
        "nocleanup": nocleanup,
        "cleanup": cleanup,
        "version": version,
        "help": help_,
    }
    if fslmat is not None:
        params["fslmat"] = fslmat
    if regmat is not None:
        params["regmat"] = regmat
    if xfmmat is not None:
        params["xfmmat"] = xfmmat
    if ltamat is not None:
        params["ltamat"] = ltamat
    if applyxfm is not None:
        params["applyxfm"] = applyxfm
    if initxfm is not None:
        params["initxfm"] = initxfm
    if maxangle is not None:
        params["maxangle"] = maxangle
    if interp is not None:
        params["interp"] = interp
    if dof is not None:
        params["dof"] = dof
    if bins is not None:
        params["bins"] = bins
    if cost is not None:
        params["cost"] = cost
    if tmpdir is not None:
        params["tmpdir"] = tmpdir
    if subject is not None:
        params["subject"] = subject
    return params


def fsl_rigid_register_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `FslRigidRegisterParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("refvol", None) is None:
        raise StyxValidationError("`refvol` must not be None")
    if not isinstance(params["refvol"], (pathlib.Path, str)):
        raise StyxValidationError(f'`refvol` has the wrong type: Received `{type(params.get("refvol", None))}` expected `InputPathType`')
    if params.get("inputvol", None) is None:
        raise StyxValidationError("`inputvol` must not be None")
    if not isinstance(params["inputvol"], (pathlib.Path, str)):
        raise StyxValidationError(f'`inputvol` has the wrong type: Received `{type(params.get("inputvol", None))}` expected `InputPathType`')
    if params.get("outputvol", None) is None:
        raise StyxValidationError("`outputvol` must not be None")
    if not isinstance(params["outputvol"], str):
        raise StyxValidationError(f'`outputvol` has the wrong type: Received `{type(params.get("outputvol", None))}` expected `str`')
    if params.get("fslmat", None) is not None:
        if not isinstance(params["fslmat"], str):
            raise StyxValidationError(f'`fslmat` has the wrong type: Received `{type(params.get("fslmat", None))}` expected `str | None`')
    if params.get("regmat", None) is not None:
        if not isinstance(params["regmat"], str):
            raise StyxValidationError(f'`regmat` has the wrong type: Received `{type(params.get("regmat", None))}` expected `str | None`')
    if params.get("xfmmat", None) is not None:
        if not isinstance(params["xfmmat"], str):
            raise StyxValidationError(f'`xfmmat` has the wrong type: Received `{type(params.get("xfmmat", None))}` expected `str | None`')
    if params.get("ltamat", None) is not None:
        if not isinstance(params["ltamat"], str):
            raise StyxValidationError(f'`ltamat` has the wrong type: Received `{type(params.get("ltamat", None))}` expected `str | None`')
    if params.get("noinitgeom", False) is None:
        raise StyxValidationError("`noinitgeom` must not be None")
    if not isinstance(params["noinitgeom"], bool):
        raise StyxValidationError(f'`noinitgeom` has the wrong type: Received `{type(params.get("noinitgeom", False))}` expected `bool`')
    if params.get("applyxfm", None) is not None:
        if not isinstance(params["applyxfm"], (pathlib.Path, str)):
            raise StyxValidationError(f'`applyxfm` has the wrong type: Received `{type(params.get("applyxfm", None))}` expected `InputPathType | None`')
    if params.get("applyinitxfm", False) is None:
        raise StyxValidationError("`applyinitxfm` must not be None")
    if not isinstance(params["applyinitxfm"], bool):
        raise StyxValidationError(f'`applyinitxfm` has the wrong type: Received `{type(params.get("applyinitxfm", False))}` expected `bool`')
    if params.get("initxfm", None) is not None:
        if not isinstance(params["initxfm"], (pathlib.Path, str)):
            raise StyxValidationError(f'`initxfm` has the wrong type: Received `{type(params.get("initxfm", None))}` expected `InputPathType | None`')
    if params.get("maxangle", None) is not None:
        if not isinstance(params["maxangle"], (float, int)):
            raise StyxValidationError(f'`maxangle` has the wrong type: Received `{type(params.get("maxangle", None))}` expected `float | None`')
    if params.get("interp", None) is not None:
        if not isinstance(params["interp"], str):
            raise StyxValidationError(f'`interp` has the wrong type: Received `{type(params.get("interp", None))}` expected `str | None`')
    if params.get("dof", None) is not None:
        if not isinstance(params["dof"], (float, int)):
            raise StyxValidationError(f'`dof` has the wrong type: Received `{type(params.get("dof", None))}` expected `float | None`')
    if params.get("bins", None) is not None:
        if not isinstance(params["bins"], (float, int)):
            raise StyxValidationError(f'`bins` has the wrong type: Received `{type(params.get("bins", None))}` expected `float | None`')
    if params.get("cost", None) is not None:
        if not isinstance(params["cost"], str):
            raise StyxValidationError(f'`cost` has the wrong type: Received `{type(params.get("cost", None))}` expected `str | None`')
    if params.get("tmpdir", None) is not None:
        if not isinstance(params["tmpdir"], str):
            raise StyxValidationError(f'`tmpdir` has the wrong type: Received `{type(params.get("tmpdir", None))}` expected `str | None`')
    if params.get("nocleanup", False) is None:
        raise StyxValidationError("`nocleanup` must not be None")
    if not isinstance(params["nocleanup"], bool):
        raise StyxValidationError(f'`nocleanup` has the wrong type: Received `{type(params.get("nocleanup", False))}` expected `bool`')
    if params.get("cleanup", False) is None:
        raise StyxValidationError("`cleanup` must not be None")
    if not isinstance(params["cleanup"], bool):
        raise StyxValidationError(f'`cleanup` has the wrong type: Received `{type(params.get("cleanup", False))}` expected `bool`')
    if params.get("subject", None) is not None:
        if not isinstance(params["subject"], str):
            raise StyxValidationError(f'`subject` has the wrong type: Received `{type(params.get("subject", None))}` expected `str | None`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')


def fsl_rigid_register_cargs(
    params: FslRigidRegisterParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("fsl_rigid_register")
    cargs.extend([
        "-r",
        execution.input_file(params.get("refvol", None))
    ])
    cargs.extend([
        "-i",
        execution.input_file(params.get("inputvol", None))
    ])
    cargs.extend([
        "-o",
        params.get("outputvol", None)
    ])
    if params.get("fslmat", None) is not None:
        cargs.extend([
            "-fslmat",
            params.get("fslmat", None)
        ])
    if params.get("regmat", None) is not None:
        cargs.extend([
            "-regmat",
            params.get("regmat", None)
        ])
    if params.get("xfmmat", None) is not None:
        cargs.extend([
            "-xfmmat",
            params.get("xfmmat", None)
        ])
    if params.get("ltamat", None) is not None:
        cargs.extend([
            "-ltamat",
            params.get("ltamat", None)
        ])
    if params.get("noinitgeom", False):
        cargs.append("-noinitgeom")
    if params.get("applyxfm", None) is not None:
        cargs.extend([
            "-applyxfm",
            execution.input_file(params.get("applyxfm", None))
        ])
    if params.get("applyinitxfm", False):
        cargs.append("-applyinitxfm")
    if params.get("initxfm", None) is not None:
        cargs.extend([
            "-initxfm",
            execution.input_file(params.get("initxfm", None))
        ])
    if params.get("maxangle", None) is not None:
        cargs.extend([
            "-maxangle",
            str(params.get("maxangle", None))
        ])
    if params.get("interp", None) is not None:
        cargs.extend([
            "-interp",
            params.get("interp", None)
        ])
    if params.get("dof", None) is not None:
        cargs.extend([
            "-dof",
            str(params.get("dof", None))
        ])
    if params.get("bins", None) is not None:
        cargs.extend([
            "-bins",
            str(params.get("bins", None))
        ])
    if params.get("cost", None) is not None:
        cargs.extend([
            "-cost",
            params.get("cost", None)
        ])
    if params.get("tmpdir", None) is not None:
        cargs.extend([
            "-tmpdir",
            params.get("tmpdir", None)
        ])
    if params.get("nocleanup", False):
        cargs.append("-nocleanup")
    if params.get("cleanup", False):
        cargs.append("-cleanup")
    if params.get("subject", None) is not None:
        cargs.extend([
            "-subject",
            params.get("subject", None)
        ])
    if params.get("version", False):
        cargs.append("-version")
    if params.get("help", False):
        cargs.append("-help")
    return cargs


def fsl_rigid_register_outputs(
    params: FslRigidRegisterParamsDict,
    execution: Execution,
) -> FslRigidRegisterOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = FslRigidRegisterOutputs(
        root=execution.output_file("."),
        fslmat_output=execution.output_file(params.get("outputvol", None) + ".fslmat"),
    )
    return ret


def fsl_rigid_register_execute(
    params: FslRigidRegisterParamsDict,
    runner: Runner | None = None,
) -> FslRigidRegisterOutputs:
    """
    fsl_rigid_register
    
    A front-end tool for FSL's FLIRT that computes a rigid registration matrix
    and resamples the input volume to the reference volume.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FslRigidRegisterOutputs`).
    """
    fsl_rigid_register_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(FSL_RIGID_REGISTER_METADATA)
    params = execution.params(params)
    cargs = fsl_rigid_register_cargs(params, execution)
    ret = fsl_rigid_register_outputs(params, execution)
    execution.run(cargs)
    return ret


def fsl_rigid_register(
    refvol: InputPathType,
    inputvol: InputPathType,
    outputvol: str,
    fslmat: str | None = None,
    regmat: str | None = None,
    xfmmat: str | None = None,
    ltamat: str | None = None,
    noinitgeom: bool = False,
    applyxfm: InputPathType | None = None,
    applyinitxfm: bool = False,
    initxfm: InputPathType | None = None,
    maxangle: float | None = None,
    interp: str | None = None,
    dof: float | None = None,
    bins: float | None = None,
    cost: str | None = None,
    tmpdir: str | None = None,
    nocleanup: bool = False,
    cleanup: bool = False,
    subject: str | None = None,
    version: bool = False,
    help_: bool = False,
    runner: Runner | None = None,
) -> FslRigidRegisterOutputs:
    """
    fsl_rigid_register
    
    A front-end tool for FSL's FLIRT that computes a rigid registration matrix
    and resamples the input volume to the reference volume.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        refvol: Reference/Target volume.
        inputvol: Input/Moveable volume.
        outputvol: Input resampled to reference.
        fslmat: Specifies explicitly where to store the FSL registration\
            matrix.
        regmat: Get registration matrix in register.dat file format.
        xfmmat: Get registration matrix as MNI xfm file.
        ltamat: Get registration matrix as MGH lta file.
        noinitgeom: Do not initialize matrix based on geometry.
        applyxfm: Apply a transformation file to the input without\
            registration.
        applyinitxfm: Apply initial transformation to the input without\
            registration.
        initxfm: Use this as an initial matrix for registration.
        maxangle: Only search over +/- max angle degrees.
        interp: Interpolation method: trilinear, nearestneighbour, sinc.
        dof: Use degrees of freedom instead of 6.
        bins: Number of bins to use (default 256).
        cost: Objective function: mutualinfo, corratio (default), normcorr,\
            normmi, leastsq.
        tmpdir: Specify temporary directory.
        nocleanup: Do not delete temporary files.
        cleanup: Delete temporary files (default).
        subject: Only puts it in the register.dat file.
        version: Print version and exit.
        help_: Print help and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FslRigidRegisterOutputs`).
    """
    params = fsl_rigid_register_params(
        refvol=refvol,
        inputvol=inputvol,
        outputvol=outputvol,
        fslmat=fslmat,
        regmat=regmat,
        xfmmat=xfmmat,
        ltamat=ltamat,
        noinitgeom=noinitgeom,
        applyxfm=applyxfm,
        applyinitxfm=applyinitxfm,
        initxfm=initxfm,
        maxangle=maxangle,
        interp=interp,
        dof=dof,
        bins=bins,
        cost=cost,
        tmpdir=tmpdir,
        nocleanup=nocleanup,
        cleanup=cleanup,
        subject=subject,
        version=version,
        help_=help_,
    )
    return fsl_rigid_register_execute(params, runner)


__all__ = [
    "FSL_RIGID_REGISTER_METADATA",
    "FslRigidRegisterOutputs",
    "FslRigidRegisterParamsDict",
    "FslRigidRegisterParamsDictTagged",
    "fsl_rigid_register",
    "fsl_rigid_register_execute",
    "fsl_rigid_register_params",
]
