# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRIS_PLACE_SURFACE_METADATA = Metadata(
    id="3f7d8d94531fd53404a21d725a43fbeb40114765.boutiques",
    name="mris_place_surface",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MrisPlaceSurfaceParamsDictNoTag = typing.TypedDict('_MrisPlaceSurfaceParamsDictNoTag', {
    "output_surface": str,
    "input_surface": str,
    "autodetect_gray_white_stats": str,
    "input_volume": str,
    "surface_type_group": typing.Literal["--white", "--pial"],
    "hemi_group": typing.Literal["--lh", "--rh"],
    "wm_segment": typing.NotRequired[str | None],
    "out_volume": typing.NotRequired[str | None],
    "out_volume_only": typing.NotRequired[str | None],
    "restore_255": bool,
    "segmentation": typing.NotRequired[str | None],
    "cortical_parcellation": typing.NotRequired[str | None],
    "nsmooth": typing.NotRequired[float | None],
    "smooth_after_rip": bool,
    "max_cbv_dist": typing.NotRequired[float | None],
    "rip_label": typing.NotRequired[str | None],
    "rip_midline": bool,
    "rip_bg": bool,
    "rip_bg_no_annot": bool,
    "no_rip_freeze": bool,
    "rip_wmsa": bool,
    "rip_lesion": bool,
    "no_rip": bool,
    "rip_overlay": typing.NotRequired[str | None],
    "rip_surface": typing.NotRequired[str | None],
    "rip_projection": typing.NotRequired[list[float] | None],
    "repulse_surface": typing.NotRequired[str | None],
    "white_surface": typing.NotRequired[str | None],
    "blend_surface": typing.NotRequired[str | None],
    "multimodal_input": typing.NotRequired[str | None],
    "mm_refine": bool,
    "pin_medial_wall": typing.NotRequired[str | None],
    "no_intensity_proc": bool,
    "debug_vertex": typing.NotRequired[float | None],
    "ripflag_out": typing.NotRequired[str | None],
    "local_max": typing.NotRequired[str | None],
    "target_surf": typing.NotRequired[str | None],
    "stop_mask": bool,
    "mm_intensity_limits": typing.NotRequired[str | None],
    "cover_seg": typing.NotRequired[str | None],
    "first_peak_d1": bool,
    "first_peak_d2": bool,
    "white_border_low_factor": typing.NotRequired[float | None],
    "fill_lateral_ventricles": typing.NotRequired[list[float] | None],
})
MrisPlaceSurfaceParamsDictTagged = typing.TypedDict('MrisPlaceSurfaceParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mris_place_surface"],
    "output_surface": str,
    "input_surface": str,
    "autodetect_gray_white_stats": str,
    "input_volume": str,
    "surface_type_group": typing.Literal["--white", "--pial"],
    "hemi_group": typing.Literal["--lh", "--rh"],
    "wm_segment": typing.NotRequired[str | None],
    "out_volume": typing.NotRequired[str | None],
    "out_volume_only": typing.NotRequired[str | None],
    "restore_255": bool,
    "segmentation": typing.NotRequired[str | None],
    "cortical_parcellation": typing.NotRequired[str | None],
    "nsmooth": typing.NotRequired[float | None],
    "smooth_after_rip": bool,
    "max_cbv_dist": typing.NotRequired[float | None],
    "rip_label": typing.NotRequired[str | None],
    "rip_midline": bool,
    "rip_bg": bool,
    "rip_bg_no_annot": bool,
    "no_rip_freeze": bool,
    "rip_wmsa": bool,
    "rip_lesion": bool,
    "no_rip": bool,
    "rip_overlay": typing.NotRequired[str | None],
    "rip_surface": typing.NotRequired[str | None],
    "rip_projection": typing.NotRequired[list[float] | None],
    "repulse_surface": typing.NotRequired[str | None],
    "white_surface": typing.NotRequired[str | None],
    "blend_surface": typing.NotRequired[str | None],
    "multimodal_input": typing.NotRequired[str | None],
    "mm_refine": bool,
    "pin_medial_wall": typing.NotRequired[str | None],
    "no_intensity_proc": bool,
    "debug_vertex": typing.NotRequired[float | None],
    "ripflag_out": typing.NotRequired[str | None],
    "local_max": typing.NotRequired[str | None],
    "target_surf": typing.NotRequired[str | None],
    "stop_mask": bool,
    "mm_intensity_limits": typing.NotRequired[str | None],
    "cover_seg": typing.NotRequired[str | None],
    "first_peak_d1": bool,
    "first_peak_d2": bool,
    "white_border_low_factor": typing.NotRequired[float | None],
    "fill_lateral_ventricles": typing.NotRequired[list[float] | None],
})
MrisPlaceSurfaceParamsDict = _MrisPlaceSurfaceParamsDictNoTag | MrisPlaceSurfaceParamsDictTagged


class MrisPlaceSurfaceOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MrisPlaceSurfaceParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mris_place_surface_params(
    output_surface: str,
    input_surface: str,
    autodetect_gray_white_stats: str,
    input_volume: str,
    surface_type_group: typing.Literal["--white", "--pial"],
    hemi_group: typing.Literal["--lh", "--rh"],
    wm_segment: str | None = None,
    out_volume: str | None = None,
    out_volume_only: str | None = None,
    restore_255: bool = False,
    segmentation: str | None = None,
    cortical_parcellation: str | None = None,
    nsmooth: float | None = None,
    smooth_after_rip: bool = False,
    max_cbv_dist: float | None = None,
    rip_label: str | None = None,
    rip_midline: bool = False,
    rip_bg: bool = False,
    rip_bg_no_annot: bool = False,
    no_rip_freeze: bool = False,
    rip_wmsa: bool = False,
    rip_lesion: bool = False,
    no_rip: bool = False,
    rip_overlay: str | None = None,
    rip_surface: str | None = None,
    rip_projection: list[float] | None = None,
    repulse_surface: str | None = None,
    white_surface: str | None = None,
    blend_surface: str | None = None,
    multimodal_input: str | None = None,
    mm_refine: bool = False,
    pin_medial_wall: str | None = None,
    no_intensity_proc: bool = False,
    debug_vertex: float | None = None,
    ripflag_out: str | None = None,
    local_max: str | None = None,
    target_surf: str | None = None,
    stop_mask: bool = False,
    mm_intensity_limits: str | None = None,
    cover_seg: str | None = None,
    first_peak_d1: bool = False,
    first_peak_d2: bool = False,
    white_border_low_factor: float | None = None,
    fill_lateral_ventricles: list[float] | None = None,
) -> MrisPlaceSurfaceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output_surface: Output surface.
        input_surface: Input surface.
        autodetect_gray_white_stats: Intensity stats created by\
            mris_autodet_gwstats.
        input_volume: T1-weighed intensity volume used to find white/gray/csf\
            gradients (usually brain.finalsurf.mgz).
        surface_type_group: Place the white surface or the pial surface. Must\
            choose one.
        hemi_group: Left or right hemisphere. Must choose one.
        wm_segment: White matter segmentation.
        out_volume: Save input volume after preprocessing.
        out_volume_only: Save input volume after preprocessing and then exit.
        restore_255: Set voxels in the input volume that start off as 255 to\
            110 (white surf only).
        segmentation: Whole-brain segmentation (usually aseg.presurf.mgz).
        cortical_parcellation: Set cortical parcellation used to rip vertices\
            (usually ?h.aparc.annot).
        nsmooth: Smooth input surface by number of iterations.
        smooth_after_rip: Smooth after ripping.
        max_cbv_dist: Limit distance MRIScomputeBorderValues() can search from\
            the input.
        rip_label: Do not move vertices that are NOT in the cortex label.
        rip_midline: Do not move vertices that are in the midline as indicated\
            by the seg.
        rip_bg: Do not move vertices near basal ganglia (as defined by seg).
        rip_bg_no_annot: Do not require surface have an annotation when ripping\
            BG.
        no_rip_freeze: Do NOT move vertices in/near freeze voxels (247 as\
            defined in seg).
        rip_wmsa: Do not move vertices in/near white-matter signal\
            abnormalities (77,78,79 as defined in seg).
        rip_lesion: Do not move vertices in/near lesions (25 and 57 as defined\
            in seg).
        no_rip: Turn off all ripping.
        rip_overlay: Rip vertices > 0.5 in the surface overlay file.
        rip_surface: Use this surface with ripping midline, BG, Freezes,\
            Lesions, and WMSA.
        rip_projection: Control projection depth along normal to ripsurface\
            when sampling seg.
        repulse_surface: Force input surface away from this surface (usually\
            the white surface when placing the pial).
        white_surface: Set the white{xyz} coordinates of the input surface\
            using this surface.
        blend_surface: Recompute the xyz coordinates of the input surface by\
            computing a weighted average with the blend surface.
        multimodal_input: Specify a T2 or FLAIR input volume used for placing\
            the pial surface. Must be in registration with the input volume.
        mm_refine: Use Siless' MultimodalRefinement. Sets tspring=nspring=0.3.
        pin_medial_wall: Set coordinates in vertices NOT in cortexlabel to be\
            that of the white{xyz} coordinates.
        no_intensity_proc: Do not process the input intensity volume (eg, to\
            remove parts of eye socket).
        debug_vertex: Debug vertex number.
        ripflag_out: Save ripflag as overlay.
        local_max: Save LocalMaxFoundFlag as overlay.
        target_surf: Save CBV target surface.
        stop_mask: Stop mask to stop search along normal for max gradient.
        mm_intensity_limits: Intensity limits for placing pial on multimodal\
            input.
        cover_seg: Force surface to cover the segmentation.
        first_peak_d1: Use find-first-peak option with 1st derivative in\
            ComputeBorderValues.
        first_peak_d2: Use find-first-peak option with 2nd derivative in\
            ComputeBorderValues.
        white_border_low_factor: white_border_low = f*adgws.gray_mean +\
            (1-f)*adgws.white_mean;.
        fill_lateral_ventricles: Fill lateral ventricles with 110.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mris_place_surface",
        "output_surface": output_surface,
        "input_surface": input_surface,
        "autodetect_gray_white_stats": autodetect_gray_white_stats,
        "input_volume": input_volume,
        "surface_type_group": surface_type_group,
        "hemi_group": hemi_group,
        "restore_255": restore_255,
        "smooth_after_rip": smooth_after_rip,
        "rip_midline": rip_midline,
        "rip_bg": rip_bg,
        "rip_bg_no_annot": rip_bg_no_annot,
        "no_rip_freeze": no_rip_freeze,
        "rip_wmsa": rip_wmsa,
        "rip_lesion": rip_lesion,
        "no_rip": no_rip,
        "mm_refine": mm_refine,
        "no_intensity_proc": no_intensity_proc,
        "stop_mask": stop_mask,
        "first_peak_d1": first_peak_d1,
        "first_peak_d2": first_peak_d2,
    }
    if wm_segment is not None:
        params["wm_segment"] = wm_segment
    if out_volume is not None:
        params["out_volume"] = out_volume
    if out_volume_only is not None:
        params["out_volume_only"] = out_volume_only
    if segmentation is not None:
        params["segmentation"] = segmentation
    if cortical_parcellation is not None:
        params["cortical_parcellation"] = cortical_parcellation
    if nsmooth is not None:
        params["nsmooth"] = nsmooth
    if max_cbv_dist is not None:
        params["max_cbv_dist"] = max_cbv_dist
    if rip_label is not None:
        params["rip_label"] = rip_label
    if rip_overlay is not None:
        params["rip_overlay"] = rip_overlay
    if rip_surface is not None:
        params["rip_surface"] = rip_surface
    if rip_projection is not None:
        params["rip_projection"] = rip_projection
    if repulse_surface is not None:
        params["repulse_surface"] = repulse_surface
    if white_surface is not None:
        params["white_surface"] = white_surface
    if blend_surface is not None:
        params["blend_surface"] = blend_surface
    if multimodal_input is not None:
        params["multimodal_input"] = multimodal_input
    if pin_medial_wall is not None:
        params["pin_medial_wall"] = pin_medial_wall
    if debug_vertex is not None:
        params["debug_vertex"] = debug_vertex
    if ripflag_out is not None:
        params["ripflag_out"] = ripflag_out
    if local_max is not None:
        params["local_max"] = local_max
    if target_surf is not None:
        params["target_surf"] = target_surf
    if mm_intensity_limits is not None:
        params["mm_intensity_limits"] = mm_intensity_limits
    if cover_seg is not None:
        params["cover_seg"] = cover_seg
    if white_border_low_factor is not None:
        params["white_border_low_factor"] = white_border_low_factor
    if fill_lateral_ventricles is not None:
        params["fill_lateral_ventricles"] = fill_lateral_ventricles
    return params


def mris_place_surface_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MrisPlaceSurfaceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output_surface", None) is None:
        raise StyxValidationError("`output_surface` must not be None")
    if not isinstance(params["output_surface"], str):
        raise StyxValidationError(f'`output_surface` has the wrong type: Received `{type(params.get("output_surface", None))}` expected `str`')
    if params.get("input_surface", None) is None:
        raise StyxValidationError("`input_surface` must not be None")
    if not isinstance(params["input_surface"], str):
        raise StyxValidationError(f'`input_surface` has the wrong type: Received `{type(params.get("input_surface", None))}` expected `str`')
    if params.get("autodetect_gray_white_stats", None) is None:
        raise StyxValidationError("`autodetect_gray_white_stats` must not be None")
    if not isinstance(params["autodetect_gray_white_stats"], str):
        raise StyxValidationError(f'`autodetect_gray_white_stats` has the wrong type: Received `{type(params.get("autodetect_gray_white_stats", None))}` expected `str`')
    if params.get("input_volume", None) is None:
        raise StyxValidationError("`input_volume` must not be None")
    if not isinstance(params["input_volume"], str):
        raise StyxValidationError(f'`input_volume` has the wrong type: Received `{type(params.get("input_volume", None))}` expected `str`')
    if params.get("surface_type_group", None) is None:
        raise StyxValidationError("`surface_type_group` must not be None")
    if not isinstance(params["surface_type_group"], str):
        raise StyxValidationError(f'`surface_type_group` has the wrong type: Received `{type(params.get("surface_type_group", None))}` expected `typing.Literal["--white", "--pial"]`')
    if params["surface_type_group"] not in ["--white", "--pial"]:
        raise StyxValidationError("Parameter `surface_type_group` must be one of [\"--white\", \"--pial\"]")
    if params.get("hemi_group", None) is None:
        raise StyxValidationError("`hemi_group` must not be None")
    if not isinstance(params["hemi_group"], str):
        raise StyxValidationError(f'`hemi_group` has the wrong type: Received `{type(params.get("hemi_group", None))}` expected `typing.Literal["--lh", "--rh"]`')
    if params["hemi_group"] not in ["--lh", "--rh"]:
        raise StyxValidationError("Parameter `hemi_group` must be one of [\"--lh\", \"--rh\"]")
    if params.get("wm_segment", None) is not None:
        if not isinstance(params["wm_segment"], str):
            raise StyxValidationError(f'`wm_segment` has the wrong type: Received `{type(params.get("wm_segment", None))}` expected `str | None`')
    if params.get("out_volume", None) is not None:
        if not isinstance(params["out_volume"], str):
            raise StyxValidationError(f'`out_volume` has the wrong type: Received `{type(params.get("out_volume", None))}` expected `str | None`')
    if params.get("out_volume_only", None) is not None:
        if not isinstance(params["out_volume_only"], str):
            raise StyxValidationError(f'`out_volume_only` has the wrong type: Received `{type(params.get("out_volume_only", None))}` expected `str | None`')
    if params.get("restore_255", False) is None:
        raise StyxValidationError("`restore_255` must not be None")
    if not isinstance(params["restore_255"], bool):
        raise StyxValidationError(f'`restore_255` has the wrong type: Received `{type(params.get("restore_255", False))}` expected `bool`')
    if params.get("segmentation", None) is not None:
        if not isinstance(params["segmentation"], str):
            raise StyxValidationError(f'`segmentation` has the wrong type: Received `{type(params.get("segmentation", None))}` expected `str | None`')
    if params.get("cortical_parcellation", None) is not None:
        if not isinstance(params["cortical_parcellation"], str):
            raise StyxValidationError(f'`cortical_parcellation` has the wrong type: Received `{type(params.get("cortical_parcellation", None))}` expected `str | None`')
    if params.get("nsmooth", None) is not None:
        if not isinstance(params["nsmooth"], (float, int)):
            raise StyxValidationError(f'`nsmooth` has the wrong type: Received `{type(params.get("nsmooth", None))}` expected `float | None`')
    if params.get("smooth_after_rip", False) is None:
        raise StyxValidationError("`smooth_after_rip` must not be None")
    if not isinstance(params["smooth_after_rip"], bool):
        raise StyxValidationError(f'`smooth_after_rip` has the wrong type: Received `{type(params.get("smooth_after_rip", False))}` expected `bool`')
    if params.get("max_cbv_dist", None) is not None:
        if not isinstance(params["max_cbv_dist"], (float, int)):
            raise StyxValidationError(f'`max_cbv_dist` has the wrong type: Received `{type(params.get("max_cbv_dist", None))}` expected `float | None`')
    if params.get("rip_label", None) is not None:
        if not isinstance(params["rip_label"], str):
            raise StyxValidationError(f'`rip_label` has the wrong type: Received `{type(params.get("rip_label", None))}` expected `str | None`')
    if params.get("rip_midline", False) is None:
        raise StyxValidationError("`rip_midline` must not be None")
    if not isinstance(params["rip_midline"], bool):
        raise StyxValidationError(f'`rip_midline` has the wrong type: Received `{type(params.get("rip_midline", False))}` expected `bool`')
    if params.get("rip_bg", False) is None:
        raise StyxValidationError("`rip_bg` must not be None")
    if not isinstance(params["rip_bg"], bool):
        raise StyxValidationError(f'`rip_bg` has the wrong type: Received `{type(params.get("rip_bg", False))}` expected `bool`')
    if params.get("rip_bg_no_annot", False) is None:
        raise StyxValidationError("`rip_bg_no_annot` must not be None")
    if not isinstance(params["rip_bg_no_annot"], bool):
        raise StyxValidationError(f'`rip_bg_no_annot` has the wrong type: Received `{type(params.get("rip_bg_no_annot", False))}` expected `bool`')
    if params.get("no_rip_freeze", False) is None:
        raise StyxValidationError("`no_rip_freeze` must not be None")
    if not isinstance(params["no_rip_freeze"], bool):
        raise StyxValidationError(f'`no_rip_freeze` has the wrong type: Received `{type(params.get("no_rip_freeze", False))}` expected `bool`')
    if params.get("rip_wmsa", False) is None:
        raise StyxValidationError("`rip_wmsa` must not be None")
    if not isinstance(params["rip_wmsa"], bool):
        raise StyxValidationError(f'`rip_wmsa` has the wrong type: Received `{type(params.get("rip_wmsa", False))}` expected `bool`')
    if params.get("rip_lesion", False) is None:
        raise StyxValidationError("`rip_lesion` must not be None")
    if not isinstance(params["rip_lesion"], bool):
        raise StyxValidationError(f'`rip_lesion` has the wrong type: Received `{type(params.get("rip_lesion", False))}` expected `bool`')
    if params.get("no_rip", False) is None:
        raise StyxValidationError("`no_rip` must not be None")
    if not isinstance(params["no_rip"], bool):
        raise StyxValidationError(f'`no_rip` has the wrong type: Received `{type(params.get("no_rip", False))}` expected `bool`')
    if params.get("rip_overlay", None) is not None:
        if not isinstance(params["rip_overlay"], str):
            raise StyxValidationError(f'`rip_overlay` has the wrong type: Received `{type(params.get("rip_overlay", None))}` expected `str | None`')
    if params.get("rip_surface", None) is not None:
        if not isinstance(params["rip_surface"], str):
            raise StyxValidationError(f'`rip_surface` has the wrong type: Received `{type(params.get("rip_surface", None))}` expected `str | None`')
    if params.get("rip_projection", None) is not None:
        if not isinstance(params["rip_projection"], list):
            raise StyxValidationError(f'`rip_projection` has the wrong type: Received `{type(params.get("rip_projection", None))}` expected `list[float] | None`')
        if len(params["rip_projection"]) != 3:
            raise StyxValidationError("Parameter `rip_projection` must contain exactly 3 elements")
        for e in params["rip_projection"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`rip_projection` has the wrong type: Received `{type(params.get("rip_projection", None))}` expected `list[float] | None`')
    if params.get("repulse_surface", None) is not None:
        if not isinstance(params["repulse_surface"], str):
            raise StyxValidationError(f'`repulse_surface` has the wrong type: Received `{type(params.get("repulse_surface", None))}` expected `str | None`')
    if params.get("white_surface", None) is not None:
        if not isinstance(params["white_surface"], str):
            raise StyxValidationError(f'`white_surface` has the wrong type: Received `{type(params.get("white_surface", None))}` expected `str | None`')
    if params.get("blend_surface", None) is not None:
        if not isinstance(params["blend_surface"], str):
            raise StyxValidationError(f'`blend_surface` has the wrong type: Received `{type(params.get("blend_surface", None))}` expected `str | None`')
    if params.get("multimodal_input", None) is not None:
        if not isinstance(params["multimodal_input"], str):
            raise StyxValidationError(f'`multimodal_input` has the wrong type: Received `{type(params.get("multimodal_input", None))}` expected `str | None`')
    if params.get("mm_refine", False) is None:
        raise StyxValidationError("`mm_refine` must not be None")
    if not isinstance(params["mm_refine"], bool):
        raise StyxValidationError(f'`mm_refine` has the wrong type: Received `{type(params.get("mm_refine", False))}` expected `bool`')
    if params.get("pin_medial_wall", None) is not None:
        if not isinstance(params["pin_medial_wall"], str):
            raise StyxValidationError(f'`pin_medial_wall` has the wrong type: Received `{type(params.get("pin_medial_wall", None))}` expected `str | None`')
    if params.get("no_intensity_proc", False) is None:
        raise StyxValidationError("`no_intensity_proc` must not be None")
    if not isinstance(params["no_intensity_proc"], bool):
        raise StyxValidationError(f'`no_intensity_proc` has the wrong type: Received `{type(params.get("no_intensity_proc", False))}` expected `bool`')
    if params.get("debug_vertex", None) is not None:
        if not isinstance(params["debug_vertex"], (float, int)):
            raise StyxValidationError(f'`debug_vertex` has the wrong type: Received `{type(params.get("debug_vertex", None))}` expected `float | None`')
    if params.get("ripflag_out", None) is not None:
        if not isinstance(params["ripflag_out"], str):
            raise StyxValidationError(f'`ripflag_out` has the wrong type: Received `{type(params.get("ripflag_out", None))}` expected `str | None`')
    if params.get("local_max", None) is not None:
        if not isinstance(params["local_max"], str):
            raise StyxValidationError(f'`local_max` has the wrong type: Received `{type(params.get("local_max", None))}` expected `str | None`')
    if params.get("target_surf", None) is not None:
        if not isinstance(params["target_surf"], str):
            raise StyxValidationError(f'`target_surf` has the wrong type: Received `{type(params.get("target_surf", None))}` expected `str | None`')
    if params.get("stop_mask", False) is None:
        raise StyxValidationError("`stop_mask` must not be None")
    if not isinstance(params["stop_mask"], bool):
        raise StyxValidationError(f'`stop_mask` has the wrong type: Received `{type(params.get("stop_mask", False))}` expected `bool`')
    if params.get("mm_intensity_limits", None) is not None:
        if not isinstance(params["mm_intensity_limits"], str):
            raise StyxValidationError(f'`mm_intensity_limits` has the wrong type: Received `{type(params.get("mm_intensity_limits", None))}` expected `str | None`')
    if params.get("cover_seg", None) is not None:
        if not isinstance(params["cover_seg"], str):
            raise StyxValidationError(f'`cover_seg` has the wrong type: Received `{type(params.get("cover_seg", None))}` expected `str | None`')
    if params.get("first_peak_d1", False) is None:
        raise StyxValidationError("`first_peak_d1` must not be None")
    if not isinstance(params["first_peak_d1"], bool):
        raise StyxValidationError(f'`first_peak_d1` has the wrong type: Received `{type(params.get("first_peak_d1", False))}` expected `bool`')
    if params.get("first_peak_d2", False) is None:
        raise StyxValidationError("`first_peak_d2` must not be None")
    if not isinstance(params["first_peak_d2"], bool):
        raise StyxValidationError(f'`first_peak_d2` has the wrong type: Received `{type(params.get("first_peak_d2", False))}` expected `bool`')
    if params.get("white_border_low_factor", None) is not None:
        if not isinstance(params["white_border_low_factor"], (float, int)):
            raise StyxValidationError(f'`white_border_low_factor` has the wrong type: Received `{type(params.get("white_border_low_factor", None))}` expected `float | None`')
    if params.get("fill_lateral_ventricles", None) is not None:
        if not isinstance(params["fill_lateral_ventricles"], list):
            raise StyxValidationError(f'`fill_lateral_ventricles` has the wrong type: Received `{type(params.get("fill_lateral_ventricles", None))}` expected `list[float] | None`')
        if len(params["fill_lateral_ventricles"]) < 3:
            raise StyxValidationError("Parameter `fill_lateral_ventricles` must contain at least 3 elements")
        for e in params["fill_lateral_ventricles"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`fill_lateral_ventricles` has the wrong type: Received `{type(params.get("fill_lateral_ventricles", None))}` expected `list[float] | None`')


def mris_place_surface_cargs(
    params: MrisPlaceSurfaceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mris_place_surface")
    cargs.extend([
        "--o",
        params.get("output_surface", None)
    ])
    cargs.extend([
        "--i",
        params.get("input_surface", None)
    ])
    cargs.extend([
        "--adgw",
        params.get("autodetect_gray_white_stats", None)
    ])
    cargs.extend([
        "--invol",
        params.get("input_volume", None)
    ])
    cargs.append(params.get("surface_type_group", None))
    cargs.append(params.get("hemi_group", None))
    if params.get("wm_segment", None) is not None:
        cargs.extend([
            "--wm",
            params.get("wm_segment", None)
        ])
    if params.get("out_volume", None) is not None:
        cargs.extend([
            "--outvol",
            params.get("out_volume", None)
        ])
    if params.get("out_volume_only", None) is not None:
        cargs.extend([
            "--outvol-only",
            params.get("out_volume_only", None)
        ])
    if params.get("restore_255", False):
        cargs.append("--restore-255")
    if params.get("segmentation", None) is not None:
        cargs.extend([
            "--seg",
            params.get("segmentation", None)
        ])
    if params.get("cortical_parcellation", None) is not None:
        cargs.extend([
            "--aparc",
            params.get("cortical_parcellation", None)
        ])
    if params.get("nsmooth", None) is not None:
        cargs.extend([
            "--nsmooth",
            str(params.get("nsmooth", None))
        ])
    if params.get("smooth_after_rip", False):
        cargs.append("--smooth-after-rip")
    if params.get("max_cbv_dist", None) is not None:
        cargs.extend([
            "--max-cbv-dist",
            str(params.get("max_cbv_dist", None))
        ])
    if params.get("rip_label", None) is not None:
        cargs.extend([
            "--rip-label",
            params.get("rip_label", None)
        ])
    if params.get("rip_midline", False):
        cargs.append("--rip-midline")
    if params.get("rip_bg", False):
        cargs.append("--rip-bg")
    if params.get("rip_bg_no_annot", False):
        cargs.append("--rip-bg-no-annot")
    if params.get("no_rip_freeze", False):
        cargs.append("--no-rip-freeze")
    if params.get("rip_wmsa", False):
        cargs.append("--rip-wmsa")
    if params.get("rip_lesion", False):
        cargs.append("--rip-lesion")
    if params.get("no_rip", False):
        cargs.append("--no-rip")
    if params.get("rip_overlay", None) is not None:
        cargs.extend([
            "--rip-overlay",
            params.get("rip_overlay", None)
        ])
    if params.get("rip_surface", None) is not None:
        cargs.extend([
            "--ripsurface",
            params.get("rip_surface", None)
        ])
    if params.get("rip_projection", None) is not None:
        cargs.extend([
            "--rip-projection",
            *map(str, params.get("rip_projection", None))
        ])
    if params.get("repulse_surface", None) is not None:
        cargs.extend([
            "--repulse-surf",
            params.get("repulse_surface", None)
        ])
    if params.get("white_surface", None) is not None:
        cargs.extend([
            "--white-surf",
            params.get("white_surface", None)
        ])
    if params.get("blend_surface", None) is not None:
        cargs.extend([
            "--blend-surf",
            params.get("blend_surface", None)
        ])
    if params.get("multimodal_input", None) is not None:
        cargs.extend([
            "--mmvol",
            params.get("multimodal_input", None)
        ])
    if params.get("mm_refine", False):
        cargs.append("--mm-refine")
    if params.get("pin_medial_wall", None) is not None:
        cargs.extend([
            "--pin-medial-wall",
            params.get("pin_medial_wall", None)
        ])
    if params.get("no_intensity_proc", False):
        cargs.append("--no-intensity-proc")
    if params.get("debug_vertex", None) is not None:
        cargs.extend([
            "--debug-vertex",
            str(params.get("debug_vertex", None))
        ])
    if params.get("ripflag_out", None) is not None:
        cargs.extend([
            "--ripflag-out",
            params.get("ripflag_out", None)
        ])
    if params.get("local_max", None) is not None:
        cargs.extend([
            "--local-max",
            params.get("local_max", None)
        ])
    if params.get("target_surf", None) is not None:
        cargs.extend([
            "--target",
            params.get("target_surf", None)
        ])
    if params.get("stop_mask", False):
        cargs.append("--stop")
    if params.get("mm_intensity_limits", None) is not None:
        cargs.extend([
            "--mm_{min,max}_{inside,outside}",
            params.get("mm_intensity_limits", None)
        ])
    if params.get("cover_seg", None) is not None:
        cargs.extend([
            "--cover-seg",
            params.get("cover_seg", None)
        ])
    if params.get("first_peak_d1", False):
        cargs.append("--first-peak-d1")
    if params.get("first_peak_d2", False):
        cargs.append("--first-peak-d2")
    if params.get("white_border_low_factor", None) is not None:
        cargs.extend([
            "--white_border_low_factor",
            str(params.get("white_border_low_factor", None))
        ])
    if params.get("fill_lateral_ventricles", None) is not None:
        cargs.extend([
            "--fill-lat-vents",
            *map(str, params.get("fill_lateral_ventricles", None))
        ])
    return cargs


def mris_place_surface_outputs(
    params: MrisPlaceSurfaceParamsDict,
    execution: Execution,
) -> MrisPlaceSurfaceOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MrisPlaceSurfaceOutputs(
        root=execution.output_file("."),
    )
    return ret


def mris_place_surface_execute(
    params: MrisPlaceSurfaceParamsDict,
    runner: Runner | None = None,
) -> MrisPlaceSurfaceOutputs:
    """
    mris_place_surface
    
    This program positions the triangular mesh representing a cortical surface,
    either the 'white' surface (ie, white/gray boundary) or the 'pial' surface
    (ie, the gray/csf boundary).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrisPlaceSurfaceOutputs`).
    """
    mris_place_surface_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRIS_PLACE_SURFACE_METADATA)
    params = execution.params(params)
    cargs = mris_place_surface_cargs(params, execution)
    ret = mris_place_surface_outputs(params, execution)
    execution.run(cargs)
    return ret


def mris_place_surface(
    output_surface: str,
    input_surface: str,
    autodetect_gray_white_stats: str,
    input_volume: str,
    surface_type_group: typing.Literal["--white", "--pial"],
    hemi_group: typing.Literal["--lh", "--rh"],
    wm_segment: str | None = None,
    out_volume: str | None = None,
    out_volume_only: str | None = None,
    restore_255: bool = False,
    segmentation: str | None = None,
    cortical_parcellation: str | None = None,
    nsmooth: float | None = None,
    smooth_after_rip: bool = False,
    max_cbv_dist: float | None = None,
    rip_label: str | None = None,
    rip_midline: bool = False,
    rip_bg: bool = False,
    rip_bg_no_annot: bool = False,
    no_rip_freeze: bool = False,
    rip_wmsa: bool = False,
    rip_lesion: bool = False,
    no_rip: bool = False,
    rip_overlay: str | None = None,
    rip_surface: str | None = None,
    rip_projection: list[float] | None = None,
    repulse_surface: str | None = None,
    white_surface: str | None = None,
    blend_surface: str | None = None,
    multimodal_input: str | None = None,
    mm_refine: bool = False,
    pin_medial_wall: str | None = None,
    no_intensity_proc: bool = False,
    debug_vertex: float | None = None,
    ripflag_out: str | None = None,
    local_max: str | None = None,
    target_surf: str | None = None,
    stop_mask: bool = False,
    mm_intensity_limits: str | None = None,
    cover_seg: str | None = None,
    first_peak_d1: bool = False,
    first_peak_d2: bool = False,
    white_border_low_factor: float | None = None,
    fill_lateral_ventricles: list[float] | None = None,
    runner: Runner | None = None,
) -> MrisPlaceSurfaceOutputs:
    """
    mris_place_surface
    
    This program positions the triangular mesh representing a cortical surface,
    either the 'white' surface (ie, white/gray boundary) or the 'pial' surface
    (ie, the gray/csf boundary).
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        output_surface: Output surface.
        input_surface: Input surface.
        autodetect_gray_white_stats: Intensity stats created by\
            mris_autodet_gwstats.
        input_volume: T1-weighed intensity volume used to find white/gray/csf\
            gradients (usually brain.finalsurf.mgz).
        surface_type_group: Place the white surface or the pial surface. Must\
            choose one.
        hemi_group: Left or right hemisphere. Must choose one.
        wm_segment: White matter segmentation.
        out_volume: Save input volume after preprocessing.
        out_volume_only: Save input volume after preprocessing and then exit.
        restore_255: Set voxels in the input volume that start off as 255 to\
            110 (white surf only).
        segmentation: Whole-brain segmentation (usually aseg.presurf.mgz).
        cortical_parcellation: Set cortical parcellation used to rip vertices\
            (usually ?h.aparc.annot).
        nsmooth: Smooth input surface by number of iterations.
        smooth_after_rip: Smooth after ripping.
        max_cbv_dist: Limit distance MRIScomputeBorderValues() can search from\
            the input.
        rip_label: Do not move vertices that are NOT in the cortex label.
        rip_midline: Do not move vertices that are in the midline as indicated\
            by the seg.
        rip_bg: Do not move vertices near basal ganglia (as defined by seg).
        rip_bg_no_annot: Do not require surface have an annotation when ripping\
            BG.
        no_rip_freeze: Do NOT move vertices in/near freeze voxels (247 as\
            defined in seg).
        rip_wmsa: Do not move vertices in/near white-matter signal\
            abnormalities (77,78,79 as defined in seg).
        rip_lesion: Do not move vertices in/near lesions (25 and 57 as defined\
            in seg).
        no_rip: Turn off all ripping.
        rip_overlay: Rip vertices > 0.5 in the surface overlay file.
        rip_surface: Use this surface with ripping midline, BG, Freezes,\
            Lesions, and WMSA.
        rip_projection: Control projection depth along normal to ripsurface\
            when sampling seg.
        repulse_surface: Force input surface away from this surface (usually\
            the white surface when placing the pial).
        white_surface: Set the white{xyz} coordinates of the input surface\
            using this surface.
        blend_surface: Recompute the xyz coordinates of the input surface by\
            computing a weighted average with the blend surface.
        multimodal_input: Specify a T2 or FLAIR input volume used for placing\
            the pial surface. Must be in registration with the input volume.
        mm_refine: Use Siless' MultimodalRefinement. Sets tspring=nspring=0.3.
        pin_medial_wall: Set coordinates in vertices NOT in cortexlabel to be\
            that of the white{xyz} coordinates.
        no_intensity_proc: Do not process the input intensity volume (eg, to\
            remove parts of eye socket).
        debug_vertex: Debug vertex number.
        ripflag_out: Save ripflag as overlay.
        local_max: Save LocalMaxFoundFlag as overlay.
        target_surf: Save CBV target surface.
        stop_mask: Stop mask to stop search along normal for max gradient.
        mm_intensity_limits: Intensity limits for placing pial on multimodal\
            input.
        cover_seg: Force surface to cover the segmentation.
        first_peak_d1: Use find-first-peak option with 1st derivative in\
            ComputeBorderValues.
        first_peak_d2: Use find-first-peak option with 2nd derivative in\
            ComputeBorderValues.
        white_border_low_factor: white_border_low = f*adgws.gray_mean +\
            (1-f)*adgws.white_mean;.
        fill_lateral_ventricles: Fill lateral ventricles with 110.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MrisPlaceSurfaceOutputs`).
    """
    params = mris_place_surface_params(
        output_surface=output_surface,
        input_surface=input_surface,
        autodetect_gray_white_stats=autodetect_gray_white_stats,
        input_volume=input_volume,
        surface_type_group=surface_type_group,
        hemi_group=hemi_group,
        wm_segment=wm_segment,
        out_volume=out_volume,
        out_volume_only=out_volume_only,
        restore_255=restore_255,
        segmentation=segmentation,
        cortical_parcellation=cortical_parcellation,
        nsmooth=nsmooth,
        smooth_after_rip=smooth_after_rip,
        max_cbv_dist=max_cbv_dist,
        rip_label=rip_label,
        rip_midline=rip_midline,
        rip_bg=rip_bg,
        rip_bg_no_annot=rip_bg_no_annot,
        no_rip_freeze=no_rip_freeze,
        rip_wmsa=rip_wmsa,
        rip_lesion=rip_lesion,
        no_rip=no_rip,
        rip_overlay=rip_overlay,
        rip_surface=rip_surface,
        rip_projection=rip_projection,
        repulse_surface=repulse_surface,
        white_surface=white_surface,
        blend_surface=blend_surface,
        multimodal_input=multimodal_input,
        mm_refine=mm_refine,
        pin_medial_wall=pin_medial_wall,
        no_intensity_proc=no_intensity_proc,
        debug_vertex=debug_vertex,
        ripflag_out=ripflag_out,
        local_max=local_max,
        target_surf=target_surf,
        stop_mask=stop_mask,
        mm_intensity_limits=mm_intensity_limits,
        cover_seg=cover_seg,
        first_peak_d1=first_peak_d1,
        first_peak_d2=first_peak_d2,
        white_border_low_factor=white_border_low_factor,
        fill_lateral_ventricles=fill_lateral_ventricles,
    )
    return mris_place_surface_execute(params, runner)


__all__ = [
    "MRIS_PLACE_SURFACE_METADATA",
    "MrisPlaceSurfaceOutputs",
    "MrisPlaceSurfaceParamsDict",
    "MrisPlaceSurfaceParamsDictTagged",
    "mris_place_surface",
    "mris_place_surface_execute",
    "mris_place_surface_params",
]
