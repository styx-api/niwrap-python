# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

DMRI_TRAIN_METADATA = Metadata(
    id="62544142f9acdbe8969a134c0089af273bafcc2c.boutiques",
    name="dmri_train",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_DmriTrainParamsDictNoTag = typing.TypedDict('_DmriTrainParamsDictNoTag', {
    "slist": InputPathType,
    "trk_files": list[InputPathType],
    "rois": typing.NotRequired[list[InputPathType] | None],
    "seg": InputPathType,
    "cmask": InputPathType,
    "lmask": list[float],
    "bmask_training": list[InputPathType],
    "outtrk": list[InputPathType],
    "bmask_test": list[InputPathType],
    "fa": typing.NotRequired[list[InputPathType] | None],
    "reg": typing.NotRequired[InputPathType | None],
    "regnl": typing.NotRequired[InputPathType | None],
    "refnl": typing.NotRequired[InputPathType | None],
    "basereg": typing.NotRequired[list[InputPathType] | None],
    "baseref": typing.NotRequired[list[InputPathType] | None],
    "ncpts": list[float],
    "max_streamlines": float,
    "xstr": bool,
    "aprior": bool,
    "sprior": bool,
    "trunc": bool,
    "out_files": list[str],
    "outdir": typing.NotRequired[str | None],
    "cptdir": typing.NotRequired[str | None],
    "debug": bool,
    "checkopts": bool,
    "help": bool,
    "version": bool,
})
DmriTrainParamsDictTagged = typing.TypedDict('DmriTrainParamsDictTagged', {
    "@type": typing.Literal["freesurfer/dmri_train"],
    "slist": InputPathType,
    "trk_files": list[InputPathType],
    "rois": typing.NotRequired[list[InputPathType] | None],
    "seg": InputPathType,
    "cmask": InputPathType,
    "lmask": list[float],
    "bmask_training": list[InputPathType],
    "outtrk": list[InputPathType],
    "bmask_test": list[InputPathType],
    "fa": typing.NotRequired[list[InputPathType] | None],
    "reg": typing.NotRequired[InputPathType | None],
    "regnl": typing.NotRequired[InputPathType | None],
    "refnl": typing.NotRequired[InputPathType | None],
    "basereg": typing.NotRequired[list[InputPathType] | None],
    "baseref": typing.NotRequired[list[InputPathType] | None],
    "ncpts": list[float],
    "max_streamlines": float,
    "xstr": bool,
    "aprior": bool,
    "sprior": bool,
    "trunc": bool,
    "out_files": list[str],
    "outdir": typing.NotRequired[str | None],
    "cptdir": typing.NotRequired[str | None],
    "debug": bool,
    "checkopts": bool,
    "help": bool,
    "version": bool,
})
DmriTrainParamsDict = _DmriTrainParamsDictNoTag | DmriTrainParamsDictTagged


class DmriTrainOutputs(typing.NamedTuple):
    """
    Output object returned when calling `DmriTrainParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def dmri_train_params(
    slist: InputPathType,
    trk_files: list[InputPathType],
    seg: InputPathType,
    cmask: InputPathType,
    lmask: list[float],
    bmask_training: list[InputPathType],
    outtrk: list[InputPathType],
    bmask_test: list[InputPathType],
    ncpts: list[float],
    max_streamlines: float,
    out_files: list[str],
    rois: list[InputPathType] | None = None,
    fa: list[InputPathType] | None = None,
    reg: InputPathType | None = None,
    regnl: InputPathType | None = None,
    refnl: InputPathType | None = None,
    basereg: list[InputPathType] | None = None,
    baseref: list[InputPathType] | None = None,
    xstr: bool = False,
    aprior: bool = False,
    sprior: bool = False,
    trunc: bool = False,
    outdir: str | None = None,
    cptdir: str | None = None,
    debug: bool = False,
    checkopts: bool = False,
    help_: bool = False,
    version: bool = False,
) -> DmriTrainParamsDictTagged:
    """
    Build parameters.
    
    Args:
        slist: Text file with list of training subject directories.
        trk_files: Name(s) of input .trk file(s), one per path.
        seg: Name of input aparc+aseg volume.
        cmask: Name of input cortex mask volume.
        lmask: Add a label ID from aparc+aseg to cortex mask, one per path.
        bmask_training: Input brain mask volume(s).
        outtrk: Name(s) of output, pre-sorted .trk file(s), one per path.
        bmask_test: Input brain mask volume(s) for test subject.
        ncpts: Number of control points for initial spline.
        max_streamlines: Maximum number of training streamlines to keep per\
            path.
        out_files: Base name(s) of output(s) for test subject, one per path.
        rois: Optional, names of input tract labeling ROIs, two per path.
        fa: Input FA volume(s) for test subject.
        reg: Affine registration from atlas to base space.
        regnl: Nonlinear registration from atlas to base space.
        refnl: Nonlinear registration source reference volume.
        basereg: Affine registration(s) from base to FA volume(s).
        baseref: Base space reference volume.
        xstr: Exclude previously chosen center streamline(s).
        aprior: Compute priors on underlying anatomy.
        sprior: Compute priors on shape.
        trunc: Use all training streamlines, truncated or not.
        outdir: Output directory.
        cptdir: Output directory for control points in test subject's space.
        debug: Turn on debugging.
        checkopts: Don't run anything, just check options and exit.
        help_: Print out information on how to use this program.
        version: Print out version and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/dmri_train",
        "slist": slist,
        "trk_files": trk_files,
        "seg": seg,
        "cmask": cmask,
        "lmask": lmask,
        "bmask_training": bmask_training,
        "outtrk": outtrk,
        "bmask_test": bmask_test,
        "ncpts": ncpts,
        "max_streamlines": max_streamlines,
        "xstr": xstr,
        "aprior": aprior,
        "sprior": sprior,
        "trunc": trunc,
        "out_files": out_files,
        "debug": debug,
        "checkopts": checkopts,
        "help": help_,
        "version": version,
    }
    if rois is not None:
        params["rois"] = rois
    if fa is not None:
        params["fa"] = fa
    if reg is not None:
        params["reg"] = reg
    if regnl is not None:
        params["regnl"] = regnl
    if refnl is not None:
        params["refnl"] = refnl
    if basereg is not None:
        params["basereg"] = basereg
    if baseref is not None:
        params["baseref"] = baseref
    if outdir is not None:
        params["outdir"] = outdir
    if cptdir is not None:
        params["cptdir"] = cptdir
    return params


def dmri_train_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `DmriTrainParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("slist", None) is None:
        raise StyxValidationError("`slist` must not be None")
    if not isinstance(params["slist"], (pathlib.Path, str)):
        raise StyxValidationError(f'`slist` has the wrong type: Received `{type(params.get("slist", None))}` expected `InputPathType`')
    if params.get("trk_files", None) is None:
        raise StyxValidationError("`trk_files` must not be None")
    if not isinstance(params["trk_files"], list):
        raise StyxValidationError(f'`trk_files` has the wrong type: Received `{type(params.get("trk_files", None))}` expected `list[InputPathType]`')
    for e in params["trk_files"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`trk_files` has the wrong type: Received `{type(params.get("trk_files", None))}` expected `list[InputPathType]`')
    if params.get("rois", None) is not None:
        if not isinstance(params["rois"], list):
            raise StyxValidationError(f'`rois` has the wrong type: Received `{type(params.get("rois", None))}` expected `list[InputPathType] | None`')
        for e in params["rois"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`rois` has the wrong type: Received `{type(params.get("rois", None))}` expected `list[InputPathType] | None`')
    if params.get("seg", None) is None:
        raise StyxValidationError("`seg` must not be None")
    if not isinstance(params["seg"], (pathlib.Path, str)):
        raise StyxValidationError(f'`seg` has the wrong type: Received `{type(params.get("seg", None))}` expected `InputPathType`')
    if params.get("cmask", None) is None:
        raise StyxValidationError("`cmask` must not be None")
    if not isinstance(params["cmask"], (pathlib.Path, str)):
        raise StyxValidationError(f'`cmask` has the wrong type: Received `{type(params.get("cmask", None))}` expected `InputPathType`')
    if params.get("lmask", None) is None:
        raise StyxValidationError("`lmask` must not be None")
    if not isinstance(params["lmask"], list):
        raise StyxValidationError(f'`lmask` has the wrong type: Received `{type(params.get("lmask", None))}` expected `list[float]`')
    for e in params["lmask"]:
        if not isinstance(e, (float, int)):
            raise StyxValidationError(f'`lmask` has the wrong type: Received `{type(params.get("lmask", None))}` expected `list[float]`')
    if params.get("bmask_training", None) is None:
        raise StyxValidationError("`bmask_training` must not be None")
    if not isinstance(params["bmask_training"], list):
        raise StyxValidationError(f'`bmask_training` has the wrong type: Received `{type(params.get("bmask_training", None))}` expected `list[InputPathType]`')
    for e in params["bmask_training"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`bmask_training` has the wrong type: Received `{type(params.get("bmask_training", None))}` expected `list[InputPathType]`')
    if params.get("outtrk", None) is None:
        raise StyxValidationError("`outtrk` must not be None")
    if not isinstance(params["outtrk"], list):
        raise StyxValidationError(f'`outtrk` has the wrong type: Received `{type(params.get("outtrk", None))}` expected `list[InputPathType]`')
    for e in params["outtrk"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`outtrk` has the wrong type: Received `{type(params.get("outtrk", None))}` expected `list[InputPathType]`')
    if params.get("bmask_test", None) is None:
        raise StyxValidationError("`bmask_test` must not be None")
    if not isinstance(params["bmask_test"], list):
        raise StyxValidationError(f'`bmask_test` has the wrong type: Received `{type(params.get("bmask_test", None))}` expected `list[InputPathType]`')
    for e in params["bmask_test"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`bmask_test` has the wrong type: Received `{type(params.get("bmask_test", None))}` expected `list[InputPathType]`')
    if params.get("fa", None) is not None:
        if not isinstance(params["fa"], list):
            raise StyxValidationError(f'`fa` has the wrong type: Received `{type(params.get("fa", None))}` expected `list[InputPathType] | None`')
        for e in params["fa"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`fa` has the wrong type: Received `{type(params.get("fa", None))}` expected `list[InputPathType] | None`')
    if params.get("reg", None) is not None:
        if not isinstance(params["reg"], (pathlib.Path, str)):
            raise StyxValidationError(f'`reg` has the wrong type: Received `{type(params.get("reg", None))}` expected `InputPathType | None`')
    if params.get("regnl", None) is not None:
        if not isinstance(params["regnl"], (pathlib.Path, str)):
            raise StyxValidationError(f'`regnl` has the wrong type: Received `{type(params.get("regnl", None))}` expected `InputPathType | None`')
    if params.get("refnl", None) is not None:
        if not isinstance(params["refnl"], (pathlib.Path, str)):
            raise StyxValidationError(f'`refnl` has the wrong type: Received `{type(params.get("refnl", None))}` expected `InputPathType | None`')
    if params.get("basereg", None) is not None:
        if not isinstance(params["basereg"], list):
            raise StyxValidationError(f'`basereg` has the wrong type: Received `{type(params.get("basereg", None))}` expected `list[InputPathType] | None`')
        for e in params["basereg"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`basereg` has the wrong type: Received `{type(params.get("basereg", None))}` expected `list[InputPathType] | None`')
    if params.get("baseref", None) is not None:
        if not isinstance(params["baseref"], list):
            raise StyxValidationError(f'`baseref` has the wrong type: Received `{type(params.get("baseref", None))}` expected `list[InputPathType] | None`')
        for e in params["baseref"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`baseref` has the wrong type: Received `{type(params.get("baseref", None))}` expected `list[InputPathType] | None`')
    if params.get("ncpts", None) is None:
        raise StyxValidationError("`ncpts` must not be None")
    if not isinstance(params["ncpts"], list):
        raise StyxValidationError(f'`ncpts` has the wrong type: Received `{type(params.get("ncpts", None))}` expected `list[float]`')
    for e in params["ncpts"]:
        if not isinstance(e, (float, int)):
            raise StyxValidationError(f'`ncpts` has the wrong type: Received `{type(params.get("ncpts", None))}` expected `list[float]`')
    if params.get("max_streamlines", None) is None:
        raise StyxValidationError("`max_streamlines` must not be None")
    if not isinstance(params["max_streamlines"], (float, int)):
        raise StyxValidationError(f'`max_streamlines` has the wrong type: Received `{type(params.get("max_streamlines", None))}` expected `float`')
    if params.get("xstr", False) is None:
        raise StyxValidationError("`xstr` must not be None")
    if not isinstance(params["xstr"], bool):
        raise StyxValidationError(f'`xstr` has the wrong type: Received `{type(params.get("xstr", False))}` expected `bool`')
    if params.get("aprior", False) is None:
        raise StyxValidationError("`aprior` must not be None")
    if not isinstance(params["aprior"], bool):
        raise StyxValidationError(f'`aprior` has the wrong type: Received `{type(params.get("aprior", False))}` expected `bool`')
    if params.get("sprior", False) is None:
        raise StyxValidationError("`sprior` must not be None")
    if not isinstance(params["sprior"], bool):
        raise StyxValidationError(f'`sprior` has the wrong type: Received `{type(params.get("sprior", False))}` expected `bool`')
    if params.get("trunc", False) is None:
        raise StyxValidationError("`trunc` must not be None")
    if not isinstance(params["trunc"], bool):
        raise StyxValidationError(f'`trunc` has the wrong type: Received `{type(params.get("trunc", False))}` expected `bool`')
    if params.get("out_files", None) is None:
        raise StyxValidationError("`out_files` must not be None")
    if not isinstance(params["out_files"], list):
        raise StyxValidationError(f'`out_files` has the wrong type: Received `{type(params.get("out_files", None))}` expected `list[str]`')
    for e in params["out_files"]:
        if not isinstance(e, str):
            raise StyxValidationError(f'`out_files` has the wrong type: Received `{type(params.get("out_files", None))}` expected `list[str]`')
    if params.get("outdir", None) is not None:
        if not isinstance(params["outdir"], str):
            raise StyxValidationError(f'`outdir` has the wrong type: Received `{type(params.get("outdir", None))}` expected `str | None`')
    if params.get("cptdir", None) is not None:
        if not isinstance(params["cptdir"], str):
            raise StyxValidationError(f'`cptdir` has the wrong type: Received `{type(params.get("cptdir", None))}` expected `str | None`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("checkopts", False) is None:
        raise StyxValidationError("`checkopts` must not be None")
    if not isinstance(params["checkopts"], bool):
        raise StyxValidationError(f'`checkopts` has the wrong type: Received `{type(params.get("checkopts", False))}` expected `bool`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')


def dmri_train_cargs(
    params: DmriTrainParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("dmri_train")
    cargs.extend([
        "--slist",
        execution.input_file(params.get("slist", None))
    ])
    cargs.extend([
        "--trk",
        *[execution.input_file(f) for f in params.get("trk_files", None)]
    ])
    if params.get("rois", None) is not None:
        cargs.extend([
            "--rois",
            *[execution.input_file(f) for f in params.get("rois", None)]
        ])
    cargs.extend([
        "--seg",
        execution.input_file(params.get("seg", None))
    ])
    cargs.extend([
        "--cmask",
        execution.input_file(params.get("cmask", None))
    ])
    cargs.extend([
        "--lmask",
        *map(str, params.get("lmask", None))
    ])
    cargs.extend([
        "--bmask",
        *[execution.input_file(f) for f in params.get("bmask_training", None)]
    ])
    cargs.extend([
        "--outtrk",
        *[execution.input_file(f) for f in params.get("outtrk", None)]
    ])
    cargs.extend([
        "--bmask",
        *[execution.input_file(f) for f in params.get("bmask_test", None)]
    ])
    if params.get("fa", None) is not None:
        cargs.extend([
            "--fa",
            *[execution.input_file(f) for f in params.get("fa", None)]
        ])
    if params.get("reg", None) is not None:
        cargs.extend([
            "--reg",
            execution.input_file(params.get("reg", None))
        ])
    if params.get("regnl", None) is not None:
        cargs.extend([
            "--regnl",
            execution.input_file(params.get("regnl", None))
        ])
    if params.get("refnl", None) is not None:
        cargs.extend([
            "--refnl",
            execution.input_file(params.get("refnl", None))
        ])
    if params.get("basereg", None) is not None:
        cargs.extend([
            "--basereg",
            *[execution.input_file(f) for f in params.get("basereg", None)]
        ])
    if params.get("baseref", None) is not None:
        cargs.extend([
            "--baseref",
            *[execution.input_file(f) for f in params.get("baseref", None)]
        ])
    cargs.extend([
        "--ncpts",
        *map(str, params.get("ncpts", None))
    ])
    cargs.extend([
        "--max",
        str(params.get("max_streamlines", None))
    ])
    if params.get("xstr", False):
        cargs.append("--xstr")
    if params.get("aprior", False):
        cargs.append("--aprior")
    if params.get("sprior", False):
        cargs.append("--sprior")
    if params.get("trunc", False):
        cargs.append("--trunc")
    cargs.extend([
        "--out",
        *params.get("out_files", None)
    ])
    if params.get("outdir", None) is not None:
        cargs.extend([
            "--outdir",
            params.get("outdir", None)
        ])
    if params.get("cptdir", None) is not None:
        cargs.extend([
            "--cptdir",
            params.get("cptdir", None)
        ])
    if params.get("debug", False):
        cargs.append("--debug")
    if params.get("checkopts", False):
        cargs.append("--checkopts")
    if params.get("help", False):
        cargs.append("--help")
    if params.get("version", False):
        cargs.append("--version")
    return cargs


def dmri_train_outputs(
    params: DmriTrainParamsDict,
    execution: Execution,
) -> DmriTrainOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = DmriTrainOutputs(
        root=execution.output_file("."),
    )
    return ret


def dmri_train_execute(
    params: DmriTrainParamsDict,
    runner: Runner | None = None,
) -> DmriTrainOutputs:
    """
    dmri_train
    
    DMRI training tool for processing diffusion MRI data in FreeSurfer.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DmriTrainOutputs`).
    """
    dmri_train_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(DMRI_TRAIN_METADATA)
    params = execution.params(params)
    cargs = dmri_train_cargs(params, execution)
    ret = dmri_train_outputs(params, execution)
    execution.run(cargs)
    return ret


def dmri_train(
    slist: InputPathType,
    trk_files: list[InputPathType],
    seg: InputPathType,
    cmask: InputPathType,
    lmask: list[float],
    bmask_training: list[InputPathType],
    outtrk: list[InputPathType],
    bmask_test: list[InputPathType],
    ncpts: list[float],
    max_streamlines: float,
    out_files: list[str],
    rois: list[InputPathType] | None = None,
    fa: list[InputPathType] | None = None,
    reg: InputPathType | None = None,
    regnl: InputPathType | None = None,
    refnl: InputPathType | None = None,
    basereg: list[InputPathType] | None = None,
    baseref: list[InputPathType] | None = None,
    xstr: bool = False,
    aprior: bool = False,
    sprior: bool = False,
    trunc: bool = False,
    outdir: str | None = None,
    cptdir: str | None = None,
    debug: bool = False,
    checkopts: bool = False,
    help_: bool = False,
    version: bool = False,
    runner: Runner | None = None,
) -> DmriTrainOutputs:
    """
    dmri_train
    
    DMRI training tool for processing diffusion MRI data in FreeSurfer.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        slist: Text file with list of training subject directories.
        trk_files: Name(s) of input .trk file(s), one per path.
        seg: Name of input aparc+aseg volume.
        cmask: Name of input cortex mask volume.
        lmask: Add a label ID from aparc+aseg to cortex mask, one per path.
        bmask_training: Input brain mask volume(s).
        outtrk: Name(s) of output, pre-sorted .trk file(s), one per path.
        bmask_test: Input brain mask volume(s) for test subject.
        ncpts: Number of control points for initial spline.
        max_streamlines: Maximum number of training streamlines to keep per\
            path.
        out_files: Base name(s) of output(s) for test subject, one per path.
        rois: Optional, names of input tract labeling ROIs, two per path.
        fa: Input FA volume(s) for test subject.
        reg: Affine registration from atlas to base space.
        regnl: Nonlinear registration from atlas to base space.
        refnl: Nonlinear registration source reference volume.
        basereg: Affine registration(s) from base to FA volume(s).
        baseref: Base space reference volume.
        xstr: Exclude previously chosen center streamline(s).
        aprior: Compute priors on underlying anatomy.
        sprior: Compute priors on shape.
        trunc: Use all training streamlines, truncated or not.
        outdir: Output directory.
        cptdir: Output directory for control points in test subject's space.
        debug: Turn on debugging.
        checkopts: Don't run anything, just check options and exit.
        help_: Print out information on how to use this program.
        version: Print out version and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `DmriTrainOutputs`).
    """
    params = dmri_train_params(
        slist=slist,
        trk_files=trk_files,
        rois=rois,
        seg=seg,
        cmask=cmask,
        lmask=lmask,
        bmask_training=bmask_training,
        outtrk=outtrk,
        bmask_test=bmask_test,
        fa=fa,
        reg=reg,
        regnl=regnl,
        refnl=refnl,
        basereg=basereg,
        baseref=baseref,
        ncpts=ncpts,
        max_streamlines=max_streamlines,
        xstr=xstr,
        aprior=aprior,
        sprior=sprior,
        trunc=trunc,
        out_files=out_files,
        outdir=outdir,
        cptdir=cptdir,
        debug=debug,
        checkopts=checkopts,
        help_=help_,
        version=version,
    )
    return dmri_train_execute(params, runner)


__all__ = [
    "DMRI_TRAIN_METADATA",
    "DmriTrainOutputs",
    "DmriTrainParamsDict",
    "DmriTrainParamsDictTagged",
    "dmri_train",
    "dmri_train_execute",
    "dmri_train_params",
]
