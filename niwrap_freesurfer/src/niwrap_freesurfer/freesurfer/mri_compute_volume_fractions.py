# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_COMPUTE_VOLUME_FRACTIONS_METADATA = Metadata(
    id="accbafaf30228c24ceb75d17b4edd13fde8b245c.boutiques",
    name="mri_compute_volume_fractions",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriComputeVolumeFractionsParamsDictNoTag = typing.TypedDict('_MriComputeVolumeFractionsParamsDictNoTag', {
    "output_stem": str,
    "registration_file": typing.NotRequired[InputPathType | None],
    "regheader": typing.NotRequired[str | None],
    "usf": typing.NotRequired[float | None],
    "resolution": typing.NotRequired[float | None],
    "resmm": typing.NotRequired[float | None],
    "segmentation_file": typing.NotRequired[InputPathType | None],
    "wsurf": typing.NotRequired[str | None],
    "psurf": typing.NotRequired[str | None],
    "no_aseg": bool,
    "stackfile": typing.NotRequired[str | None],
    "gmfile": typing.NotRequired[str | None],
    "no_fill_csf": bool,
    "dilation": typing.NotRequired[float | None],
    "out_seg": typing.NotRequired[str | None],
    "ttseg": typing.NotRequired[str | None],
    "ttseg_ctab": typing.NotRequired[str | None],
    "mgz_format": bool,
    "mgh_format": bool,
    "nii_format": bool,
    "nii_gz_format": bool,
    "ttype_head": bool,
    "vg_thresh": typing.NotRequired[float | None],
    "debug": bool,
    "checkopts": bool,
})
MriComputeVolumeFractionsParamsDictTagged = typing.TypedDict('MriComputeVolumeFractionsParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_compute_volume_fractions"],
    "output_stem": str,
    "registration_file": typing.NotRequired[InputPathType | None],
    "regheader": typing.NotRequired[str | None],
    "usf": typing.NotRequired[float | None],
    "resolution": typing.NotRequired[float | None],
    "resmm": typing.NotRequired[float | None],
    "segmentation_file": typing.NotRequired[InputPathType | None],
    "wsurf": typing.NotRequired[str | None],
    "psurf": typing.NotRequired[str | None],
    "no_aseg": bool,
    "stackfile": typing.NotRequired[str | None],
    "gmfile": typing.NotRequired[str | None],
    "no_fill_csf": bool,
    "dilation": typing.NotRequired[float | None],
    "out_seg": typing.NotRequired[str | None],
    "ttseg": typing.NotRequired[str | None],
    "ttseg_ctab": typing.NotRequired[str | None],
    "mgz_format": bool,
    "mgh_format": bool,
    "nii_format": bool,
    "nii_gz_format": bool,
    "ttype_head": bool,
    "vg_thresh": typing.NotRequired[float | None],
    "debug": bool,
    "checkopts": bool,
})
MriComputeVolumeFractionsParamsDict = _MriComputeVolumeFractionsParamsDictNoTag | MriComputeVolumeFractionsParamsDictTagged


class MriComputeVolumeFractionsOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriComputeVolumeFractionsParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_cortex: OutputPathType
    """Output cortex volume file."""
    output_subcort_gm: OutputPathType
    """Output subcortical gray matter volume file."""
    output_wm: OutputPathType
    """Output white matter volume file."""
    output_csf: OutputPathType
    """Output cerebrospinal fluid volume file."""


def mri_compute_volume_fractions_params(
    output_stem: str,
    registration_file: InputPathType | None = None,
    regheader: str | None = None,
    usf: float | None = None,
    resolution: float | None = None,
    resmm: float | None = None,
    segmentation_file: InputPathType | None = None,
    wsurf: str | None = None,
    psurf: str | None = None,
    no_aseg: bool = False,
    stackfile: str | None = None,
    gmfile: str | None = None,
    no_fill_csf: bool = False,
    dilation: float | None = None,
    out_seg: str | None = None,
    ttseg: str | None = None,
    ttseg_ctab: str | None = None,
    mgz_format: bool = False,
    mgh_format: bool = False,
    nii_format: bool = False,
    nii_gz_format: bool = False,
    ttype_head: bool = False,
    vg_thresh: float | None = None,
    debug: bool = False,
    checkopts: bool = False,
) -> MriComputeVolumeFractionsParamsDictTagged:
    """
    Build parameters.
    
    Args:
        output_stem: Output stem for generated files (e.g. cortex, subcort_gm,\
            wm, csf). Files will be saved with this stem in different formats based\
            on the selected flags.
        registration_file: Registration file (can be LTA or reg.dat). If using\
            reg.dat, a template volume is needed.
        regheader: Specify the subject for regheader.
        usf: Set anatomical upsample factor (default is 2).
        resolution: Resolution setting. Sets USF to round(1/res).
        resmm: Set functional upsampling resolution (default is\
            aseg->xsize/(USF)).
        segmentation_file: Use specified segmentation file instead of aseg.mgz.
        wsurf: Specify the white surface (default is 'white').
        psurf: Specify the pial surface (default is 'pial').
        no_aseg: Do not include aseg in processing (useful for testing).
        stackfile: Put cortex, subcortical GM, WM, CSF into a single\
            multi-frame file.
        gmfile: Put cortex + subcortical GM into a single-frame file.
        no_fill_csf: Do not attempt to fill voxels surrounding segmentation\
            with extracerebral CSF segmentation.
        dilation: For xCSF fill, dilate by specified number (default is 3). Use\
            -1 to fill the entire volume.
        out_seg: Save segmentation (after adding xCSF voxels).
        ttseg: Save tissue type segmentation.
        ttseg_ctab: Save tissue type segmentation color table.
        mgz_format: Use MGZ format.
        mgh_format: Use MGH format.
        nii_format: Use NII format.
        nii_gz_format: Use NII.GZ format.
        ttype_head: Use default+head instead of default tissue type info for\
            segmentation.
        vg_thresh: Threshold for 'ERROR: LTAconcat(): LTAs 0 and 1 do not\
            match'.
        debug: Turn on debugging mode.
        checkopts: Do not run anything, just check options and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_compute_volume_fractions",
        "output_stem": output_stem,
        "no_aseg": no_aseg,
        "no_fill_csf": no_fill_csf,
        "mgz_format": mgz_format,
        "mgh_format": mgh_format,
        "nii_format": nii_format,
        "nii_gz_format": nii_gz_format,
        "ttype_head": ttype_head,
        "debug": debug,
        "checkopts": checkopts,
    }
    if registration_file is not None:
        params["registration_file"] = registration_file
    if regheader is not None:
        params["regheader"] = regheader
    if usf is not None:
        params["usf"] = usf
    if resolution is not None:
        params["resolution"] = resolution
    if resmm is not None:
        params["resmm"] = resmm
    if segmentation_file is not None:
        params["segmentation_file"] = segmentation_file
    if wsurf is not None:
        params["wsurf"] = wsurf
    if psurf is not None:
        params["psurf"] = psurf
    if stackfile is not None:
        params["stackfile"] = stackfile
    if gmfile is not None:
        params["gmfile"] = gmfile
    if dilation is not None:
        params["dilation"] = dilation
    if out_seg is not None:
        params["out_seg"] = out_seg
    if ttseg is not None:
        params["ttseg"] = ttseg
    if ttseg_ctab is not None:
        params["ttseg_ctab"] = ttseg_ctab
    if vg_thresh is not None:
        params["vg_thresh"] = vg_thresh
    return params


def mri_compute_volume_fractions_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriComputeVolumeFractionsParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("output_stem", None) is None:
        raise StyxValidationError("`output_stem` must not be None")
    if not isinstance(params["output_stem"], str):
        raise StyxValidationError(f'`output_stem` has the wrong type: Received `{type(params.get("output_stem", None))}` expected `str`')
    if params.get("registration_file", None) is not None:
        if not isinstance(params["registration_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`registration_file` has the wrong type: Received `{type(params.get("registration_file", None))}` expected `InputPathType | None`')
    if params.get("regheader", None) is not None:
        if not isinstance(params["regheader"], str):
            raise StyxValidationError(f'`regheader` has the wrong type: Received `{type(params.get("regheader", None))}` expected `str | None`')
    if params.get("usf", None) is not None:
        if not isinstance(params["usf"], (float, int)):
            raise StyxValidationError(f'`usf` has the wrong type: Received `{type(params.get("usf", None))}` expected `float | None`')
    if params.get("resolution", None) is not None:
        if not isinstance(params["resolution"], (float, int)):
            raise StyxValidationError(f'`resolution` has the wrong type: Received `{type(params.get("resolution", None))}` expected `float | None`')
    if params.get("resmm", None) is not None:
        if not isinstance(params["resmm"], (float, int)):
            raise StyxValidationError(f'`resmm` has the wrong type: Received `{type(params.get("resmm", None))}` expected `float | None`')
    if params.get("segmentation_file", None) is not None:
        if not isinstance(params["segmentation_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`segmentation_file` has the wrong type: Received `{type(params.get("segmentation_file", None))}` expected `InputPathType | None`')
    if params.get("wsurf", None) is not None:
        if not isinstance(params["wsurf"], str):
            raise StyxValidationError(f'`wsurf` has the wrong type: Received `{type(params.get("wsurf", None))}` expected `str | None`')
    if params.get("psurf", None) is not None:
        if not isinstance(params["psurf"], str):
            raise StyxValidationError(f'`psurf` has the wrong type: Received `{type(params.get("psurf", None))}` expected `str | None`')
    if params.get("no_aseg", False) is None:
        raise StyxValidationError("`no_aseg` must not be None")
    if not isinstance(params["no_aseg"], bool):
        raise StyxValidationError(f'`no_aseg` has the wrong type: Received `{type(params.get("no_aseg", False))}` expected `bool`')
    if params.get("stackfile", None) is not None:
        if not isinstance(params["stackfile"], str):
            raise StyxValidationError(f'`stackfile` has the wrong type: Received `{type(params.get("stackfile", None))}` expected `str | None`')
    if params.get("gmfile", None) is not None:
        if not isinstance(params["gmfile"], str):
            raise StyxValidationError(f'`gmfile` has the wrong type: Received `{type(params.get("gmfile", None))}` expected `str | None`')
    if params.get("no_fill_csf", False) is None:
        raise StyxValidationError("`no_fill_csf` must not be None")
    if not isinstance(params["no_fill_csf"], bool):
        raise StyxValidationError(f'`no_fill_csf` has the wrong type: Received `{type(params.get("no_fill_csf", False))}` expected `bool`')
    if params.get("dilation", None) is not None:
        if not isinstance(params["dilation"], (float, int)):
            raise StyxValidationError(f'`dilation` has the wrong type: Received `{type(params.get("dilation", None))}` expected `float | None`')
    if params.get("out_seg", None) is not None:
        if not isinstance(params["out_seg"], str):
            raise StyxValidationError(f'`out_seg` has the wrong type: Received `{type(params.get("out_seg", None))}` expected `str | None`')
    if params.get("ttseg", None) is not None:
        if not isinstance(params["ttseg"], str):
            raise StyxValidationError(f'`ttseg` has the wrong type: Received `{type(params.get("ttseg", None))}` expected `str | None`')
    if params.get("ttseg_ctab", None) is not None:
        if not isinstance(params["ttseg_ctab"], str):
            raise StyxValidationError(f'`ttseg_ctab` has the wrong type: Received `{type(params.get("ttseg_ctab", None))}` expected `str | None`')
    if params.get("mgz_format", False) is None:
        raise StyxValidationError("`mgz_format` must not be None")
    if not isinstance(params["mgz_format"], bool):
        raise StyxValidationError(f'`mgz_format` has the wrong type: Received `{type(params.get("mgz_format", False))}` expected `bool`')
    if params.get("mgh_format", False) is None:
        raise StyxValidationError("`mgh_format` must not be None")
    if not isinstance(params["mgh_format"], bool):
        raise StyxValidationError(f'`mgh_format` has the wrong type: Received `{type(params.get("mgh_format", False))}` expected `bool`')
    if params.get("nii_format", False) is None:
        raise StyxValidationError("`nii_format` must not be None")
    if not isinstance(params["nii_format"], bool):
        raise StyxValidationError(f'`nii_format` has the wrong type: Received `{type(params.get("nii_format", False))}` expected `bool`')
    if params.get("nii_gz_format", False) is None:
        raise StyxValidationError("`nii_gz_format` must not be None")
    if not isinstance(params["nii_gz_format"], bool):
        raise StyxValidationError(f'`nii_gz_format` has the wrong type: Received `{type(params.get("nii_gz_format", False))}` expected `bool`')
    if params.get("ttype_head", False) is None:
        raise StyxValidationError("`ttype_head` must not be None")
    if not isinstance(params["ttype_head"], bool):
        raise StyxValidationError(f'`ttype_head` has the wrong type: Received `{type(params.get("ttype_head", False))}` expected `bool`')
    if params.get("vg_thresh", None) is not None:
        if not isinstance(params["vg_thresh"], (float, int)):
            raise StyxValidationError(f'`vg_thresh` has the wrong type: Received `{type(params.get("vg_thresh", None))}` expected `float | None`')
    if params.get("debug", False) is None:
        raise StyxValidationError("`debug` must not be None")
    if not isinstance(params["debug"], bool):
        raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", False))}` expected `bool`')
    if params.get("checkopts", False) is None:
        raise StyxValidationError("`checkopts` must not be None")
    if not isinstance(params["checkopts"], bool):
        raise StyxValidationError(f'`checkopts` has the wrong type: Received `{type(params.get("checkopts", False))}` expected `bool`')


def mri_compute_volume_fractions_cargs(
    params: MriComputeVolumeFractionsParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_compute_volume_fractions")
    cargs.extend([
        "--o",
        params.get("output_stem", None)
    ])
    if params.get("registration_file", None) is not None:
        cargs.extend([
            "--reg",
            execution.input_file(params.get("registration_file", None))
        ])
    if params.get("regheader", None) is not None:
        cargs.extend([
            "--regheader",
            params.get("regheader", None)
        ])
    if params.get("usf", None) is not None:
        cargs.extend([
            "--usf",
            str(params.get("usf", None))
        ])
    if params.get("resolution", None) is not None:
        cargs.extend([
            "--r",
            str(params.get("resolution", None))
        ])
    if params.get("resmm", None) is not None:
        cargs.extend([
            "--resmm",
            str(params.get("resmm", None))
        ])
    if params.get("segmentation_file", None) is not None:
        cargs.extend([
            "--seg",
            execution.input_file(params.get("segmentation_file", None))
        ])
    if params.get("wsurf", None) is not None:
        cargs.extend([
            "--wsurf",
            params.get("wsurf", None)
        ])
    if params.get("psurf", None) is not None:
        cargs.extend([
            "--psurf",
            params.get("psurf", None)
        ])
    if params.get("no_aseg", False):
        cargs.append("--no-aseg")
    if params.get("stackfile", None) is not None:
        cargs.extend([
            "--stack",
            params.get("stackfile", None)
        ])
    if params.get("gmfile", None) is not None:
        cargs.extend([
            "--gm",
            params.get("gmfile", None)
        ])
    if params.get("no_fill_csf", False):
        cargs.append("--no-fill-csf")
    if params.get("dilation", None) is not None:
        cargs.extend([
            "--dil",
            str(params.get("dilation", None))
        ])
    if params.get("out_seg", None) is not None:
        cargs.extend([
            "--out-seg",
            params.get("out_seg", None)
        ])
    if params.get("ttseg", None) is not None:
        cargs.extend([
            "--ttseg",
            params.get("ttseg", None)
        ])
    if params.get("ttseg_ctab", None) is not None:
        cargs.extend([
            "--ttseg-ctab",
            params.get("ttseg_ctab", None)
        ])
    if params.get("mgz_format", False):
        cargs.append("--mgz")
    if params.get("mgh_format", False):
        cargs.append("--mgh")
    if params.get("nii_format", False):
        cargs.append("--nii")
    if params.get("nii_gz_format", False):
        cargs.append("--nii.gz")
    if params.get("ttype_head", False):
        cargs.append("--ttype+head")
    if params.get("vg_thresh", None) is not None:
        cargs.extend([
            "--vg-thresh",
            str(params.get("vg_thresh", None))
        ])
    if params.get("debug", False):
        cargs.append("--debug")
    if params.get("checkopts", False):
        cargs.append("--checkopts")
    return cargs


def mri_compute_volume_fractions_outputs(
    params: MriComputeVolumeFractionsParamsDict,
    execution: Execution,
) -> MriComputeVolumeFractionsOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriComputeVolumeFractionsOutputs(
        root=execution.output_file("."),
        output_cortex=execution.output_file(params.get("output_stem", None) + ".cortex.mgz"),
        output_subcort_gm=execution.output_file(params.get("output_stem", None) + ".subcort_gm.mgz"),
        output_wm=execution.output_file(params.get("output_stem", None) + ".wm.mgz"),
        output_csf=execution.output_file(params.get("output_stem", None) + ".csf.mgz"),
    )
    return ret


def mri_compute_volume_fractions_execute(
    params: MriComputeVolumeFractionsParamsDict,
    runner: Runner | None = None,
) -> MriComputeVolumeFractionsOutputs:
    """
    mri_compute_volume_fractions
    
    Computes partial volume fractions for cortex, subcortical GM, WM and CSF.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriComputeVolumeFractionsOutputs`).
    """
    mri_compute_volume_fractions_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_COMPUTE_VOLUME_FRACTIONS_METADATA)
    params = execution.params(params)
    cargs = mri_compute_volume_fractions_cargs(params, execution)
    ret = mri_compute_volume_fractions_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_compute_volume_fractions(
    output_stem: str,
    registration_file: InputPathType | None = None,
    regheader: str | None = None,
    usf: float | None = None,
    resolution: float | None = None,
    resmm: float | None = None,
    segmentation_file: InputPathType | None = None,
    wsurf: str | None = None,
    psurf: str | None = None,
    no_aseg: bool = False,
    stackfile: str | None = None,
    gmfile: str | None = None,
    no_fill_csf: bool = False,
    dilation: float | None = None,
    out_seg: str | None = None,
    ttseg: str | None = None,
    ttseg_ctab: str | None = None,
    mgz_format: bool = False,
    mgh_format: bool = False,
    nii_format: bool = False,
    nii_gz_format: bool = False,
    ttype_head: bool = False,
    vg_thresh: float | None = None,
    debug: bool = False,
    checkopts: bool = False,
    runner: Runner | None = None,
) -> MriComputeVolumeFractionsOutputs:
    """
    mri_compute_volume_fractions
    
    Computes partial volume fractions for cortex, subcortical GM, WM and CSF.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        output_stem: Output stem for generated files (e.g. cortex, subcort_gm,\
            wm, csf). Files will be saved with this stem in different formats based\
            on the selected flags.
        registration_file: Registration file (can be LTA or reg.dat). If using\
            reg.dat, a template volume is needed.
        regheader: Specify the subject for regheader.
        usf: Set anatomical upsample factor (default is 2).
        resolution: Resolution setting. Sets USF to round(1/res).
        resmm: Set functional upsampling resolution (default is\
            aseg->xsize/(USF)).
        segmentation_file: Use specified segmentation file instead of aseg.mgz.
        wsurf: Specify the white surface (default is 'white').
        psurf: Specify the pial surface (default is 'pial').
        no_aseg: Do not include aseg in processing (useful for testing).
        stackfile: Put cortex, subcortical GM, WM, CSF into a single\
            multi-frame file.
        gmfile: Put cortex + subcortical GM into a single-frame file.
        no_fill_csf: Do not attempt to fill voxels surrounding segmentation\
            with extracerebral CSF segmentation.
        dilation: For xCSF fill, dilate by specified number (default is 3). Use\
            -1 to fill the entire volume.
        out_seg: Save segmentation (after adding xCSF voxels).
        ttseg: Save tissue type segmentation.
        ttseg_ctab: Save tissue type segmentation color table.
        mgz_format: Use MGZ format.
        mgh_format: Use MGH format.
        nii_format: Use NII format.
        nii_gz_format: Use NII.GZ format.
        ttype_head: Use default+head instead of default tissue type info for\
            segmentation.
        vg_thresh: Threshold for 'ERROR: LTAconcat(): LTAs 0 and 1 do not\
            match'.
        debug: Turn on debugging mode.
        checkopts: Do not run anything, just check options and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriComputeVolumeFractionsOutputs`).
    """
    params = mri_compute_volume_fractions_params(
        output_stem=output_stem,
        registration_file=registration_file,
        regheader=regheader,
        usf=usf,
        resolution=resolution,
        resmm=resmm,
        segmentation_file=segmentation_file,
        wsurf=wsurf,
        psurf=psurf,
        no_aseg=no_aseg,
        stackfile=stackfile,
        gmfile=gmfile,
        no_fill_csf=no_fill_csf,
        dilation=dilation,
        out_seg=out_seg,
        ttseg=ttseg,
        ttseg_ctab=ttseg_ctab,
        mgz_format=mgz_format,
        mgh_format=mgh_format,
        nii_format=nii_format,
        nii_gz_format=nii_gz_format,
        ttype_head=ttype_head,
        vg_thresh=vg_thresh,
        debug=debug,
        checkopts=checkopts,
    )
    return mri_compute_volume_fractions_execute(params, runner)


__all__ = [
    "MRI_COMPUTE_VOLUME_FRACTIONS_METADATA",
    "MriComputeVolumeFractionsOutputs",
    "MriComputeVolumeFractionsParamsDict",
    "MriComputeVolumeFractionsParamsDictTagged",
    "mri_compute_volume_fractions",
    "mri_compute_volume_fractions_execute",
    "mri_compute_volume_fractions_params",
]
