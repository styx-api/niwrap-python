# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

BBMASK_METADATA = Metadata(
    id="a836059c0ed308457e36032736d75953ebf2eb7e.boutiques",
    name="bbmask",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_BbmaskParamsDictNoTag = typing.TypedDict('_BbmaskParamsDictNoTag', {
    "mask": list[InputPathType],
    "src_volumes": typing.NotRequired[list[InputPathType] | None],
    "npad": typing.NotRequired[float | None],
    "registration": typing.NotRequired[list[InputPathType] | None],
    "regheader": typing.NotRequired[InputPathType | None],
    "sub2src": typing.NotRequired[InputPathType | None],
})
BbmaskParamsDictTagged = typing.TypedDict('BbmaskParamsDictTagged', {
    "@type": typing.Literal["freesurfer/bbmask"],
    "mask": list[InputPathType],
    "src_volumes": typing.NotRequired[list[InputPathType] | None],
    "npad": typing.NotRequired[float | None],
    "registration": typing.NotRequired[list[InputPathType] | None],
    "regheader": typing.NotRequired[InputPathType | None],
    "sub2src": typing.NotRequired[InputPathType | None],
})
BbmaskParamsDict = _BbmaskParamsDictNoTag | BbmaskParamsDictTagged


class BbmaskOutputs(typing.NamedTuple):
    """
    Output object returned when calling `BbmaskParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    mask_output_file: OutputPathType
    """Output mask volume"""
    src_output_file: OutputPathType
    """Output reduced volume(s)"""
    registration_output_file: OutputPathType
    """Output registration file"""
    regheader_output_file: OutputPathType
    """Output registration file from regheader"""
    sub2src_output_file: OutputPathType
    """Output file for sub2src registration"""


def bbmask_params(
    mask: list[InputPathType],
    src_volumes: list[InputPathType] | None = None,
    npad: float | None = None,
    registration: list[InputPathType] | None = None,
    regheader: InputPathType | None = None,
    sub2src: InputPathType | None = None,
) -> BbmaskParamsDictTagged:
    """
    Build parameters.
    
    Args:
        mask: Input and output for the mask volume.
        src_volumes: Input and output volumes to be reduced to the bounding\
            box.
        npad: Number of voxels to expand the bounding box.
        registration: Input and output registration files.
        regheader: Output registration file from header.
        sub2src: Output file for sub-source registration.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/bbmask",
        "mask": mask,
    }
    if src_volumes is not None:
        params["src_volumes"] = src_volumes
    if npad is not None:
        params["npad"] = npad
    if registration is not None:
        params["registration"] = registration
    if regheader is not None:
        params["regheader"] = regheader
    if sub2src is not None:
        params["sub2src"] = sub2src
    return params


def bbmask_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `BbmaskParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("mask", None) is None:
        raise StyxValidationError("`mask` must not be None")
    if not isinstance(params["mask"], list):
        raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `list[InputPathType]`')
    if len(params["mask"]) != 2:
        raise StyxValidationError("Parameter `mask` must contain exactly 2 elements")
    for e in params["mask"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `list[InputPathType]`')
    if params.get("src_volumes", None) is not None:
        if not isinstance(params["src_volumes"], list):
            raise StyxValidationError(f'`src_volumes` has the wrong type: Received `{type(params.get("src_volumes", None))}` expected `list[InputPathType] | None`')
        if len(params["src_volumes"]) < 2:
            raise StyxValidationError("Parameter `src_volumes` must contain at least 2 elements")
        for e in params["src_volumes"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`src_volumes` has the wrong type: Received `{type(params.get("src_volumes", None))}` expected `list[InputPathType] | None`')
    if params.get("npad", None) is not None:
        if not isinstance(params["npad"], (float, int)):
            raise StyxValidationError(f'`npad` has the wrong type: Received `{type(params.get("npad", None))}` expected `float | None`')
    if params.get("registration", None) is not None:
        if not isinstance(params["registration"], list):
            raise StyxValidationError(f'`registration` has the wrong type: Received `{type(params.get("registration", None))}` expected `list[InputPathType] | None`')
        if len(params["registration"]) != 2:
            raise StyxValidationError("Parameter `registration` must contain exactly 2 elements")
        for e in params["registration"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`registration` has the wrong type: Received `{type(params.get("registration", None))}` expected `list[InputPathType] | None`')
    if params.get("regheader", None) is not None:
        if not isinstance(params["regheader"], (pathlib.Path, str)):
            raise StyxValidationError(f'`regheader` has the wrong type: Received `{type(params.get("regheader", None))}` expected `InputPathType | None`')
    if params.get("sub2src", None) is not None:
        if not isinstance(params["sub2src"], (pathlib.Path, str)):
            raise StyxValidationError(f'`sub2src` has the wrong type: Received `{type(params.get("sub2src", None))}` expected `InputPathType | None`')


def bbmask_cargs(
    params: BbmaskParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("bbmask")
    cargs.extend([
        "--mask",
        *[execution.input_file(f) for f in params.get("mask", None)]
    ])
    if params.get("src_volumes", None) is not None:
        cargs.extend([
            "--src",
            *[execution.input_file(f) for f in params.get("src_volumes", None)]
        ])
    if params.get("npad", None) is not None:
        cargs.extend([
            "--npad",
            str(params.get("npad", None))
        ])
    if params.get("registration", None) is not None:
        cargs.extend([
            "--reg",
            *[execution.input_file(f) for f in params.get("registration", None)]
        ])
    if params.get("regheader", None) is not None:
        cargs.extend([
            "--regheader",
            execution.input_file(params.get("regheader", None))
        ])
    if params.get("sub2src", None) is not None:
        cargs.extend([
            "--sub2src",
            execution.input_file(params.get("sub2src", None))
        ])
    return cargs


def bbmask_outputs(
    params: BbmaskParamsDict,
    execution: Execution,
) -> BbmaskOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = BbmaskOutputs(
        root=execution.output_file("."),
        mask_output_file=execution.output_file("[MASK_OUTPUT]"),
        src_output_file=execution.output_file("[SRC_OUTPUT]"),
        registration_output_file=execution.output_file("[REG_OUTPUT]"),
        regheader_output_file=execution.output_file("[REG_HEADER_OUTPUT]"),
        sub2src_output_file=execution.output_file("[SUB2SRC_OUTPUT]"),
    )
    return ret


def bbmask_execute(
    params: BbmaskParamsDict,
    runner: Runner | None = None,
) -> BbmaskOutputs:
    """
    bbmask
    
    Tool to create a volume with a smaller field of view by creating a bounding
    box that encompasses a mask.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `BbmaskOutputs`).
    """
    bbmask_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(BBMASK_METADATA)
    params = execution.params(params)
    cargs = bbmask_cargs(params, execution)
    ret = bbmask_outputs(params, execution)
    execution.run(cargs)
    return ret


def bbmask(
    mask: list[InputPathType],
    src_volumes: list[InputPathType] | None = None,
    npad: float | None = None,
    registration: list[InputPathType] | None = None,
    regheader: InputPathType | None = None,
    sub2src: InputPathType | None = None,
    runner: Runner | None = None,
) -> BbmaskOutputs:
    """
    bbmask
    
    Tool to create a volume with a smaller field of view by creating a bounding
    box that encompasses a mask.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        mask: Input and output for the mask volume.
        src_volumes: Input and output volumes to be reduced to the bounding\
            box.
        npad: Number of voxels to expand the bounding box.
        registration: Input and output registration files.
        regheader: Output registration file from header.
        sub2src: Output file for sub-source registration.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `BbmaskOutputs`).
    """
    params = bbmask_params(
        mask=mask,
        src_volumes=src_volumes,
        npad=npad,
        registration=registration,
        regheader=regheader,
        sub2src=sub2src,
    )
    return bbmask_execute(params, runner)


__all__ = [
    "BBMASK_METADATA",
    "BbmaskOutputs",
    "BbmaskParamsDict",
    "BbmaskParamsDictTagged",
    "bbmask",
    "bbmask_execute",
    "bbmask_params",
]
