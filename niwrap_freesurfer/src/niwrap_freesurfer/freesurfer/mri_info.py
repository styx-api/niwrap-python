# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_INFO_METADATA = Metadata(
    id="1d97a1ead36919cb2e69c8897c1d721d19426dcb.boutiques",
    name="mri_info",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriInfoParamsDictNoTag = typing.TypedDict('_MriInfoParamsDictNoTag', {
    "input1": InputPathType,
    "input2": typing.NotRequired[InputPathType | None],
    "conformed": bool,
    "conformed_to_min": bool,
    "is_1mm_iso": bool,
    "type": bool,
    "tr": bool,
    "te": bool,
    "ti": bool,
    "fa": bool,
    "pedir": bool,
    "res": bool,
    "cres": bool,
    "rres": bool,
    "sres": bool,
    "voxvol": bool,
    "voxvolsum": bool,
    "ncols": bool,
    "nrows": bool,
    "nslices": bool,
    "dim": bool,
    "cdc": bool,
    "rdc": bool,
    "sdc": bool,
    "vox2ras": bool,
    "ras2vox": bool,
    "vox2ras_tkr": bool,
    "ras2vox_tkr": bool,
    "vox2ras_fsl": bool,
    "tkr2scanner": bool,
    "scanner2tkr": bool,
    "ras_good": bool,
    "cras": bool,
    "center": bool,
    "zero_cras": bool,
    "p0": bool,
    "det": bool,
    "dof": bool,
    "nframes": bool,
    "mid_frame": bool,
    "format": bool,
    "orientation": bool,
    "slicedirection": bool,
    "autoalign": bool,
    "ctab": bool,
    "cmds": bool,
    "dump": bool,
    "voxel_crs": typing.NotRequired[list[str] | None],
    "entropy": bool,
    "output_file": typing.NotRequired[InputPathType | None],
    "orig_ras2vox": bool,
    "in_type": typing.NotRequired[str | None],
})
MriInfoParamsDictTagged = typing.TypedDict('MriInfoParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_info"],
    "input1": InputPathType,
    "input2": typing.NotRequired[InputPathType | None],
    "conformed": bool,
    "conformed_to_min": bool,
    "is_1mm_iso": bool,
    "type": bool,
    "tr": bool,
    "te": bool,
    "ti": bool,
    "fa": bool,
    "pedir": bool,
    "res": bool,
    "cres": bool,
    "rres": bool,
    "sres": bool,
    "voxvol": bool,
    "voxvolsum": bool,
    "ncols": bool,
    "nrows": bool,
    "nslices": bool,
    "dim": bool,
    "cdc": bool,
    "rdc": bool,
    "sdc": bool,
    "vox2ras": bool,
    "ras2vox": bool,
    "vox2ras_tkr": bool,
    "ras2vox_tkr": bool,
    "vox2ras_fsl": bool,
    "tkr2scanner": bool,
    "scanner2tkr": bool,
    "ras_good": bool,
    "cras": bool,
    "center": bool,
    "zero_cras": bool,
    "p0": bool,
    "det": bool,
    "dof": bool,
    "nframes": bool,
    "mid_frame": bool,
    "format": bool,
    "orientation": bool,
    "slicedirection": bool,
    "autoalign": bool,
    "ctab": bool,
    "cmds": bool,
    "dump": bool,
    "voxel_crs": typing.NotRequired[list[str] | None],
    "entropy": bool,
    "output_file": typing.NotRequired[InputPathType | None],
    "orig_ras2vox": bool,
    "in_type": typing.NotRequired[str | None],
})
MriInfoParamsDict = _MriInfoParamsDictNoTag | MriInfoParamsDictTagged


class MriInfoOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriInfoParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mri_info_params(
    input1: InputPathType,
    input2: InputPathType | None = None,
    conformed: bool = False,
    conformed_to_min: bool = False,
    is_1mm_iso: bool = False,
    type_: bool = False,
    tr: bool = False,
    te: bool = False,
    ti: bool = False,
    fa: bool = False,
    pedir: bool = False,
    res: bool = False,
    cres: bool = False,
    rres: bool = False,
    sres: bool = False,
    voxvol: bool = False,
    voxvolsum: bool = False,
    ncols: bool = False,
    nrows: bool = False,
    nslices: bool = False,
    dim: bool = False,
    cdc: bool = False,
    rdc: bool = False,
    sdc: bool = False,
    vox2ras: bool = False,
    ras2vox: bool = False,
    vox2ras_tkr: bool = False,
    ras2vox_tkr: bool = False,
    vox2ras_fsl: bool = False,
    tkr2scanner: bool = False,
    scanner2tkr: bool = False,
    ras_good: bool = False,
    cras: bool = False,
    center: bool = False,
    zero_cras: bool = False,
    p0: bool = False,
    det: bool = False,
    dof: bool = False,
    nframes: bool = False,
    mid_frame: bool = False,
    format_: bool = False,
    orientation: bool = False,
    slicedirection: bool = False,
    autoalign: bool = False,
    ctab: bool = False,
    cmds: bool = False,
    dump: bool = False,
    voxel_crs: list[str] | None = None,
    entropy: bool = False,
    output_file: InputPathType | None = None,
    orig_ras2vox: bool = False,
    in_type: str | None = None,
) -> MriInfoParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input1: Primary input file.
        input2: Secondary input file (optional).
        conformed: Print whether a volume is conformed.
        conformed_to_min: Print whether a volume is conformed-to-min.
        is_1mm_iso: Print whether the voxel size is 1mm isotropic.
        type_: Print the voxel type/precision.
        tr: Print TR.
        te: Print TE.
        ti: Print TI.
        fa: Print flip angle.
        pedir: Print phase encode direction.
        res: Print column, row, slice, and frame resolution.
        cres: Print column voxel size.
        rres: Print row voxel size.
        sres: Print slice voxel size.
        voxvol: Print voxel volume.
        voxvolsum: Compute sum of all voxels times the voxel volume.
        ncols: Print number of columns.
        nrows: Print number of rows.
        nslices: Print number of slices.
        dim: Print number of columns, rows, slices, and frames.
        cdc: Print column direction cosine (x_{r,a,s}).
        rdc: Print row direction cosine (y_{r,a,s}).
        sdc: Print slice direction cosine (z_{r,a,s}).
        vox2ras: Print the native/qform vox2ras matrix.
        ras2vox: Print the native/qform ras2vox matrix.
        vox2ras_tkr: Print the tkregister vox2ras matrix.
        ras2vox_tkr: Print the tkregister ras2vox matrix.
        vox2ras_fsl: Print the FSL/FLIRT vox2ras matrix.
        tkr2scanner: Print tkrRAS-to-scannerRAS matrix.
        scanner2tkr: Print scannerRAS-to-tkrRAS matrix.
        ras_good: Print the ras_good_flag.
        cras: Print the RAS near the center of the volume.
        center: Print the RAS at the actual center of the volume.
        zero_cras: Zero the center ras.
        p0: Print the RAS at voxel (0,0,0).
        det: Print the determinant of the vox2ras matrix.
        dof: Print the degrees of freedom stored in the header.
        nframes: Print the number of frames.
        mid_frame: Print the middle frame.
        format_: Print file format.
        orientation: Print orientation string (e.g., LPS, RAS, RPI).
        slicedirection: Print primary slice direction (e.g., axial).
        autoalign: Print auto align matrix (if it exists).
        ctab: Print embedded color lookup table.
        cmds: Print command-line provenance info.
        dump: Print FA, TR, TE, TI, etc.
        voxel_crs: Dump voxel value from column, row, slice (0-based, all\
            frames).
        entropy: Compute and print entropy.
        output_file: Print flagged results to file.
        orig_ras2vox: Print orig Ras2Vox matrix if present.
        in_type: Explicitly specify file type.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_info",
        "input1": input1,
        "conformed": conformed,
        "conformed_to_min": conformed_to_min,
        "is_1mm_iso": is_1mm_iso,
        "type": type_,
        "tr": tr,
        "te": te,
        "ti": ti,
        "fa": fa,
        "pedir": pedir,
        "res": res,
        "cres": cres,
        "rres": rres,
        "sres": sres,
        "voxvol": voxvol,
        "voxvolsum": voxvolsum,
        "ncols": ncols,
        "nrows": nrows,
        "nslices": nslices,
        "dim": dim,
        "cdc": cdc,
        "rdc": rdc,
        "sdc": sdc,
        "vox2ras": vox2ras,
        "ras2vox": ras2vox,
        "vox2ras_tkr": vox2ras_tkr,
        "ras2vox_tkr": ras2vox_tkr,
        "vox2ras_fsl": vox2ras_fsl,
        "tkr2scanner": tkr2scanner,
        "scanner2tkr": scanner2tkr,
        "ras_good": ras_good,
        "cras": cras,
        "center": center,
        "zero_cras": zero_cras,
        "p0": p0,
        "det": det,
        "dof": dof,
        "nframes": nframes,
        "mid_frame": mid_frame,
        "format": format_,
        "orientation": orientation,
        "slicedirection": slicedirection,
        "autoalign": autoalign,
        "ctab": ctab,
        "cmds": cmds,
        "dump": dump,
        "entropy": entropy,
        "orig_ras2vox": orig_ras2vox,
    }
    if input2 is not None:
        params["input2"] = input2
    if voxel_crs is not None:
        params["voxel_crs"] = voxel_crs
    if output_file is not None:
        params["output_file"] = output_file
    if in_type is not None:
        params["in_type"] = in_type
    return params


def mri_info_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriInfoParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input1", None) is None:
        raise StyxValidationError("`input1` must not be None")
    if not isinstance(params["input1"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input1` has the wrong type: Received `{type(params.get("input1", None))}` expected `InputPathType`')
    if params.get("input2", None) is not None:
        if not isinstance(params["input2"], (pathlib.Path, str)):
            raise StyxValidationError(f'`input2` has the wrong type: Received `{type(params.get("input2", None))}` expected `InputPathType | None`')
    if params.get("conformed", False) is None:
        raise StyxValidationError("`conformed` must not be None")
    if not isinstance(params["conformed"], bool):
        raise StyxValidationError(f'`conformed` has the wrong type: Received `{type(params.get("conformed", False))}` expected `bool`')
    if params.get("conformed_to_min", False) is None:
        raise StyxValidationError("`conformed_to_min` must not be None")
    if not isinstance(params["conformed_to_min"], bool):
        raise StyxValidationError(f'`conformed_to_min` has the wrong type: Received `{type(params.get("conformed_to_min", False))}` expected `bool`')
    if params.get("is_1mm_iso", False) is None:
        raise StyxValidationError("`is_1mm_iso` must not be None")
    if not isinstance(params["is_1mm_iso"], bool):
        raise StyxValidationError(f'`is_1mm_iso` has the wrong type: Received `{type(params.get("is_1mm_iso", False))}` expected `bool`')
    if params.get("type", False) is None:
        raise StyxValidationError("`type` must not be None")
    if not isinstance(params["type"], bool):
        raise StyxValidationError(f'`type` has the wrong type: Received `{type(params.get("type", False))}` expected `bool`')
    if params.get("tr", False) is None:
        raise StyxValidationError("`tr` must not be None")
    if not isinstance(params["tr"], bool):
        raise StyxValidationError(f'`tr` has the wrong type: Received `{type(params.get("tr", False))}` expected `bool`')
    if params.get("te", False) is None:
        raise StyxValidationError("`te` must not be None")
    if not isinstance(params["te"], bool):
        raise StyxValidationError(f'`te` has the wrong type: Received `{type(params.get("te", False))}` expected `bool`')
    if params.get("ti", False) is None:
        raise StyxValidationError("`ti` must not be None")
    if not isinstance(params["ti"], bool):
        raise StyxValidationError(f'`ti` has the wrong type: Received `{type(params.get("ti", False))}` expected `bool`')
    if params.get("fa", False) is None:
        raise StyxValidationError("`fa` must not be None")
    if not isinstance(params["fa"], bool):
        raise StyxValidationError(f'`fa` has the wrong type: Received `{type(params.get("fa", False))}` expected `bool`')
    if params.get("pedir", False) is None:
        raise StyxValidationError("`pedir` must not be None")
    if not isinstance(params["pedir"], bool):
        raise StyxValidationError(f'`pedir` has the wrong type: Received `{type(params.get("pedir", False))}` expected `bool`')
    if params.get("res", False) is None:
        raise StyxValidationError("`res` must not be None")
    if not isinstance(params["res"], bool):
        raise StyxValidationError(f'`res` has the wrong type: Received `{type(params.get("res", False))}` expected `bool`')
    if params.get("cres", False) is None:
        raise StyxValidationError("`cres` must not be None")
    if not isinstance(params["cres"], bool):
        raise StyxValidationError(f'`cres` has the wrong type: Received `{type(params.get("cres", False))}` expected `bool`')
    if params.get("rres", False) is None:
        raise StyxValidationError("`rres` must not be None")
    if not isinstance(params["rres"], bool):
        raise StyxValidationError(f'`rres` has the wrong type: Received `{type(params.get("rres", False))}` expected `bool`')
    if params.get("sres", False) is None:
        raise StyxValidationError("`sres` must not be None")
    if not isinstance(params["sres"], bool):
        raise StyxValidationError(f'`sres` has the wrong type: Received `{type(params.get("sres", False))}` expected `bool`')
    if params.get("voxvol", False) is None:
        raise StyxValidationError("`voxvol` must not be None")
    if not isinstance(params["voxvol"], bool):
        raise StyxValidationError(f'`voxvol` has the wrong type: Received `{type(params.get("voxvol", False))}` expected `bool`')
    if params.get("voxvolsum", False) is None:
        raise StyxValidationError("`voxvolsum` must not be None")
    if not isinstance(params["voxvolsum"], bool):
        raise StyxValidationError(f'`voxvolsum` has the wrong type: Received `{type(params.get("voxvolsum", False))}` expected `bool`')
    if params.get("ncols", False) is None:
        raise StyxValidationError("`ncols` must not be None")
    if not isinstance(params["ncols"], bool):
        raise StyxValidationError(f'`ncols` has the wrong type: Received `{type(params.get("ncols", False))}` expected `bool`')
    if params.get("nrows", False) is None:
        raise StyxValidationError("`nrows` must not be None")
    if not isinstance(params["nrows"], bool):
        raise StyxValidationError(f'`nrows` has the wrong type: Received `{type(params.get("nrows", False))}` expected `bool`')
    if params.get("nslices", False) is None:
        raise StyxValidationError("`nslices` must not be None")
    if not isinstance(params["nslices"], bool):
        raise StyxValidationError(f'`nslices` has the wrong type: Received `{type(params.get("nslices", False))}` expected `bool`')
    if params.get("dim", False) is None:
        raise StyxValidationError("`dim` must not be None")
    if not isinstance(params["dim"], bool):
        raise StyxValidationError(f'`dim` has the wrong type: Received `{type(params.get("dim", False))}` expected `bool`')
    if params.get("cdc", False) is None:
        raise StyxValidationError("`cdc` must not be None")
    if not isinstance(params["cdc"], bool):
        raise StyxValidationError(f'`cdc` has the wrong type: Received `{type(params.get("cdc", False))}` expected `bool`')
    if params.get("rdc", False) is None:
        raise StyxValidationError("`rdc` must not be None")
    if not isinstance(params["rdc"], bool):
        raise StyxValidationError(f'`rdc` has the wrong type: Received `{type(params.get("rdc", False))}` expected `bool`')
    if params.get("sdc", False) is None:
        raise StyxValidationError("`sdc` must not be None")
    if not isinstance(params["sdc"], bool):
        raise StyxValidationError(f'`sdc` has the wrong type: Received `{type(params.get("sdc", False))}` expected `bool`')
    if params.get("vox2ras", False) is None:
        raise StyxValidationError("`vox2ras` must not be None")
    if not isinstance(params["vox2ras"], bool):
        raise StyxValidationError(f'`vox2ras` has the wrong type: Received `{type(params.get("vox2ras", False))}` expected `bool`')
    if params.get("ras2vox", False) is None:
        raise StyxValidationError("`ras2vox` must not be None")
    if not isinstance(params["ras2vox"], bool):
        raise StyxValidationError(f'`ras2vox` has the wrong type: Received `{type(params.get("ras2vox", False))}` expected `bool`')
    if params.get("vox2ras_tkr", False) is None:
        raise StyxValidationError("`vox2ras_tkr` must not be None")
    if not isinstance(params["vox2ras_tkr"], bool):
        raise StyxValidationError(f'`vox2ras_tkr` has the wrong type: Received `{type(params.get("vox2ras_tkr", False))}` expected `bool`')
    if params.get("ras2vox_tkr", False) is None:
        raise StyxValidationError("`ras2vox_tkr` must not be None")
    if not isinstance(params["ras2vox_tkr"], bool):
        raise StyxValidationError(f'`ras2vox_tkr` has the wrong type: Received `{type(params.get("ras2vox_tkr", False))}` expected `bool`')
    if params.get("vox2ras_fsl", False) is None:
        raise StyxValidationError("`vox2ras_fsl` must not be None")
    if not isinstance(params["vox2ras_fsl"], bool):
        raise StyxValidationError(f'`vox2ras_fsl` has the wrong type: Received `{type(params.get("vox2ras_fsl", False))}` expected `bool`')
    if params.get("tkr2scanner", False) is None:
        raise StyxValidationError("`tkr2scanner` must not be None")
    if not isinstance(params["tkr2scanner"], bool):
        raise StyxValidationError(f'`tkr2scanner` has the wrong type: Received `{type(params.get("tkr2scanner", False))}` expected `bool`')
    if params.get("scanner2tkr", False) is None:
        raise StyxValidationError("`scanner2tkr` must not be None")
    if not isinstance(params["scanner2tkr"], bool):
        raise StyxValidationError(f'`scanner2tkr` has the wrong type: Received `{type(params.get("scanner2tkr", False))}` expected `bool`')
    if params.get("ras_good", False) is None:
        raise StyxValidationError("`ras_good` must not be None")
    if not isinstance(params["ras_good"], bool):
        raise StyxValidationError(f'`ras_good` has the wrong type: Received `{type(params.get("ras_good", False))}` expected `bool`')
    if params.get("cras", False) is None:
        raise StyxValidationError("`cras` must not be None")
    if not isinstance(params["cras"], bool):
        raise StyxValidationError(f'`cras` has the wrong type: Received `{type(params.get("cras", False))}` expected `bool`')
    if params.get("center", False) is None:
        raise StyxValidationError("`center` must not be None")
    if not isinstance(params["center"], bool):
        raise StyxValidationError(f'`center` has the wrong type: Received `{type(params.get("center", False))}` expected `bool`')
    if params.get("zero_cras", False) is None:
        raise StyxValidationError("`zero_cras` must not be None")
    if not isinstance(params["zero_cras"], bool):
        raise StyxValidationError(f'`zero_cras` has the wrong type: Received `{type(params.get("zero_cras", False))}` expected `bool`')
    if params.get("p0", False) is None:
        raise StyxValidationError("`p0` must not be None")
    if not isinstance(params["p0"], bool):
        raise StyxValidationError(f'`p0` has the wrong type: Received `{type(params.get("p0", False))}` expected `bool`')
    if params.get("det", False) is None:
        raise StyxValidationError("`det` must not be None")
    if not isinstance(params["det"], bool):
        raise StyxValidationError(f'`det` has the wrong type: Received `{type(params.get("det", False))}` expected `bool`')
    if params.get("dof", False) is None:
        raise StyxValidationError("`dof` must not be None")
    if not isinstance(params["dof"], bool):
        raise StyxValidationError(f'`dof` has the wrong type: Received `{type(params.get("dof", False))}` expected `bool`')
    if params.get("nframes", False) is None:
        raise StyxValidationError("`nframes` must not be None")
    if not isinstance(params["nframes"], bool):
        raise StyxValidationError(f'`nframes` has the wrong type: Received `{type(params.get("nframes", False))}` expected `bool`')
    if params.get("mid_frame", False) is None:
        raise StyxValidationError("`mid_frame` must not be None")
    if not isinstance(params["mid_frame"], bool):
        raise StyxValidationError(f'`mid_frame` has the wrong type: Received `{type(params.get("mid_frame", False))}` expected `bool`')
    if params.get("format", False) is None:
        raise StyxValidationError("`format` must not be None")
    if not isinstance(params["format"], bool):
        raise StyxValidationError(f'`format` has the wrong type: Received `{type(params.get("format", False))}` expected `bool`')
    if params.get("orientation", False) is None:
        raise StyxValidationError("`orientation` must not be None")
    if not isinstance(params["orientation"], bool):
        raise StyxValidationError(f'`orientation` has the wrong type: Received `{type(params.get("orientation", False))}` expected `bool`')
    if params.get("slicedirection", False) is None:
        raise StyxValidationError("`slicedirection` must not be None")
    if not isinstance(params["slicedirection"], bool):
        raise StyxValidationError(f'`slicedirection` has the wrong type: Received `{type(params.get("slicedirection", False))}` expected `bool`')
    if params.get("autoalign", False) is None:
        raise StyxValidationError("`autoalign` must not be None")
    if not isinstance(params["autoalign"], bool):
        raise StyxValidationError(f'`autoalign` has the wrong type: Received `{type(params.get("autoalign", False))}` expected `bool`')
    if params.get("ctab", False) is None:
        raise StyxValidationError("`ctab` must not be None")
    if not isinstance(params["ctab"], bool):
        raise StyxValidationError(f'`ctab` has the wrong type: Received `{type(params.get("ctab", False))}` expected `bool`')
    if params.get("cmds", False) is None:
        raise StyxValidationError("`cmds` must not be None")
    if not isinstance(params["cmds"], bool):
        raise StyxValidationError(f'`cmds` has the wrong type: Received `{type(params.get("cmds", False))}` expected `bool`')
    if params.get("dump", False) is None:
        raise StyxValidationError("`dump` must not be None")
    if not isinstance(params["dump"], bool):
        raise StyxValidationError(f'`dump` has the wrong type: Received `{type(params.get("dump", False))}` expected `bool`')
    if params.get("voxel_crs", None) is not None:
        if not isinstance(params["voxel_crs"], list):
            raise StyxValidationError(f'`voxel_crs` has the wrong type: Received `{type(params.get("voxel_crs", None))}` expected `list[str] | None`')
        if len(params["voxel_crs"]) != 3:
            raise StyxValidationError("Parameter `voxel_crs` must contain exactly 3 elements")
        for e in params["voxel_crs"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`voxel_crs` has the wrong type: Received `{type(params.get("voxel_crs", None))}` expected `list[str] | None`')
    if params.get("entropy", False) is None:
        raise StyxValidationError("`entropy` must not be None")
    if not isinstance(params["entropy"], bool):
        raise StyxValidationError(f'`entropy` has the wrong type: Received `{type(params.get("entropy", False))}` expected `bool`')
    if params.get("output_file", None) is not None:
        if not isinstance(params["output_file"], (pathlib.Path, str)):
            raise StyxValidationError(f'`output_file` has the wrong type: Received `{type(params.get("output_file", None))}` expected `InputPathType | None`')
    if params.get("orig_ras2vox", False) is None:
        raise StyxValidationError("`orig_ras2vox` must not be None")
    if not isinstance(params["orig_ras2vox"], bool):
        raise StyxValidationError(f'`orig_ras2vox` has the wrong type: Received `{type(params.get("orig_ras2vox", False))}` expected `bool`')
    if params.get("in_type", None) is not None:
        if not isinstance(params["in_type"], str):
            raise StyxValidationError(f'`in_type` has the wrong type: Received `{type(params.get("in_type", None))}` expected `str | None`')


def mri_info_cargs(
    params: MriInfoParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_info")
    cargs.append(execution.input_file(params.get("input1", None)))
    if params.get("input2", None) is not None:
        cargs.append(execution.input_file(params.get("input2", None)))
    if params.get("conformed", False):
        cargs.append("--conformed")
    if params.get("conformed_to_min", False):
        cargs.append("--conformed-to-min")
    if params.get("is_1mm_iso", False):
        cargs.append("--is-1mm-iso")
    if params.get("type", False):
        cargs.append("--type")
    if params.get("tr", False):
        cargs.append("--tr")
    if params.get("te", False):
        cargs.append("--te")
    if params.get("ti", False):
        cargs.append("--ti")
    if params.get("fa", False):
        cargs.append("--fa")
    if params.get("pedir", False):
        cargs.append("--pedir")
    if params.get("res", False):
        cargs.append("--res")
    if params.get("cres", False):
        cargs.append("--cres")
    if params.get("rres", False):
        cargs.append("--rres")
    if params.get("sres", False):
        cargs.append("--sres")
    if params.get("voxvol", False):
        cargs.append("--voxvol")
    if params.get("voxvolsum", False):
        cargs.append("--voxvolsum")
    if params.get("ncols", False):
        cargs.append("--ncols")
    if params.get("nrows", False):
        cargs.append("--nrows")
    if params.get("nslices", False):
        cargs.append("--nslices")
    if params.get("dim", False):
        cargs.append("--dim")
    if params.get("cdc", False):
        cargs.append("--cdc")
    if params.get("rdc", False):
        cargs.append("--rdc")
    if params.get("sdc", False):
        cargs.append("--sdc")
    if params.get("vox2ras", False):
        cargs.append("--vox2ras")
    if params.get("ras2vox", False):
        cargs.append("--ras2vox")
    if params.get("vox2ras_tkr", False):
        cargs.append("--vox2ras-tkr")
    if params.get("ras2vox_tkr", False):
        cargs.append("--ras2vox-tkr")
    if params.get("vox2ras_fsl", False):
        cargs.append("--vox2ras-fsl")
    if params.get("tkr2scanner", False):
        cargs.append("--tkr2scanner")
    if params.get("scanner2tkr", False):
        cargs.append("--scanner2tkr")
    if params.get("ras_good", False):
        cargs.append("--ras_good")
    if params.get("cras", False):
        cargs.append("--cras")
    if params.get("center", False):
        cargs.append("--center")
    if params.get("zero_cras", False):
        cargs.append("--zero-cras")
    if params.get("p0", False):
        cargs.append("--p0")
    if params.get("det", False):
        cargs.append("--det")
    if params.get("dof", False):
        cargs.append("--dof")
    if params.get("nframes", False):
        cargs.append("--nframes")
    if params.get("mid_frame", False):
        cargs.append("--mid-frame")
    if params.get("format", False):
        cargs.append("--format")
    if params.get("orientation", False):
        cargs.append("--orientation")
    if params.get("slicedirection", False):
        cargs.append("--slicedirection")
    if params.get("autoalign", False):
        cargs.append("--autoalign")
    if params.get("ctab", False):
        cargs.append("--ctab")
    if params.get("cmds", False):
        cargs.append("--cmds")
    if params.get("dump", False):
        cargs.append("--dump")
    if params.get("voxel_crs", None) is not None:
        cargs.extend([
            "--voxel",
            *params.get("voxel_crs", None)
        ])
    if params.get("entropy", False):
        cargs.append("--entropy")
    if params.get("output_file", None) is not None:
        cargs.extend([
            "--o",
            execution.input_file(params.get("output_file", None))
        ])
    if params.get("orig_ras2vox", False):
        cargs.append("--orig_ras2vox")
    if params.get("in_type", None) is not None:
        cargs.extend([
            "--in_type",
            params.get("in_type", None)
        ])
    return cargs


def mri_info_outputs(
    params: MriInfoParamsDict,
    execution: Execution,
) -> MriInfoOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriInfoOutputs(
        root=execution.output_file("."),
    )
    return ret


def mri_info_execute(
    params: MriInfoParamsDict,
    runner: Runner | None = None,
) -> MriInfoOutputs:
    """
    mri_info
    
    Tool to extract metadata from MRI volumes.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriInfoOutputs`).
    """
    mri_info_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_INFO_METADATA)
    params = execution.params(params)
    cargs = mri_info_cargs(params, execution)
    ret = mri_info_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_info(
    input1: InputPathType,
    input2: InputPathType | None = None,
    conformed: bool = False,
    conformed_to_min: bool = False,
    is_1mm_iso: bool = False,
    type_: bool = False,
    tr: bool = False,
    te: bool = False,
    ti: bool = False,
    fa: bool = False,
    pedir: bool = False,
    res: bool = False,
    cres: bool = False,
    rres: bool = False,
    sres: bool = False,
    voxvol: bool = False,
    voxvolsum: bool = False,
    ncols: bool = False,
    nrows: bool = False,
    nslices: bool = False,
    dim: bool = False,
    cdc: bool = False,
    rdc: bool = False,
    sdc: bool = False,
    vox2ras: bool = False,
    ras2vox: bool = False,
    vox2ras_tkr: bool = False,
    ras2vox_tkr: bool = False,
    vox2ras_fsl: bool = False,
    tkr2scanner: bool = False,
    scanner2tkr: bool = False,
    ras_good: bool = False,
    cras: bool = False,
    center: bool = False,
    zero_cras: bool = False,
    p0: bool = False,
    det: bool = False,
    dof: bool = False,
    nframes: bool = False,
    mid_frame: bool = False,
    format_: bool = False,
    orientation: bool = False,
    slicedirection: bool = False,
    autoalign: bool = False,
    ctab: bool = False,
    cmds: bool = False,
    dump: bool = False,
    voxel_crs: list[str] | None = None,
    entropy: bool = False,
    output_file: InputPathType | None = None,
    orig_ras2vox: bool = False,
    in_type: str | None = None,
    runner: Runner | None = None,
) -> MriInfoOutputs:
    """
    mri_info
    
    Tool to extract metadata from MRI volumes.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        input1: Primary input file.
        input2: Secondary input file (optional).
        conformed: Print whether a volume is conformed.
        conformed_to_min: Print whether a volume is conformed-to-min.
        is_1mm_iso: Print whether the voxel size is 1mm isotropic.
        type_: Print the voxel type/precision.
        tr: Print TR.
        te: Print TE.
        ti: Print TI.
        fa: Print flip angle.
        pedir: Print phase encode direction.
        res: Print column, row, slice, and frame resolution.
        cres: Print column voxel size.
        rres: Print row voxel size.
        sres: Print slice voxel size.
        voxvol: Print voxel volume.
        voxvolsum: Compute sum of all voxels times the voxel volume.
        ncols: Print number of columns.
        nrows: Print number of rows.
        nslices: Print number of slices.
        dim: Print number of columns, rows, slices, and frames.
        cdc: Print column direction cosine (x_{r,a,s}).
        rdc: Print row direction cosine (y_{r,a,s}).
        sdc: Print slice direction cosine (z_{r,a,s}).
        vox2ras: Print the native/qform vox2ras matrix.
        ras2vox: Print the native/qform ras2vox matrix.
        vox2ras_tkr: Print the tkregister vox2ras matrix.
        ras2vox_tkr: Print the tkregister ras2vox matrix.
        vox2ras_fsl: Print the FSL/FLIRT vox2ras matrix.
        tkr2scanner: Print tkrRAS-to-scannerRAS matrix.
        scanner2tkr: Print scannerRAS-to-tkrRAS matrix.
        ras_good: Print the ras_good_flag.
        cras: Print the RAS near the center of the volume.
        center: Print the RAS at the actual center of the volume.
        zero_cras: Zero the center ras.
        p0: Print the RAS at voxel (0,0,0).
        det: Print the determinant of the vox2ras matrix.
        dof: Print the degrees of freedom stored in the header.
        nframes: Print the number of frames.
        mid_frame: Print the middle frame.
        format_: Print file format.
        orientation: Print orientation string (e.g., LPS, RAS, RPI).
        slicedirection: Print primary slice direction (e.g., axial).
        autoalign: Print auto align matrix (if it exists).
        ctab: Print embedded color lookup table.
        cmds: Print command-line provenance info.
        dump: Print FA, TR, TE, TI, etc.
        voxel_crs: Dump voxel value from column, row, slice (0-based, all\
            frames).
        entropy: Compute and print entropy.
        output_file: Print flagged results to file.
        orig_ras2vox: Print orig Ras2Vox matrix if present.
        in_type: Explicitly specify file type.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriInfoOutputs`).
    """
    params = mri_info_params(
        input1=input1,
        input2=input2,
        conformed=conformed,
        conformed_to_min=conformed_to_min,
        is_1mm_iso=is_1mm_iso,
        type_=type_,
        tr=tr,
        te=te,
        ti=ti,
        fa=fa,
        pedir=pedir,
        res=res,
        cres=cres,
        rres=rres,
        sres=sres,
        voxvol=voxvol,
        voxvolsum=voxvolsum,
        ncols=ncols,
        nrows=nrows,
        nslices=nslices,
        dim=dim,
        cdc=cdc,
        rdc=rdc,
        sdc=sdc,
        vox2ras=vox2ras,
        ras2vox=ras2vox,
        vox2ras_tkr=vox2ras_tkr,
        ras2vox_tkr=ras2vox_tkr,
        vox2ras_fsl=vox2ras_fsl,
        tkr2scanner=tkr2scanner,
        scanner2tkr=scanner2tkr,
        ras_good=ras_good,
        cras=cras,
        center=center,
        zero_cras=zero_cras,
        p0=p0,
        det=det,
        dof=dof,
        nframes=nframes,
        mid_frame=mid_frame,
        format_=format_,
        orientation=orientation,
        slicedirection=slicedirection,
        autoalign=autoalign,
        ctab=ctab,
        cmds=cmds,
        dump=dump,
        voxel_crs=voxel_crs,
        entropy=entropy,
        output_file=output_file,
        orig_ras2vox=orig_ras2vox,
        in_type=in_type,
    )
    return mri_info_execute(params, runner)


__all__ = [
    "MRI_INFO_METADATA",
    "MriInfoOutputs",
    "MriInfoParamsDict",
    "MriInfoParamsDictTagged",
    "mri_info",
    "mri_info_execute",
    "mri_info_params",
]
