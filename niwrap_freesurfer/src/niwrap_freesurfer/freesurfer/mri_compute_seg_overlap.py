# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_COMPUTE_SEG_OVERLAP_METADATA = Metadata(
    id="cb7bdb7f79028467f821e5384b1d725873398a3c.boutiques",
    name="mri_compute_seg_overlap",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriComputeSegOverlapParamsDictNoTag = typing.TypedDict('_MriComputeSegOverlapParamsDictNoTag', {
    "segvol1": InputPathType,
    "segvol2": InputPathType,
    "log_file": typing.NotRequired[str | None],
    "mean_log_file": typing.NotRequired[str | None],
    "std_log_file": typing.NotRequired[str | None],
    "overall_log_flag": bool,
    "exclude_cortex_flag": bool,
    "exclude_wm_flag": bool,
    "all_labels_flag": bool,
    "dice_params": typing.NotRequired[str | None],
})
MriComputeSegOverlapParamsDictTagged = typing.TypedDict('MriComputeSegOverlapParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_compute_seg_overlap"],
    "segvol1": InputPathType,
    "segvol2": InputPathType,
    "log_file": typing.NotRequired[str | None],
    "mean_log_file": typing.NotRequired[str | None],
    "std_log_file": typing.NotRequired[str | None],
    "overall_log_flag": bool,
    "exclude_cortex_flag": bool,
    "exclude_wm_flag": bool,
    "all_labels_flag": bool,
    "dice_params": typing.NotRequired[str | None],
})
MriComputeSegOverlapParamsDict = _MriComputeSegOverlapParamsDictNoTag | MriComputeSegOverlapParamsDictTagged


class MriComputeSegOverlapOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriComputeSegOverlapParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def mri_compute_seg_overlap_params(
    segvol1: InputPathType,
    segvol2: InputPathType,
    log_file: str | None = None,
    mean_log_file: str | None = None,
    std_log_file: str | None = None,
    overall_log_flag: bool = False,
    exclude_cortex_flag: bool = False,
    exclude_wm_flag: bool = False,
    all_labels_flag: bool = False,
    dice_params: str | None = None,
) -> MriComputeSegOverlapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        segvol1: First segmentation volume.
        segvol2: Second segmentation volume.
        log_file: Log file for individual Dice coefficients for 12 structure\
            pairs, plus mean, std, and 'overall'.
        mean_log_file: Log file for mean Dice.
        std_log_file: Log file for std Dice.
        overall_log_flag: Log file for 'overall' Dice (mean excluding wm, gm,\
            and accumbens).
        exclude_cortex_flag: Exclude cerebral cortex labels from all\
            calculation. (0/1 flag, if nonzero).
        exclude_wm_flag: Exclude cerebral white matter labels from all\
            calculation. (0/1 flag, if nonzero).
        all_labels_flag: Check all labels, not just the predefined main\
            structures.
        dice_params: Standalone way to compute Dice coefficients, using seg1,\
            seg2, ctab, ReportEmpty01, ExcludeId, datfile, and tablefile as\
            additional parameters.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_compute_seg_overlap",
        "segvol1": segvol1,
        "segvol2": segvol2,
        "overall_log_flag": overall_log_flag,
        "exclude_cortex_flag": exclude_cortex_flag,
        "exclude_wm_flag": exclude_wm_flag,
        "all_labels_flag": all_labels_flag,
    }
    if log_file is not None:
        params["log_file"] = log_file
    if mean_log_file is not None:
        params["mean_log_file"] = mean_log_file
    if std_log_file is not None:
        params["std_log_file"] = std_log_file
    if dice_params is not None:
        params["dice_params"] = dice_params
    return params


def mri_compute_seg_overlap_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriComputeSegOverlapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("segvol1", None) is None:
        raise StyxValidationError("`segvol1` must not be None")
    if not isinstance(params["segvol1"], (pathlib.Path, str)):
        raise StyxValidationError(f'`segvol1` has the wrong type: Received `{type(params.get("segvol1", None))}` expected `InputPathType`')
    if params.get("segvol2", None) is None:
        raise StyxValidationError("`segvol2` must not be None")
    if not isinstance(params["segvol2"], (pathlib.Path, str)):
        raise StyxValidationError(f'`segvol2` has the wrong type: Received `{type(params.get("segvol2", None))}` expected `InputPathType`')
    if params.get("log_file", None) is not None:
        if not isinstance(params["log_file"], str):
            raise StyxValidationError(f'`log_file` has the wrong type: Received `{type(params.get("log_file", None))}` expected `str | None`')
    if params.get("mean_log_file", None) is not None:
        if not isinstance(params["mean_log_file"], str):
            raise StyxValidationError(f'`mean_log_file` has the wrong type: Received `{type(params.get("mean_log_file", None))}` expected `str | None`')
    if params.get("std_log_file", None) is not None:
        if not isinstance(params["std_log_file"], str):
            raise StyxValidationError(f'`std_log_file` has the wrong type: Received `{type(params.get("std_log_file", None))}` expected `str | None`')
    if params.get("overall_log_flag", False) is None:
        raise StyxValidationError("`overall_log_flag` must not be None")
    if not isinstance(params["overall_log_flag"], bool):
        raise StyxValidationError(f'`overall_log_flag` has the wrong type: Received `{type(params.get("overall_log_flag", False))}` expected `bool`')
    if params.get("exclude_cortex_flag", False) is None:
        raise StyxValidationError("`exclude_cortex_flag` must not be None")
    if not isinstance(params["exclude_cortex_flag"], bool):
        raise StyxValidationError(f'`exclude_cortex_flag` has the wrong type: Received `{type(params.get("exclude_cortex_flag", False))}` expected `bool`')
    if params.get("exclude_wm_flag", False) is None:
        raise StyxValidationError("`exclude_wm_flag` must not be None")
    if not isinstance(params["exclude_wm_flag"], bool):
        raise StyxValidationError(f'`exclude_wm_flag` has the wrong type: Received `{type(params.get("exclude_wm_flag", False))}` expected `bool`')
    if params.get("all_labels_flag", False) is None:
        raise StyxValidationError("`all_labels_flag` must not be None")
    if not isinstance(params["all_labels_flag"], bool):
        raise StyxValidationError(f'`all_labels_flag` has the wrong type: Received `{type(params.get("all_labels_flag", False))}` expected `bool`')
    if params.get("dice_params", None) is not None:
        if not isinstance(params["dice_params"], str):
            raise StyxValidationError(f'`dice_params` has the wrong type: Received `{type(params.get("dice_params", None))}` expected `str | None`')


def mri_compute_seg_overlap_cargs(
    params: MriComputeSegOverlapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_compute_seg_overlap")
    cargs.append(execution.input_file(params.get("segvol1", None)))
    cargs.append(execution.input_file(params.get("segvol2", None)))
    if params.get("log_file", None) is not None:
        cargs.extend([
            "-log",
            params.get("log_file", None)
        ])
    if params.get("mean_log_file", None) is not None:
        cargs.extend([
            "-mlog",
            params.get("mean_log_file", None)
        ])
    if params.get("std_log_file", None) is not None:
        cargs.extend([
            "-slog",
            params.get("std_log_file", None)
        ])
    if params.get("overall_log_flag", False):
        cargs.append("-olog")
    if params.get("exclude_cortex_flag", False):
        cargs.append("-cortex")
    if params.get("exclude_wm_flag", False):
        cargs.append("-wm")
    if params.get("all_labels_flag", False):
        cargs.append("-all_labels")
    if params.get("dice_params", None) is not None:
        cargs.extend([
            "-dice",
            params.get("dice_params", None)
        ])
    return cargs


def mri_compute_seg_overlap_outputs(
    params: MriComputeSegOverlapParamsDict,
    execution: Execution,
) -> MriComputeSegOverlapOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriComputeSegOverlapOutputs(
        root=execution.output_file("."),
    )
    return ret


def mri_compute_seg_overlap_execute(
    params: MriComputeSegOverlapParamsDict,
    runner: Runner | None = None,
) -> MriComputeSegOverlapOutputs:
    """
    mri_compute_seg_overlap
    
    Compute coefficients of overlap between segmentation volumes.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriComputeSegOverlapOutputs`).
    """
    mri_compute_seg_overlap_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_COMPUTE_SEG_OVERLAP_METADATA)
    params = execution.params(params)
    cargs = mri_compute_seg_overlap_cargs(params, execution)
    ret = mri_compute_seg_overlap_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_compute_seg_overlap(
    segvol1: InputPathType,
    segvol2: InputPathType,
    log_file: str | None = None,
    mean_log_file: str | None = None,
    std_log_file: str | None = None,
    overall_log_flag: bool = False,
    exclude_cortex_flag: bool = False,
    exclude_wm_flag: bool = False,
    all_labels_flag: bool = False,
    dice_params: str | None = None,
    runner: Runner | None = None,
) -> MriComputeSegOverlapOutputs:
    """
    mri_compute_seg_overlap
    
    Compute coefficients of overlap between segmentation volumes.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        segvol1: First segmentation volume.
        segvol2: Second segmentation volume.
        log_file: Log file for individual Dice coefficients for 12 structure\
            pairs, plus mean, std, and 'overall'.
        mean_log_file: Log file for mean Dice.
        std_log_file: Log file for std Dice.
        overall_log_flag: Log file for 'overall' Dice (mean excluding wm, gm,\
            and accumbens).
        exclude_cortex_flag: Exclude cerebral cortex labels from all\
            calculation. (0/1 flag, if nonzero).
        exclude_wm_flag: Exclude cerebral white matter labels from all\
            calculation. (0/1 flag, if nonzero).
        all_labels_flag: Check all labels, not just the predefined main\
            structures.
        dice_params: Standalone way to compute Dice coefficients, using seg1,\
            seg2, ctab, ReportEmpty01, ExcludeId, datfile, and tablefile as\
            additional parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriComputeSegOverlapOutputs`).
    """
    params = mri_compute_seg_overlap_params(
        segvol1=segvol1,
        segvol2=segvol2,
        log_file=log_file,
        mean_log_file=mean_log_file,
        std_log_file=std_log_file,
        overall_log_flag=overall_log_flag,
        exclude_cortex_flag=exclude_cortex_flag,
        exclude_wm_flag=exclude_wm_flag,
        all_labels_flag=all_labels_flag,
        dice_params=dice_params,
    )
    return mri_compute_seg_overlap_execute(params, runner)


__all__ = [
    "MRI_COMPUTE_SEG_OVERLAP_METADATA",
    "MriComputeSegOverlapOutputs",
    "MriComputeSegOverlapParamsDict",
    "MriComputeSegOverlapParamsDictTagged",
    "mri_compute_seg_overlap",
    "mri_compute_seg_overlap_execute",
    "mri_compute_seg_overlap_params",
]
