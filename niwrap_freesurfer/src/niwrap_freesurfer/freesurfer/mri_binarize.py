# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MRI_BINARIZE_METADATA = Metadata(
    id="a2558ecb51097bc4b25b69c0139e28c48bd342e8.boutiques",
    name="mri_binarize",
    package="freesurfer",
    container_image_tag="freesurfer/freesurfer:7.4.1",
)


_MriBinarizeParamsDictNoTag = typing.TypedDict('_MriBinarizeParamsDictNoTag', {
    "input_volume": InputPathType,
    "output_volume": str,
    "min_threshold": typing.NotRequired[float | None],
    "max_threshold": typing.NotRequired[float | None],
    "pct_threshold": typing.NotRequired[float | None],
    "rmin": typing.NotRequired[float | None],
    "rmax": typing.NotRequired[float | None],
    "fdr_threshold": typing.NotRequired[float | None],
    "match_values": typing.NotRequired[list[float] | None],
    "replace_values": typing.NotRequired[list[float] | None],
    "binval": typing.NotRequired[float | None],
    "binval_not": typing.NotRequired[float | None],
    "frame": typing.NotRequired[float | None],
    "merge_volume": typing.NotRequired[InputPathType | None],
    "mask_volume": typing.NotRequired[InputPathType | None],
    "mask_threshold": typing.NotRequired[float | None],
    "surf_name": typing.NotRequired[str | None],
    "surf_smooth": typing.NotRequired[float | None],
    "threads": typing.NotRequired[float | None],
    "ctx_wm_flag": bool,
    "all_wm_flag": bool,
    "ventricles_flag": bool,
    "wm_vcsf_flag": bool,
    "gm_flag": bool,
    "subcort_gm_flag": bool,
    "scm_lh_flag": bool,
    "scm_rh_flag": bool,
    "zero_edges_flag": bool,
    "zero_slice_edges_flag": bool,
    "dilate_vertex": typing.NotRequired[str | None],
    "remove_islands_flag": bool,
    "fill_holes_flag": bool,
    "noverbose_flag": bool,
    "debug_flag": bool,
})
MriBinarizeParamsDictTagged = typing.TypedDict('MriBinarizeParamsDictTagged', {
    "@type": typing.Literal["freesurfer/mri_binarize"],
    "input_volume": InputPathType,
    "output_volume": str,
    "min_threshold": typing.NotRequired[float | None],
    "max_threshold": typing.NotRequired[float | None],
    "pct_threshold": typing.NotRequired[float | None],
    "rmin": typing.NotRequired[float | None],
    "rmax": typing.NotRequired[float | None],
    "fdr_threshold": typing.NotRequired[float | None],
    "match_values": typing.NotRequired[list[float] | None],
    "replace_values": typing.NotRequired[list[float] | None],
    "binval": typing.NotRequired[float | None],
    "binval_not": typing.NotRequired[float | None],
    "frame": typing.NotRequired[float | None],
    "merge_volume": typing.NotRequired[InputPathType | None],
    "mask_volume": typing.NotRequired[InputPathType | None],
    "mask_threshold": typing.NotRequired[float | None],
    "surf_name": typing.NotRequired[str | None],
    "surf_smooth": typing.NotRequired[float | None],
    "threads": typing.NotRequired[float | None],
    "ctx_wm_flag": bool,
    "all_wm_flag": bool,
    "ventricles_flag": bool,
    "wm_vcsf_flag": bool,
    "gm_flag": bool,
    "subcort_gm_flag": bool,
    "scm_lh_flag": bool,
    "scm_rh_flag": bool,
    "zero_edges_flag": bool,
    "zero_slice_edges_flag": bool,
    "dilate_vertex": typing.NotRequired[str | None],
    "remove_islands_flag": bool,
    "fill_holes_flag": bool,
    "noverbose_flag": bool,
    "debug_flag": bool,
})
MriBinarizeParamsDict = _MriBinarizeParamsDictNoTag | MriBinarizeParamsDictTagged


class MriBinarizeOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MriBinarizeParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out_volume: OutputPathType
    """The resulting binarized volume."""


def mri_binarize_params(
    input_volume: InputPathType,
    output_volume: str,
    min_threshold: float | None = None,
    max_threshold: float | None = None,
    pct_threshold: float | None = None,
    rmin: float | None = None,
    rmax: float | None = None,
    fdr_threshold: float | None = None,
    match_values: list[float] | None = None,
    replace_values: list[float] | None = None,
    binval: float | None = None,
    binval_not: float | None = None,
    frame: float | None = None,
    merge_volume: InputPathType | None = None,
    mask_volume: InputPathType | None = None,
    mask_threshold: float | None = None,
    surf_name: str | None = None,
    surf_smooth: float | None = None,
    threads: float | None = None,
    ctx_wm_flag: bool = False,
    all_wm_flag: bool = False,
    ventricles_flag: bool = False,
    wm_vcsf_flag: bool = False,
    gm_flag: bool = False,
    subcort_gm_flag: bool = False,
    scm_lh_flag: bool = False,
    scm_rh_flag: bool = False,
    zero_edges_flag: bool = False,
    zero_slice_edges_flag: bool = False,
    dilate_vertex: str | None = None,
    remove_islands_flag: bool = False,
    fill_holes_flag: bool = False,
    noverbose_flag: bool = False,
    debug_flag: bool = False,
) -> MriBinarizeParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_volume: Input volume to be binarized.
        output_volume: Path to output volume.
        min_threshold: Minimum threshold (default is -inf).
        max_threshold: Maximum threshold (default is +inf).
        pct_threshold: Set threshold to capture top P% of voxels.
        rmin: Compute min threshold based on rmin times global mean.
        rmax: Compute max threshold based on rmax times global mean.
        fdr_threshold: Compute min threshold based on FDR.
        match_values: Binarize based on matching values.
        replace_values: Replace voxels with specified values. Format: V1 V2.
        binval: Set voxel value within threshold to specified value (default is\
            1).
        binval_not: Set voxel value outside threshold range to specified value\
            (default is 0).
        frame: Use specific frame of the input. 0-based index.
        merge_volume: Merge with another volume. Must be the same dimensions as\
            input volume.
        mask_volume: Mask input with a specified mask volume.
        mask_threshold: Set threshold for mask volume (default is 0.5).
        surf_name: Create a surface mesh from the binarization.
        surf_smooth: Smooth the surface mesh iteratively, specifying the number\
            of iterations.
        threads: Specify number of threads to use.
        ctx_wm_flag: Set match values for cerebral white matter.
        all_wm_flag: Set match values for all white matter.
        ventricles_flag: Set match values for ventricles and choroid.
        wm_vcsf_flag: Match for WM and ventricular CSF.
        gm_flag: Match for all WM, VCSF and background, then invert.
        subcort_gm_flag: Match for subcortical gray matter.
        scm_lh_flag: Subcortical mass for left hemisphere.
        scm_rh_flag: Subcortical mass for right hemisphere.
        zero_edges_flag: Set edge voxels to zero.
        zero_slice_edges_flag: Set edge slice voxels to zero.
        dilate_vertex: Dilate vertex to a specific target area.
        remove_islands_flag: Remove islands in the mask.
        fill_holes_flag: Remove holes in the mask.
        noverbose_flag: Suppress verbose output.
        debug_flag: Enable debugging output.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "freesurfer/mri_binarize",
        "input_volume": input_volume,
        "output_volume": output_volume,
        "ctx_wm_flag": ctx_wm_flag,
        "all_wm_flag": all_wm_flag,
        "ventricles_flag": ventricles_flag,
        "wm_vcsf_flag": wm_vcsf_flag,
        "gm_flag": gm_flag,
        "subcort_gm_flag": subcort_gm_flag,
        "scm_lh_flag": scm_lh_flag,
        "scm_rh_flag": scm_rh_flag,
        "zero_edges_flag": zero_edges_flag,
        "zero_slice_edges_flag": zero_slice_edges_flag,
        "remove_islands_flag": remove_islands_flag,
        "fill_holes_flag": fill_holes_flag,
        "noverbose_flag": noverbose_flag,
        "debug_flag": debug_flag,
    }
    if min_threshold is not None:
        params["min_threshold"] = min_threshold
    if max_threshold is not None:
        params["max_threshold"] = max_threshold
    if pct_threshold is not None:
        params["pct_threshold"] = pct_threshold
    if rmin is not None:
        params["rmin"] = rmin
    if rmax is not None:
        params["rmax"] = rmax
    if fdr_threshold is not None:
        params["fdr_threshold"] = fdr_threshold
    if match_values is not None:
        params["match_values"] = match_values
    if replace_values is not None:
        params["replace_values"] = replace_values
    if binval is not None:
        params["binval"] = binval
    if binval_not is not None:
        params["binval_not"] = binval_not
    if frame is not None:
        params["frame"] = frame
    if merge_volume is not None:
        params["merge_volume"] = merge_volume
    if mask_volume is not None:
        params["mask_volume"] = mask_volume
    if mask_threshold is not None:
        params["mask_threshold"] = mask_threshold
    if surf_name is not None:
        params["surf_name"] = surf_name
    if surf_smooth is not None:
        params["surf_smooth"] = surf_smooth
    if threads is not None:
        params["threads"] = threads
    if dilate_vertex is not None:
        params["dilate_vertex"] = dilate_vertex
    return params


def mri_binarize_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MriBinarizeParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input_volume", None) is None:
        raise StyxValidationError("`input_volume` must not be None")
    if not isinstance(params["input_volume"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input_volume` has the wrong type: Received `{type(params.get("input_volume", None))}` expected `InputPathType`')
    if params.get("output_volume", None) is None:
        raise StyxValidationError("`output_volume` must not be None")
    if not isinstance(params["output_volume"], str):
        raise StyxValidationError(f'`output_volume` has the wrong type: Received `{type(params.get("output_volume", None))}` expected `str`')
    if params.get("min_threshold", None) is not None:
        if not isinstance(params["min_threshold"], (float, int)):
            raise StyxValidationError(f'`min_threshold` has the wrong type: Received `{type(params.get("min_threshold", None))}` expected `float | None`')
    if params.get("max_threshold", None) is not None:
        if not isinstance(params["max_threshold"], (float, int)):
            raise StyxValidationError(f'`max_threshold` has the wrong type: Received `{type(params.get("max_threshold", None))}` expected `float | None`')
    if params.get("pct_threshold", None) is not None:
        if not isinstance(params["pct_threshold"], (float, int)):
            raise StyxValidationError(f'`pct_threshold` has the wrong type: Received `{type(params.get("pct_threshold", None))}` expected `float | None`')
    if params.get("rmin", None) is not None:
        if not isinstance(params["rmin"], (float, int)):
            raise StyxValidationError(f'`rmin` has the wrong type: Received `{type(params.get("rmin", None))}` expected `float | None`')
    if params.get("rmax", None) is not None:
        if not isinstance(params["rmax"], (float, int)):
            raise StyxValidationError(f'`rmax` has the wrong type: Received `{type(params.get("rmax", None))}` expected `float | None`')
    if params.get("fdr_threshold", None) is not None:
        if not isinstance(params["fdr_threshold"], (float, int)):
            raise StyxValidationError(f'`fdr_threshold` has the wrong type: Received `{type(params.get("fdr_threshold", None))}` expected `float | None`')
    if params.get("match_values", None) is not None:
        if not isinstance(params["match_values"], list):
            raise StyxValidationError(f'`match_values` has the wrong type: Received `{type(params.get("match_values", None))}` expected `list[float] | None`')
        for e in params["match_values"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`match_values` has the wrong type: Received `{type(params.get("match_values", None))}` expected `list[float] | None`')
    if params.get("replace_values", None) is not None:
        if not isinstance(params["replace_values"], list):
            raise StyxValidationError(f'`replace_values` has the wrong type: Received `{type(params.get("replace_values", None))}` expected `list[float] | None`')
        for e in params["replace_values"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`replace_values` has the wrong type: Received `{type(params.get("replace_values", None))}` expected `list[float] | None`')
    if params.get("binval", None) is not None:
        if not isinstance(params["binval"], (float, int)):
            raise StyxValidationError(f'`binval` has the wrong type: Received `{type(params.get("binval", None))}` expected `float | None`')
    if params.get("binval_not", None) is not None:
        if not isinstance(params["binval_not"], (float, int)):
            raise StyxValidationError(f'`binval_not` has the wrong type: Received `{type(params.get("binval_not", None))}` expected `float | None`')
    if params.get("frame", None) is not None:
        if not isinstance(params["frame"], (float, int)):
            raise StyxValidationError(f'`frame` has the wrong type: Received `{type(params.get("frame", None))}` expected `float | None`')
    if params.get("merge_volume", None) is not None:
        if not isinstance(params["merge_volume"], (pathlib.Path, str)):
            raise StyxValidationError(f'`merge_volume` has the wrong type: Received `{type(params.get("merge_volume", None))}` expected `InputPathType | None`')
    if params.get("mask_volume", None) is not None:
        if not isinstance(params["mask_volume"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask_volume` has the wrong type: Received `{type(params.get("mask_volume", None))}` expected `InputPathType | None`')
    if params.get("mask_threshold", None) is not None:
        if not isinstance(params["mask_threshold"], (float, int)):
            raise StyxValidationError(f'`mask_threshold` has the wrong type: Received `{type(params.get("mask_threshold", None))}` expected `float | None`')
    if params.get("surf_name", None) is not None:
        if not isinstance(params["surf_name"], str):
            raise StyxValidationError(f'`surf_name` has the wrong type: Received `{type(params.get("surf_name", None))}` expected `str | None`')
    if params.get("surf_smooth", None) is not None:
        if not isinstance(params["surf_smooth"], (float, int)):
            raise StyxValidationError(f'`surf_smooth` has the wrong type: Received `{type(params.get("surf_smooth", None))}` expected `float | None`')
    if params.get("threads", None) is not None:
        if not isinstance(params["threads"], (float, int)):
            raise StyxValidationError(f'`threads` has the wrong type: Received `{type(params.get("threads", None))}` expected `float | None`')
    if params.get("ctx_wm_flag", False) is None:
        raise StyxValidationError("`ctx_wm_flag` must not be None")
    if not isinstance(params["ctx_wm_flag"], bool):
        raise StyxValidationError(f'`ctx_wm_flag` has the wrong type: Received `{type(params.get("ctx_wm_flag", False))}` expected `bool`')
    if params.get("all_wm_flag", False) is None:
        raise StyxValidationError("`all_wm_flag` must not be None")
    if not isinstance(params["all_wm_flag"], bool):
        raise StyxValidationError(f'`all_wm_flag` has the wrong type: Received `{type(params.get("all_wm_flag", False))}` expected `bool`')
    if params.get("ventricles_flag", False) is None:
        raise StyxValidationError("`ventricles_flag` must not be None")
    if not isinstance(params["ventricles_flag"], bool):
        raise StyxValidationError(f'`ventricles_flag` has the wrong type: Received `{type(params.get("ventricles_flag", False))}` expected `bool`')
    if params.get("wm_vcsf_flag", False) is None:
        raise StyxValidationError("`wm_vcsf_flag` must not be None")
    if not isinstance(params["wm_vcsf_flag"], bool):
        raise StyxValidationError(f'`wm_vcsf_flag` has the wrong type: Received `{type(params.get("wm_vcsf_flag", False))}` expected `bool`')
    if params.get("gm_flag", False) is None:
        raise StyxValidationError("`gm_flag` must not be None")
    if not isinstance(params["gm_flag"], bool):
        raise StyxValidationError(f'`gm_flag` has the wrong type: Received `{type(params.get("gm_flag", False))}` expected `bool`')
    if params.get("subcort_gm_flag", False) is None:
        raise StyxValidationError("`subcort_gm_flag` must not be None")
    if not isinstance(params["subcort_gm_flag"], bool):
        raise StyxValidationError(f'`subcort_gm_flag` has the wrong type: Received `{type(params.get("subcort_gm_flag", False))}` expected `bool`')
    if params.get("scm_lh_flag", False) is None:
        raise StyxValidationError("`scm_lh_flag` must not be None")
    if not isinstance(params["scm_lh_flag"], bool):
        raise StyxValidationError(f'`scm_lh_flag` has the wrong type: Received `{type(params.get("scm_lh_flag", False))}` expected `bool`')
    if params.get("scm_rh_flag", False) is None:
        raise StyxValidationError("`scm_rh_flag` must not be None")
    if not isinstance(params["scm_rh_flag"], bool):
        raise StyxValidationError(f'`scm_rh_flag` has the wrong type: Received `{type(params.get("scm_rh_flag", False))}` expected `bool`')
    if params.get("zero_edges_flag", False) is None:
        raise StyxValidationError("`zero_edges_flag` must not be None")
    if not isinstance(params["zero_edges_flag"], bool):
        raise StyxValidationError(f'`zero_edges_flag` has the wrong type: Received `{type(params.get("zero_edges_flag", False))}` expected `bool`')
    if params.get("zero_slice_edges_flag", False) is None:
        raise StyxValidationError("`zero_slice_edges_flag` must not be None")
    if not isinstance(params["zero_slice_edges_flag"], bool):
        raise StyxValidationError(f'`zero_slice_edges_flag` has the wrong type: Received `{type(params.get("zero_slice_edges_flag", False))}` expected `bool`')
    if params.get("dilate_vertex", None) is not None:
        if not isinstance(params["dilate_vertex"], str):
            raise StyxValidationError(f'`dilate_vertex` has the wrong type: Received `{type(params.get("dilate_vertex", None))}` expected `str | None`')
    if params.get("remove_islands_flag", False) is None:
        raise StyxValidationError("`remove_islands_flag` must not be None")
    if not isinstance(params["remove_islands_flag"], bool):
        raise StyxValidationError(f'`remove_islands_flag` has the wrong type: Received `{type(params.get("remove_islands_flag", False))}` expected `bool`')
    if params.get("fill_holes_flag", False) is None:
        raise StyxValidationError("`fill_holes_flag` must not be None")
    if not isinstance(params["fill_holes_flag"], bool):
        raise StyxValidationError(f'`fill_holes_flag` has the wrong type: Received `{type(params.get("fill_holes_flag", False))}` expected `bool`')
    if params.get("noverbose_flag", False) is None:
        raise StyxValidationError("`noverbose_flag` must not be None")
    if not isinstance(params["noverbose_flag"], bool):
        raise StyxValidationError(f'`noverbose_flag` has the wrong type: Received `{type(params.get("noverbose_flag", False))}` expected `bool`')
    if params.get("debug_flag", False) is None:
        raise StyxValidationError("`debug_flag` must not be None")
    if not isinstance(params["debug_flag"], bool):
        raise StyxValidationError(f'`debug_flag` has the wrong type: Received `{type(params.get("debug_flag", False))}` expected `bool`')


def mri_binarize_cargs(
    params: MriBinarizeParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("mri_binarize")
    cargs.extend([
        "--i",
        execution.input_file(params.get("input_volume", None))
    ])
    cargs.extend([
        "--o",
        params.get("output_volume", None)
    ])
    if params.get("min_threshold", None) is not None:
        cargs.extend([
            "--min",
            str(params.get("min_threshold", None))
        ])
    if params.get("max_threshold", None) is not None:
        cargs.extend([
            "--max",
            str(params.get("max_threshold", None))
        ])
    if params.get("pct_threshold", None) is not None:
        cargs.extend([
            "--pct",
            str(params.get("pct_threshold", None))
        ])
    if params.get("rmin", None) is not None:
        cargs.extend([
            "--rmin",
            str(params.get("rmin", None))
        ])
    if params.get("rmax", None) is not None:
        cargs.extend([
            "--rmax",
            str(params.get("rmax", None))
        ])
    if params.get("fdr_threshold", None) is not None:
        cargs.extend([
            "--fdr",
            str(params.get("fdr_threshold", None))
        ])
    if params.get("match_values", None) is not None:
        cargs.extend([
            "--match",
            *map(str, params.get("match_values", None))
        ])
    if params.get("replace_values", None) is not None:
        cargs.extend([
            "--replace",
            *map(str, params.get("replace_values", None))
        ])
    if params.get("binval", None) is not None:
        cargs.extend([
            "--binval",
            str(params.get("binval", None))
        ])
    if params.get("binval_not", None) is not None:
        cargs.extend([
            "--binvalnot",
            str(params.get("binval_not", None))
        ])
    if params.get("frame", None) is not None:
        cargs.extend([
            "--frame",
            str(params.get("frame", None))
        ])
    if params.get("merge_volume", None) is not None:
        cargs.extend([
            "--merge",
            execution.input_file(params.get("merge_volume", None))
        ])
    if params.get("mask_volume", None) is not None:
        cargs.extend([
            "--mask",
            execution.input_file(params.get("mask_volume", None))
        ])
    if params.get("mask_threshold", None) is not None:
        cargs.extend([
            "--mask-thresh",
            str(params.get("mask_threshold", None))
        ])
    if params.get("surf_name", None) is not None:
        cargs.extend([
            "--surf",
            params.get("surf_name", None)
        ])
    if params.get("surf_smooth", None) is not None:
        cargs.extend([
            "--surf-smooth",
            str(params.get("surf_smooth", None))
        ])
    if params.get("threads", None) is not None:
        cargs.extend([
            "--threads",
            str(params.get("threads", None))
        ])
    if params.get("ctx_wm_flag", False):
        cargs.append("--ctx-wm")
    if params.get("all_wm_flag", False):
        cargs.append("--all-wm")
    if params.get("ventricles_flag", False):
        cargs.append("--ventricles")
    if params.get("wm_vcsf_flag", False):
        cargs.append("--wm+vcsf")
    if params.get("gm_flag", False):
        cargs.append("--gm")
    if params.get("subcort_gm_flag", False):
        cargs.append("--subcort-gm")
    if params.get("scm_lh_flag", False):
        cargs.append("--scm-lh")
    if params.get("scm_rh_flag", False):
        cargs.append("--scm-rh")
    if params.get("zero_edges_flag", False):
        cargs.append("--zero-edges")
    if params.get("zero_slice_edges_flag", False):
        cargs.append("--zero-slice-edges")
    if params.get("dilate_vertex", None) is not None:
        cargs.extend([
            "--dilate-vertex",
            params.get("dilate_vertex", None)
        ])
    if params.get("remove_islands_flag", False):
        cargs.append("--remove-islands")
    if params.get("fill_holes_flag", False):
        cargs.append("--fill-holes")
    if params.get("noverbose_flag", False):
        cargs.append("--noverbose")
    if params.get("debug_flag", False):
        cargs.append("--debug")
    return cargs


def mri_binarize_outputs(
    params: MriBinarizeParamsDict,
    execution: Execution,
) -> MriBinarizeOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MriBinarizeOutputs(
        root=execution.output_file("."),
        out_volume=execution.output_file(params.get("output_volume", None)),
    )
    return ret


def mri_binarize_execute(
    params: MriBinarizeParamsDict,
    runner: Runner | None = None,
) -> MriBinarizeOutputs:
    """
    mri_binarize
    
    A program to binarize a volume or volume-encoded surface file, with options
    to merge and manipulate binarized output.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriBinarizeOutputs`).
    """
    mri_binarize_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MRI_BINARIZE_METADATA)
    params = execution.params(params)
    cargs = mri_binarize_cargs(params, execution)
    ret = mri_binarize_outputs(params, execution)
    execution.run(cargs)
    return ret


def mri_binarize(
    input_volume: InputPathType,
    output_volume: str,
    min_threshold: float | None = None,
    max_threshold: float | None = None,
    pct_threshold: float | None = None,
    rmin: float | None = None,
    rmax: float | None = None,
    fdr_threshold: float | None = None,
    match_values: list[float] | None = None,
    replace_values: list[float] | None = None,
    binval: float | None = None,
    binval_not: float | None = None,
    frame: float | None = None,
    merge_volume: InputPathType | None = None,
    mask_volume: InputPathType | None = None,
    mask_threshold: float | None = None,
    surf_name: str | None = None,
    surf_smooth: float | None = None,
    threads: float | None = None,
    ctx_wm_flag: bool = False,
    all_wm_flag: bool = False,
    ventricles_flag: bool = False,
    wm_vcsf_flag: bool = False,
    gm_flag: bool = False,
    subcort_gm_flag: bool = False,
    scm_lh_flag: bool = False,
    scm_rh_flag: bool = False,
    zero_edges_flag: bool = False,
    zero_slice_edges_flag: bool = False,
    dilate_vertex: str | None = None,
    remove_islands_flag: bool = False,
    fill_holes_flag: bool = False,
    noverbose_flag: bool = False,
    debug_flag: bool = False,
    runner: Runner | None = None,
) -> MriBinarizeOutputs:
    """
    mri_binarize
    
    A program to binarize a volume or volume-encoded surface file, with options
    to merge and manipulate binarized output.
    
    Author: FreeSurfer Developers
    
    URL: https://github.com/freesurfer/freesurfer
    
    Args:
        input_volume: Input volume to be binarized.
        output_volume: Path to output volume.
        min_threshold: Minimum threshold (default is -inf).
        max_threshold: Maximum threshold (default is +inf).
        pct_threshold: Set threshold to capture top P% of voxels.
        rmin: Compute min threshold based on rmin times global mean.
        rmax: Compute max threshold based on rmax times global mean.
        fdr_threshold: Compute min threshold based on FDR.
        match_values: Binarize based on matching values.
        replace_values: Replace voxels with specified values. Format: V1 V2.
        binval: Set voxel value within threshold to specified value (default is\
            1).
        binval_not: Set voxel value outside threshold range to specified value\
            (default is 0).
        frame: Use specific frame of the input. 0-based index.
        merge_volume: Merge with another volume. Must be the same dimensions as\
            input volume.
        mask_volume: Mask input with a specified mask volume.
        mask_threshold: Set threshold for mask volume (default is 0.5).
        surf_name: Create a surface mesh from the binarization.
        surf_smooth: Smooth the surface mesh iteratively, specifying the number\
            of iterations.
        threads: Specify number of threads to use.
        ctx_wm_flag: Set match values for cerebral white matter.
        all_wm_flag: Set match values for all white matter.
        ventricles_flag: Set match values for ventricles and choroid.
        wm_vcsf_flag: Match for WM and ventricular CSF.
        gm_flag: Match for all WM, VCSF and background, then invert.
        subcort_gm_flag: Match for subcortical gray matter.
        scm_lh_flag: Subcortical mass for left hemisphere.
        scm_rh_flag: Subcortical mass for right hemisphere.
        zero_edges_flag: Set edge voxels to zero.
        zero_slice_edges_flag: Set edge slice voxels to zero.
        dilate_vertex: Dilate vertex to a specific target area.
        remove_islands_flag: Remove islands in the mask.
        fill_holes_flag: Remove holes in the mask.
        noverbose_flag: Suppress verbose output.
        debug_flag: Enable debugging output.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MriBinarizeOutputs`).
    """
    params = mri_binarize_params(
        input_volume=input_volume,
        output_volume=output_volume,
        min_threshold=min_threshold,
        max_threshold=max_threshold,
        pct_threshold=pct_threshold,
        rmin=rmin,
        rmax=rmax,
        fdr_threshold=fdr_threshold,
        match_values=match_values,
        replace_values=replace_values,
        binval=binval,
        binval_not=binval_not,
        frame=frame,
        merge_volume=merge_volume,
        mask_volume=mask_volume,
        mask_threshold=mask_threshold,
        surf_name=surf_name,
        surf_smooth=surf_smooth,
        threads=threads,
        ctx_wm_flag=ctx_wm_flag,
        all_wm_flag=all_wm_flag,
        ventricles_flag=ventricles_flag,
        wm_vcsf_flag=wm_vcsf_flag,
        gm_flag=gm_flag,
        subcort_gm_flag=subcort_gm_flag,
        scm_lh_flag=scm_lh_flag,
        scm_rh_flag=scm_rh_flag,
        zero_edges_flag=zero_edges_flag,
        zero_slice_edges_flag=zero_slice_edges_flag,
        dilate_vertex=dilate_vertex,
        remove_islands_flag=remove_islands_flag,
        fill_holes_flag=fill_holes_flag,
        noverbose_flag=noverbose_flag,
        debug_flag=debug_flag,
    )
    return mri_binarize_execute(params, runner)


__all__ = [
    "MRI_BINARIZE_METADATA",
    "MriBinarizeOutputs",
    "MriBinarizeParamsDict",
    "MriBinarizeParamsDictTagged",
    "mri_binarize",
    "mri_binarize_execute",
    "mri_binarize_params",
]
