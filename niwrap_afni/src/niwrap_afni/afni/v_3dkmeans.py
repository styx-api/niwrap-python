# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

V_3DKMEANS_METADATA = Metadata(
    id="4659eac7c7853548ba4e9fb9cedfdec6b3bfd618.boutiques",
    name="3dkmeans",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_V3dkmeansParamsDictNoTag = typing.TypedDict('_V3dkmeansParamsDictNoTag', {
    "version": bool,
    "input": list[InputPathType],
    "mask": typing.NotRequired[InputPathType | None],
    "mask_range": typing.NotRequired[list[float] | None],
    "cmask": typing.NotRequired[str | None],
    "jobname": typing.NotRequired[str | None],
    "prefix": typing.NotRequired[str | None],
    "distance_measure": typing.NotRequired[float | None],
    "num_clusters": typing.NotRequired[float | None],
    "remap_method": typing.NotRequired[str | None],
    "labeltable": typing.NotRequired[InputPathType | None],
    "clabels": typing.NotRequired[list[str] | None],
    "clust_init": typing.NotRequired[InputPathType | None],
    "num_repeats": typing.NotRequired[float | None],
    "rsigs": typing.NotRequired[InputPathType | None],
    "verbose": bool,
    "write_dists": bool,
    "voxdbg": typing.NotRequired[list[float] | None],
    "seed": typing.NotRequired[float | None],
})
V3dkmeansParamsDictTagged = typing.TypedDict('V3dkmeansParamsDictTagged', {
    "@type": typing.Literal["afni/3dkmeans"],
    "version": bool,
    "input": list[InputPathType],
    "mask": typing.NotRequired[InputPathType | None],
    "mask_range": typing.NotRequired[list[float] | None],
    "cmask": typing.NotRequired[str | None],
    "jobname": typing.NotRequired[str | None],
    "prefix": typing.NotRequired[str | None],
    "distance_measure": typing.NotRequired[float | None],
    "num_clusters": typing.NotRequired[float | None],
    "remap_method": typing.NotRequired[str | None],
    "labeltable": typing.NotRequired[InputPathType | None],
    "clabels": typing.NotRequired[list[str] | None],
    "clust_init": typing.NotRequired[InputPathType | None],
    "num_repeats": typing.NotRequired[float | None],
    "rsigs": typing.NotRequired[InputPathType | None],
    "verbose": bool,
    "write_dists": bool,
    "voxdbg": typing.NotRequired[list[float] | None],
    "seed": typing.NotRequired[float | None],
})
V3dkmeansParamsDict = _V3dkmeansParamsDictNoTag | V3dkmeansParamsDictTagged


class V3dkmeansOutputs(typing.NamedTuple):
    """
    Output object returned when calling `V3dkmeansParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    cluster_membership: OutputPathType | None
    """Output volume for the cluster membership."""
    cluster_distance: OutputPathType | None
    """Output volume for the cluster distance measures."""
    distances_text_file: OutputPathType
    """Output text file containing distances between clusters."""
    centroids_text_file: OutputPathType
    """Output text file containing cluster centroids."""
    within_cluster_sum_text_file: OutputPathType
    """Output text file containing within cluster sum of distances."""
    max_distance_text_file: OutputPathType
    """Output text file containing maximum distance within each cluster."""
    voxel_distance_to_centroid: OutputPathType
    """Output text file containing distance from voxel to its centroid."""


def v_3dkmeans_params(
    input_: list[InputPathType],
    version: bool = False,
    mask: InputPathType | None = None,
    mask_range: list[float] | None = None,
    cmask: str | None = None,
    jobname: str | None = None,
    prefix: str | None = None,
    distance_measure: float | None = None,
    num_clusters: float | None = None,
    remap_method: str | None = None,
    labeltable: InputPathType | None = None,
    clabels: list[str] | None = None,
    clust_init: InputPathType | None = None,
    num_repeats: float | None = None,
    rsigs: InputPathType | None = None,
    verbose: bool = False,
    write_dists: bool = False,
    voxdbg: list[float] | None = None,
    seed: float | None = None,
) -> V3dkmeansParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_: Input data to be clustered. You can specify multiple filenames\
            in sequence and they will be concatenated internally.
        version:.
        mask: Dataset to be used as a mask; only voxels with nonzero values in\
            'mset' will be used.
        mask_range: Restrict the voxels from 'mset' to only those mask values\
            between 'a' and 'b' (inclusive).
        cmask: Execute the options enclosed in single quotes as a 3dcalc-like\
            program to produce a mask from the resulting 3D brick.
        jobname: Specify a different name for the output files. Default is\
            derived from the input file name.
        prefix: Specify a prefix for the output volumes. Default is the same as\
            jobname.
        distance_measure: Specifies distance measure for clustering. Supported\
            values: 0 (No clustering), 1 (Uncentered correlation distance), 2\
            (Pearson distance), 3 (Uncentered correlation distance, absolute\
            value), 4 (Pearson distance, absolute value), 5 (Spearman's rank\
            distance), 6 (Kendall's distance), 7 (Euclidean distance), 8\
            (City-block distance).
        num_clusters: Specify number of clusters.
        remap_method: Reassign clusters numbers based on METHOD: NONE\
            (default), COUNT, iCOUNT, MAG, iMAG.
        labeltable: Attach labeltable to clustering output.
        clabels: Provide a label for each cluster. Labels cannot start with\
            '-'.
        clust_init: Specify a dataset to initialize clustering. If provided,\
            sets -r 0.
        num_repeats: Number of times the k-means clustering algorithm is run.
        rsigs: Calculate distances from each voxel's signature to the\
            signatures in this multi-column file. No clustering done.
        verbose: Enable verbose mode.
        write_dists: Output text files containing various distance measures.
        voxdbg: Output debugging info for specified voxel (I J K).
        seed: Seed for the random number generator. Default is 1234567.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/3dkmeans",
        "version": version,
        "input": input_,
        "verbose": verbose,
        "write_dists": write_dists,
    }
    if mask is not None:
        params["mask"] = mask
    if mask_range is not None:
        params["mask_range"] = mask_range
    if cmask is not None:
        params["cmask"] = cmask
    if jobname is not None:
        params["jobname"] = jobname
    if prefix is not None:
        params["prefix"] = prefix
    if distance_measure is not None:
        params["distance_measure"] = distance_measure
    if num_clusters is not None:
        params["num_clusters"] = num_clusters
    if remap_method is not None:
        params["remap_method"] = remap_method
    if labeltable is not None:
        params["labeltable"] = labeltable
    if clabels is not None:
        params["clabels"] = clabels
    if clust_init is not None:
        params["clust_init"] = clust_init
    if num_repeats is not None:
        params["num_repeats"] = num_repeats
    if rsigs is not None:
        params["rsigs"] = rsigs
    if voxdbg is not None:
        params["voxdbg"] = voxdbg
    if seed is not None:
        params["seed"] = seed
    return params


def v_3dkmeans_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `V3dkmeansParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("version", False) is None:
        raise StyxValidationError("`version` must not be None")
    if not isinstance(params["version"], bool):
        raise StyxValidationError(f'`version` has the wrong type: Received `{type(params.get("version", False))}` expected `bool`')
    if params.get("input", None) is None:
        raise StyxValidationError("`input` must not be None")
    if not isinstance(params["input"], list):
        raise StyxValidationError(f'`input` has the wrong type: Received `{type(params.get("input", None))}` expected `list[InputPathType]`')
    for e in params["input"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`input` has the wrong type: Received `{type(params.get("input", None))}` expected `list[InputPathType]`')
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType | None`')
    if params.get("mask_range", None) is not None:
        if not isinstance(params["mask_range"], list):
            raise StyxValidationError(f'`mask_range` has the wrong type: Received `{type(params.get("mask_range", None))}` expected `list[float] | None`')
        if len(params["mask_range"]) != 2:
            raise StyxValidationError("Parameter `mask_range` must contain exactly 2 elements")
        for e in params["mask_range"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`mask_range` has the wrong type: Received `{type(params.get("mask_range", None))}` expected `list[float] | None`')
    if params.get("cmask", None) is not None:
        if not isinstance(params["cmask"], str):
            raise StyxValidationError(f'`cmask` has the wrong type: Received `{type(params.get("cmask", None))}` expected `str | None`')
    if params.get("jobname", None) is not None:
        if not isinstance(params["jobname"], str):
            raise StyxValidationError(f'`jobname` has the wrong type: Received `{type(params.get("jobname", None))}` expected `str | None`')
    if params.get("prefix", None) is not None:
        if not isinstance(params["prefix"], str):
            raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str | None`')
    if params.get("distance_measure", None) is not None:
        if not isinstance(params["distance_measure"], (float, int)):
            raise StyxValidationError(f'`distance_measure` has the wrong type: Received `{type(params.get("distance_measure", None))}` expected `float | None`')
    if params.get("num_clusters", None) is not None:
        if not isinstance(params["num_clusters"], (float, int)):
            raise StyxValidationError(f'`num_clusters` has the wrong type: Received `{type(params.get("num_clusters", None))}` expected `float | None`')
    if params.get("remap_method", None) is not None:
        if not isinstance(params["remap_method"], str):
            raise StyxValidationError(f'`remap_method` has the wrong type: Received `{type(params.get("remap_method", None))}` expected `str | None`')
    if params.get("labeltable", None) is not None:
        if not isinstance(params["labeltable"], (pathlib.Path, str)):
            raise StyxValidationError(f'`labeltable` has the wrong type: Received `{type(params.get("labeltable", None))}` expected `InputPathType | None`')
    if params.get("clabels", None) is not None:
        if not isinstance(params["clabels"], list):
            raise StyxValidationError(f'`clabels` has the wrong type: Received `{type(params.get("clabels", None))}` expected `list[str] | None`')
        for e in params["clabels"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`clabels` has the wrong type: Received `{type(params.get("clabels", None))}` expected `list[str] | None`')
    if params.get("clust_init", None) is not None:
        if not isinstance(params["clust_init"], (pathlib.Path, str)):
            raise StyxValidationError(f'`clust_init` has the wrong type: Received `{type(params.get("clust_init", None))}` expected `InputPathType | None`')
    if params.get("num_repeats", None) is not None:
        if not isinstance(params["num_repeats"], (float, int)):
            raise StyxValidationError(f'`num_repeats` has the wrong type: Received `{type(params.get("num_repeats", None))}` expected `float | None`')
    if params.get("rsigs", None) is not None:
        if not isinstance(params["rsigs"], (pathlib.Path, str)):
            raise StyxValidationError(f'`rsigs` has the wrong type: Received `{type(params.get("rsigs", None))}` expected `InputPathType | None`')
    if params.get("verbose", False) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], bool):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", False))}` expected `bool`')
    if params.get("write_dists", False) is None:
        raise StyxValidationError("`write_dists` must not be None")
    if not isinstance(params["write_dists"], bool):
        raise StyxValidationError(f'`write_dists` has the wrong type: Received `{type(params.get("write_dists", False))}` expected `bool`')
    if params.get("voxdbg", None) is not None:
        if not isinstance(params["voxdbg"], list):
            raise StyxValidationError(f'`voxdbg` has the wrong type: Received `{type(params.get("voxdbg", None))}` expected `list[float] | None`')
        if len(params["voxdbg"]) != 3:
            raise StyxValidationError("Parameter `voxdbg` must contain exactly 3 elements")
        for e in params["voxdbg"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`voxdbg` has the wrong type: Received `{type(params.get("voxdbg", None))}` expected `list[float] | None`')
    if params.get("seed", None) is not None:
        if not isinstance(params["seed"], (float, int)):
            raise StyxValidationError(f'`seed` has the wrong type: Received `{type(params.get("seed", None))}` expected `float | None`')


def v_3dkmeans_cargs(
    params: V3dkmeansParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("3dkmeans")
    if params.get("version", False):
        cargs.append("--version")
    cargs.extend([
        "-f",
        *[execution.input_file(f) for f in params.get("input", None)]
    ])
    if params.get("mask", None) is not None:
        cargs.extend([
            "-mask",
            execution.input_file(params.get("mask", None))
        ])
    if params.get("mask_range", None) is not None:
        cargs.extend([
            "-mrange",
            *map(str, params.get("mask_range", None))
        ])
    if params.get("cmask", None) is not None:
        cargs.extend([
            "-cmask",
            params.get("cmask", None)
        ])
    if params.get("jobname", None) is not None:
        cargs.extend([
            "-u",
            params.get("jobname", None)
        ])
    if params.get("prefix", None) is not None:
        cargs.extend([
            "-prefix",
            params.get("prefix", None)
        ])
    if params.get("distance_measure", None) is not None:
        cargs.extend([
            "-g",
            str(params.get("distance_measure", None))
        ])
    if params.get("num_clusters", None) is not None:
        cargs.extend([
            "-k",
            str(params.get("num_clusters", None))
        ])
    if params.get("remap_method", None) is not None:
        cargs.extend([
            "-remap",
            params.get("remap_method", None)
        ])
    if params.get("labeltable", None) is not None:
        cargs.extend([
            "-labeltable",
            execution.input_file(params.get("labeltable", None))
        ])
    if params.get("clabels", None) is not None:
        cargs.extend([
            "-clabels",
            *params.get("clabels", None)
        ])
    if params.get("clust_init", None) is not None:
        cargs.extend([
            "-clust_init",
            execution.input_file(params.get("clust_init", None))
        ])
    if params.get("num_repeats", None) is not None:
        cargs.extend([
            "-r",
            str(params.get("num_repeats", None))
        ])
    if params.get("rsigs", None) is not None:
        cargs.extend([
            "-rsigs",
            execution.input_file(params.get("rsigs", None))
        ])
    if params.get("verbose", False):
        cargs.append("-verb")
    if params.get("write_dists", False):
        cargs.append("-write_dists")
    if params.get("voxdbg", None) is not None:
        cargs.extend([
            "-voxdbg",
            *map(str, params.get("voxdbg", None))
        ])
    if params.get("seed", None) is not None:
        cargs.extend([
            "-seed",
            str(params.get("seed", None))
        ])
    return cargs


def v_3dkmeans_outputs(
    params: V3dkmeansParamsDict,
    execution: Execution,
) -> V3dkmeansOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = V3dkmeansOutputs(
        root=execution.output_file("."),
        cluster_membership=execution.output_file(params.get("jobname", None) + "_membership.nii.gz") if (params.get("jobname") is not None) else None,
        cluster_distance=execution.output_file(params.get("jobname", None) + "_distance.nii.gz") if (params.get("jobname") is not None) else None,
        distances_text_file=execution.output_file("FILE.dis.1D"),
        centroids_text_file=execution.output_file("FILE.cen.1D"),
        within_cluster_sum_text_file=execution.output_file("FILE.info1.1D"),
        max_distance_text_file=execution.output_file("FILE.info2.1D"),
        voxel_distance_to_centroid=execution.output_file("FILE.vcd.1D"),
    )
    return ret


def v_3dkmeans_execute(
    params: V3dkmeansParamsDict,
    runner: Runner | None = None,
) -> V3dkmeansOutputs:
    """
    3dkmeans
    
    3d+t Clustering segmentation based on The C clustering library.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dkmeansOutputs`).
    """
    v_3dkmeans_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(V_3DKMEANS_METADATA)
    params = execution.params(params)
    cargs = v_3dkmeans_cargs(params, execution)
    ret = v_3dkmeans_outputs(params, execution)
    execution.run(cargs)
    return ret


def v_3dkmeans(
    input_: list[InputPathType],
    version: bool = False,
    mask: InputPathType | None = None,
    mask_range: list[float] | None = None,
    cmask: str | None = None,
    jobname: str | None = None,
    prefix: str | None = None,
    distance_measure: float | None = None,
    num_clusters: float | None = None,
    remap_method: str | None = None,
    labeltable: InputPathType | None = None,
    clabels: list[str] | None = None,
    clust_init: InputPathType | None = None,
    num_repeats: float | None = None,
    rsigs: InputPathType | None = None,
    verbose: bool = False,
    write_dists: bool = False,
    voxdbg: list[float] | None = None,
    seed: float | None = None,
    runner: Runner | None = None,
) -> V3dkmeansOutputs:
    """
    3dkmeans
    
    3d+t Clustering segmentation based on The C clustering library.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        input_: Input data to be clustered. You can specify multiple filenames\
            in sequence and they will be concatenated internally.
        version:.
        mask: Dataset to be used as a mask; only voxels with nonzero values in\
            'mset' will be used.
        mask_range: Restrict the voxels from 'mset' to only those mask values\
            between 'a' and 'b' (inclusive).
        cmask: Execute the options enclosed in single quotes as a 3dcalc-like\
            program to produce a mask from the resulting 3D brick.
        jobname: Specify a different name for the output files. Default is\
            derived from the input file name.
        prefix: Specify a prefix for the output volumes. Default is the same as\
            jobname.
        distance_measure: Specifies distance measure for clustering. Supported\
            values: 0 (No clustering), 1 (Uncentered correlation distance), 2\
            (Pearson distance), 3 (Uncentered correlation distance, absolute\
            value), 4 (Pearson distance, absolute value), 5 (Spearman's rank\
            distance), 6 (Kendall's distance), 7 (Euclidean distance), 8\
            (City-block distance).
        num_clusters: Specify number of clusters.
        remap_method: Reassign clusters numbers based on METHOD: NONE\
            (default), COUNT, iCOUNT, MAG, iMAG.
        labeltable: Attach labeltable to clustering output.
        clabels: Provide a label for each cluster. Labels cannot start with\
            '-'.
        clust_init: Specify a dataset to initialize clustering. If provided,\
            sets -r 0.
        num_repeats: Number of times the k-means clustering algorithm is run.
        rsigs: Calculate distances from each voxel's signature to the\
            signatures in this multi-column file. No clustering done.
        verbose: Enable verbose mode.
        write_dists: Output text files containing various distance measures.
        voxdbg: Output debugging info for specified voxel (I J K).
        seed: Seed for the random number generator. Default is 1234567.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dkmeansOutputs`).
    """
    params = v_3dkmeans_params(
        version=version,
        input_=input_,
        mask=mask,
        mask_range=mask_range,
        cmask=cmask,
        jobname=jobname,
        prefix=prefix,
        distance_measure=distance_measure,
        num_clusters=num_clusters,
        remap_method=remap_method,
        labeltable=labeltable,
        clabels=clabels,
        clust_init=clust_init,
        num_repeats=num_repeats,
        rsigs=rsigs,
        verbose=verbose,
        write_dists=write_dists,
        voxdbg=voxdbg,
        seed=seed,
    )
    return v_3dkmeans_execute(params, runner)


__all__ = [
    "V3dkmeansOutputs",
    "V3dkmeansParamsDict",
    "V3dkmeansParamsDictTagged",
    "V_3DKMEANS_METADATA",
    "v_3dkmeans",
    "v_3dkmeans_execute",
    "v_3dkmeans_params",
]
