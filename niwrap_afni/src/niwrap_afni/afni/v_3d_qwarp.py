# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

V_3D_QWARP_METADATA = Metadata(
    id="6de643b301465958f6dc83399eef2305f9613e56.boutiques",
    name="3dQwarp",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_V3dQwarpParamsDictNoTag = typing.TypedDict('_V3dQwarpParamsDictNoTag', {
    "base_dataset": InputPathType,
    "source_dataset": InputPathType,
    "prefix": str,
    "no_warp": bool,
    "inverse_warp": bool,
    "no_dataset": bool,
    "a_warp": bool,
    "pcl": bool,
    "pear": bool,
    "hel": bool,
    "mi": bool,
    "nmi": bool,
    "lpc": bool,
    "lpa": bool,
    "noneg": bool,
    "nopenalty": bool,
    "minpatch": typing.NotRequired[float | None],
    "maxlev": typing.NotRequired[float | None],
    "verbose": bool,
    "quiet": bool,
})
V3dQwarpParamsDictTagged = typing.TypedDict('V3dQwarpParamsDictTagged', {
    "@type": typing.Literal["afni/3dQwarp"],
    "base_dataset": InputPathType,
    "source_dataset": InputPathType,
    "prefix": str,
    "no_warp": bool,
    "inverse_warp": bool,
    "no_dataset": bool,
    "a_warp": bool,
    "pcl": bool,
    "pear": bool,
    "hel": bool,
    "mi": bool,
    "nmi": bool,
    "lpc": bool,
    "lpa": bool,
    "noneg": bool,
    "nopenalty": bool,
    "minpatch": typing.NotRequired[float | None],
    "maxlev": typing.NotRequired[float | None],
    "verbose": bool,
    "quiet": bool,
})
V3dQwarpParamsDict = _V3dQwarpParamsDictNoTag | V3dQwarpParamsDictTagged


class V3dQwarpOutputs(typing.NamedTuple):
    """
    Output object returned when calling `V3dQwarpParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    warped_dataset: OutputPathType
    """Warped dataset"""
    warp_dataset: OutputPathType
    """Warp dataset"""
    inverse_warp_dataset: OutputPathType
    """Inverse warp dataset"""


def v_3d_qwarp_params(
    base_dataset: InputPathType,
    source_dataset: InputPathType,
    prefix: str,
    no_warp: bool = False,
    inverse_warp: bool = False,
    no_dataset: bool = False,
    a_warp: bool = False,
    pcl: bool = False,
    pear: bool = False,
    hel: bool = False,
    mi: bool = False,
    nmi: bool = False,
    lpc: bool = False,
    lpa: bool = False,
    noneg: bool = False,
    nopenalty: bool = False,
    minpatch: float | None = None,
    maxlev: float | None = None,
    verbose: bool = False,
    quiet: bool = False,
) -> V3dQwarpParamsDictTagged:
    """
    Build parameters.
    
    Args:
        base_dataset: Base dataset.
        source_dataset: Source dataset.
        prefix: Prefix for the output datasets.
        no_warp: Do not save the _WARP file.
        inverse_warp: Compute and save the _WARPINV file.
        no_dataset: Do not save the warped source dataset.
        a_warp: Output the nonlinear warp when -allineate is used.
        pcl: Clipped Pearson correlation (default method).
        pear: Use strict Pearson correlation for matching.
        hel: Use Hellinger metric for matching.
        mi: Use Mutual Information for matching.
        nmi: Use Normalized Mutual Information for matching.
        lpc: Use Local Pearson correlation (signed) for matching.
        lpa: Use Local Pearson correlation (absolute value) for matching.
        noneg: Replace negative values in either input volume with 0.
        nopenalty: Don't use a penalty on the cost functional.
        minpatch: Set the minimum patch size for warp searching.
        maxlev: Set the maximum refinement level.
        verbose: Print out very verbose progress messages.
        quiet: Cut out most progress messages.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/3dQwarp",
        "base_dataset": base_dataset,
        "source_dataset": source_dataset,
        "prefix": prefix,
        "no_warp": no_warp,
        "inverse_warp": inverse_warp,
        "no_dataset": no_dataset,
        "a_warp": a_warp,
        "pcl": pcl,
        "pear": pear,
        "hel": hel,
        "mi": mi,
        "nmi": nmi,
        "lpc": lpc,
        "lpa": lpa,
        "noneg": noneg,
        "nopenalty": nopenalty,
        "verbose": verbose,
        "quiet": quiet,
    }
    if minpatch is not None:
        params["minpatch"] = minpatch
    if maxlev is not None:
        params["maxlev"] = maxlev
    return params


def v_3d_qwarp_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `V3dQwarpParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("base_dataset", None) is None:
        raise StyxValidationError("`base_dataset` must not be None")
    if not isinstance(params["base_dataset"], (pathlib.Path, str)):
        raise StyxValidationError(f'`base_dataset` has the wrong type: Received `{type(params.get("base_dataset", None))}` expected `InputPathType`')
    if params.get("source_dataset", None) is None:
        raise StyxValidationError("`source_dataset` must not be None")
    if not isinstance(params["source_dataset"], (pathlib.Path, str)):
        raise StyxValidationError(f'`source_dataset` has the wrong type: Received `{type(params.get("source_dataset", None))}` expected `InputPathType`')
    if params.get("prefix", None) is None:
        raise StyxValidationError("`prefix` must not be None")
    if not isinstance(params["prefix"], str):
        raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str`')
    if params.get("no_warp", False) is None:
        raise StyxValidationError("`no_warp` must not be None")
    if not isinstance(params["no_warp"], bool):
        raise StyxValidationError(f'`no_warp` has the wrong type: Received `{type(params.get("no_warp", False))}` expected `bool`')
    if params.get("inverse_warp", False) is None:
        raise StyxValidationError("`inverse_warp` must not be None")
    if not isinstance(params["inverse_warp"], bool):
        raise StyxValidationError(f'`inverse_warp` has the wrong type: Received `{type(params.get("inverse_warp", False))}` expected `bool`')
    if params.get("no_dataset", False) is None:
        raise StyxValidationError("`no_dataset` must not be None")
    if not isinstance(params["no_dataset"], bool):
        raise StyxValidationError(f'`no_dataset` has the wrong type: Received `{type(params.get("no_dataset", False))}` expected `bool`')
    if params.get("a_warp", False) is None:
        raise StyxValidationError("`a_warp` must not be None")
    if not isinstance(params["a_warp"], bool):
        raise StyxValidationError(f'`a_warp` has the wrong type: Received `{type(params.get("a_warp", False))}` expected `bool`')
    if params.get("pcl", False) is None:
        raise StyxValidationError("`pcl` must not be None")
    if not isinstance(params["pcl"], bool):
        raise StyxValidationError(f'`pcl` has the wrong type: Received `{type(params.get("pcl", False))}` expected `bool`')
    if params.get("pear", False) is None:
        raise StyxValidationError("`pear` must not be None")
    if not isinstance(params["pear"], bool):
        raise StyxValidationError(f'`pear` has the wrong type: Received `{type(params.get("pear", False))}` expected `bool`')
    if params.get("hel", False) is None:
        raise StyxValidationError("`hel` must not be None")
    if not isinstance(params["hel"], bool):
        raise StyxValidationError(f'`hel` has the wrong type: Received `{type(params.get("hel", False))}` expected `bool`')
    if params.get("mi", False) is None:
        raise StyxValidationError("`mi` must not be None")
    if not isinstance(params["mi"], bool):
        raise StyxValidationError(f'`mi` has the wrong type: Received `{type(params.get("mi", False))}` expected `bool`')
    if params.get("nmi", False) is None:
        raise StyxValidationError("`nmi` must not be None")
    if not isinstance(params["nmi"], bool):
        raise StyxValidationError(f'`nmi` has the wrong type: Received `{type(params.get("nmi", False))}` expected `bool`')
    if params.get("lpc", False) is None:
        raise StyxValidationError("`lpc` must not be None")
    if not isinstance(params["lpc"], bool):
        raise StyxValidationError(f'`lpc` has the wrong type: Received `{type(params.get("lpc", False))}` expected `bool`')
    if params.get("lpa", False) is None:
        raise StyxValidationError("`lpa` must not be None")
    if not isinstance(params["lpa"], bool):
        raise StyxValidationError(f'`lpa` has the wrong type: Received `{type(params.get("lpa", False))}` expected `bool`')
    if params.get("noneg", False) is None:
        raise StyxValidationError("`noneg` must not be None")
    if not isinstance(params["noneg"], bool):
        raise StyxValidationError(f'`noneg` has the wrong type: Received `{type(params.get("noneg", False))}` expected `bool`')
    if params.get("nopenalty", False) is None:
        raise StyxValidationError("`nopenalty` must not be None")
    if not isinstance(params["nopenalty"], bool):
        raise StyxValidationError(f'`nopenalty` has the wrong type: Received `{type(params.get("nopenalty", False))}` expected `bool`')
    if params.get("minpatch", None) is not None:
        if not isinstance(params["minpatch"], (float, int)):
            raise StyxValidationError(f'`minpatch` has the wrong type: Received `{type(params.get("minpatch", None))}` expected `float | None`')
    if params.get("maxlev", None) is not None:
        if not isinstance(params["maxlev"], (float, int)):
            raise StyxValidationError(f'`maxlev` has the wrong type: Received `{type(params.get("maxlev", None))}` expected `float | None`')
    if params.get("verbose", False) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], bool):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", False))}` expected `bool`')
    if params.get("quiet", False) is None:
        raise StyxValidationError("`quiet` must not be None")
    if not isinstance(params["quiet"], bool):
        raise StyxValidationError(f'`quiet` has the wrong type: Received `{type(params.get("quiet", False))}` expected `bool`')


def v_3d_qwarp_cargs(
    params: V3dQwarpParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("3dQwarp")
    cargs.append(execution.input_file(params.get("base_dataset", None)))
    cargs.append(execution.input_file(params.get("source_dataset", None)))
    cargs.append(params.get("prefix", None))
    if params.get("no_warp", False):
        cargs.append("-nowarp")
    if params.get("inverse_warp", False):
        cargs.append("-iwarp")
    if params.get("no_dataset", False):
        cargs.append("-nodset")
    if params.get("a_warp", False):
        cargs.append("-awarp")
    if params.get("pcl", False):
        cargs.append("-pcl")
    if params.get("pear", False):
        cargs.append("-pear")
    if params.get("hel", False):
        cargs.append("-hel")
    if params.get("mi", False):
        cargs.append("-mi")
    if params.get("nmi", False):
        cargs.append("-nmi")
    if params.get("lpc", False):
        cargs.append("-lpc")
    if params.get("lpa", False):
        cargs.append("-lpa")
    if params.get("noneg", False):
        cargs.append("-noneg")
    if params.get("nopenalty", False):
        cargs.append("-nopenalty")
    if params.get("minpatch", None) is not None:
        cargs.extend([
            "-minpatch",
            str(params.get("minpatch", None))
        ])
    if params.get("maxlev", None) is not None:
        cargs.extend([
            "-maxlev",
            str(params.get("maxlev", None))
        ])
    if params.get("verbose", False):
        cargs.append("-verb")
    if params.get("quiet", False):
        cargs.append("-quiet")
    return cargs


def v_3d_qwarp_outputs(
    params: V3dQwarpParamsDict,
    execution: Execution,
) -> V3dQwarpOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = V3dQwarpOutputs(
        root=execution.output_file("."),
        warped_dataset=execution.output_file("{PREFIX}+tlrc"),
        warp_dataset=execution.output_file("{PREFIX}_WARP+tlrc"),
        inverse_warp_dataset=execution.output_file("{PREFIX}_WARPINV+tlrc"),
    )
    return ret


def v_3d_qwarp_execute(
    params: V3dQwarpParamsDict,
    runner: Runner | None = None,
) -> V3dQwarpOutputs:
    """
    3dQwarp
    
    Computes a nonlinearly warped version of source_dataset to match
    base_dataset.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dQwarpOutputs`).
    """
    v_3d_qwarp_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(V_3D_QWARP_METADATA)
    params = execution.params(params)
    cargs = v_3d_qwarp_cargs(params, execution)
    ret = v_3d_qwarp_outputs(params, execution)
    execution.run(cargs)
    return ret


def v_3d_qwarp(
    base_dataset: InputPathType,
    source_dataset: InputPathType,
    prefix: str,
    no_warp: bool = False,
    inverse_warp: bool = False,
    no_dataset: bool = False,
    a_warp: bool = False,
    pcl: bool = False,
    pear: bool = False,
    hel: bool = False,
    mi: bool = False,
    nmi: bool = False,
    lpc: bool = False,
    lpa: bool = False,
    noneg: bool = False,
    nopenalty: bool = False,
    minpatch: float | None = None,
    maxlev: float | None = None,
    verbose: bool = False,
    quiet: bool = False,
    runner: Runner | None = None,
) -> V3dQwarpOutputs:
    """
    3dQwarp
    
    Computes a nonlinearly warped version of source_dataset to match
    base_dataset.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        base_dataset: Base dataset.
        source_dataset: Source dataset.
        prefix: Prefix for the output datasets.
        no_warp: Do not save the _WARP file.
        inverse_warp: Compute and save the _WARPINV file.
        no_dataset: Do not save the warped source dataset.
        a_warp: Output the nonlinear warp when -allineate is used.
        pcl: Clipped Pearson correlation (default method).
        pear: Use strict Pearson correlation for matching.
        hel: Use Hellinger metric for matching.
        mi: Use Mutual Information for matching.
        nmi: Use Normalized Mutual Information for matching.
        lpc: Use Local Pearson correlation (signed) for matching.
        lpa: Use Local Pearson correlation (absolute value) for matching.
        noneg: Replace negative values in either input volume with 0.
        nopenalty: Don't use a penalty on the cost functional.
        minpatch: Set the minimum patch size for warp searching.
        maxlev: Set the maximum refinement level.
        verbose: Print out very verbose progress messages.
        quiet: Cut out most progress messages.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dQwarpOutputs`).
    """
    params = v_3d_qwarp_params(
        base_dataset=base_dataset,
        source_dataset=source_dataset,
        prefix=prefix,
        no_warp=no_warp,
        inverse_warp=inverse_warp,
        no_dataset=no_dataset,
        a_warp=a_warp,
        pcl=pcl,
        pear=pear,
        hel=hel,
        mi=mi,
        nmi=nmi,
        lpc=lpc,
        lpa=lpa,
        noneg=noneg,
        nopenalty=nopenalty,
        minpatch=minpatch,
        maxlev=maxlev,
        verbose=verbose,
        quiet=quiet,
    )
    return v_3d_qwarp_execute(params, runner)


__all__ = [
    "V3dQwarpOutputs",
    "V3dQwarpParamsDict",
    "V3dQwarpParamsDictTagged",
    "V_3D_QWARP_METADATA",
    "v_3d_qwarp",
    "v_3d_qwarp_execute",
    "v_3d_qwarp_params",
]
