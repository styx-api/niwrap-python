# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

TEDANA_WRAPPER_PY_METADATA = Metadata(
    id="35e559ddd827c563b8387bf1e45614d747bf5d09.boutiques",
    name="tedana_wrapper.py",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_TedanaWrapperPyParamsDictNoTag = typing.TypedDict('_TedanaWrapperPyParamsDictNoTag', {
    "input_files": list[InputPathType],
    "echo_times": list[float],
    "mask": InputPathType,
    "results_dir": typing.NotRequired[str | None],
    "prefix": typing.NotRequired[str | None],
    "save_all": bool,
    "prep_only": bool,
    "tedana_prog": typing.NotRequired[str | None],
    "tedana_is_exec": bool,
    "ted_label": typing.NotRequired[str | None],
    "tedana_opts": typing.NotRequired[str | None],
    "help": bool,
    "detailed_help": bool,
})
TedanaWrapperPyParamsDictTagged = typing.TypedDict('TedanaWrapperPyParamsDictTagged', {
    "@type": typing.Literal["afni/tedana_wrapper.py"],
    "input_files": list[InputPathType],
    "echo_times": list[float],
    "mask": InputPathType,
    "results_dir": typing.NotRequired[str | None],
    "prefix": typing.NotRequired[str | None],
    "save_all": bool,
    "prep_only": bool,
    "tedana_prog": typing.NotRequired[str | None],
    "tedana_is_exec": bool,
    "ted_label": typing.NotRequired[str | None],
    "tedana_opts": typing.NotRequired[str | None],
    "help": bool,
    "detailed_help": bool,
})
TedanaWrapperPyParamsDict = _TedanaWrapperPyParamsDictNoTag | TedanaWrapperPyParamsDictTagged


class TedanaWrapperPyOutputs(typing.NamedTuple):
    """
    Output object returned when calling `TedanaWrapperPyParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    tedana_output: OutputPathType | None
    """Output directory for tedana results."""
    tedana_report: OutputPathType | None
    """Tedana report file."""


def tedana_wrapper_py_params(
    input_files: list[InputPathType],
    echo_times: list[float],
    mask: InputPathType,
    results_dir: str | None = None,
    prefix: str | None = None,
    save_all: bool = False,
    prep_only: bool = False,
    tedana_prog: str | None = None,
    tedana_is_exec: bool = False,
    ted_label: str | None = None,
    tedana_opts: str | None = None,
    help_: bool = False,
    detailed_help: bool = False,
) -> TedanaWrapperPyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_files: 4D dataset for each echo.
        echo_times: Echo time (ms) for each echo.
        mask: Mask in same space/grid as the input datasets.
        results_dir: Folder to be created for all outputs. Default\
            [./Bunnymen].
        prefix: Prefix for dataset names. Default [Bunnymen].
        save_all: Save intermediate datasets. Default is to save only the\
            3dZcat stacked dataset (and tedana stuff).
        prep_only: Do not run tedana.py, stop at 3dZcat.
        tedana_prog: Path and name of the version of tedana.py that will be\
            run. Default is meica.libs/tedana.py in the afni binaries directory.
        tedana_is_exec: Run 'tedana.py' rather than 'python tedana.py'.
        ted_label: Suffix for output folder. Adds suffix like TED.LABEL (NOT A\
            PATH).
        tedana_opts: Additional options to pass to tedana.py. (In quotes)\
            Example: '--initcost=tanh --conv=2.5e-5'.
        help_: Show help message and exit.
        detailed_help: Show detailed help and exit.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/tedana_wrapper.py",
        "input_files": input_files,
        "echo_times": echo_times,
        "mask": mask,
        "save_all": save_all,
        "prep_only": prep_only,
        "tedana_is_exec": tedana_is_exec,
        "help": help_,
        "detailed_help": detailed_help,
    }
    if results_dir is not None:
        params["results_dir"] = results_dir
    if prefix is not None:
        params["prefix"] = prefix
    if tedana_prog is not None:
        params["tedana_prog"] = tedana_prog
    if ted_label is not None:
        params["ted_label"] = ted_label
    if tedana_opts is not None:
        params["tedana_opts"] = tedana_opts
    return params


def tedana_wrapper_py_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `TedanaWrapperPyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input_files", None) is None:
        raise StyxValidationError("`input_files` must not be None")
    if not isinstance(params["input_files"], list):
        raise StyxValidationError(f'`input_files` has the wrong type: Received `{type(params.get("input_files", None))}` expected `list[InputPathType]`')
    for e in params["input_files"]:
        if not isinstance(e, (pathlib.Path, str)):
            raise StyxValidationError(f'`input_files` has the wrong type: Received `{type(params.get("input_files", None))}` expected `list[InputPathType]`')
    if params.get("echo_times", None) is None:
        raise StyxValidationError("`echo_times` must not be None")
    if not isinstance(params["echo_times"], list):
        raise StyxValidationError(f'`echo_times` has the wrong type: Received `{type(params.get("echo_times", None))}` expected `list[float]`')
    for e in params["echo_times"]:
        if not isinstance(e, (float, int)):
            raise StyxValidationError(f'`echo_times` has the wrong type: Received `{type(params.get("echo_times", None))}` expected `list[float]`')
    if params.get("mask", None) is None:
        raise StyxValidationError("`mask` must not be None")
    if not isinstance(params["mask"], (pathlib.Path, str)):
        raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType`')
    if params.get("results_dir", None) is not None:
        if not isinstance(params["results_dir"], str):
            raise StyxValidationError(f'`results_dir` has the wrong type: Received `{type(params.get("results_dir", None))}` expected `str | None`')
    if params.get("prefix", None) is not None:
        if not isinstance(params["prefix"], str):
            raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str | None`')
    if params.get("save_all", False) is None:
        raise StyxValidationError("`save_all` must not be None")
    if not isinstance(params["save_all"], bool):
        raise StyxValidationError(f'`save_all` has the wrong type: Received `{type(params.get("save_all", False))}` expected `bool`')
    if params.get("prep_only", False) is None:
        raise StyxValidationError("`prep_only` must not be None")
    if not isinstance(params["prep_only"], bool):
        raise StyxValidationError(f'`prep_only` has the wrong type: Received `{type(params.get("prep_only", False))}` expected `bool`')
    if params.get("tedana_prog", None) is not None:
        if not isinstance(params["tedana_prog"], str):
            raise StyxValidationError(f'`tedana_prog` has the wrong type: Received `{type(params.get("tedana_prog", None))}` expected `str | None`')
    if params.get("tedana_is_exec", False) is None:
        raise StyxValidationError("`tedana_is_exec` must not be None")
    if not isinstance(params["tedana_is_exec"], bool):
        raise StyxValidationError(f'`tedana_is_exec` has the wrong type: Received `{type(params.get("tedana_is_exec", False))}` expected `bool`')
    if params.get("ted_label", None) is not None:
        if not isinstance(params["ted_label"], str):
            raise StyxValidationError(f'`ted_label` has the wrong type: Received `{type(params.get("ted_label", None))}` expected `str | None`')
    if params.get("tedana_opts", None) is not None:
        if not isinstance(params["tedana_opts"], str):
            raise StyxValidationError(f'`tedana_opts` has the wrong type: Received `{type(params.get("tedana_opts", None))}` expected `str | None`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("detailed_help", False) is None:
        raise StyxValidationError("`detailed_help` must not be None")
    if not isinstance(params["detailed_help"], bool):
        raise StyxValidationError(f'`detailed_help` has the wrong type: Received `{type(params.get("detailed_help", False))}` expected `bool`')


def tedana_wrapper_py_cargs(
    params: TedanaWrapperPyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("tedana_wrapper.py")
    cargs.extend([
        "-input",
        *[execution.input_file(f) for f in params.get("input_files", None)]
    ])
    cargs.extend([
        "-TE",
        *map(str, params.get("echo_times", None))
    ])
    cargs.extend([
        "-mask",
        execution.input_file(params.get("mask", None))
    ])
    if params.get("results_dir", None) is not None:
        cargs.extend([
            "-results_dir",
            params.get("results_dir", None)
        ])
    if params.get("prefix", None) is not None:
        cargs.extend([
            "-prefix",
            params.get("prefix", None)
        ])
    if params.get("save_all", False):
        cargs.append("-save_all")
    if params.get("prep_only", False):
        cargs.append("-prep_only")
    if params.get("tedana_prog", None) is not None:
        cargs.extend([
            "-tedana_prog",
            params.get("tedana_prog", None)
        ])
    if params.get("tedana_is_exec", False):
        cargs.append("-tedana_is_exec")
    if params.get("ted_label", None) is not None:
        cargs.extend([
            "-ted_label",
            params.get("ted_label", None)
        ])
    if params.get("tedana_opts", None) is not None:
        cargs.extend([
            "-tedana_opts",
            params.get("tedana_opts", None)
        ])
    if params.get("help", False):
        cargs.append("-h")
    if params.get("detailed_help", False):
        cargs.append("-help")
    return cargs


def tedana_wrapper_py_outputs(
    params: TedanaWrapperPyParamsDict,
    execution: Execution,
) -> TedanaWrapperPyOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = TedanaWrapperPyOutputs(
        root=execution.output_file("."),
        tedana_output=execution.output_file(params.get("results_dir", None) + "/" + params.get("prefix", None) + "_ted_output") if (params.get("results_dir") is not None and params.get("prefix") is not None) else None,
        tedana_report=execution.output_file(params.get("results_dir", None) + "/" + params.get("prefix", None) + "_tedana_report.txt") if (params.get("results_dir") is not None and params.get("prefix") is not None) else None,
    )
    return ret


def tedana_wrapper_py_execute(
    params: TedanaWrapperPyParamsDict,
    runner: Runner | None = None,
) -> TedanaWrapperPyOutputs:
    """
    tedana_wrapper.py
    
    Internal wrapper to run tedana.py, typically used within afni_proc.py.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TedanaWrapperPyOutputs`).
    """
    tedana_wrapper_py_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(TEDANA_WRAPPER_PY_METADATA)
    params = execution.params(params)
    cargs = tedana_wrapper_py_cargs(params, execution)
    ret = tedana_wrapper_py_outputs(params, execution)
    execution.run(cargs)
    return ret


def tedana_wrapper_py(
    input_files: list[InputPathType],
    echo_times: list[float],
    mask: InputPathType,
    results_dir: str | None = None,
    prefix: str | None = None,
    save_all: bool = False,
    prep_only: bool = False,
    tedana_prog: str | None = None,
    tedana_is_exec: bool = False,
    ted_label: str | None = None,
    tedana_opts: str | None = None,
    help_: bool = False,
    detailed_help: bool = False,
    runner: Runner | None = None,
) -> TedanaWrapperPyOutputs:
    """
    tedana_wrapper.py
    
    Internal wrapper to run tedana.py, typically used within afni_proc.py.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        input_files: 4D dataset for each echo.
        echo_times: Echo time (ms) for each echo.
        mask: Mask in same space/grid as the input datasets.
        results_dir: Folder to be created for all outputs. Default\
            [./Bunnymen].
        prefix: Prefix for dataset names. Default [Bunnymen].
        save_all: Save intermediate datasets. Default is to save only the\
            3dZcat stacked dataset (and tedana stuff).
        prep_only: Do not run tedana.py, stop at 3dZcat.
        tedana_prog: Path and name of the version of tedana.py that will be\
            run. Default is meica.libs/tedana.py in the afni binaries directory.
        tedana_is_exec: Run 'tedana.py' rather than 'python tedana.py'.
        ted_label: Suffix for output folder. Adds suffix like TED.LABEL (NOT A\
            PATH).
        tedana_opts: Additional options to pass to tedana.py. (In quotes)\
            Example: '--initcost=tanh --conv=2.5e-5'.
        help_: Show help message and exit.
        detailed_help: Show detailed help and exit.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TedanaWrapperPyOutputs`).
    """
    params = tedana_wrapper_py_params(
        input_files=input_files,
        echo_times=echo_times,
        mask=mask,
        results_dir=results_dir,
        prefix=prefix,
        save_all=save_all,
        prep_only=prep_only,
        tedana_prog=tedana_prog,
        tedana_is_exec=tedana_is_exec,
        ted_label=ted_label,
        tedana_opts=tedana_opts,
        help_=help_,
        detailed_help=detailed_help,
    )
    return tedana_wrapper_py_execute(params, runner)


__all__ = [
    "TEDANA_WRAPPER_PY_METADATA",
    "TedanaWrapperPyOutputs",
    "TedanaWrapperPyParamsDict",
    "TedanaWrapperPyParamsDictTagged",
    "tedana_wrapper_py",
    "tedana_wrapper_py_execute",
    "tedana_wrapper_py_params",
]
