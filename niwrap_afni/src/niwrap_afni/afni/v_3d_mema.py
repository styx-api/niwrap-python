# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

V_3D_MEMA_METADATA = Metadata(
    id="f041c65105cb28ba9e2c96580eb2aeada384b9ed.boutiques",
    name="3dMEMA",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_V3dMemaParamsDictNoTag = typing.TypedDict('_V3dMemaParamsDictNoTag', {
    "prefix": str,
    "jobs": typing.NotRequired[float | None],
    "set": list[str],
    "covariates": typing.NotRequired[InputPathType | None],
    "covariates_center": typing.NotRequired[str | None],
    "covariates_model": typing.NotRequired[str | None],
    "covariates_name": typing.NotRequired[list[str] | None],
    "groups": typing.NotRequired[list[str] | None],
    "cio": bool,
    "HKtest": bool,
    "mask": typing.NotRequired[InputPathType | None],
    "max_zeros": typing.NotRequired[float | None],
    "missing_data": typing.NotRequired[list[str] | None],
    "model_outliers": bool,
    "n_nonzero": typing.NotRequired[float | None],
    "no_HKtest": bool,
    "no_model_outliers": bool,
    "no_residual_Z": bool,
    "residual_Z": bool,
    "Rio": bool,
    "equal_variance": bool,
    "unequal_variance": bool,
    "verb": typing.NotRequired[float | None],
    "dbgArgs": bool,
    "help": bool,
    "conditions": typing.NotRequired[list[str] | None],
    "no_tstat": bool,
})
V3dMemaParamsDictTagged = typing.TypedDict('V3dMemaParamsDictTagged', {
    "@type": typing.Literal["afni/3dMEMA"],
    "prefix": str,
    "jobs": typing.NotRequired[float | None],
    "set": list[str],
    "covariates": typing.NotRequired[InputPathType | None],
    "covariates_center": typing.NotRequired[str | None],
    "covariates_model": typing.NotRequired[str | None],
    "covariates_name": typing.NotRequired[list[str] | None],
    "groups": typing.NotRequired[list[str] | None],
    "cio": bool,
    "HKtest": bool,
    "mask": typing.NotRequired[InputPathType | None],
    "max_zeros": typing.NotRequired[float | None],
    "missing_data": typing.NotRequired[list[str] | None],
    "model_outliers": bool,
    "n_nonzero": typing.NotRequired[float | None],
    "no_HKtest": bool,
    "no_model_outliers": bool,
    "no_residual_Z": bool,
    "residual_Z": bool,
    "Rio": bool,
    "equal_variance": bool,
    "unequal_variance": bool,
    "verb": typing.NotRequired[float | None],
    "dbgArgs": bool,
    "help": bool,
    "conditions": typing.NotRequired[list[str] | None],
    "no_tstat": bool,
})
V3dMemaParamsDict = _V3dMemaParamsDictNoTag | V3dMemaParamsDictTagged


class V3dMemaOutputs(typing.NamedTuple):
    """
    Output object returned when calling `V3dMemaParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_file: OutputPathType
    """Output file from the analysis"""


def v_3d_mema_params(
    prefix: str,
    set_: list[str],
    jobs: float | None = None,
    covariates: InputPathType | None = None,
    covariates_center: str | None = None,
    covariates_model: str | None = None,
    covariates_name: list[str] | None = None,
    groups: list[str] | None = None,
    cio: bool = False,
    hktest: bool = False,
    mask: InputPathType | None = None,
    max_zeros: float | None = None,
    missing_data: list[str] | None = None,
    model_outliers: bool = False,
    n_nonzero: float | None = None,
    no_hktest: bool = False,
    no_model_outliers: bool = False,
    no_residual_z: bool = False,
    residual_z: bool = False,
    rio: bool = False,
    equal_variance: bool = False,
    unequal_variance: bool = False,
    verb: float | None = None,
    dbg_args: bool = False,
    help_: bool = False,
    conditions: list[str] | None = None,
    no_tstat: bool = False,
) -> V3dMemaParamsDictTagged:
    """
    Build parameters.
    
    Args:
        prefix: Output prefix (just prefix, no view+suffix needed).
        set_: Set data for one of the test variables.
        jobs: Number of jobs for parallel computing.
        covariates: Specify the name of a text file containing a table for the\
            covariate(s).
        covariates_center: Specify the center values for covariates.
        covariates_model: Specify how covariates should be modeled.
        covariates_name: Specify the name of each covariate.
        groups: Label of groups, used for output naming.
        cio: Use AFNI's C io functions.
        hktest: Perform Hartung-Knapp adjustment for the output t-statistic.
        mask: Only process voxels inside the specified mask.
        max_zeros: Specify how many beta/t-statistics can be zero.
        missing_data: Specify missing data handling.
        model_outliers: Model outliers with a Laplace distribution.
        n_nonzero: Number of non-zero beta values required.
        no_hktest: Specify not to use Hartung-Knapp adjustment.
        no_model_outliers: Specify not to model outliers.
        no_residual_z: Do not output residuals and their Z values.
        residual_z: Output residuals and their Z values.
        rio: Use R's io functions.
        equal_variance: Assume same cross-subjects variability between groups.
        unequal_variance: Model cross-subject variability difference between\
            groups.
        verb: Specify verbosity level.
        dbg_args: Output missing data debug file.
        help_: Show help message.
        conditions: Name of 1 or 2 conditions, tasks, or GLTs.
        no_tstat: Do not compute t-statistics.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/3dMEMA",
        "prefix": prefix,
        "set": set_,
        "cio": cio,
        "HKtest": hktest,
        "model_outliers": model_outliers,
        "no_HKtest": no_hktest,
        "no_model_outliers": no_model_outliers,
        "no_residual_Z": no_residual_z,
        "residual_Z": residual_z,
        "Rio": rio,
        "equal_variance": equal_variance,
        "unequal_variance": unequal_variance,
        "dbgArgs": dbg_args,
        "help": help_,
        "no_tstat": no_tstat,
    }
    if jobs is not None:
        params["jobs"] = jobs
    if covariates is not None:
        params["covariates"] = covariates
    if covariates_center is not None:
        params["covariates_center"] = covariates_center
    if covariates_model is not None:
        params["covariates_model"] = covariates_model
    if covariates_name is not None:
        params["covariates_name"] = covariates_name
    if groups is not None:
        params["groups"] = groups
    if mask is not None:
        params["mask"] = mask
    if max_zeros is not None:
        params["max_zeros"] = max_zeros
    if missing_data is not None:
        params["missing_data"] = missing_data
    if n_nonzero is not None:
        params["n_nonzero"] = n_nonzero
    if verb is not None:
        params["verb"] = verb
    if conditions is not None:
        params["conditions"] = conditions
    return params


def v_3d_mema_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `V3dMemaParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("prefix", None) is None:
        raise StyxValidationError("`prefix` must not be None")
    if not isinstance(params["prefix"], str):
        raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str`')
    if params.get("jobs", None) is not None:
        if not isinstance(params["jobs"], (float, int)):
            raise StyxValidationError(f'`jobs` has the wrong type: Received `{type(params.get("jobs", None))}` expected `float | None`')
    if params.get("set", None) is None:
        raise StyxValidationError("`set` must not be None")
    if not isinstance(params["set"], list):
        raise StyxValidationError(f'`set` has the wrong type: Received `{type(params.get("set", None))}` expected `list[str]`')
    for e in params["set"]:
        if not isinstance(e, str):
            raise StyxValidationError(f'`set` has the wrong type: Received `{type(params.get("set", None))}` expected `list[str]`')
    if params.get("covariates", None) is not None:
        if not isinstance(params["covariates"], (pathlib.Path, str)):
            raise StyxValidationError(f'`covariates` has the wrong type: Received `{type(params.get("covariates", None))}` expected `InputPathType | None`')
    if params.get("covariates_center", None) is not None:
        if not isinstance(params["covariates_center"], str):
            raise StyxValidationError(f'`covariates_center` has the wrong type: Received `{type(params.get("covariates_center", None))}` expected `str | None`')
    if params.get("covariates_model", None) is not None:
        if not isinstance(params["covariates_model"], str):
            raise StyxValidationError(f'`covariates_model` has the wrong type: Received `{type(params.get("covariates_model", None))}` expected `str | None`')
    if params.get("covariates_name", None) is not None:
        if not isinstance(params["covariates_name"], list):
            raise StyxValidationError(f'`covariates_name` has the wrong type: Received `{type(params.get("covariates_name", None))}` expected `list[str] | None`')
        for e in params["covariates_name"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`covariates_name` has the wrong type: Received `{type(params.get("covariates_name", None))}` expected `list[str] | None`')
    if params.get("groups", None) is not None:
        if not isinstance(params["groups"], list):
            raise StyxValidationError(f'`groups` has the wrong type: Received `{type(params.get("groups", None))}` expected `list[str] | None`')
        for e in params["groups"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`groups` has the wrong type: Received `{type(params.get("groups", None))}` expected `list[str] | None`')
    if params.get("cio", False) is None:
        raise StyxValidationError("`cio` must not be None")
    if not isinstance(params["cio"], bool):
        raise StyxValidationError(f'`cio` has the wrong type: Received `{type(params.get("cio", False))}` expected `bool`')
    if params.get("HKtest", False) is None:
        raise StyxValidationError("`HKtest` must not be None")
    if not isinstance(params["HKtest"], bool):
        raise StyxValidationError(f'`HKtest` has the wrong type: Received `{type(params.get("HKtest", False))}` expected `bool`')
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType | None`')
    if params.get("max_zeros", None) is not None:
        if not isinstance(params["max_zeros"], (float, int)):
            raise StyxValidationError(f'`max_zeros` has the wrong type: Received `{type(params.get("max_zeros", None))}` expected `float | None`')
    if params.get("missing_data", None) is not None:
        if not isinstance(params["missing_data"], list):
            raise StyxValidationError(f'`missing_data` has the wrong type: Received `{type(params.get("missing_data", None))}` expected `list[str] | None`')
        for e in params["missing_data"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`missing_data` has the wrong type: Received `{type(params.get("missing_data", None))}` expected `list[str] | None`')
    if params.get("model_outliers", False) is None:
        raise StyxValidationError("`model_outliers` must not be None")
    if not isinstance(params["model_outliers"], bool):
        raise StyxValidationError(f'`model_outliers` has the wrong type: Received `{type(params.get("model_outliers", False))}` expected `bool`')
    if params.get("n_nonzero", None) is not None:
        if not isinstance(params["n_nonzero"], (float, int)):
            raise StyxValidationError(f'`n_nonzero` has the wrong type: Received `{type(params.get("n_nonzero", None))}` expected `float | None`')
    if params.get("no_HKtest", False) is None:
        raise StyxValidationError("`no_HKtest` must not be None")
    if not isinstance(params["no_HKtest"], bool):
        raise StyxValidationError(f'`no_HKtest` has the wrong type: Received `{type(params.get("no_HKtest", False))}` expected `bool`')
    if params.get("no_model_outliers", False) is None:
        raise StyxValidationError("`no_model_outliers` must not be None")
    if not isinstance(params["no_model_outliers"], bool):
        raise StyxValidationError(f'`no_model_outliers` has the wrong type: Received `{type(params.get("no_model_outliers", False))}` expected `bool`')
    if params.get("no_residual_Z", False) is None:
        raise StyxValidationError("`no_residual_Z` must not be None")
    if not isinstance(params["no_residual_Z"], bool):
        raise StyxValidationError(f'`no_residual_Z` has the wrong type: Received `{type(params.get("no_residual_Z", False))}` expected `bool`')
    if params.get("residual_Z", False) is None:
        raise StyxValidationError("`residual_Z` must not be None")
    if not isinstance(params["residual_Z"], bool):
        raise StyxValidationError(f'`residual_Z` has the wrong type: Received `{type(params.get("residual_Z", False))}` expected `bool`')
    if params.get("Rio", False) is None:
        raise StyxValidationError("`Rio` must not be None")
    if not isinstance(params["Rio"], bool):
        raise StyxValidationError(f'`Rio` has the wrong type: Received `{type(params.get("Rio", False))}` expected `bool`')
    if params.get("equal_variance", False) is None:
        raise StyxValidationError("`equal_variance` must not be None")
    if not isinstance(params["equal_variance"], bool):
        raise StyxValidationError(f'`equal_variance` has the wrong type: Received `{type(params.get("equal_variance", False))}` expected `bool`')
    if params.get("unequal_variance", False) is None:
        raise StyxValidationError("`unequal_variance` must not be None")
    if not isinstance(params["unequal_variance"], bool):
        raise StyxValidationError(f'`unequal_variance` has the wrong type: Received `{type(params.get("unequal_variance", False))}` expected `bool`')
    if params.get("verb", None) is not None:
        if not isinstance(params["verb"], (float, int)):
            raise StyxValidationError(f'`verb` has the wrong type: Received `{type(params.get("verb", None))}` expected `float | None`')
    if params.get("dbgArgs", False) is None:
        raise StyxValidationError("`dbgArgs` must not be None")
    if not isinstance(params["dbgArgs"], bool):
        raise StyxValidationError(f'`dbgArgs` has the wrong type: Received `{type(params.get("dbgArgs", False))}` expected `bool`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("conditions", None) is not None:
        if not isinstance(params["conditions"], list):
            raise StyxValidationError(f'`conditions` has the wrong type: Received `{type(params.get("conditions", None))}` expected `list[str] | None`')
        for e in params["conditions"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`conditions` has the wrong type: Received `{type(params.get("conditions", None))}` expected `list[str] | None`')
    if params.get("no_tstat", False) is None:
        raise StyxValidationError("`no_tstat` must not be None")
    if not isinstance(params["no_tstat"], bool):
        raise StyxValidationError(f'`no_tstat` has the wrong type: Received `{type(params.get("no_tstat", False))}` expected `bool`')


def v_3d_mema_cargs(
    params: V3dMemaParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("3dMEMA")
    cargs.extend([
        "-prefix",
        params.get("prefix", None)
    ])
    if params.get("jobs", None) is not None:
        cargs.extend([
            "-jobs",
            str(params.get("jobs", None))
        ])
    cargs.extend([
        "-set",
        *params.get("set", None)
    ])
    if params.get("covariates", None) is not None:
        cargs.extend([
            "-covariates",
            execution.input_file(params.get("covariates", None))
        ])
    if params.get("covariates_center", None) is not None:
        cargs.extend([
            "-covariates_center",
            params.get("covariates_center", None)
        ])
    if params.get("covariates_model", None) is not None:
        cargs.extend([
            "-covariates_model",
            params.get("covariates_model", None)
        ])
    if params.get("covariates_name", None) is not None:
        cargs.extend([
            "-covariates_name",
            *params.get("covariates_name", None)
        ])
    if params.get("groups", None) is not None:
        cargs.extend([
            "-groups",
            *params.get("groups", None)
        ])
    if params.get("cio", False):
        cargs.append("-cio")
    if params.get("HKtest", False):
        cargs.append("-HKtest")
    if params.get("mask", None) is not None:
        cargs.extend([
            "-mask",
            execution.input_file(params.get("mask", None))
        ])
    if params.get("max_zeros", None) is not None:
        cargs.extend([
            "-max_zeros",
            str(params.get("max_zeros", None))
        ])
    if params.get("missing_data", None) is not None:
        cargs.extend([
            "-missing_data",
            *params.get("missing_data", None)
        ])
    if params.get("model_outliers", False):
        cargs.append("-model_outliers")
    if params.get("n_nonzero", None) is not None:
        cargs.extend([
            "-n_nonzero",
            str(params.get("n_nonzero", None))
        ])
    if params.get("no_HKtest", False):
        cargs.append("-no_HKtest")
    if params.get("no_model_outliers", False):
        cargs.append("-no_model_outliers")
    if params.get("no_residual_Z", False):
        cargs.append("-no_residual_Z")
    if params.get("residual_Z", False):
        cargs.append("-residual_Z")
    if params.get("Rio", False):
        cargs.append("-Rio")
    if params.get("equal_variance", False):
        cargs.append("-equal_variance")
    if params.get("unequal_variance", False):
        cargs.append("-unequal_variance")
    if params.get("verb", None) is not None:
        cargs.extend([
            "-verb",
            str(params.get("verb", None))
        ])
    if params.get("dbgArgs", False):
        cargs.append("-dbgArgs")
    if params.get("help", False):
        cargs.append("-help")
    if params.get("conditions", None) is not None:
        cargs.extend([
            "-conditions",
            *params.get("conditions", None)
        ])
    if params.get("no_tstat", False):
        cargs.append("-no_tstat")
    return cargs


def v_3d_mema_outputs(
    params: V3dMemaParamsDict,
    execution: Execution,
) -> V3dMemaOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = V3dMemaOutputs(
        root=execution.output_file("."),
        output_file=execution.output_file(params.get("prefix", None) + ".nii.gz"),
    )
    return ret


def v_3d_mema_execute(
    params: V3dMemaParamsDict,
    runner: Runner | None = None,
) -> V3dMemaOutputs:
    """
    3dMEMA
    
    3dMEMA is a program for performing Mixed Effects Meta Analysis at group
    level that models both within- and across-subjects variability.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dMemaOutputs`).
    """
    v_3d_mema_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(V_3D_MEMA_METADATA)
    params = execution.params(params)
    cargs = v_3d_mema_cargs(params, execution)
    ret = v_3d_mema_outputs(params, execution)
    execution.run(cargs)
    return ret


def v_3d_mema(
    prefix: str,
    set_: list[str],
    jobs: float | None = None,
    covariates: InputPathType | None = None,
    covariates_center: str | None = None,
    covariates_model: str | None = None,
    covariates_name: list[str] | None = None,
    groups: list[str] | None = None,
    cio: bool = False,
    hktest: bool = False,
    mask: InputPathType | None = None,
    max_zeros: float | None = None,
    missing_data: list[str] | None = None,
    model_outliers: bool = False,
    n_nonzero: float | None = None,
    no_hktest: bool = False,
    no_model_outliers: bool = False,
    no_residual_z: bool = False,
    residual_z: bool = False,
    rio: bool = False,
    equal_variance: bool = False,
    unequal_variance: bool = False,
    verb: float | None = None,
    dbg_args: bool = False,
    help_: bool = False,
    conditions: list[str] | None = None,
    no_tstat: bool = False,
    runner: Runner | None = None,
) -> V3dMemaOutputs:
    """
    3dMEMA
    
    3dMEMA is a program for performing Mixed Effects Meta Analysis at group
    level that models both within- and across-subjects variability.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        prefix: Output prefix (just prefix, no view+suffix needed).
        set_: Set data for one of the test variables.
        jobs: Number of jobs for parallel computing.
        covariates: Specify the name of a text file containing a table for the\
            covariate(s).
        covariates_center: Specify the center values for covariates.
        covariates_model: Specify how covariates should be modeled.
        covariates_name: Specify the name of each covariate.
        groups: Label of groups, used for output naming.
        cio: Use AFNI's C io functions.
        hktest: Perform Hartung-Knapp adjustment for the output t-statistic.
        mask: Only process voxels inside the specified mask.
        max_zeros: Specify how many beta/t-statistics can be zero.
        missing_data: Specify missing data handling.
        model_outliers: Model outliers with a Laplace distribution.
        n_nonzero: Number of non-zero beta values required.
        no_hktest: Specify not to use Hartung-Knapp adjustment.
        no_model_outliers: Specify not to model outliers.
        no_residual_z: Do not output residuals and their Z values.
        residual_z: Output residuals and their Z values.
        rio: Use R's io functions.
        equal_variance: Assume same cross-subjects variability between groups.
        unequal_variance: Model cross-subject variability difference between\
            groups.
        verb: Specify verbosity level.
        dbg_args: Output missing data debug file.
        help_: Show help message.
        conditions: Name of 1 or 2 conditions, tasks, or GLTs.
        no_tstat: Do not compute t-statistics.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dMemaOutputs`).
    """
    params = v_3d_mema_params(
        prefix=prefix,
        jobs=jobs,
        set_=set_,
        covariates=covariates,
        covariates_center=covariates_center,
        covariates_model=covariates_model,
        covariates_name=covariates_name,
        groups=groups,
        cio=cio,
        hktest=hktest,
        mask=mask,
        max_zeros=max_zeros,
        missing_data=missing_data,
        model_outliers=model_outliers,
        n_nonzero=n_nonzero,
        no_hktest=no_hktest,
        no_model_outliers=no_model_outliers,
        no_residual_z=no_residual_z,
        residual_z=residual_z,
        rio=rio,
        equal_variance=equal_variance,
        unequal_variance=unequal_variance,
        verb=verb,
        dbg_args=dbg_args,
        help_=help_,
        conditions=conditions,
        no_tstat=no_tstat,
    )
    return v_3d_mema_execute(params, runner)


__all__ = [
    "V3dMemaOutputs",
    "V3dMemaParamsDict",
    "V3dMemaParamsDictTagged",
    "V_3D_MEMA_METADATA",
    "v_3d_mema",
    "v_3d_mema_execute",
    "v_3d_mema_params",
]
