# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

MAKE_RANDOM_TIMING_PY_METADATA = Metadata(
    id="f96003155efad79f23c3556d53a99f53506b4443.boutiques",
    name="make_random_timing.py",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_MakeRandomTimingPyParamsDictNoTag = typing.TypedDict('_MakeRandomTimingPyParamsDictNoTag', {
    "num_runs": float,
    "run_time": list[float],
    "num_stim": float,
    "num_reps": list[float],
    "prefix": str,
    "stim_dur": typing.NotRequired[list[float] | None],
    "across_runs": bool,
    "max_consec": typing.NotRequired[list[float] | None],
    "max_rest": typing.NotRequired[float | None],
    "min_rest": typing.NotRequired[float | None],
    "not_first": typing.NotRequired[list[str] | None],
    "not_last": typing.NotRequired[list[str] | None],
    "offset": typing.NotRequired[float | None],
    "ordered_stimuli": typing.NotRequired[list[str] | None],
    "pre_stim_rest": typing.NotRequired[float | None],
    "post_stim_rest": typing.NotRequired[float | None],
    "save_3dd_cmd": typing.NotRequired[str | None],
    "seed": typing.NotRequired[float | None],
    "stim_labels": typing.NotRequired[list[str] | None],
    "t_digits": typing.NotRequired[float | None],
    "t_gran": typing.NotRequired[float | None],
    "tr": typing.NotRequired[float | None],
    "tr_locked": bool,
    "verb": typing.NotRequired[float | None],
    "show_timing_stats": bool,
})
MakeRandomTimingPyParamsDictTagged = typing.TypedDict('MakeRandomTimingPyParamsDictTagged', {
    "@type": typing.Literal["afni/make_random_timing.py"],
    "num_runs": float,
    "run_time": list[float],
    "num_stim": float,
    "num_reps": list[float],
    "prefix": str,
    "stim_dur": typing.NotRequired[list[float] | None],
    "across_runs": bool,
    "max_consec": typing.NotRequired[list[float] | None],
    "max_rest": typing.NotRequired[float | None],
    "min_rest": typing.NotRequired[float | None],
    "not_first": typing.NotRequired[list[str] | None],
    "not_last": typing.NotRequired[list[str] | None],
    "offset": typing.NotRequired[float | None],
    "ordered_stimuli": typing.NotRequired[list[str] | None],
    "pre_stim_rest": typing.NotRequired[float | None],
    "post_stim_rest": typing.NotRequired[float | None],
    "save_3dd_cmd": typing.NotRequired[str | None],
    "seed": typing.NotRequired[float | None],
    "stim_labels": typing.NotRequired[list[str] | None],
    "t_digits": typing.NotRequired[float | None],
    "t_gran": typing.NotRequired[float | None],
    "tr": typing.NotRequired[float | None],
    "tr_locked": bool,
    "verb": typing.NotRequired[float | None],
    "show_timing_stats": bool,
})
MakeRandomTimingPyParamsDict = _MakeRandomTimingPyParamsDictNoTag | MakeRandomTimingPyParamsDictTagged


class MakeRandomTimingPyOutputs(typing.NamedTuple):
    """
    Output object returned when calling `MakeRandomTimingPyParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def make_random_timing_py_params(
    num_runs: float,
    run_time: list[float],
    num_stim: float,
    num_reps: list[float],
    prefix: str,
    stim_dur: list[float] | None = None,
    across_runs: bool = False,
    max_consec: list[float] | None = None,
    max_rest: float | None = None,
    min_rest: float | None = None,
    not_first: list[str] | None = None,
    not_last: list[str] | None = None,
    offset: float | None = None,
    ordered_stimuli: list[str] | None = None,
    pre_stim_rest: float | None = None,
    post_stim_rest: float | None = None,
    save_3dd_cmd: str | None = None,
    seed: float | None = None,
    stim_labels: list[str] | None = None,
    t_digits: float | None = None,
    t_gran: float | None = None,
    tr: float | None = None,
    tr_locked: bool = False,
    verb: float | None = None,
    show_timing_stats: bool = False,
) -> MakeRandomTimingPyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        num_runs: Set the number of runs.
        run_time: Set the total time per run (in seconds).
        num_stim: Set the number of stimulus classes.
        num_reps: Set the number of repetitions per class (or across runs).
        prefix: Set the prefix for output filenames.
        stim_dur: Set the duration for a single stimulus (in seconds).
        across_runs: Distribute stimuli across all runs at once.
        max_consec: Specify maximum consecutive stimuli per class.
        max_rest: Specify maximum rest between stimuli.
        min_rest: Specify extra rest after each stimulus.
        not_first: Specify classes that should not start a run.
        not_last: Specify classes that should not end a run.
        offset: Specify an offset to add to every stim time.
        ordered_stimuli: Specify a partial ordering of stimuli.
        pre_stim_rest: Specify minimum rest period to start each run.
        post_stim_rest: Specify minimum rest period to end each run.
        save_3dd_cmd: Save a 3dDeconvolve -nodata example.
        seed: Specify a seed for random number generation.
        stim_labels: Specify labels for the stimulus classes.
        t_digits: Set the number of decimal places for times.
        t_gran: Set the time granularity.
        tr: Set the scanner TR.
        tr_locked: Make stimuli timing locked to the accompanying TR.
        verb: Set the verbose level.
        show_timing_stats: Show statistics from the timing.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/make_random_timing.py",
        "num_runs": num_runs,
        "run_time": run_time,
        "num_stim": num_stim,
        "num_reps": num_reps,
        "prefix": prefix,
        "across_runs": across_runs,
        "tr_locked": tr_locked,
        "show_timing_stats": show_timing_stats,
    }
    if stim_dur is not None:
        params["stim_dur"] = stim_dur
    if max_consec is not None:
        params["max_consec"] = max_consec
    if max_rest is not None:
        params["max_rest"] = max_rest
    if min_rest is not None:
        params["min_rest"] = min_rest
    if not_first is not None:
        params["not_first"] = not_first
    if not_last is not None:
        params["not_last"] = not_last
    if offset is not None:
        params["offset"] = offset
    if ordered_stimuli is not None:
        params["ordered_stimuli"] = ordered_stimuli
    if pre_stim_rest is not None:
        params["pre_stim_rest"] = pre_stim_rest
    if post_stim_rest is not None:
        params["post_stim_rest"] = post_stim_rest
    if save_3dd_cmd is not None:
        params["save_3dd_cmd"] = save_3dd_cmd
    if seed is not None:
        params["seed"] = seed
    if stim_labels is not None:
        params["stim_labels"] = stim_labels
    if t_digits is not None:
        params["t_digits"] = t_digits
    if t_gran is not None:
        params["t_gran"] = t_gran
    if tr is not None:
        params["tr"] = tr
    if verb is not None:
        params["verb"] = verb
    return params


def make_random_timing_py_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `MakeRandomTimingPyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("num_runs", None) is None:
        raise StyxValidationError("`num_runs` must not be None")
    if not isinstance(params["num_runs"], (float, int)):
        raise StyxValidationError(f'`num_runs` has the wrong type: Received `{type(params.get("num_runs", None))}` expected `float`')
    if params["num_runs"] < 1:
        raise StyxValidationError("Parameter `num_runs` must be at least 1")
    if params.get("run_time", None) is None:
        raise StyxValidationError("`run_time` must not be None")
    if not isinstance(params["run_time"], list):
        raise StyxValidationError(f'`run_time` has the wrong type: Received `{type(params.get("run_time", None))}` expected `list[float]`')
    if len(params["run_time"]) < 1:
        raise StyxValidationError("Parameter `run_time` must contain at least 1 element")
    for e in params["run_time"]:
        if not isinstance(e, (float, int)):
            raise StyxValidationError(f'`run_time` has the wrong type: Received `{type(params.get("run_time", None))}` expected `list[float]`')
    if params.get("num_stim", None) is None:
        raise StyxValidationError("`num_stim` must not be None")
    if not isinstance(params["num_stim"], (float, int)):
        raise StyxValidationError(f'`num_stim` has the wrong type: Received `{type(params.get("num_stim", None))}` expected `float`')
    if params["num_stim"] < 1:
        raise StyxValidationError("Parameter `num_stim` must be at least 1")
    if params.get("num_reps", None) is None:
        raise StyxValidationError("`num_reps` must not be None")
    if not isinstance(params["num_reps"], list):
        raise StyxValidationError(f'`num_reps` has the wrong type: Received `{type(params.get("num_reps", None))}` expected `list[float]`')
    if len(params["num_reps"]) < 1:
        raise StyxValidationError("Parameter `num_reps` must contain at least 1 element")
    for e in params["num_reps"]:
        if not isinstance(e, (float, int)):
            raise StyxValidationError(f'`num_reps` has the wrong type: Received `{type(params.get("num_reps", None))}` expected `list[float]`')
    if params.get("prefix", None) is None:
        raise StyxValidationError("`prefix` must not be None")
    if not isinstance(params["prefix"], str):
        raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str`')
    if params.get("stim_dur", None) is not None:
        if not isinstance(params["stim_dur"], list):
            raise StyxValidationError(f'`stim_dur` has the wrong type: Received `{type(params.get("stim_dur", None))}` expected `list[float] | None`')
        if len(params["stim_dur"]) < 1:
            raise StyxValidationError("Parameter `stim_dur` must contain at least 1 element")
        for e in params["stim_dur"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`stim_dur` has the wrong type: Received `{type(params.get("stim_dur", None))}` expected `list[float] | None`')
    if params.get("across_runs", False) is None:
        raise StyxValidationError("`across_runs` must not be None")
    if not isinstance(params["across_runs"], bool):
        raise StyxValidationError(f'`across_runs` has the wrong type: Received `{type(params.get("across_runs", False))}` expected `bool`')
    if params.get("max_consec", None) is not None:
        if not isinstance(params["max_consec"], list):
            raise StyxValidationError(f'`max_consec` has the wrong type: Received `{type(params.get("max_consec", None))}` expected `list[float] | None`')
        if len(params["max_consec"]) < 1:
            raise StyxValidationError("Parameter `max_consec` must contain at least 1 element")
        for e in params["max_consec"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`max_consec` has the wrong type: Received `{type(params.get("max_consec", None))}` expected `list[float] | None`')
    if params.get("max_rest", None) is not None:
        if not isinstance(params["max_rest"], (float, int)):
            raise StyxValidationError(f'`max_rest` has the wrong type: Received `{type(params.get("max_rest", None))}` expected `float | None`')
    if params.get("min_rest", None) is not None:
        if not isinstance(params["min_rest"], (float, int)):
            raise StyxValidationError(f'`min_rest` has the wrong type: Received `{type(params.get("min_rest", None))}` expected `float | None`')
    if params.get("not_first", None) is not None:
        if not isinstance(params["not_first"], list):
            raise StyxValidationError(f'`not_first` has the wrong type: Received `{type(params.get("not_first", None))}` expected `list[str] | None`')
        if len(params["not_first"]) < 1:
            raise StyxValidationError("Parameter `not_first` must contain at least 1 element")
        for e in params["not_first"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`not_first` has the wrong type: Received `{type(params.get("not_first", None))}` expected `list[str] | None`')
    if params.get("not_last", None) is not None:
        if not isinstance(params["not_last"], list):
            raise StyxValidationError(f'`not_last` has the wrong type: Received `{type(params.get("not_last", None))}` expected `list[str] | None`')
        if len(params["not_last"]) < 1:
            raise StyxValidationError("Parameter `not_last` must contain at least 1 element")
        for e in params["not_last"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`not_last` has the wrong type: Received `{type(params.get("not_last", None))}` expected `list[str] | None`')
    if params.get("offset", None) is not None:
        if not isinstance(params["offset"], (float, int)):
            raise StyxValidationError(f'`offset` has the wrong type: Received `{type(params.get("offset", None))}` expected `float | None`')
    if params.get("ordered_stimuli", None) is not None:
        if not isinstance(params["ordered_stimuli"], list):
            raise StyxValidationError(f'`ordered_stimuli` has the wrong type: Received `{type(params.get("ordered_stimuli", None))}` expected `list[str] | None`')
        if len(params["ordered_stimuli"]) < 1:
            raise StyxValidationError("Parameter `ordered_stimuli` must contain at least 1 element")
        for e in params["ordered_stimuli"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`ordered_stimuli` has the wrong type: Received `{type(params.get("ordered_stimuli", None))}` expected `list[str] | None`')
    if params.get("pre_stim_rest", None) is not None:
        if not isinstance(params["pre_stim_rest"], (float, int)):
            raise StyxValidationError(f'`pre_stim_rest` has the wrong type: Received `{type(params.get("pre_stim_rest", None))}` expected `float | None`')
    if params.get("post_stim_rest", None) is not None:
        if not isinstance(params["post_stim_rest"], (float, int)):
            raise StyxValidationError(f'`post_stim_rest` has the wrong type: Received `{type(params.get("post_stim_rest", None))}` expected `float | None`')
    if params.get("save_3dd_cmd", None) is not None:
        if not isinstance(params["save_3dd_cmd"], str):
            raise StyxValidationError(f'`save_3dd_cmd` has the wrong type: Received `{type(params.get("save_3dd_cmd", None))}` expected `str | None`')
    if params.get("seed", None) is not None:
        if not isinstance(params["seed"], (float, int)):
            raise StyxValidationError(f'`seed` has the wrong type: Received `{type(params.get("seed", None))}` expected `float | None`')
    if params.get("stim_labels", None) is not None:
        if not isinstance(params["stim_labels"], list):
            raise StyxValidationError(f'`stim_labels` has the wrong type: Received `{type(params.get("stim_labels", None))}` expected `list[str] | None`')
        if len(params["stim_labels"]) < 1:
            raise StyxValidationError("Parameter `stim_labels` must contain at least 1 element")
        for e in params["stim_labels"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`stim_labels` has the wrong type: Received `{type(params.get("stim_labels", None))}` expected `list[str] | None`')
    if params.get("t_digits", None) is not None:
        if not isinstance(params["t_digits"], (float, int)):
            raise StyxValidationError(f'`t_digits` has the wrong type: Received `{type(params.get("t_digits", None))}` expected `float | None`')
    if params.get("t_gran", None) is not None:
        if not isinstance(params["t_gran"], (float, int)):
            raise StyxValidationError(f'`t_gran` has the wrong type: Received `{type(params.get("t_gran", None))}` expected `float | None`')
    if params.get("tr", None) is not None:
        if not isinstance(params["tr"], (float, int)):
            raise StyxValidationError(f'`tr` has the wrong type: Received `{type(params.get("tr", None))}` expected `float | None`')
    if params.get("tr_locked", False) is None:
        raise StyxValidationError("`tr_locked` must not be None")
    if not isinstance(params["tr_locked"], bool):
        raise StyxValidationError(f'`tr_locked` has the wrong type: Received `{type(params.get("tr_locked", False))}` expected `bool`')
    if params.get("verb", None) is not None:
        if not isinstance(params["verb"], (float, int)):
            raise StyxValidationError(f'`verb` has the wrong type: Received `{type(params.get("verb", None))}` expected `float | None`')
    if params.get("show_timing_stats", False) is None:
        raise StyxValidationError("`show_timing_stats` must not be None")
    if not isinstance(params["show_timing_stats"], bool):
        raise StyxValidationError(f'`show_timing_stats` has the wrong type: Received `{type(params.get("show_timing_stats", False))}` expected `bool`')


def make_random_timing_py_cargs(
    params: MakeRandomTimingPyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("make_random_timing.py")
    cargs.extend([
        "-num_runs",
        str(params.get("num_runs", None))
    ])
    cargs.extend([
        "-run_time",
        *map(str, params.get("run_time", None))
    ])
    cargs.extend([
        "-num_stim",
        str(params.get("num_stim", None))
    ])
    cargs.extend([
        "-num_reps",
        *map(str, params.get("num_reps", None))
    ])
    cargs.extend([
        "-prefix",
        params.get("prefix", None)
    ])
    if params.get("stim_dur", None) is not None:
        cargs.extend([
            "-stim_dur",
            *map(str, params.get("stim_dur", None))
        ])
    if params.get("across_runs", False):
        cargs.append("-across_runs")
    if params.get("max_consec", None) is not None:
        cargs.extend([
            "-max_consec",
            *map(str, params.get("max_consec", None))
        ])
    if params.get("max_rest", None) is not None:
        cargs.extend([
            "-max_rest",
            str(params.get("max_rest", None))
        ])
    if params.get("min_rest", None) is not None:
        cargs.extend([
            "-min_rest",
            str(params.get("min_rest", None))
        ])
    if params.get("not_first", None) is not None:
        cargs.extend([
            "-not_first",
            *params.get("not_first", None)
        ])
    if params.get("not_last", None) is not None:
        cargs.extend([
            "-not_last",
            *params.get("not_last", None)
        ])
    if params.get("offset", None) is not None:
        cargs.extend([
            "-offset",
            str(params.get("offset", None))
        ])
    if params.get("ordered_stimuli", None) is not None:
        cargs.extend([
            "-ordered_stimuli",
            *params.get("ordered_stimuli", None)
        ])
    if params.get("pre_stim_rest", None) is not None:
        cargs.extend([
            "-pre_stim_rest",
            str(params.get("pre_stim_rest", None))
        ])
    if params.get("post_stim_rest", None) is not None:
        cargs.extend([
            "-post_stim_rest",
            str(params.get("post_stim_rest", None))
        ])
    if params.get("save_3dd_cmd", None) is not None:
        cargs.extend([
            "-save_3dd_cmd",
            params.get("save_3dd_cmd", None)
        ])
    if params.get("seed", None) is not None:
        cargs.extend([
            "-seed",
            str(params.get("seed", None))
        ])
    if params.get("stim_labels", None) is not None:
        cargs.extend([
            "-stim_labels",
            *params.get("stim_labels", None)
        ])
    if params.get("t_digits", None) is not None:
        cargs.extend([
            "-t_digits",
            str(params.get("t_digits", None))
        ])
    if params.get("t_gran", None) is not None:
        cargs.extend([
            "-t_gran",
            str(params.get("t_gran", None))
        ])
    if params.get("tr", None) is not None:
        cargs.extend([
            "-tr",
            str(params.get("tr", None))
        ])
    if params.get("tr_locked", False):
        cargs.append("-tr_locked")
    if params.get("verb", None) is not None:
        cargs.extend([
            "-verb",
            str(params.get("verb", None))
        ])
    if params.get("show_timing_stats", False):
        cargs.append("-show_timing_stats")
    return cargs


def make_random_timing_py_outputs(
    params: MakeRandomTimingPyParamsDict,
    execution: Execution,
) -> MakeRandomTimingPyOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = MakeRandomTimingPyOutputs(
        root=execution.output_file("."),
    )
    return ret


def make_random_timing_py_execute(
    params: MakeRandomTimingPyParamsDict,
    runner: Runner | None = None,
) -> MakeRandomTimingPyOutputs:
    """
    make_random_timing.py
    
    Create random stimulus timing files for use with AFNI 3dDeconvolve.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MakeRandomTimingPyOutputs`).
    """
    make_random_timing_py_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(MAKE_RANDOM_TIMING_PY_METADATA)
    params = execution.params(params)
    cargs = make_random_timing_py_cargs(params, execution)
    ret = make_random_timing_py_outputs(params, execution)
    execution.run(cargs)
    return ret


def make_random_timing_py(
    num_runs: float,
    run_time: list[float],
    num_stim: float,
    num_reps: list[float],
    prefix: str,
    stim_dur: list[float] | None = None,
    across_runs: bool = False,
    max_consec: list[float] | None = None,
    max_rest: float | None = None,
    min_rest: float | None = None,
    not_first: list[str] | None = None,
    not_last: list[str] | None = None,
    offset: float | None = None,
    ordered_stimuli: list[str] | None = None,
    pre_stim_rest: float | None = None,
    post_stim_rest: float | None = None,
    save_3dd_cmd: str | None = None,
    seed: float | None = None,
    stim_labels: list[str] | None = None,
    t_digits: float | None = None,
    t_gran: float | None = None,
    tr: float | None = None,
    tr_locked: bool = False,
    verb: float | None = None,
    show_timing_stats: bool = False,
    runner: Runner | None = None,
) -> MakeRandomTimingPyOutputs:
    """
    make_random_timing.py
    
    Create random stimulus timing files for use with AFNI 3dDeconvolve.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        num_runs: Set the number of runs.
        run_time: Set the total time per run (in seconds).
        num_stim: Set the number of stimulus classes.
        num_reps: Set the number of repetitions per class (or across runs).
        prefix: Set the prefix for output filenames.
        stim_dur: Set the duration for a single stimulus (in seconds).
        across_runs: Distribute stimuli across all runs at once.
        max_consec: Specify maximum consecutive stimuli per class.
        max_rest: Specify maximum rest between stimuli.
        min_rest: Specify extra rest after each stimulus.
        not_first: Specify classes that should not start a run.
        not_last: Specify classes that should not end a run.
        offset: Specify an offset to add to every stim time.
        ordered_stimuli: Specify a partial ordering of stimuli.
        pre_stim_rest: Specify minimum rest period to start each run.
        post_stim_rest: Specify minimum rest period to end each run.
        save_3dd_cmd: Save a 3dDeconvolve -nodata example.
        seed: Specify a seed for random number generation.
        stim_labels: Specify labels for the stimulus classes.
        t_digits: Set the number of decimal places for times.
        t_gran: Set the time granularity.
        tr: Set the scanner TR.
        tr_locked: Make stimuli timing locked to the accompanying TR.
        verb: Set the verbose level.
        show_timing_stats: Show statistics from the timing.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `MakeRandomTimingPyOutputs`).
    """
    params = make_random_timing_py_params(
        num_runs=num_runs,
        run_time=run_time,
        num_stim=num_stim,
        num_reps=num_reps,
        prefix=prefix,
        stim_dur=stim_dur,
        across_runs=across_runs,
        max_consec=max_consec,
        max_rest=max_rest,
        min_rest=min_rest,
        not_first=not_first,
        not_last=not_last,
        offset=offset,
        ordered_stimuli=ordered_stimuli,
        pre_stim_rest=pre_stim_rest,
        post_stim_rest=post_stim_rest,
        save_3dd_cmd=save_3dd_cmd,
        seed=seed,
        stim_labels=stim_labels,
        t_digits=t_digits,
        t_gran=t_gran,
        tr=tr,
        tr_locked=tr_locked,
        verb=verb,
        show_timing_stats=show_timing_stats,
    )
    return make_random_timing_py_execute(params, runner)


__all__ = [
    "MAKE_RANDOM_TIMING_PY_METADATA",
    "MakeRandomTimingPyOutputs",
    "MakeRandomTimingPyParamsDict",
    "MakeRandomTimingPyParamsDictTagged",
    "make_random_timing_py",
    "make_random_timing_py_execute",
    "make_random_timing_py_params",
]
