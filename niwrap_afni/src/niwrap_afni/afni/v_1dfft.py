# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

V_1DFFT_METADATA = Metadata(
    id="caefc7d8624de50408fd39f32f266189e373c0aa.boutiques",
    name="1dfft",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_V1dfftParamsDictNoTag = typing.TypedDict('_V1dfftParamsDictNoTag', {
    "infile": InputPathType,
    "outfile": str,
    "ignore": typing.NotRequired[float | None],
    "use": typing.NotRequired[float | None],
    "nfft": typing.NotRequired[float | None],
    "tocx": bool,
    "fromcx": bool,
    "hilbert": bool,
    "nodetrend": bool,
})
V1dfftParamsDictTagged = typing.TypedDict('V1dfftParamsDictTagged', {
    "@type": typing.Literal["afni/1dfft"],
    "infile": InputPathType,
    "outfile": str,
    "ignore": typing.NotRequired[float | None],
    "use": typing.NotRequired[float | None],
    "nfft": typing.NotRequired[float | None],
    "tocx": bool,
    "fromcx": bool,
    "hilbert": bool,
    "nodetrend": bool,
})
V1dfftParamsDict = _V1dfftParamsDictNoTag | V1dfftParamsDictTagged


class V1dfftOutputs(typing.NamedTuple):
    """
    Output object returned when calling `V1dfftParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out_fft: OutputPathType
    """Output file with the absolute value of the FFT of the input columns."""


def v_1dfft_params(
    infile: InputPathType,
    outfile: str,
    ignore: float | None = None,
    use: float | None = None,
    nfft: float | None = None,
    tocx: bool = False,
    fromcx: bool = False,
    hilbert: bool = False,
    nodetrend: bool = False,
) -> V1dfftParamsDictTagged:
    """
    Build parameters.
    
    Args:
        infile: Input .1D file containing an ASCII list of numbers arranged in\
            columns.
        outfile: Output file to store the FFT results.
        ignore: Skip the first 'sss' lines in the input file. [default = no\
            skipping].
        use: Use only 'uuu' lines of the input file. [default = use them all].
        nfft: Set FFT length to 'nnn'. [default = length of data (# of lines\
            used)].
        tocx: Save Re and Im parts of transform in 2 columns.
        fromcx: Convert 2 column complex input into 1 column real output. Note:\
            This will not work if the original data FFT length was an odd number.
        hilbert: When -fromcx is used, the inverse FFT will do the Hilbert\
            transform instead.
        nodetrend: Skip the detrending of the input.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/1dfft",
        "infile": infile,
        "outfile": outfile,
        "tocx": tocx,
        "fromcx": fromcx,
        "hilbert": hilbert,
        "nodetrend": nodetrend,
    }
    if ignore is not None:
        params["ignore"] = ignore
    if use is not None:
        params["use"] = use
    if nfft is not None:
        params["nfft"] = nfft
    return params


def v_1dfft_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `V1dfftParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("infile", None) is None:
        raise StyxValidationError("`infile` must not be None")
    if not isinstance(params["infile"], (pathlib.Path, str)):
        raise StyxValidationError(f'`infile` has the wrong type: Received `{type(params.get("infile", None))}` expected `InputPathType`')
    if params.get("outfile", None) is None:
        raise StyxValidationError("`outfile` must not be None")
    if not isinstance(params["outfile"], str):
        raise StyxValidationError(f'`outfile` has the wrong type: Received `{type(params.get("outfile", None))}` expected `str`')
    if params.get("ignore", None) is not None:
        if not isinstance(params["ignore"], (float, int)):
            raise StyxValidationError(f'`ignore` has the wrong type: Received `{type(params.get("ignore", None))}` expected `float | None`')
        if params["ignore"] < 0:
            raise StyxValidationError("Parameter `ignore` must be at least 0")
    if params.get("use", None) is not None:
        if not isinstance(params["use"], (float, int)):
            raise StyxValidationError(f'`use` has the wrong type: Received `{type(params.get("use", None))}` expected `float | None`')
        if params["use"] < 0:
            raise StyxValidationError("Parameter `use` must be at least 0")
    if params.get("nfft", None) is not None:
        if not isinstance(params["nfft"], (float, int)):
            raise StyxValidationError(f'`nfft` has the wrong type: Received `{type(params.get("nfft", None))}` expected `float | None`')
        if params["nfft"] < 1:
            raise StyxValidationError("Parameter `nfft` must be at least 1")
    if params.get("tocx", False) is None:
        raise StyxValidationError("`tocx` must not be None")
    if not isinstance(params["tocx"], bool):
        raise StyxValidationError(f'`tocx` has the wrong type: Received `{type(params.get("tocx", False))}` expected `bool`')
    if params.get("fromcx", False) is None:
        raise StyxValidationError("`fromcx` must not be None")
    if not isinstance(params["fromcx"], bool):
        raise StyxValidationError(f'`fromcx` has the wrong type: Received `{type(params.get("fromcx", False))}` expected `bool`')
    if params.get("hilbert", False) is None:
        raise StyxValidationError("`hilbert` must not be None")
    if not isinstance(params["hilbert"], bool):
        raise StyxValidationError(f'`hilbert` has the wrong type: Received `{type(params.get("hilbert", False))}` expected `bool`')
    if params.get("nodetrend", False) is None:
        raise StyxValidationError("`nodetrend` must not be None")
    if not isinstance(params["nodetrend"], bool):
        raise StyxValidationError(f'`nodetrend` has the wrong type: Received `{type(params.get("nodetrend", False))}` expected `bool`')


def v_1dfft_cargs(
    params: V1dfftParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("1dfft")
    cargs.append(execution.input_file(params.get("infile", None)))
    cargs.append(params.get("outfile", None))
    if params.get("ignore", None) is not None:
        cargs.extend([
            "-ignore",
            str(params.get("ignore", None))
        ])
    if params.get("use", None) is not None:
        cargs.extend([
            "-use",
            str(params.get("use", None))
        ])
    if params.get("nfft", None) is not None:
        cargs.extend([
            "-nfft",
            str(params.get("nfft", None))
        ])
    if params.get("tocx", False):
        cargs.append("-tocx")
    if params.get("fromcx", False):
        cargs.append("-fromcx")
    if params.get("hilbert", False):
        cargs.append("-hilbert")
    if params.get("nodetrend", False):
        cargs.append("-nodetrend")
    return cargs


def v_1dfft_outputs(
    params: V1dfftParamsDict,
    execution: Execution,
) -> V1dfftOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = V1dfftOutputs(
        root=execution.output_file("."),
        out_fft=execution.output_file(params.get("outfile", None)),
    )
    return ret


def v_1dfft_execute(
    params: V1dfftParamsDict,
    runner: Runner | None = None,
) -> V1dfftOutputs:
    """
    1dfft
    
    Compute the absolute value of the FFT of input columns from an AFNI 1D file.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V1dfftOutputs`).
    """
    v_1dfft_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(V_1DFFT_METADATA)
    params = execution.params(params)
    cargs = v_1dfft_cargs(params, execution)
    ret = v_1dfft_outputs(params, execution)
    execution.run(cargs)
    return ret


def v_1dfft(
    infile: InputPathType,
    outfile: str,
    ignore: float | None = None,
    use: float | None = None,
    nfft: float | None = None,
    tocx: bool = False,
    fromcx: bool = False,
    hilbert: bool = False,
    nodetrend: bool = False,
    runner: Runner | None = None,
) -> V1dfftOutputs:
    """
    1dfft
    
    Compute the absolute value of the FFT of input columns from an AFNI 1D file.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        infile: Input .1D file containing an ASCII list of numbers arranged in\
            columns.
        outfile: Output file to store the FFT results.
        ignore: Skip the first 'sss' lines in the input file. [default = no\
            skipping].
        use: Use only 'uuu' lines of the input file. [default = use them all].
        nfft: Set FFT length to 'nnn'. [default = length of data (# of lines\
            used)].
        tocx: Save Re and Im parts of transform in 2 columns.
        fromcx: Convert 2 column complex input into 1 column real output. Note:\
            This will not work if the original data FFT length was an odd number.
        hilbert: When -fromcx is used, the inverse FFT will do the Hilbert\
            transform instead.
        nodetrend: Skip the detrending of the input.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V1dfftOutputs`).
    """
    params = v_1dfft_params(
        infile=infile,
        outfile=outfile,
        ignore=ignore,
        use=use,
        nfft=nfft,
        tocx=tocx,
        fromcx=fromcx,
        hilbert=hilbert,
        nodetrend=nodetrend,
    )
    return v_1dfft_execute(params, runner)


__all__ = [
    "V1dfftOutputs",
    "V1dfftParamsDict",
    "V1dfftParamsDictTagged",
    "V_1DFFT_METADATA",
    "v_1dfft",
    "v_1dfft_execute",
    "v_1dfft_params",
]
