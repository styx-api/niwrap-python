# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

V_3D_TSMOOTH_METADATA = Metadata(
    id="3db17981529d52a5b5608759bc63ca9447ff22b5.boutiques",
    name="3dTsmooth",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_V3dTsmoothParamsDictNoTag = typing.TypedDict('_V3dTsmoothParamsDictNoTag', {
    "input_dataset": InputPathType,
    "prefix": typing.NotRequired[str | None],
    "datum_type": typing.NotRequired[str | None],
    "lin_filter": bool,
    "med_filter": bool,
    "osf_filter": bool,
    "lin_filter_custom": typing.NotRequired[float | None],
    "hamming": typing.NotRequired[int | None],
    "blackman": typing.NotRequired[int | None],
    "custom_filter": typing.NotRequired[InputPathType | None],
    "extend": bool,
    "zero": bool,
    "trend": bool,
    "adaptive": typing.NotRequired[int | None],
})
V3dTsmoothParamsDictTagged = typing.TypedDict('V3dTsmoothParamsDictTagged', {
    "@type": typing.Literal["afni/3dTsmooth"],
    "input_dataset": InputPathType,
    "prefix": typing.NotRequired[str | None],
    "datum_type": typing.NotRequired[str | None],
    "lin_filter": bool,
    "med_filter": bool,
    "osf_filter": bool,
    "lin_filter_custom": typing.NotRequired[float | None],
    "hamming": typing.NotRequired[int | None],
    "blackman": typing.NotRequired[int | None],
    "custom_filter": typing.NotRequired[InputPathType | None],
    "extend": bool,
    "zero": bool,
    "trend": bool,
    "adaptive": typing.NotRequired[int | None],
})
V3dTsmoothParamsDict = _V3dTsmoothParamsDictNoTag | V3dTsmoothParamsDictTagged


class V3dTsmoothOutputs(typing.NamedTuple):
    """
    Output object returned when calling `V3dTsmoothParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_dataset: OutputPathType | None
    """Smoothed 3D+time dataset"""


def v_3d_tsmooth_params(
    input_dataset: InputPathType,
    prefix: str | None = None,
    datum_type: str | None = None,
    lin_filter: bool = False,
    med_filter: bool = False,
    osf_filter: bool = False,
    lin_filter_custom: float | None = None,
    hamming: int | None = None,
    blackman: int | None = None,
    custom_filter: InputPathType | None = None,
    extend: bool = False,
    zero: bool = False,
    trend: bool = False,
    adaptive: int | None = None,
) -> V3dTsmoothParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_dataset: The input 3D+time dataset.
        prefix: Sets the prefix of the output dataset.
        datum_type: Coerce output dataset to be stored as the given type.
        lin_filter: 3 point linear filter: 0.15*a + 0.70*b + 0.15*c.
        med_filter: 3 point median filter: median(a,b,c).
        osf_filter: 3 point order statistics filter: 0.15*min(a,b,c) +\
            0.70*median(a,b,c) + 0.15*max(a,b,c).
        lin_filter_custom: 3 point linear filter with custom weight:\
            0.5*(1-m)*a + m*b + 0.5*(1-m)*c.
        hamming: Use N point Hamming window filter.
        blackman: Use N point Blackman window filter.
        custom_filter: Use custom filter with coefficients from a specified\
            file.
        extend: BEFORE: use the first value; AFTER: use the last value.
        zero: BEFORE and AFTER: use zero.
        trend: Compute a linear trend, and extrapolate BEFORE and AFTER.
        adaptive: Use adaptive mean filtering of width N (N must be odd and\
            bigger than 3).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/3dTsmooth",
        "input_dataset": input_dataset,
        "lin_filter": lin_filter,
        "med_filter": med_filter,
        "osf_filter": osf_filter,
        "extend": extend,
        "zero": zero,
        "trend": trend,
    }
    if prefix is not None:
        params["prefix"] = prefix
    if datum_type is not None:
        params["datum_type"] = datum_type
    if lin_filter_custom is not None:
        params["lin_filter_custom"] = lin_filter_custom
    if hamming is not None:
        params["hamming"] = hamming
    if blackman is not None:
        params["blackman"] = blackman
    if custom_filter is not None:
        params["custom_filter"] = custom_filter
    if adaptive is not None:
        params["adaptive"] = adaptive
    return params


def v_3d_tsmooth_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `V3dTsmoothParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input_dataset", None) is None:
        raise StyxValidationError("`input_dataset` must not be None")
    if not isinstance(params["input_dataset"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input_dataset` has the wrong type: Received `{type(params.get("input_dataset", None))}` expected `InputPathType`')
    if params.get("prefix", None) is not None:
        if not isinstance(params["prefix"], str):
            raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str | None`')
    if params.get("datum_type", None) is not None:
        if not isinstance(params["datum_type"], str):
            raise StyxValidationError(f'`datum_type` has the wrong type: Received `{type(params.get("datum_type", None))}` expected `str | None`')
    if params.get("lin_filter", False) is None:
        raise StyxValidationError("`lin_filter` must not be None")
    if not isinstance(params["lin_filter"], bool):
        raise StyxValidationError(f'`lin_filter` has the wrong type: Received `{type(params.get("lin_filter", False))}` expected `bool`')
    if params.get("med_filter", False) is None:
        raise StyxValidationError("`med_filter` must not be None")
    if not isinstance(params["med_filter"], bool):
        raise StyxValidationError(f'`med_filter` has the wrong type: Received `{type(params.get("med_filter", False))}` expected `bool`')
    if params.get("osf_filter", False) is None:
        raise StyxValidationError("`osf_filter` must not be None")
    if not isinstance(params["osf_filter"], bool):
        raise StyxValidationError(f'`osf_filter` has the wrong type: Received `{type(params.get("osf_filter", False))}` expected `bool`')
    if params.get("lin_filter_custom", None) is not None:
        if not isinstance(params["lin_filter_custom"], (float, int)):
            raise StyxValidationError(f'`lin_filter_custom` has the wrong type: Received `{type(params.get("lin_filter_custom", None))}` expected `float | None`')
        if not (0 <= params["lin_filter_custom"] <= 1):
            raise StyxValidationError("Parameter `lin_filter_custom` must be between 0 and 1 (inclusive)")
    if params.get("hamming", None) is not None:
        if not isinstance(params["hamming"], int):
            raise StyxValidationError(f'`hamming` has the wrong type: Received `{type(params.get("hamming", None))}` expected `int | None`')
    if params.get("blackman", None) is not None:
        if not isinstance(params["blackman"], int):
            raise StyxValidationError(f'`blackman` has the wrong type: Received `{type(params.get("blackman", None))}` expected `int | None`')
    if params.get("custom_filter", None) is not None:
        if not isinstance(params["custom_filter"], (pathlib.Path, str)):
            raise StyxValidationError(f'`custom_filter` has the wrong type: Received `{type(params.get("custom_filter", None))}` expected `InputPathType | None`')
    if params.get("extend", False) is None:
        raise StyxValidationError("`extend` must not be None")
    if not isinstance(params["extend"], bool):
        raise StyxValidationError(f'`extend` has the wrong type: Received `{type(params.get("extend", False))}` expected `bool`')
    if params.get("zero", False) is None:
        raise StyxValidationError("`zero` must not be None")
    if not isinstance(params["zero"], bool):
        raise StyxValidationError(f'`zero` has the wrong type: Received `{type(params.get("zero", False))}` expected `bool`')
    if params.get("trend", False) is None:
        raise StyxValidationError("`trend` must not be None")
    if not isinstance(params["trend"], bool):
        raise StyxValidationError(f'`trend` has the wrong type: Received `{type(params.get("trend", False))}` expected `bool`')
    if params.get("adaptive", None) is not None:
        if not isinstance(params["adaptive"], int):
            raise StyxValidationError(f'`adaptive` has the wrong type: Received `{type(params.get("adaptive", None))}` expected `int | None`')


def v_3d_tsmooth_cargs(
    params: V3dTsmoothParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("3dTsmooth")
    cargs.append(execution.input_file(params.get("input_dataset", None)))
    if params.get("prefix", None) is not None:
        cargs.extend([
            "-prefix",
            params.get("prefix", None)
        ])
    if params.get("datum_type", None) is not None:
        cargs.extend([
            "-datum",
            params.get("datum_type", None)
        ])
    if params.get("lin_filter", False):
        cargs.append("-lin")
    if params.get("med_filter", False):
        cargs.append("-med")
    if params.get("osf_filter", False):
        cargs.append("-osf")
    if params.get("lin_filter_custom", None) is not None:
        cargs.extend([
            "-3lin",
            str(params.get("lin_filter_custom", None))
        ])
    if params.get("hamming", None) is not None:
        cargs.extend([
            "-hamming",
            str(params.get("hamming", None))
        ])
    if params.get("blackman", None) is not None:
        cargs.extend([
            "-blackman",
            str(params.get("blackman", None))
        ])
    if params.get("custom_filter", None) is not None:
        cargs.extend([
            "-custom",
            execution.input_file(params.get("custom_filter", None))
        ])
    if params.get("extend", False):
        cargs.append("-EXTEND")
    if params.get("zero", False):
        cargs.append("-ZERO")
    if params.get("trend", False):
        cargs.append("-TREND")
    if params.get("adaptive", None) is not None:
        cargs.extend([
            "-adaptive",
            str(params.get("adaptive", None))
        ])
    return cargs


def v_3d_tsmooth_outputs(
    params: V3dTsmoothParamsDict,
    execution: Execution,
) -> V3dTsmoothOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = V3dTsmoothOutputs(
        root=execution.output_file("."),
        output_dataset=execution.output_file(params.get("prefix", None) + ".nii.gz") if (params.get("prefix") is not None) else None,
    )
    return ret


def v_3d_tsmooth_execute(
    params: V3dTsmoothParamsDict,
    runner: Runner | None = None,
) -> V3dTsmoothOutputs:
    """
    3dTsmooth
    
    Smooths each voxel time series in a 3D+time dataset and produces as output a
    new 3D+time dataset (e.g., lowpass filter in time).
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dTsmoothOutputs`).
    """
    v_3d_tsmooth_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(V_3D_TSMOOTH_METADATA)
    params = execution.params(params)
    cargs = v_3d_tsmooth_cargs(params, execution)
    ret = v_3d_tsmooth_outputs(params, execution)
    execution.run(cargs)
    return ret


def v_3d_tsmooth(
    input_dataset: InputPathType,
    prefix: str | None = None,
    datum_type: str | None = None,
    lin_filter: bool = False,
    med_filter: bool = False,
    osf_filter: bool = False,
    lin_filter_custom: float | None = None,
    hamming: int | None = None,
    blackman: int | None = None,
    custom_filter: InputPathType | None = None,
    extend: bool = False,
    zero: bool = False,
    trend: bool = False,
    adaptive: int | None = None,
    runner: Runner | None = None,
) -> V3dTsmoothOutputs:
    """
    3dTsmooth
    
    Smooths each voxel time series in a 3D+time dataset and produces as output a
    new 3D+time dataset (e.g., lowpass filter in time).
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        input_dataset: The input 3D+time dataset.
        prefix: Sets the prefix of the output dataset.
        datum_type: Coerce output dataset to be stored as the given type.
        lin_filter: 3 point linear filter: 0.15*a + 0.70*b + 0.15*c.
        med_filter: 3 point median filter: median(a,b,c).
        osf_filter: 3 point order statistics filter: 0.15*min(a,b,c) +\
            0.70*median(a,b,c) + 0.15*max(a,b,c).
        lin_filter_custom: 3 point linear filter with custom weight:\
            0.5*(1-m)*a + m*b + 0.5*(1-m)*c.
        hamming: Use N point Hamming window filter.
        blackman: Use N point Blackman window filter.
        custom_filter: Use custom filter with coefficients from a specified\
            file.
        extend: BEFORE: use the first value; AFTER: use the last value.
        zero: BEFORE and AFTER: use zero.
        trend: Compute a linear trend, and extrapolate BEFORE and AFTER.
        adaptive: Use adaptive mean filtering of width N (N must be odd and\
            bigger than 3).
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dTsmoothOutputs`).
    """
    params = v_3d_tsmooth_params(
        input_dataset=input_dataset,
        prefix=prefix,
        datum_type=datum_type,
        lin_filter=lin_filter,
        med_filter=med_filter,
        osf_filter=osf_filter,
        lin_filter_custom=lin_filter_custom,
        hamming=hamming,
        blackman=blackman,
        custom_filter=custom_filter,
        extend=extend,
        zero=zero,
        trend=trend,
        adaptive=adaptive,
    )
    return v_3d_tsmooth_execute(params, runner)


__all__ = [
    "V3dTsmoothOutputs",
    "V3dTsmoothParamsDict",
    "V3dTsmoothParamsDictTagged",
    "V_3D_TSMOOTH_METADATA",
    "v_3d_tsmooth",
    "v_3d_tsmooth_execute",
    "v_3d_tsmooth_params",
]
