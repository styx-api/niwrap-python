# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

GEN_GROUP_COMMAND_PY_METADATA = Metadata(
    id="a50fced0bad2328ced816377a295b47a238138e1.boutiques",
    name="gen_group_command.py",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_GenGroupCommandPyParamsDictNoTag = typing.TypedDict('_GenGroupCommandPyParamsDictNoTag', {
    "command_name": str,
    "datasets": list[str],
    "prefix": typing.NotRequired[str | None],
    "set_labels": typing.NotRequired[list[str] | None],
    "subj_prefix": typing.NotRequired[str | None],
    "subj_suffix": typing.NotRequired[str | None],
    "subs_betas": typing.NotRequired[list[str] | None],
    "subs_tstats": typing.NotRequired[list[str] | None],
    "type": typing.NotRequired[str | None],
    "verb": typing.NotRequired[str | None],
    "write_script": typing.NotRequired[str | None],
    "other_options": typing.NotRequired[list[str] | None],
})
GenGroupCommandPyParamsDictTagged = typing.TypedDict('GenGroupCommandPyParamsDictTagged', {
    "@type": typing.Literal["afni/gen_group_command.py"],
    "command_name": str,
    "datasets": list[str],
    "prefix": typing.NotRequired[str | None],
    "set_labels": typing.NotRequired[list[str] | None],
    "subj_prefix": typing.NotRequired[str | None],
    "subj_suffix": typing.NotRequired[str | None],
    "subs_betas": typing.NotRequired[list[str] | None],
    "subs_tstats": typing.NotRequired[list[str] | None],
    "type": typing.NotRequired[str | None],
    "verb": typing.NotRequired[str | None],
    "write_script": typing.NotRequired[str | None],
    "other_options": typing.NotRequired[list[str] | None],
})
GenGroupCommandPyParamsDict = _GenGroupCommandPyParamsDictNoTag | GenGroupCommandPyParamsDictTagged


class GenGroupCommandPyOutputs(typing.NamedTuple):
    """
    Output object returned when calling `GenGroupCommandPyParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_script: OutputPathType | None
    """The generated command script file"""


def gen_group_command_py_params(
    command_name: str,
    datasets: list[str],
    prefix: str | None = None,
    set_labels: list[str] | None = None,
    subj_prefix: str | None = None,
    subj_suffix: str | None = None,
    subs_betas: list[str] | None = None,
    subs_tstats: list[str] | None = None,
    type_: str | None = None,
    verb: str | None = None,
    write_script: str | None = None,
    other_options: list[str] | None = None,
) -> GenGroupCommandPyParamsDictTagged:
    """
    Build parameters.
    
    Args:
        command_name: Resulting command, such as 3dttest++.
        datasets: List of datasets, can be used multiple times for different\
            groups.
        prefix: Prefix for the output file names.
        set_labels: Labels corresponding to datasets entries.
        subj_prefix: Prefix for subject names.
        subj_suffix: Suffix for subject names.
        subs_betas: Sub-bricks for beta weights.
        subs_tstats: Sub-bricks for t-stats (3dMEMA).
        type_: Specify the type of test to perform.
        verb: Set the verbosity level.
        write_script: Write command script to specified file name.
        other_options: List of options to pass along to result.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/gen_group_command.py",
        "command_name": command_name,
        "datasets": datasets,
    }
    if prefix is not None:
        params["prefix"] = prefix
    if set_labels is not None:
        params["set_labels"] = set_labels
    if subj_prefix is not None:
        params["subj_prefix"] = subj_prefix
    if subj_suffix is not None:
        params["subj_suffix"] = subj_suffix
    if subs_betas is not None:
        params["subs_betas"] = subs_betas
    if subs_tstats is not None:
        params["subs_tstats"] = subs_tstats
    if type_ is not None:
        params["type"] = type_
    if verb is not None:
        params["verb"] = verb
    if write_script is not None:
        params["write_script"] = write_script
    if other_options is not None:
        params["other_options"] = other_options
    return params


def gen_group_command_py_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `GenGroupCommandPyParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("command_name", None) is None:
        raise StyxValidationError("`command_name` must not be None")
    if not isinstance(params["command_name"], str):
        raise StyxValidationError(f'`command_name` has the wrong type: Received `{type(params.get("command_name", None))}` expected `str`')
    if params.get("datasets", None) is None:
        raise StyxValidationError("`datasets` must not be None")
    if not isinstance(params["datasets"], list):
        raise StyxValidationError(f'`datasets` has the wrong type: Received `{type(params.get("datasets", None))}` expected `list[str]`')
    for e in params["datasets"]:
        if not isinstance(e, str):
            raise StyxValidationError(f'`datasets` has the wrong type: Received `{type(params.get("datasets", None))}` expected `list[str]`')
    if params.get("prefix", None) is not None:
        if not isinstance(params["prefix"], str):
            raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str | None`')
    if params.get("set_labels", None) is not None:
        if not isinstance(params["set_labels"], list):
            raise StyxValidationError(f'`set_labels` has the wrong type: Received `{type(params.get("set_labels", None))}` expected `list[str] | None`')
        for e in params["set_labels"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`set_labels` has the wrong type: Received `{type(params.get("set_labels", None))}` expected `list[str] | None`')
    if params.get("subj_prefix", None) is not None:
        if not isinstance(params["subj_prefix"], str):
            raise StyxValidationError(f'`subj_prefix` has the wrong type: Received `{type(params.get("subj_prefix", None))}` expected `str | None`')
    if params.get("subj_suffix", None) is not None:
        if not isinstance(params["subj_suffix"], str):
            raise StyxValidationError(f'`subj_suffix` has the wrong type: Received `{type(params.get("subj_suffix", None))}` expected `str | None`')
    if params.get("subs_betas", None) is not None:
        if not isinstance(params["subs_betas"], list):
            raise StyxValidationError(f'`subs_betas` has the wrong type: Received `{type(params.get("subs_betas", None))}` expected `list[str] | None`')
        for e in params["subs_betas"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`subs_betas` has the wrong type: Received `{type(params.get("subs_betas", None))}` expected `list[str] | None`')
    if params.get("subs_tstats", None) is not None:
        if not isinstance(params["subs_tstats"], list):
            raise StyxValidationError(f'`subs_tstats` has the wrong type: Received `{type(params.get("subs_tstats", None))}` expected `list[str] | None`')
        for e in params["subs_tstats"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`subs_tstats` has the wrong type: Received `{type(params.get("subs_tstats", None))}` expected `list[str] | None`')
    if params.get("type", None) is not None:
        if not isinstance(params["type"], str):
            raise StyxValidationError(f'`type` has the wrong type: Received `{type(params.get("type", None))}` expected `str | None`')
    if params.get("verb", None) is not None:
        if not isinstance(params["verb"], str):
            raise StyxValidationError(f'`verb` has the wrong type: Received `{type(params.get("verb", None))}` expected `str | None`')
    if params.get("write_script", None) is not None:
        if not isinstance(params["write_script"], str):
            raise StyxValidationError(f'`write_script` has the wrong type: Received `{type(params.get("write_script", None))}` expected `str | None`')
    if params.get("other_options", None) is not None:
        if not isinstance(params["other_options"], list):
            raise StyxValidationError(f'`other_options` has the wrong type: Received `{type(params.get("other_options", None))}` expected `list[str] | None`')
        for e in params["other_options"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`other_options` has the wrong type: Received `{type(params.get("other_options", None))}` expected `list[str] | None`')


def gen_group_command_py_cargs(
    params: GenGroupCommandPyParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("gen_group_command.py")
    cargs.extend([
        "-command",
        params.get("command_name", None)
    ])
    cargs.extend([
        "-dsets",
        *params.get("datasets", None)
    ])
    if params.get("prefix", None) is not None:
        cargs.extend([
            "-prefix",
            params.get("prefix", None)
        ])
    if params.get("set_labels", None) is not None:
        cargs.extend([
            "-set_labels",
            *params.get("set_labels", None)
        ])
    if params.get("subj_prefix", None) is not None:
        cargs.extend([
            "-subj_prefix",
            params.get("subj_prefix", None)
        ])
    if params.get("subj_suffix", None) is not None:
        cargs.extend([
            "-subj_suffix",
            params.get("subj_suffix", None)
        ])
    if params.get("subs_betas", None) is not None:
        cargs.extend([
            "-subs_betas",
            *params.get("subs_betas", None)
        ])
    if params.get("subs_tstats", None) is not None:
        cargs.extend([
            "-subs_tstats",
            *params.get("subs_tstats", None)
        ])
    if params.get("type", None) is not None:
        cargs.extend([
            "-type",
            params.get("type", None)
        ])
    if params.get("verb", None) is not None:
        cargs.extend([
            "-verb",
            params.get("verb", None)
        ])
    if params.get("write_script", None) is not None:
        cargs.extend([
            "-write_script",
            params.get("write_script", None)
        ])
    if params.get("other_options", None) is not None:
        cargs.extend([
            "-options",
            *params.get("other_options", None)
        ])
    return cargs


def gen_group_command_py_outputs(
    params: GenGroupCommandPyParamsDict,
    execution: Execution,
) -> GenGroupCommandPyOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = GenGroupCommandPyOutputs(
        root=execution.output_file("."),
        output_script=execution.output_file(params.get("write_script", None)) if (params.get("write_script") is not None) else None,
    )
    return ret


def gen_group_command_py_execute(
    params: GenGroupCommandPyParamsDict,
    runner: Runner | None = None,
) -> GenGroupCommandPyOutputs:
    """
    gen_group_command.py
    
    Generate group analysis command scripts by parsing wildcard-based lists of
    input datasets.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `GenGroupCommandPyOutputs`).
    """
    gen_group_command_py_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(GEN_GROUP_COMMAND_PY_METADATA)
    params = execution.params(params)
    cargs = gen_group_command_py_cargs(params, execution)
    ret = gen_group_command_py_outputs(params, execution)
    execution.run(cargs)
    return ret


def gen_group_command_py(
    command_name: str,
    datasets: list[str],
    prefix: str | None = None,
    set_labels: list[str] | None = None,
    subj_prefix: str | None = None,
    subj_suffix: str | None = None,
    subs_betas: list[str] | None = None,
    subs_tstats: list[str] | None = None,
    type_: str | None = None,
    verb: str | None = None,
    write_script: str | None = None,
    other_options: list[str] | None = None,
    runner: Runner | None = None,
) -> GenGroupCommandPyOutputs:
    """
    gen_group_command.py
    
    Generate group analysis command scripts by parsing wildcard-based lists of
    input datasets.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        command_name: Resulting command, such as 3dttest++.
        datasets: List of datasets, can be used multiple times for different\
            groups.
        prefix: Prefix for the output file names.
        set_labels: Labels corresponding to datasets entries.
        subj_prefix: Prefix for subject names.
        subj_suffix: Suffix for subject names.
        subs_betas: Sub-bricks for beta weights.
        subs_tstats: Sub-bricks for t-stats (3dMEMA).
        type_: Specify the type of test to perform.
        verb: Set the verbosity level.
        write_script: Write command script to specified file name.
        other_options: List of options to pass along to result.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `GenGroupCommandPyOutputs`).
    """
    params = gen_group_command_py_params(
        command_name=command_name,
        datasets=datasets,
        prefix=prefix,
        set_labels=set_labels,
        subj_prefix=subj_prefix,
        subj_suffix=subj_suffix,
        subs_betas=subs_betas,
        subs_tstats=subs_tstats,
        type_=type_,
        verb=verb,
        write_script=write_script,
        other_options=other_options,
    )
    return gen_group_command_py_execute(params, runner)


__all__ = [
    "GEN_GROUP_COMMAND_PY_METADATA",
    "GenGroupCommandPyOutputs",
    "GenGroupCommandPyParamsDict",
    "GenGroupCommandPyParamsDictTagged",
    "gen_group_command_py",
    "gen_group_command_py_execute",
    "gen_group_command_py_params",
]
