# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

V_3D_BANDPASS_METADATA = Metadata(
    id="f4449a76657f4e4efd9147021862a8773f7f451f.boutiques",
    name="3dBandpass",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_V3dBandpassParamsDictNoTag = typing.TypedDict('_V3dBandpassParamsDictNoTag', {
    "prefix": typing.NotRequired[str | None],
    "automask": bool,
    "blur": typing.NotRequired[float | None],
    "despike": bool,
    "highpass": float,
    "lowpass": float,
    "in_file": InputPathType,
    "localPV": typing.NotRequired[float | None],
    "mask": typing.NotRequired[InputPathType | None],
    "nfft": typing.NotRequired[int | None],
    "no_detrend": bool,
    "normalize": bool,
    "notrans": bool,
    "orthogonalize_dset": typing.NotRequired[InputPathType | None],
    "orthogonalize_file": typing.NotRequired[list[InputPathType] | None],
    "outputtype": typing.NotRequired[typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None],
    "tr": typing.NotRequired[float | None],
})
V3dBandpassParamsDictTagged = typing.TypedDict('V3dBandpassParamsDictTagged', {
    "@type": typing.Literal["afni/3dBandpass"],
    "prefix": typing.NotRequired[str | None],
    "automask": bool,
    "blur": typing.NotRequired[float | None],
    "despike": bool,
    "highpass": float,
    "lowpass": float,
    "in_file": InputPathType,
    "localPV": typing.NotRequired[float | None],
    "mask": typing.NotRequired[InputPathType | None],
    "nfft": typing.NotRequired[int | None],
    "no_detrend": bool,
    "normalize": bool,
    "notrans": bool,
    "orthogonalize_dset": typing.NotRequired[InputPathType | None],
    "orthogonalize_file": typing.NotRequired[list[InputPathType] | None],
    "outputtype": typing.NotRequired[typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None],
    "tr": typing.NotRequired[float | None],
})
V3dBandpassParamsDict = _V3dBandpassParamsDictNoTag | V3dBandpassParamsDictTagged


class V3dBandpassOutputs(typing.NamedTuple):
    """
    Output object returned when calling `V3dBandpassParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out_file: OutputPathType | None
    """Output file from 3dbandpass."""


def v_3d_bandpass_params(
    highpass: float,
    lowpass: float,
    in_file: InputPathType,
    prefix: str | None = None,
    automask: bool = False,
    blur: float | None = None,
    despike: bool = False,
    local_pv: float | None = None,
    mask: InputPathType | None = None,
    nfft: int | None = None,
    no_detrend: bool = False,
    normalize: bool = False,
    notrans: bool = False,
    orthogonalize_dset: InputPathType | None = None,
    orthogonalize_file: list[InputPathType] | None = None,
    outputtype: typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None = None,
    tr: float | None = None,
) -> V3dBandpassParamsDictTagged:
    """
    Build parameters.
    
    Args:
        highpass: Highpass.
        lowpass: Lowpass.
        in_file: Input file to 3dbandpass.
        prefix: Prefix for output file.
        automask: Create a mask from the input dataset.
        blur: Blur (inside the mask only) with a filter width (fwhm) of 'fff'\
            millimeters.
        despike: Despike each time series before other processing. hopefully,\
            you don't actually need to do this, which is why it is optional.
        local_pv: Replace each vector by the local principal vector (aka first\
            singular vector) from a neighborhood of radius 'rrr' millimeters. note\
            that the pv time series is l2 normalized. this option is mostly for bob\
            cox to have fun with.
        mask: Mask file.
        nfft: Set the fft length [must be a legal value].
        no_detrend: Skip the quadratic detrending of the input that occurs\
            before the fft-based bandpassing. you would only want to do this if the\
            dataset had been detrended already in some other program.
        normalize: Make all output time series have l2 norm = 1 (i.e., sum of\
            squares = 1).
        notrans: Don't check for initial positive transients in the data. the\
            test is a little slow, so skipping it is ok, if you know the data time\
            series are transient-free.
        orthogonalize_dset: Orthogonalize each voxel to the corresponding voxel\
            time series in dataset 'fset', which must have the same spatial and\
            temporal grid structure as the main input dataset. at present, only one\
            '-dsort' option is allowed.
        orthogonalize_file: Also orthogonalize input to columns in f.1d.\
            multiple '-ort' options are allowed.
        outputtype: 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
        tr: Set time step (tr) in sec [default=from dataset header].
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/3dBandpass",
        "automask": automask,
        "despike": despike,
        "highpass": highpass,
        "lowpass": lowpass,
        "in_file": in_file,
        "no_detrend": no_detrend,
        "normalize": normalize,
        "notrans": notrans,
    }
    if prefix is not None:
        params["prefix"] = prefix
    if blur is not None:
        params["blur"] = blur
    if local_pv is not None:
        params["localPV"] = local_pv
    if mask is not None:
        params["mask"] = mask
    if nfft is not None:
        params["nfft"] = nfft
    if orthogonalize_dset is not None:
        params["orthogonalize_dset"] = orthogonalize_dset
    if orthogonalize_file is not None:
        params["orthogonalize_file"] = orthogonalize_file
    if outputtype is not None:
        params["outputtype"] = outputtype
    if tr is not None:
        params["tr"] = tr
    return params


def v_3d_bandpass_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `V3dBandpassParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("prefix", None) is not None:
        if not isinstance(params["prefix"], str):
            raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str | None`')
    if params.get("automask", False) is None:
        raise StyxValidationError("`automask` must not be None")
    if not isinstance(params["automask"], bool):
        raise StyxValidationError(f'`automask` has the wrong type: Received `{type(params.get("automask", False))}` expected `bool`')
    if params.get("blur", None) is not None:
        if not isinstance(params["blur"], (float, int)):
            raise StyxValidationError(f'`blur` has the wrong type: Received `{type(params.get("blur", None))}` expected `float | None`')
    if params.get("despike", False) is None:
        raise StyxValidationError("`despike` must not be None")
    if not isinstance(params["despike"], bool):
        raise StyxValidationError(f'`despike` has the wrong type: Received `{type(params.get("despike", False))}` expected `bool`')
    if params.get("highpass", None) is None:
        raise StyxValidationError("`highpass` must not be None")
    if not isinstance(params["highpass"], (float, int)):
        raise StyxValidationError(f'`highpass` has the wrong type: Received `{type(params.get("highpass", None))}` expected `float`')
    if params.get("lowpass", None) is None:
        raise StyxValidationError("`lowpass` must not be None")
    if not isinstance(params["lowpass"], (float, int)):
        raise StyxValidationError(f'`lowpass` has the wrong type: Received `{type(params.get("lowpass", None))}` expected `float`')
    if params.get("in_file", None) is None:
        raise StyxValidationError("`in_file` must not be None")
    if not isinstance(params["in_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`in_file` has the wrong type: Received `{type(params.get("in_file", None))}` expected `InputPathType`')
    if params.get("localPV", None) is not None:
        if not isinstance(params["localPV"], (float, int)):
            raise StyxValidationError(f'`localPV` has the wrong type: Received `{type(params.get("localPV", None))}` expected `float | None`')
    if params.get("mask", None) is not None:
        if not isinstance(params["mask"], (pathlib.Path, str)):
            raise StyxValidationError(f'`mask` has the wrong type: Received `{type(params.get("mask", None))}` expected `InputPathType | None`')
    if params.get("nfft", None) is not None:
        if not isinstance(params["nfft"], int):
            raise StyxValidationError(f'`nfft` has the wrong type: Received `{type(params.get("nfft", None))}` expected `int | None`')
    if params.get("no_detrend", False) is None:
        raise StyxValidationError("`no_detrend` must not be None")
    if not isinstance(params["no_detrend"], bool):
        raise StyxValidationError(f'`no_detrend` has the wrong type: Received `{type(params.get("no_detrend", False))}` expected `bool`')
    if params.get("normalize", False) is None:
        raise StyxValidationError("`normalize` must not be None")
    if not isinstance(params["normalize"], bool):
        raise StyxValidationError(f'`normalize` has the wrong type: Received `{type(params.get("normalize", False))}` expected `bool`')
    if params.get("notrans", False) is None:
        raise StyxValidationError("`notrans` must not be None")
    if not isinstance(params["notrans"], bool):
        raise StyxValidationError(f'`notrans` has the wrong type: Received `{type(params.get("notrans", False))}` expected `bool`')
    if params.get("orthogonalize_dset", None) is not None:
        if not isinstance(params["orthogonalize_dset"], (pathlib.Path, str)):
            raise StyxValidationError(f'`orthogonalize_dset` has the wrong type: Received `{type(params.get("orthogonalize_dset", None))}` expected `InputPathType | None`')
    if params.get("orthogonalize_file", None) is not None:
        if not isinstance(params["orthogonalize_file"], list):
            raise StyxValidationError(f'`orthogonalize_file` has the wrong type: Received `{type(params.get("orthogonalize_file", None))}` expected `list[InputPathType] | None`')
        for e in params["orthogonalize_file"]:
            if not isinstance(e, (pathlib.Path, str)):
                raise StyxValidationError(f'`orthogonalize_file` has the wrong type: Received `{type(params.get("orthogonalize_file", None))}` expected `list[InputPathType] | None`')
    if params.get("outputtype", None) is not None:
        if not isinstance(params["outputtype"], str):
            raise StyxValidationError(f'`outputtype` has the wrong type: Received `{type(params.get("outputtype", None))}` expected `typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None`')
        if params["outputtype"] not in ["NIFTI", "AFNI", "NIFTI_GZ"]:
            raise StyxValidationError("Parameter `outputtype` must be one of [\"NIFTI\", \"AFNI\", \"NIFTI_GZ\"]")
    if params.get("tr", None) is not None:
        if not isinstance(params["tr"], (float, int)):
            raise StyxValidationError(f'`tr` has the wrong type: Received `{type(params.get("tr", None))}` expected `float | None`')


def v_3d_bandpass_cargs(
    params: V3dBandpassParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("3dBandpass")
    if params.get("prefix", None) is not None:
        cargs.extend([
            "-prefix",
            params.get("prefix", None)
        ])
    if params.get("automask", False):
        cargs.append("-automask")
    if params.get("blur", None) is not None:
        cargs.extend([
            "-blur",
            str(params.get("blur", None))
        ])
    if params.get("despike", False):
        cargs.append("-despike")
    cargs.append(str(params.get("highpass", None)))
    cargs.append(str(params.get("lowpass", None)))
    cargs.append(execution.input_file(params.get("in_file", None)))
    if params.get("localPV", None) is not None:
        cargs.extend([
            "-localPV",
            str(params.get("localPV", None))
        ])
    if params.get("mask", None) is not None:
        cargs.extend([
            "-mask",
            execution.input_file(params.get("mask", None))
        ])
    if params.get("nfft", None) is not None:
        cargs.extend([
            "-nfft",
            str(params.get("nfft", None))
        ])
    if params.get("no_detrend", False):
        cargs.append("-nodetrend")
    if params.get("normalize", False):
        cargs.append("-norm")
    if params.get("notrans", False):
        cargs.append("-notrans")
    if params.get("orthogonalize_dset", None) is not None:
        cargs.extend([
            "-dsort",
            execution.input_file(params.get("orthogonalize_dset", None))
        ])
    if params.get("orthogonalize_file", None) is not None:
        cargs.extend([
            "-ort",
            *[execution.input_file(f) for f in params.get("orthogonalize_file", None)]
        ])
    if params.get("outputtype", None) is not None:
        cargs.append(params.get("outputtype", None))
    if params.get("tr", None) is not None:
        cargs.extend([
            "-dt",
            str(params.get("tr", None))
        ])
    return cargs


def v_3d_bandpass_outputs(
    params: V3dBandpassParamsDict,
    execution: Execution,
) -> V3dBandpassOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = V3dBandpassOutputs(
        root=execution.output_file("."),
        out_file=execution.output_file(params.get("prefix", None)) if (params.get("prefix") is not None) else None,
    )
    return ret


def v_3d_bandpass_execute(
    params: V3dBandpassParamsDict,
    runner: Runner | None = None,
) -> V3dBandpassOutputs:
    """
    3dBandpass
    
    Program to lowpass and/or highpass each voxel time series in a dataset,
    offering more/different options than Fourier.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dBandpassOutputs`).
    """
    v_3d_bandpass_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(V_3D_BANDPASS_METADATA)
    params = execution.params(params)
    cargs = v_3d_bandpass_cargs(params, execution)
    ret = v_3d_bandpass_outputs(params, execution)
    execution.run(cargs)
    return ret


def v_3d_bandpass(
    highpass: float,
    lowpass: float,
    in_file: InputPathType,
    prefix: str | None = None,
    automask: bool = False,
    blur: float | None = None,
    despike: bool = False,
    local_pv: float | None = None,
    mask: InputPathType | None = None,
    nfft: int | None = None,
    no_detrend: bool = False,
    normalize: bool = False,
    notrans: bool = False,
    orthogonalize_dset: InputPathType | None = None,
    orthogonalize_file: list[InputPathType] | None = None,
    outputtype: typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None = None,
    tr: float | None = None,
    runner: Runner | None = None,
) -> V3dBandpassOutputs:
    """
    3dBandpass
    
    Program to lowpass and/or highpass each voxel time series in a dataset,
    offering more/different options than Fourier.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        highpass: Highpass.
        lowpass: Lowpass.
        in_file: Input file to 3dbandpass.
        prefix: Prefix for output file.
        automask: Create a mask from the input dataset.
        blur: Blur (inside the mask only) with a filter width (fwhm) of 'fff'\
            millimeters.
        despike: Despike each time series before other processing. hopefully,\
            you don't actually need to do this, which is why it is optional.
        local_pv: Replace each vector by the local principal vector (aka first\
            singular vector) from a neighborhood of radius 'rrr' millimeters. note\
            that the pv time series is l2 normalized. this option is mostly for bob\
            cox to have fun with.
        mask: Mask file.
        nfft: Set the fft length [must be a legal value].
        no_detrend: Skip the quadratic detrending of the input that occurs\
            before the fft-based bandpassing. you would only want to do this if the\
            dataset had been detrended already in some other program.
        normalize: Make all output time series have l2 norm = 1 (i.e., sum of\
            squares = 1).
        notrans: Don't check for initial positive transients in the data. the\
            test is a little slow, so skipping it is ok, if you know the data time\
            series are transient-free.
        orthogonalize_dset: Orthogonalize each voxel to the corresponding voxel\
            time series in dataset 'fset', which must have the same spatial and\
            temporal grid structure as the main input dataset. at present, only one\
            '-dsort' option is allowed.
        orthogonalize_file: Also orthogonalize input to columns in f.1d.\
            multiple '-ort' options are allowed.
        outputtype: 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
        tr: Set time step (tr) in sec [default=from dataset header].
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dBandpassOutputs`).
    """
    params = v_3d_bandpass_params(
        prefix=prefix,
        automask=automask,
        blur=blur,
        despike=despike,
        highpass=highpass,
        lowpass=lowpass,
        in_file=in_file,
        local_pv=local_pv,
        mask=mask,
        nfft=nfft,
        no_detrend=no_detrend,
        normalize=normalize,
        notrans=notrans,
        orthogonalize_dset=orthogonalize_dset,
        orthogonalize_file=orthogonalize_file,
        outputtype=outputtype,
        tr=tr,
    )
    return v_3d_bandpass_execute(params, runner)


__all__ = [
    "V3dBandpassOutputs",
    "V3dBandpassParamsDict",
    "V3dBandpassParamsDictTagged",
    "V_3D_BANDPASS_METADATA",
    "v_3d_bandpass",
    "v_3d_bandpass_execute",
    "v_3d_bandpass_params",
]
