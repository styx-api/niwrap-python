# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

SURF_LAYERS_METADATA = Metadata(
    id="703511de3d8b8c18aa7ffa12f03522430f692e1c.boutiques",
    name="SurfLayers",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_SurfLayersParamsDictNoTag = typing.TypedDict('_SurfLayersParamsDictNoTag', {
    "spec_dset": typing.NotRequired[InputPathType | None],
    "outdir": typing.NotRequired[str | None],
    "states": typing.NotRequired[str | None],
    "hemi": typing.NotRequired[str | None],
    "n_intermed_surfs": typing.NotRequired[float | None],
    "surf_a": typing.NotRequired[InputPathType | None],
    "surf_b": typing.NotRequired[InputPathType | None],
    "surf_intermed_pref": typing.NotRequired[str | None],
    "echo": bool,
    "no_clean": bool,
})
SurfLayersParamsDictTagged = typing.TypedDict('SurfLayersParamsDictTagged', {
    "@type": typing.Literal["afni/SurfLayers"],
    "spec_dset": typing.NotRequired[InputPathType | None],
    "outdir": typing.NotRequired[str | None],
    "states": typing.NotRequired[str | None],
    "hemi": typing.NotRequired[str | None],
    "n_intermed_surfs": typing.NotRequired[float | None],
    "surf_a": typing.NotRequired[InputPathType | None],
    "surf_b": typing.NotRequired[InputPathType | None],
    "surf_intermed_pref": typing.NotRequired[str | None],
    "echo": bool,
    "no_clean": bool,
})
SurfLayersParamsDict = _SurfLayersParamsDictNoTag | SurfLayersParamsDictTagged


class SurfLayersOutputs(typing.NamedTuple):
    """
    Output object returned when calling `SurfLayersParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_dir: OutputPathType | None
    """Directory containing output files"""


def surf_layers_params(
    spec_dset: InputPathType | None = None,
    outdir: str | None = None,
    states: str | None = None,
    hemi: str | None = None,
    n_intermed_surfs: float | None = None,
    surf_a: InputPathType | None = None,
    surf_b: InputPathType | None = None,
    surf_intermed_pref: str | None = None,
    echo: bool = False,
    no_clean: bool = False,
) -> SurfLayersParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec_dset: Dataset that is the SUMA specification file describing input\
            surfaces.
        outdir: New directory for output (default: surflayers).
        states: Typically smoothwm, pial states to describe inner and outer\
            surfaces (default: 'smoothwm pial').
        hemi: Choose hemisphere: 'lh', 'rh', or 'lh rh' (for both).
        n_intermed_surfs: Total number of intermediate surfaces to create.
        surf_a: Inner boundary surface by filename (e.g., smoothwm.gii).
        surf_b: Outer boundary surface by filename (e.g., pial.gii).
        surf_intermed_pref: Name for interpolated surfaces (default: isurf).
        echo: Run script with 'set echo' (i.e., verbosely).
        no_clean: Do not remove temp files (probably just for testing).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/SurfLayers",
        "echo": echo,
        "no_clean": no_clean,
    }
    if spec_dset is not None:
        params["spec_dset"] = spec_dset
    if outdir is not None:
        params["outdir"] = outdir
    if states is not None:
        params["states"] = states
    if hemi is not None:
        params["hemi"] = hemi
    if n_intermed_surfs is not None:
        params["n_intermed_surfs"] = n_intermed_surfs
    if surf_a is not None:
        params["surf_a"] = surf_a
    if surf_b is not None:
        params["surf_b"] = surf_b
    if surf_intermed_pref is not None:
        params["surf_intermed_pref"] = surf_intermed_pref
    return params


def surf_layers_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `SurfLayersParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec_dset", None) is not None:
        if not isinstance(params["spec_dset"], (pathlib.Path, str)):
            raise StyxValidationError(f'`spec_dset` has the wrong type: Received `{type(params.get("spec_dset", None))}` expected `InputPathType | None`')
    if params.get("outdir", None) is not None:
        if not isinstance(params["outdir"], str):
            raise StyxValidationError(f'`outdir` has the wrong type: Received `{type(params.get("outdir", None))}` expected `str | None`')
    if params.get("states", None) is not None:
        if not isinstance(params["states"], str):
            raise StyxValidationError(f'`states` has the wrong type: Received `{type(params.get("states", None))}` expected `str | None`')
    if params.get("hemi", None) is not None:
        if not isinstance(params["hemi"], str):
            raise StyxValidationError(f'`hemi` has the wrong type: Received `{type(params.get("hemi", None))}` expected `str | None`')
    if params.get("n_intermed_surfs", None) is not None:
        if not isinstance(params["n_intermed_surfs"], (float, int)):
            raise StyxValidationError(f'`n_intermed_surfs` has the wrong type: Received `{type(params.get("n_intermed_surfs", None))}` expected `float | None`')
    if params.get("surf_a", None) is not None:
        if not isinstance(params["surf_a"], (pathlib.Path, str)):
            raise StyxValidationError(f'`surf_a` has the wrong type: Received `{type(params.get("surf_a", None))}` expected `InputPathType | None`')
    if params.get("surf_b", None) is not None:
        if not isinstance(params["surf_b"], (pathlib.Path, str)):
            raise StyxValidationError(f'`surf_b` has the wrong type: Received `{type(params.get("surf_b", None))}` expected `InputPathType | None`')
    if params.get("surf_intermed_pref", None) is not None:
        if not isinstance(params["surf_intermed_pref"], str):
            raise StyxValidationError(f'`surf_intermed_pref` has the wrong type: Received `{type(params.get("surf_intermed_pref", None))}` expected `str | None`')
    if params.get("echo", False) is None:
        raise StyxValidationError("`echo` must not be None")
    if not isinstance(params["echo"], bool):
        raise StyxValidationError(f'`echo` has the wrong type: Received `{type(params.get("echo", False))}` expected `bool`')
    if params.get("no_clean", False) is None:
        raise StyxValidationError("`no_clean` must not be None")
    if not isinstance(params["no_clean"], bool):
        raise StyxValidationError(f'`no_clean` has the wrong type: Received `{type(params.get("no_clean", False))}` expected `bool`')


def surf_layers_cargs(
    params: SurfLayersParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("SurfLayers")
    if params.get("spec_dset", None) is not None:
        cargs.extend([
            "-spec",
            execution.input_file(params.get("spec_dset", None))
        ])
    if params.get("outdir", None) is not None:
        cargs.extend([
            "-outdir",
            params.get("outdir", None)
        ])
    if params.get("states", None) is not None:
        cargs.extend([
            "-states",
            params.get("states", None)
        ])
    if params.get("hemi", None) is not None:
        cargs.extend([
            "-hemi",
            params.get("hemi", None)
        ])
    if params.get("n_intermed_surfs", None) is not None:
        cargs.extend([
            "-n_intermed_surfs",
            str(params.get("n_intermed_surfs", None))
        ])
    if params.get("surf_a", None) is not None:
        cargs.extend([
            "-surf_A",
            execution.input_file(params.get("surf_a", None))
        ])
    if params.get("surf_b", None) is not None:
        cargs.extend([
            "-surf_B",
            execution.input_file(params.get("surf_b", None))
        ])
    if params.get("surf_intermed_pref", None) is not None:
        cargs.extend([
            "-surf_intermed_pref",
            params.get("surf_intermed_pref", None)
        ])
    if params.get("echo", False):
        cargs.append("-echo")
    if params.get("no_clean", False):
        cargs.append("-no_clean")
    return cargs


def surf_layers_outputs(
    params: SurfLayersParamsDict,
    execution: Execution,
) -> SurfLayersOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = SurfLayersOutputs(
        root=execution.output_file("."),
        output_dir=execution.output_file(params.get("outdir", None)) if (params.get("outdir") is not None) else None,
    )
    return ret


def surf_layers_execute(
    params: SurfLayersParamsDict,
    runner: Runner | None = None,
) -> SurfLayersOutputs:
    """
    SurfLayers
    
    Compute intermediate equi-distant surfaces between two boundary surfaces.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SurfLayersOutputs`).
    """
    surf_layers_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(SURF_LAYERS_METADATA)
    params = execution.params(params)
    cargs = surf_layers_cargs(params, execution)
    ret = surf_layers_outputs(params, execution)
    execution.run(cargs)
    return ret


def surf_layers(
    spec_dset: InputPathType | None = None,
    outdir: str | None = None,
    states: str | None = None,
    hemi: str | None = None,
    n_intermed_surfs: float | None = None,
    surf_a: InputPathType | None = None,
    surf_b: InputPathType | None = None,
    surf_intermed_pref: str | None = None,
    echo: bool = False,
    no_clean: bool = False,
    runner: Runner | None = None,
) -> SurfLayersOutputs:
    """
    SurfLayers
    
    Compute intermediate equi-distant surfaces between two boundary surfaces.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        spec_dset: Dataset that is the SUMA specification file describing input\
            surfaces.
        outdir: New directory for output (default: surflayers).
        states: Typically smoothwm, pial states to describe inner and outer\
            surfaces (default: 'smoothwm pial').
        hemi: Choose hemisphere: 'lh', 'rh', or 'lh rh' (for both).
        n_intermed_surfs: Total number of intermediate surfaces to create.
        surf_a: Inner boundary surface by filename (e.g., smoothwm.gii).
        surf_b: Outer boundary surface by filename (e.g., pial.gii).
        surf_intermed_pref: Name for interpolated surfaces (default: isurf).
        echo: Run script with 'set echo' (i.e., verbosely).
        no_clean: Do not remove temp files (probably just for testing).
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SurfLayersOutputs`).
    """
    params = surf_layers_params(
        spec_dset=spec_dset,
        outdir=outdir,
        states=states,
        hemi=hemi,
        n_intermed_surfs=n_intermed_surfs,
        surf_a=surf_a,
        surf_b=surf_b,
        surf_intermed_pref=surf_intermed_pref,
        echo=echo,
        no_clean=no_clean,
    )
    return surf_layers_execute(params, runner)


__all__ = [
    "SURF_LAYERS_METADATA",
    "SurfLayersOutputs",
    "SurfLayersParamsDict",
    "SurfLayersParamsDictTagged",
    "surf_layers",
    "surf_layers_execute",
    "surf_layers_params",
]
