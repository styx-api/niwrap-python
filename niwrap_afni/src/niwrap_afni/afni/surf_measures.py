# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

SURF_MEASURES_METADATA = Metadata(
    id="b94a39e16fa59659338338e4789f816c9ea37585.boutiques",
    name="SurfMeasures",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_SurfMeasuresParamsDictNoTag = typing.TypedDict('_SurfMeasuresParamsDictNoTag', {
    "spec_file": InputPathType,
    "surf_A": str,
    "surf_B": typing.NotRequired[str | None],
    "out_1D": typing.NotRequired[str | None],
    "out_dset": str,
    "func": typing.NotRequired[list[str] | None],
    "surf_volume": typing.NotRequired[InputPathType | None],
    "cmask": typing.NotRequired[str | None],
    "debug": typing.NotRequired[int | None],
    "dnode": typing.NotRequired[float | None],
    "nodes_1D": typing.NotRequired[InputPathType | None],
    "info_all": bool,
    "info_area": bool,
    "info_norms": bool,
    "info_thick": bool,
    "info_vol": bool,
    "info_volg": bool,
    "ver": bool,
})
SurfMeasuresParamsDictTagged = typing.TypedDict('SurfMeasuresParamsDictTagged', {
    "@type": typing.Literal["afni/SurfMeasures"],
    "spec_file": InputPathType,
    "surf_A": str,
    "surf_B": typing.NotRequired[str | None],
    "out_1D": typing.NotRequired[str | None],
    "out_dset": str,
    "func": typing.NotRequired[list[str] | None],
    "surf_volume": typing.NotRequired[InputPathType | None],
    "cmask": typing.NotRequired[str | None],
    "debug": typing.NotRequired[int | None],
    "dnode": typing.NotRequired[float | None],
    "nodes_1D": typing.NotRequired[InputPathType | None],
    "info_all": bool,
    "info_area": bool,
    "info_norms": bool,
    "info_thick": bool,
    "info_vol": bool,
    "info_volg": bool,
    "ver": bool,
})
SurfMeasuresParamsDict = _SurfMeasuresParamsDictNoTag | SurfMeasuresParamsDictTagged


class SurfMeasuresOutputs(typing.NamedTuple):
    """
    Output object returned when calling `SurfMeasuresParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    output_1_d: OutputPathType | None
    """Output in 1D format"""
    output_dset: OutputPathType
    """Output in specified dataset format"""


def surf_measures_params(
    spec_file: InputPathType,
    surf_a: str,
    out_dset: str,
    surf_b: str | None = None,
    out_1_d: str | None = None,
    func: list[str] | None = None,
    surf_volume: InputPathType | None = None,
    cmask: str | None = None,
    debug: int | None = None,
    dnode: float | None = None,
    nodes_1_d: InputPathType | None = None,
    info_all: bool = False,
    info_area: bool = False,
    info_norms: bool = False,
    info_thick: bool = False,
    info_vol: bool = False,
    info_volg: bool = False,
    ver: bool = False,
) -> SurfMeasuresParamsDictTagged:
    """
    Build parameters.
    
    Args:
        spec_file: SUMA spec file containing a list of related surfaces.
        surf_a: Surface name (in spec file) for the first surface.
        out_dset: Output filename with dataset format.
        surf_b: Surface name (in spec file) for the second surface.
        out_1_d: Output filename in 1D format.
        func: Measure function to be applied.
        surf_volume: AFNI volume dataset associated with the surface.
        cmask: Restrict nodes with a mask.
        debug: Display extra run-time information with specified debug level\
            (0-5).
        dnode: Display extra information for specified node.
        nodes_1_d: Restrict output to specific nodes listed in a file.
        info_all: Display all final info.
        info_area: Display total area of each triangulated surface.
        info_norms: Display info about the normals.
        info_thick: Display minimum and maximum thickness between surfaces.
        info_vol: Display total computed volume between surfaces.
        info_volg: Display total computed volume estimated via Gauss' theorem.
        ver: Show program version and compile date.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/SurfMeasures",
        "spec_file": spec_file,
        "surf_A": surf_a,
        "out_dset": out_dset,
        "info_all": info_all,
        "info_area": info_area,
        "info_norms": info_norms,
        "info_thick": info_thick,
        "info_vol": info_vol,
        "info_volg": info_volg,
        "ver": ver,
    }
    if surf_b is not None:
        params["surf_B"] = surf_b
    if out_1_d is not None:
        params["out_1D"] = out_1_d
    if func is not None:
        params["func"] = func
    if surf_volume is not None:
        params["surf_volume"] = surf_volume
    if cmask is not None:
        params["cmask"] = cmask
    if debug is not None:
        params["debug"] = debug
    if dnode is not None:
        params["dnode"] = dnode
    if nodes_1_d is not None:
        params["nodes_1D"] = nodes_1_d
    return params


def surf_measures_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `SurfMeasuresParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("spec_file", None) is None:
        raise StyxValidationError("`spec_file` must not be None")
    if not isinstance(params["spec_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`spec_file` has the wrong type: Received `{type(params.get("spec_file", None))}` expected `InputPathType`')
    if params.get("surf_A", None) is None:
        raise StyxValidationError("`surf_A` must not be None")
    if not isinstance(params["surf_A"], str):
        raise StyxValidationError(f'`surf_A` has the wrong type: Received `{type(params.get("surf_A", None))}` expected `str`')
    if params.get("surf_B", None) is not None:
        if not isinstance(params["surf_B"], str):
            raise StyxValidationError(f'`surf_B` has the wrong type: Received `{type(params.get("surf_B", None))}` expected `str | None`')
    if params.get("out_1D", None) is not None:
        if not isinstance(params["out_1D"], str):
            raise StyxValidationError(f'`out_1D` has the wrong type: Received `{type(params.get("out_1D", None))}` expected `str | None`')
    if params.get("out_dset", None) is None:
        raise StyxValidationError("`out_dset` must not be None")
    if not isinstance(params["out_dset"], str):
        raise StyxValidationError(f'`out_dset` has the wrong type: Received `{type(params.get("out_dset", None))}` expected `str`')
    if params.get("func", None) is not None:
        if not isinstance(params["func"], list):
            raise StyxValidationError(f'`func` has the wrong type: Received `{type(params.get("func", None))}` expected `list[str] | None`')
        for e in params["func"]:
            if not isinstance(e, str):
                raise StyxValidationError(f'`func` has the wrong type: Received `{type(params.get("func", None))}` expected `list[str] | None`')
    if params.get("surf_volume", None) is not None:
        if not isinstance(params["surf_volume"], (pathlib.Path, str)):
            raise StyxValidationError(f'`surf_volume` has the wrong type: Received `{type(params.get("surf_volume", None))}` expected `InputPathType | None`')
    if params.get("cmask", None) is not None:
        if not isinstance(params["cmask"], str):
            raise StyxValidationError(f'`cmask` has the wrong type: Received `{type(params.get("cmask", None))}` expected `str | None`')
    if params.get("debug", None) is not None:
        if not isinstance(params["debug"], int):
            raise StyxValidationError(f'`debug` has the wrong type: Received `{type(params.get("debug", None))}` expected `int | None`')
        if not (0 <= params["debug"] <= 5):
            raise StyxValidationError("Parameter `debug` must be between 0 and 5 (inclusive)")
    if params.get("dnode", None) is not None:
        if not isinstance(params["dnode"], (float, int)):
            raise StyxValidationError(f'`dnode` has the wrong type: Received `{type(params.get("dnode", None))}` expected `float | None`')
    if params.get("nodes_1D", None) is not None:
        if not isinstance(params["nodes_1D"], (pathlib.Path, str)):
            raise StyxValidationError(f'`nodes_1D` has the wrong type: Received `{type(params.get("nodes_1D", None))}` expected `InputPathType | None`')
    if params.get("info_all", False) is None:
        raise StyxValidationError("`info_all` must not be None")
    if not isinstance(params["info_all"], bool):
        raise StyxValidationError(f'`info_all` has the wrong type: Received `{type(params.get("info_all", False))}` expected `bool`')
    if params.get("info_area", False) is None:
        raise StyxValidationError("`info_area` must not be None")
    if not isinstance(params["info_area"], bool):
        raise StyxValidationError(f'`info_area` has the wrong type: Received `{type(params.get("info_area", False))}` expected `bool`')
    if params.get("info_norms", False) is None:
        raise StyxValidationError("`info_norms` must not be None")
    if not isinstance(params["info_norms"], bool):
        raise StyxValidationError(f'`info_norms` has the wrong type: Received `{type(params.get("info_norms", False))}` expected `bool`')
    if params.get("info_thick", False) is None:
        raise StyxValidationError("`info_thick` must not be None")
    if not isinstance(params["info_thick"], bool):
        raise StyxValidationError(f'`info_thick` has the wrong type: Received `{type(params.get("info_thick", False))}` expected `bool`')
    if params.get("info_vol", False) is None:
        raise StyxValidationError("`info_vol` must not be None")
    if not isinstance(params["info_vol"], bool):
        raise StyxValidationError(f'`info_vol` has the wrong type: Received `{type(params.get("info_vol", False))}` expected `bool`')
    if params.get("info_volg", False) is None:
        raise StyxValidationError("`info_volg` must not be None")
    if not isinstance(params["info_volg"], bool):
        raise StyxValidationError(f'`info_volg` has the wrong type: Received `{type(params.get("info_volg", False))}` expected `bool`')
    if params.get("ver", False) is None:
        raise StyxValidationError("`ver` must not be None")
    if not isinstance(params["ver"], bool):
        raise StyxValidationError(f'`ver` has the wrong type: Received `{type(params.get("ver", False))}` expected `bool`')


def surf_measures_cargs(
    params: SurfMeasuresParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("SurfMeasures")
    cargs.extend([
        "-spec",
        execution.input_file(params.get("spec_file", None))
    ])
    cargs.extend([
        "-surf_A",
        params.get("surf_A", None)
    ])
    if params.get("surf_B", None) is not None:
        cargs.extend([
            "-surf_B",
            params.get("surf_B", None)
        ])
    if params.get("out_1D", None) is not None:
        cargs.extend([
            "-out_1D",
            params.get("out_1D", None)
        ])
    cargs.extend([
        "-out",
        params.get("out_dset", None)
    ])
    if params.get("func", None) is not None:
        cargs.extend([
            "-func",
            *params.get("func", None)
        ])
    if params.get("surf_volume", None) is not None:
        cargs.extend([
            "-sv",
            execution.input_file(params.get("surf_volume", None))
        ])
    if params.get("cmask", None) is not None:
        cargs.extend([
            "-cmask",
            params.get("cmask", None)
        ])
    if params.get("debug", None) is not None:
        cargs.extend([
            "-debug",
            str(params.get("debug", None))
        ])
    if params.get("dnode", None) is not None:
        cargs.extend([
            "-dnode",
            str(params.get("dnode", None))
        ])
    if params.get("nodes_1D", None) is not None:
        cargs.extend([
            "-nodes_1D",
            execution.input_file(params.get("nodes_1D", None))
        ])
    if params.get("info_all", False):
        cargs.append("-info_all")
    if params.get("info_area", False):
        cargs.append("-info_area")
    if params.get("info_norms", False):
        cargs.append("-info_norms")
    if params.get("info_thick", False):
        cargs.append("-info_thick")
    if params.get("info_vol", False):
        cargs.append("-info_vol")
    if params.get("info_volg", False):
        cargs.append("-info_volg")
    if params.get("ver", False):
        cargs.append("-ver")
    return cargs


def surf_measures_outputs(
    params: SurfMeasuresParamsDict,
    execution: Execution,
) -> SurfMeasuresOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = SurfMeasuresOutputs(
        root=execution.output_file("."),
        output_1_d=execution.output_file(params.get("out_1D", None) + ".1D") if (params.get("out_1D") is not None) else None,
        output_dset=execution.output_file(params.get("out_dset", None)),
    )
    return ret


def surf_measures_execute(
    params: SurfMeasuresParamsDict,
    runner: Runner | None = None,
) -> SurfMeasuresOutputs:
    """
    SurfMeasures
    
    Compute measures from surface dataset(s).
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SurfMeasuresOutputs`).
    """
    surf_measures_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(SURF_MEASURES_METADATA)
    params = execution.params(params)
    cargs = surf_measures_cargs(params, execution)
    ret = surf_measures_outputs(params, execution)
    execution.run(cargs)
    return ret


def surf_measures(
    spec_file: InputPathType,
    surf_a: str,
    out_dset: str,
    surf_b: str | None = None,
    out_1_d: str | None = None,
    func: list[str] | None = None,
    surf_volume: InputPathType | None = None,
    cmask: str | None = None,
    debug: int | None = None,
    dnode: float | None = None,
    nodes_1_d: InputPathType | None = None,
    info_all: bool = False,
    info_area: bool = False,
    info_norms: bool = False,
    info_thick: bool = False,
    info_vol: bool = False,
    info_volg: bool = False,
    ver: bool = False,
    runner: Runner | None = None,
) -> SurfMeasuresOutputs:
    """
    SurfMeasures
    
    Compute measures from surface dataset(s).
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        spec_file: SUMA spec file containing a list of related surfaces.
        surf_a: Surface name (in spec file) for the first surface.
        out_dset: Output filename with dataset format.
        surf_b: Surface name (in spec file) for the second surface.
        out_1_d: Output filename in 1D format.
        func: Measure function to be applied.
        surf_volume: AFNI volume dataset associated with the surface.
        cmask: Restrict nodes with a mask.
        debug: Display extra run-time information with specified debug level\
            (0-5).
        dnode: Display extra information for specified node.
        nodes_1_d: Restrict output to specific nodes listed in a file.
        info_all: Display all final info.
        info_area: Display total area of each triangulated surface.
        info_norms: Display info about the normals.
        info_thick: Display minimum and maximum thickness between surfaces.
        info_vol: Display total computed volume between surfaces.
        info_volg: Display total computed volume estimated via Gauss' theorem.
        ver: Show program version and compile date.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `SurfMeasuresOutputs`).
    """
    params = surf_measures_params(
        spec_file=spec_file,
        surf_a=surf_a,
        surf_b=surf_b,
        out_1_d=out_1_d,
        out_dset=out_dset,
        func=func,
        surf_volume=surf_volume,
        cmask=cmask,
        debug=debug,
        dnode=dnode,
        nodes_1_d=nodes_1_d,
        info_all=info_all,
        info_area=info_area,
        info_norms=info_norms,
        info_thick=info_thick,
        info_vol=info_vol,
        info_volg=info_volg,
        ver=ver,
    )
    return surf_measures_execute(params, runner)


__all__ = [
    "SURF_MEASURES_METADATA",
    "SurfMeasuresOutputs",
    "SurfMeasuresParamsDict",
    "SurfMeasuresParamsDictTagged",
    "surf_measures",
    "surf_measures_execute",
    "surf_measures_params",
]
