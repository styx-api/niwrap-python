# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

V_3D_TSHIFT_METADATA = Metadata(
    id="49f64f2ab2eda625043b5f3a63bc8849ce8c369c.boutiques",
    name="3dTshift",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_V3dTshiftParamsDictNoTag = typing.TypedDict('_V3dTshiftParamsDictNoTag', {
    "prefix": typing.NotRequired[str | None],
    "ignore": typing.NotRequired[int | None],
    "in_file": InputPathType,
    "interp": typing.NotRequired[typing.Literal["Fourier", "linear", "cubic", "quintic", "heptic"] | None],
    "num_threads": typing.NotRequired[int | None],
    "outputtype": typing.NotRequired[typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None],
    "rlt": bool,
    "rltplus": bool,
    "slice_encoding_direction": typing.NotRequired[typing.Literal["k", "k-"] | None],
    "tpattern": typing.NotRequired[typing.Literal["alt+z", "altplus", "alt+z2", "alt-z", "altminus", "alt-z2", "seq+z", "seqplus", "seq-z", "seqminus"] | None],
    "tr": typing.NotRequired[float | None],
    "tslice": typing.NotRequired[int | None],
    "tzero": typing.NotRequired[float | None],
})
V3dTshiftParamsDictTagged = typing.TypedDict('V3dTshiftParamsDictTagged', {
    "@type": typing.Literal["afni/3dTshift"],
    "prefix": typing.NotRequired[str | None],
    "ignore": typing.NotRequired[int | None],
    "in_file": InputPathType,
    "interp": typing.NotRequired[typing.Literal["Fourier", "linear", "cubic", "quintic", "heptic"] | None],
    "num_threads": typing.NotRequired[int | None],
    "outputtype": typing.NotRequired[typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None],
    "rlt": bool,
    "rltplus": bool,
    "slice_encoding_direction": typing.NotRequired[typing.Literal["k", "k-"] | None],
    "tpattern": typing.NotRequired[typing.Literal["alt+z", "altplus", "alt+z2", "alt-z", "altminus", "alt-z2", "seq+z", "seqplus", "seq-z", "seqminus"] | None],
    "tr": typing.NotRequired[float | None],
    "tslice": typing.NotRequired[int | None],
    "tzero": typing.NotRequired[float | None],
})
V3dTshiftParamsDict = _V3dTshiftParamsDictNoTag | V3dTshiftParamsDictTagged


class V3dTshiftOutputs(typing.NamedTuple):
    """
    Output object returned when calling `V3dTshiftParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out_file: OutputPathType | None
    """Output image file name."""
    timing_file: OutputPathType
    """Afni formatted timing file, if ``slice_timing`` is a list."""


def v_3d_tshift_params(
    in_file: InputPathType,
    prefix: str | None = None,
    ignore: int | None = None,
    interp: typing.Literal["Fourier", "linear", "cubic", "quintic", "heptic"] | None = None,
    num_threads: int | None = None,
    outputtype: typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None = None,
    rlt: bool = False,
    rltplus: bool = False,
    slice_encoding_direction: typing.Literal["k", "k-"] | None = None,
    tpattern: typing.Literal["alt+z", "altplus", "alt+z2", "alt-z", "altminus", "alt-z2", "seq+z", "seqplus", "seq-z", "seqminus"] | None = None,
    tr: float | None = None,
    tslice: int | None = None,
    tzero: float | None = None,
) -> V3dTshiftParamsDictTagged:
    """
    Build parameters.
    
    Args:
        in_file: Input file to 3dtshift.
        prefix: Prefix for output image file name.
        ignore: Ignore the first set of points specified.
        interp: 'fourier' or 'linear' or 'cubic' or 'quintic' or 'heptic'.\
            Different interpolation methods (see 3dtshift for details) default =\
            fourier.
        num_threads: Set number of threads.
        outputtype: 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
        rlt: Before shifting, remove the mean and linear trend.
        rltplus: Before shifting, remove the mean and linear trend and later\
            put back the mean.
        slice_encoding_direction: 'k' or 'k-'. Direction in which slice_timing\
            is specified (default: k). if negative,slice_timing is defined in\
            reverse order, that is, the first entry corresponds to the slice with\
            the largest index, and the final entry corresponds to slice index zero.\
            only in effect when slice_timing is passed as list, not when it is\
            passed as file.
        tpattern: 'alt+z' or 'altplus' or 'alt+z2' or 'alt-z' or 'altminus' or\
            'alt-z2' or 'seq+z' or 'seqplus' or 'seq-z' or 'seqminus' or a string.\
            Use specified slice time pattern rather than one in header.
        tr: Manually set the tr. you can attach suffix "s" for seconds or "ms"\
            for milliseconds.
        tslice: Align each slice to time offset of given slice.
        tzero: Align each slice to given time offset.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/3dTshift",
        "in_file": in_file,
        "rlt": rlt,
        "rltplus": rltplus,
    }
    if prefix is not None:
        params["prefix"] = prefix
    if ignore is not None:
        params["ignore"] = ignore
    if interp is not None:
        params["interp"] = interp
    if num_threads is not None:
        params["num_threads"] = num_threads
    if outputtype is not None:
        params["outputtype"] = outputtype
    if slice_encoding_direction is not None:
        params["slice_encoding_direction"] = slice_encoding_direction
    if tpattern is not None:
        params["tpattern"] = tpattern
    if tr is not None:
        params["tr"] = tr
    if tslice is not None:
        params["tslice"] = tslice
    if tzero is not None:
        params["tzero"] = tzero
    return params


def v_3d_tshift_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `V3dTshiftParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("prefix", None) is not None:
        if not isinstance(params["prefix"], str):
            raise StyxValidationError(f'`prefix` has the wrong type: Received `{type(params.get("prefix", None))}` expected `str | None`')
    if params.get("ignore", None) is not None:
        if not isinstance(params["ignore"], int):
            raise StyxValidationError(f'`ignore` has the wrong type: Received `{type(params.get("ignore", None))}` expected `int | None`')
    if params.get("in_file", None) is None:
        raise StyxValidationError("`in_file` must not be None")
    if not isinstance(params["in_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`in_file` has the wrong type: Received `{type(params.get("in_file", None))}` expected `InputPathType`')
    if params.get("interp", None) is not None:
        if not isinstance(params["interp"], str):
            raise StyxValidationError(f'`interp` has the wrong type: Received `{type(params.get("interp", None))}` expected `typing.Literal["Fourier", "linear", "cubic", "quintic", "heptic"] | None`')
        if params["interp"] not in ["Fourier", "linear", "cubic", "quintic", "heptic"]:
            raise StyxValidationError("Parameter `interp` must be one of [\"Fourier\", \"linear\", \"cubic\", \"quintic\", \"heptic\"]")
    if params.get("num_threads", None) is not None:
        if not isinstance(params["num_threads"], int):
            raise StyxValidationError(f'`num_threads` has the wrong type: Received `{type(params.get("num_threads", None))}` expected `int | None`')
    if params.get("outputtype", None) is not None:
        if not isinstance(params["outputtype"], str):
            raise StyxValidationError(f'`outputtype` has the wrong type: Received `{type(params.get("outputtype", None))}` expected `typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None`')
        if params["outputtype"] not in ["NIFTI", "AFNI", "NIFTI_GZ"]:
            raise StyxValidationError("Parameter `outputtype` must be one of [\"NIFTI\", \"AFNI\", \"NIFTI_GZ\"]")
    if params.get("rlt", False) is None:
        raise StyxValidationError("`rlt` must not be None")
    if not isinstance(params["rlt"], bool):
        raise StyxValidationError(f'`rlt` has the wrong type: Received `{type(params.get("rlt", False))}` expected `bool`')
    if params.get("rltplus", False) is None:
        raise StyxValidationError("`rltplus` must not be None")
    if not isinstance(params["rltplus"], bool):
        raise StyxValidationError(f'`rltplus` has the wrong type: Received `{type(params.get("rltplus", False))}` expected `bool`')
    if params.get("slice_encoding_direction", None) is not None:
        if not isinstance(params["slice_encoding_direction"], str):
            raise StyxValidationError(f'`slice_encoding_direction` has the wrong type: Received `{type(params.get("slice_encoding_direction", None))}` expected `typing.Literal["k", "k-"] | None`')
        if params["slice_encoding_direction"] not in ["k", "k-"]:
            raise StyxValidationError("Parameter `slice_encoding_direction` must be one of [\"k\", \"k-\"]")
    if params.get("tpattern", None) is not None:
        if not isinstance(params["tpattern"], str):
            raise StyxValidationError(f'`tpattern` has the wrong type: Received `{type(params.get("tpattern", None))}` expected `typing.Literal["alt+z", "altplus", "alt+z2", "alt-z", "altminus", "alt-z2", "seq+z", "seqplus", "seq-z", "seqminus"] | None`')
        if params["tpattern"] not in ["alt+z", "altplus", "alt+z2", "alt-z", "altminus", "alt-z2", "seq+z", "seqplus", "seq-z", "seqminus"]:
            raise StyxValidationError("Parameter `tpattern` must be one of [\"alt+z\", \"altplus\", \"alt+z2\", \"alt-z\", \"altminus\", \"alt-z2\", \"seq+z\", \"seqplus\", \"seq-z\", \"seqminus\"]")
    if params.get("tr", None) is not None:
        if not isinstance(params["tr"], (float, int)):
            raise StyxValidationError(f'`tr` has the wrong type: Received `{type(params.get("tr", None))}` expected `float | None`')
    if params.get("tslice", None) is not None:
        if not isinstance(params["tslice"], int):
            raise StyxValidationError(f'`tslice` has the wrong type: Received `{type(params.get("tslice", None))}` expected `int | None`')
    if params.get("tzero", None) is not None:
        if not isinstance(params["tzero"], (float, int)):
            raise StyxValidationError(f'`tzero` has the wrong type: Received `{type(params.get("tzero", None))}` expected `float | None`')


def v_3d_tshift_cargs(
    params: V3dTshiftParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("3dTshift")
    if params.get("prefix", None) is not None:
        cargs.extend([
            "-prefix",
            params.get("prefix", None)
        ])
    if params.get("ignore", None) is not None:
        cargs.extend([
            "-ignore",
            str(params.get("ignore", None))
        ])
    cargs.append(execution.input_file(params.get("in_file", None)))
    if params.get("interp", None) is not None:
        cargs.extend([
            "-",
            params.get("interp", None)
        ])
    if params.get("num_threads", None) is not None:
        cargs.append(str(params.get("num_threads", None)))
    if params.get("outputtype", None) is not None:
        cargs.append(params.get("outputtype", None))
    if params.get("rlt", False):
        cargs.append("-rlt")
    if params.get("rltplus", False):
        cargs.append("-rlt+")
    if params.get("slice_encoding_direction", None) is not None:
        cargs.append(params.get("slice_encoding_direction", None))
    if params.get("tpattern", None) is not None:
        cargs.extend([
            "-tpattern",
            params.get("tpattern", None)
        ])
    if params.get("tr", None) is not None:
        cargs.extend([
            "-TR",
            str(params.get("tr", None))
        ])
    if params.get("tslice", None) is not None:
        cargs.extend([
            "-slice",
            str(params.get("tslice", None))
        ])
    if params.get("tzero", None) is not None:
        cargs.extend([
            "-tzero",
            str(params.get("tzero", None))
        ])
    return cargs


def v_3d_tshift_outputs(
    params: V3dTshiftParamsDict,
    execution: Execution,
) -> V3dTshiftOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = V3dTshiftOutputs(
        root=execution.output_file("."),
        out_file=execution.output_file(params.get("prefix", None)) if (params.get("prefix") is not None) else None,
        timing_file=execution.output_file("timing_file"),
    )
    return ret


def v_3d_tshift_execute(
    params: V3dTshiftParamsDict,
    runner: Runner | None = None,
) -> V3dTshiftOutputs:
    """
    3dTshift
    
    Shifts voxel time series from input so that separate slices are aligned to
    the same temporal origin.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dTshiftOutputs`).
    """
    v_3d_tshift_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(V_3D_TSHIFT_METADATA)
    params = execution.params(params)
    cargs = v_3d_tshift_cargs(params, execution)
    ret = v_3d_tshift_outputs(params, execution)
    execution.run(cargs)
    return ret


def v_3d_tshift(
    in_file: InputPathType,
    prefix: str | None = None,
    ignore: int | None = None,
    interp: typing.Literal["Fourier", "linear", "cubic", "quintic", "heptic"] | None = None,
    num_threads: int | None = None,
    outputtype: typing.Literal["NIFTI", "AFNI", "NIFTI_GZ"] | None = None,
    rlt: bool = False,
    rltplus: bool = False,
    slice_encoding_direction: typing.Literal["k", "k-"] | None = None,
    tpattern: typing.Literal["alt+z", "altplus", "alt+z2", "alt-z", "altminus", "alt-z2", "seq+z", "seqplus", "seq-z", "seqminus"] | None = None,
    tr: float | None = None,
    tslice: int | None = None,
    tzero: float | None = None,
    runner: Runner | None = None,
) -> V3dTshiftOutputs:
    """
    3dTshift
    
    Shifts voxel time series from input so that separate slices are aligned to
    the same temporal origin.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        in_file: Input file to 3dtshift.
        prefix: Prefix for output image file name.
        ignore: Ignore the first set of points specified.
        interp: 'fourier' or 'linear' or 'cubic' or 'quintic' or 'heptic'.\
            Different interpolation methods (see 3dtshift for details) default =\
            fourier.
        num_threads: Set number of threads.
        outputtype: 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
        rlt: Before shifting, remove the mean and linear trend.
        rltplus: Before shifting, remove the mean and linear trend and later\
            put back the mean.
        slice_encoding_direction: 'k' or 'k-'. Direction in which slice_timing\
            is specified (default: k). if negative,slice_timing is defined in\
            reverse order, that is, the first entry corresponds to the slice with\
            the largest index, and the final entry corresponds to slice index zero.\
            only in effect when slice_timing is passed as list, not when it is\
            passed as file.
        tpattern: 'alt+z' or 'altplus' or 'alt+z2' or 'alt-z' or 'altminus' or\
            'alt-z2' or 'seq+z' or 'seqplus' or 'seq-z' or 'seqminus' or a string.\
            Use specified slice time pattern rather than one in header.
        tr: Manually set the tr. you can attach suffix "s" for seconds or "ms"\
            for milliseconds.
        tslice: Align each slice to time offset of given slice.
        tzero: Align each slice to given time offset.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `V3dTshiftOutputs`).
    """
    params = v_3d_tshift_params(
        prefix=prefix,
        ignore=ignore,
        in_file=in_file,
        interp=interp,
        num_threads=num_threads,
        outputtype=outputtype,
        rlt=rlt,
        rltplus=rltplus,
        slice_encoding_direction=slice_encoding_direction,
        tpattern=tpattern,
        tr=tr,
        tslice=tslice,
        tzero=tzero,
    )
    return v_3d_tshift_execute(params, runner)


__all__ = [
    "V3dTshiftOutputs",
    "V3dTshiftParamsDict",
    "V3dTshiftParamsDictTagged",
    "V_3D_TSHIFT_METADATA",
    "v_3d_tshift",
    "v_3d_tshift_execute",
    "v_3d_tshift_params",
]
