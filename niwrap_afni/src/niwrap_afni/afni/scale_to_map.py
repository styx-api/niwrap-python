# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

SCALE_TO_MAP_METADATA = Metadata(
    id="06ba06811b98fb7d08d9ac952d96068b1af51f39.boutiques",
    name="ScaleToMap",
    package="afni",
    container_image_tag="afni/afni_make_build:AFNI_24.2.06",
)


_ScaleToMapTraceParamsDictNoTag = typing.TypedDict('_ScaleToMapTraceParamsDictNoTag', {
    "trace": bool,
    "TRACE": bool,
})
ScaleToMapTraceParamsDictTagged = typing.TypedDict('ScaleToMapTraceParamsDictTagged', {
    "@type": typing.Literal["trace"],
    "trace": bool,
    "TRACE": bool,
})
ScaleToMapTraceParamsDict = _ScaleToMapTraceParamsDictNoTag | ScaleToMapTraceParamsDictTagged


_ScaleToMapParamsDictNoTag = typing.TypedDict('_ScaleToMapParamsDictNoTag', {
    "input_file": InputPathType,
    "icol": float,
    "vcol": float,
    "cmap": typing.NotRequired[str | None],
    "cmapfile": typing.NotRequired[InputPathType | None],
    "cmapdb": typing.NotRequired[InputPathType | None],
    "frf": bool,
    "clp": typing.NotRequired[list[float] | None],
    "perc_clp": typing.NotRequired[list[float] | None],
    "apr": typing.NotRequired[float | None],
    "anr": typing.NotRequired[float | None],
    "interp": bool,
    "nointerp": bool,
    "direct": bool,
    "msk_zero": bool,
    "msk": typing.NotRequired[list[float] | None],
    "msk_col": typing.NotRequired[list[float] | None],
    "nomsk_col": bool,
    "br": typing.NotRequired[float | None],
    "help": bool,
    "verbose": bool,
    "showmap": bool,
    "showdb": bool,
    "novolreg": bool,
    "noxform": bool,
    "setenv": typing.NotRequired[str | None],
    "trace": typing.NotRequired[ScaleToMapTraceParamsDict | None],
    "nomall": bool,
    "yesmall": bool,
})
ScaleToMapParamsDictTagged = typing.TypedDict('ScaleToMapParamsDictTagged', {
    "@type": typing.Literal["afni/ScaleToMap"],
    "input_file": InputPathType,
    "icol": float,
    "vcol": float,
    "cmap": typing.NotRequired[str | None],
    "cmapfile": typing.NotRequired[InputPathType | None],
    "cmapdb": typing.NotRequired[InputPathType | None],
    "frf": bool,
    "clp": typing.NotRequired[list[float] | None],
    "perc_clp": typing.NotRequired[list[float] | None],
    "apr": typing.NotRequired[float | None],
    "anr": typing.NotRequired[float | None],
    "interp": bool,
    "nointerp": bool,
    "direct": bool,
    "msk_zero": bool,
    "msk": typing.NotRequired[list[float] | None],
    "msk_col": typing.NotRequired[list[float] | None],
    "nomsk_col": bool,
    "br": typing.NotRequired[float | None],
    "help": bool,
    "verbose": bool,
    "showmap": bool,
    "showdb": bool,
    "novolreg": bool,
    "noxform": bool,
    "setenv": typing.NotRequired[str | None],
    "trace": typing.NotRequired[ScaleToMapTraceParamsDict | None],
    "nomall": bool,
    "yesmall": bool,
})
ScaleToMapParamsDict = _ScaleToMapParamsDictNoTag | ScaleToMapParamsDictTagged


def scale_to_map_trace(
    trace_: bool = False,
    trace_2: bool = False,
) -> ScaleToMapTraceParamsDictTagged:
    """
    Build parameters.
    
    Args:
        trace_: Turns on In/Out debug and Memory tracing. It's recommended to\
            redirect stdout to a file when using this option.
        trace_2: Turns on extreme tracing.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "trace",
        "trace": trace_,
        "TRACE": trace_2,
    }
    return params


def scale_to_map_trace_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `ScaleToMapTraceParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("trace", False) is None:
        raise StyxValidationError("`trace` must not be None")
    if not isinstance(params["trace"], bool):
        raise StyxValidationError(f'`trace` has the wrong type: Received `{type(params.get("trace", False))}` expected `bool`')
    if params.get("TRACE", False) is None:
        raise StyxValidationError("`TRACE` must not be None")
    if not isinstance(params["TRACE"], bool):
        raise StyxValidationError(f'`TRACE` has the wrong type: Received `{type(params.get("TRACE", False))}` expected `bool`')


def scale_to_map_trace_cargs(
    params: ScaleToMapTraceParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    if params.get("trace", False):
        cargs.append("-trace")
    if params.get("TRACE", False):
        cargs.append("-TRACE")
    return cargs


class ScaleToMapOutputs(typing.NamedTuple):
    """
    Output object returned when calling `ScaleToMapParamsDict(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""


def scale_to_map_params(
    input_file: InputPathType,
    icol: float,
    vcol: float,
    cmap: str | None = None,
    cmapfile: InputPathType | None = None,
    cmapdb: InputPathType | None = None,
    frf: bool = False,
    clp: list[float] | None = None,
    perc_clp: list[float] | None = None,
    apr: float | None = None,
    anr: float | None = None,
    interp: bool = False,
    nointerp: bool = False,
    direct: bool = False,
    msk_zero: bool = False,
    msk: list[float] | None = None,
    msk_col: list[float] | None = None,
    nomsk_col: bool = False,
    br: float | None = None,
    help_: bool = False,
    verbose: bool = False,
    showmap: bool = False,
    showdb: bool = False,
    novolreg: bool = False,
    noxform: bool = False,
    setenv: str | None = None,
    trace_: ScaleToMapTraceParamsDict | None = None,
    nomall: bool = False,
    yesmall: bool = False,
) -> ScaleToMapParamsDictTagged:
    """
    Build parameters.
    
    Args:
        input_file: Input file in 1D formatted ascii containing node values.
        icol: Index of node index column (-1 if node index is implicit).
        vcol: Index of node value column.
        cmap: Choose one of the standard colormaps available with SUMA.
        cmapfile: Read color map from a Mapfile.
        cmapdb: Read color maps from an AFNI .pal file.
        frf: Indicate that the first row in the file is the first color.
        clp: Clip values in IntVect to specified range.
        perc_clp: Percentile clip values in IntVect to specified range.
        apr: Clip values in IntVect to [0 range].
        anr: Clip values in IntVect to [-range range].
        interp: Use color interpolation between colors in colormap (default).
        nointerp: Turn off color interpolation within the colormap.
        direct: Directly map values to index of color in colormap.
        msk_zero: Mask values that are 0.
        msk: Mask values in vcol between specified range.
        msk_col: Set color of masked voxels.
        nomsk_col: Do not output nodes that got masked.
        br: Apply a brightness factor to colormap and mask color.
        help_: Display help message.
        verbose: Verbose mode.
        showmap: Print colormap to screen and quit.
        showdb: Print colors and colormaps of AFNI along with any loaded from\
            Palfile.
        novolreg: Ignore any Rotate, Volreg, Tagalign, or WarpDrive\
            transformations present in the Surface Volume.
        noxform: Same as -novolreg.
        setenv: Set environment variable ENVname to ENVvalue. Quotes are\
            necessary.
        trace_: Turns on In/Out debug and Memory tracing. It's recommended to\
            redirect stdout to a file when using this option.
        nomall: Turn off memory tracing.
        yesmall: Turn on memory tracing (default).
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "afni/ScaleToMap",
        "input_file": input_file,
        "icol": icol,
        "vcol": vcol,
        "frf": frf,
        "interp": interp,
        "nointerp": nointerp,
        "direct": direct,
        "msk_zero": msk_zero,
        "nomsk_col": nomsk_col,
        "help": help_,
        "verbose": verbose,
        "showmap": showmap,
        "showdb": showdb,
        "novolreg": novolreg,
        "noxform": noxform,
        "nomall": nomall,
        "yesmall": yesmall,
    }
    if cmap is not None:
        params["cmap"] = cmap
    if cmapfile is not None:
        params["cmapfile"] = cmapfile
    if cmapdb is not None:
        params["cmapdb"] = cmapdb
    if clp is not None:
        params["clp"] = clp
    if perc_clp is not None:
        params["perc_clp"] = perc_clp
    if apr is not None:
        params["apr"] = apr
    if anr is not None:
        params["anr"] = anr
    if msk is not None:
        params["msk"] = msk
    if msk_col is not None:
        params["msk_col"] = msk_col
    if br is not None:
        params["br"] = br
    if setenv is not None:
        params["setenv"] = setenv
    if trace_ is not None:
        params["trace"] = trace_
    return params


def scale_to_map_validate(
    params: typing.Any,
) -> None:
    """
    Validate parameters. Throws an error if `params` is not a valid
    `ScaleToMapParamsDict` object.
    
    Args:
        params: The parameters object to validate.
    """
    if params is None or not isinstance(params, dict):
        raise StyxValidationError(f'Params object has the wrong type \'{type(params)}\'')
    if params.get("input_file", None) is None:
        raise StyxValidationError("`input_file` must not be None")
    if not isinstance(params["input_file"], (pathlib.Path, str)):
        raise StyxValidationError(f'`input_file` has the wrong type: Received `{type(params.get("input_file", None))}` expected `InputPathType`')
    if params.get("icol", None) is None:
        raise StyxValidationError("`icol` must not be None")
    if not isinstance(params["icol"], (float, int)):
        raise StyxValidationError(f'`icol` has the wrong type: Received `{type(params.get("icol", None))}` expected `float`')
    if params.get("vcol", None) is None:
        raise StyxValidationError("`vcol` must not be None")
    if not isinstance(params["vcol"], (float, int)):
        raise StyxValidationError(f'`vcol` has the wrong type: Received `{type(params.get("vcol", None))}` expected `float`')
    if params.get("cmap", None) is not None:
        if not isinstance(params["cmap"], str):
            raise StyxValidationError(f'`cmap` has the wrong type: Received `{type(params.get("cmap", None))}` expected `str | None`')
    if params.get("cmapfile", None) is not None:
        if not isinstance(params["cmapfile"], (pathlib.Path, str)):
            raise StyxValidationError(f'`cmapfile` has the wrong type: Received `{type(params.get("cmapfile", None))}` expected `InputPathType | None`')
    if params.get("cmapdb", None) is not None:
        if not isinstance(params["cmapdb"], (pathlib.Path, str)):
            raise StyxValidationError(f'`cmapdb` has the wrong type: Received `{type(params.get("cmapdb", None))}` expected `InputPathType | None`')
    if params.get("frf", False) is None:
        raise StyxValidationError("`frf` must not be None")
    if not isinstance(params["frf"], bool):
        raise StyxValidationError(f'`frf` has the wrong type: Received `{type(params.get("frf", False))}` expected `bool`')
    if params.get("clp", None) is not None:
        if not isinstance(params["clp"], list):
            raise StyxValidationError(f'`clp` has the wrong type: Received `{type(params.get("clp", None))}` expected `list[float] | None`')
        if len(params["clp"]) > 2:
            raise StyxValidationError("Parameter `clp` must contain at most 2 elements")
        for e in params["clp"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`clp` has the wrong type: Received `{type(params.get("clp", None))}` expected `list[float] | None`')
    if params.get("perc_clp", None) is not None:
        if not isinstance(params["perc_clp"], list):
            raise StyxValidationError(f'`perc_clp` has the wrong type: Received `{type(params.get("perc_clp", None))}` expected `list[float] | None`')
        if len(params["perc_clp"]) > 2:
            raise StyxValidationError("Parameter `perc_clp` must contain at most 2 elements")
        for e in params["perc_clp"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`perc_clp` has the wrong type: Received `{type(params.get("perc_clp", None))}` expected `list[float] | None`')
    if params.get("apr", None) is not None:
        if not isinstance(params["apr"], (float, int)):
            raise StyxValidationError(f'`apr` has the wrong type: Received `{type(params.get("apr", None))}` expected `float | None`')
    if params.get("anr", None) is not None:
        if not isinstance(params["anr"], (float, int)):
            raise StyxValidationError(f'`anr` has the wrong type: Received `{type(params.get("anr", None))}` expected `float | None`')
    if params.get("interp", False) is None:
        raise StyxValidationError("`interp` must not be None")
    if not isinstance(params["interp"], bool):
        raise StyxValidationError(f'`interp` has the wrong type: Received `{type(params.get("interp", False))}` expected `bool`')
    if params.get("nointerp", False) is None:
        raise StyxValidationError("`nointerp` must not be None")
    if not isinstance(params["nointerp"], bool):
        raise StyxValidationError(f'`nointerp` has the wrong type: Received `{type(params.get("nointerp", False))}` expected `bool`')
    if params.get("direct", False) is None:
        raise StyxValidationError("`direct` must not be None")
    if not isinstance(params["direct"], bool):
        raise StyxValidationError(f'`direct` has the wrong type: Received `{type(params.get("direct", False))}` expected `bool`')
    if params.get("msk_zero", False) is None:
        raise StyxValidationError("`msk_zero` must not be None")
    if not isinstance(params["msk_zero"], bool):
        raise StyxValidationError(f'`msk_zero` has the wrong type: Received `{type(params.get("msk_zero", False))}` expected `bool`')
    if params.get("msk", None) is not None:
        if not isinstance(params["msk"], list):
            raise StyxValidationError(f'`msk` has the wrong type: Received `{type(params.get("msk", None))}` expected `list[float] | None`')
        if len(params["msk"]) > 2:
            raise StyxValidationError("Parameter `msk` must contain at most 2 elements")
        for e in params["msk"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`msk` has the wrong type: Received `{type(params.get("msk", None))}` expected `list[float] | None`')
    if params.get("msk_col", None) is not None:
        if not isinstance(params["msk_col"], list):
            raise StyxValidationError(f'`msk_col` has the wrong type: Received `{type(params.get("msk_col", None))}` expected `list[float] | None`')
        if len(params["msk_col"]) != 3:
            raise StyxValidationError("Parameter `msk_col` must contain exactly 3 elements")
        for e in params["msk_col"]:
            if not isinstance(e, (float, int)):
                raise StyxValidationError(f'`msk_col` has the wrong type: Received `{type(params.get("msk_col", None))}` expected `list[float] | None`')
    if params.get("nomsk_col", False) is None:
        raise StyxValidationError("`nomsk_col` must not be None")
    if not isinstance(params["nomsk_col"], bool):
        raise StyxValidationError(f'`nomsk_col` has the wrong type: Received `{type(params.get("nomsk_col", False))}` expected `bool`')
    if params.get("br", None) is not None:
        if not isinstance(params["br"], (float, int)):
            raise StyxValidationError(f'`br` has the wrong type: Received `{type(params.get("br", None))}` expected `float | None`')
    if params.get("help", False) is None:
        raise StyxValidationError("`help` must not be None")
    if not isinstance(params["help"], bool):
        raise StyxValidationError(f'`help` has the wrong type: Received `{type(params.get("help", False))}` expected `bool`')
    if params.get("verbose", False) is None:
        raise StyxValidationError("`verbose` must not be None")
    if not isinstance(params["verbose"], bool):
        raise StyxValidationError(f'`verbose` has the wrong type: Received `{type(params.get("verbose", False))}` expected `bool`')
    if params.get("showmap", False) is None:
        raise StyxValidationError("`showmap` must not be None")
    if not isinstance(params["showmap"], bool):
        raise StyxValidationError(f'`showmap` has the wrong type: Received `{type(params.get("showmap", False))}` expected `bool`')
    if params.get("showdb", False) is None:
        raise StyxValidationError("`showdb` must not be None")
    if not isinstance(params["showdb"], bool):
        raise StyxValidationError(f'`showdb` has the wrong type: Received `{type(params.get("showdb", False))}` expected `bool`')
    if params.get("novolreg", False) is None:
        raise StyxValidationError("`novolreg` must not be None")
    if not isinstance(params["novolreg"], bool):
        raise StyxValidationError(f'`novolreg` has the wrong type: Received `{type(params.get("novolreg", False))}` expected `bool`')
    if params.get("noxform", False) is None:
        raise StyxValidationError("`noxform` must not be None")
    if not isinstance(params["noxform"], bool):
        raise StyxValidationError(f'`noxform` has the wrong type: Received `{type(params.get("noxform", False))}` expected `bool`')
    if params.get("setenv", None) is not None:
        if not isinstance(params["setenv"], str):
            raise StyxValidationError(f'`setenv` has the wrong type: Received `{type(params.get("setenv", None))}` expected `str | None`')
    if params.get("trace", None) is not None:
        scale_to_map_trace_validate(params["trace"])
    if params.get("nomall", False) is None:
        raise StyxValidationError("`nomall` must not be None")
    if not isinstance(params["nomall"], bool):
        raise StyxValidationError(f'`nomall` has the wrong type: Received `{type(params.get("nomall", False))}` expected `bool`')
    if params.get("yesmall", False) is None:
        raise StyxValidationError("`yesmall` must not be None")
    if not isinstance(params["yesmall"], bool):
        raise StyxValidationError(f'`yesmall` has the wrong type: Received `{type(params.get("yesmall", False))}` expected `bool`')


def scale_to_map_cargs(
    params: ScaleToMapParamsDict,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("ScaleToMap")
    cargs.append(execution.input_file(params.get("input_file", None)))
    cargs.append(str(params.get("icol", None)))
    cargs.append(str(params.get("vcol", None)))
    if params.get("cmap", None) is not None:
        cargs.extend([
            "-cmap",
            params.get("cmap", None)
        ])
    if params.get("cmapfile", None) is not None:
        cargs.extend([
            "-cmapfile",
            execution.input_file(params.get("cmapfile", None))
        ])
    if params.get("cmapdb", None) is not None:
        cargs.extend([
            "-cmapdb",
            execution.input_file(params.get("cmapdb", None))
        ])
    if params.get("frf", False):
        cargs.append("-frf")
    if params.get("clp", None) is not None:
        cargs.extend([
            "-clp",
            *map(str, params.get("clp", None))
        ])
    if params.get("perc_clp", None) is not None:
        cargs.extend([
            "-perc_clp",
            *map(str, params.get("perc_clp", None))
        ])
    if params.get("apr", None) is not None:
        cargs.extend([
            "-apr",
            str(params.get("apr", None))
        ])
    if params.get("anr", None) is not None:
        cargs.extend([
            "-anr",
            str(params.get("anr", None))
        ])
    if params.get("interp", False):
        cargs.append("-interp")
    if params.get("nointerp", False):
        cargs.append("-nointerp")
    if params.get("direct", False):
        cargs.append("-direct")
    if params.get("msk_zero", False):
        cargs.append("-msk_zero")
    if params.get("msk", None) is not None:
        cargs.extend([
            "-msk",
            *map(str, params.get("msk", None))
        ])
    if params.get("msk_col", None) is not None:
        cargs.extend([
            "-msk_col",
            *map(str, params.get("msk_col", None))
        ])
    if params.get("nomsk_col", False):
        cargs.append("-nomsk_col")
    if params.get("br", None) is not None:
        cargs.extend([
            "-br",
            str(params.get("br", None))
        ])
    if params.get("help", False):
        cargs.append("-h")
    if params.get("verbose", False):
        cargs.append("-verb")
    if params.get("showmap", False):
        cargs.append("-showmap")
    if params.get("showdb", False):
        cargs.append("-showdb")
    if params.get("novolreg", False):
        cargs.append("-novolreg")
    if params.get("noxform", False):
        cargs.append("-noxform")
    if params.get("setenv", None) is not None:
        cargs.extend([
            "-setenv",
            params.get("setenv", None)
        ])
    if params.get("trace", None) is not None:
        cargs.extend(scale_to_map_trace_cargs(params.get("trace", None), execution))
    if params.get("nomall", False):
        cargs.append("-nomall")
    if params.get("yesmall", False):
        cargs.append("-yesmall")
    return cargs


def scale_to_map_outputs(
    params: ScaleToMapParamsDict,
    execution: Execution,
) -> ScaleToMapOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = ScaleToMapOutputs(
        root=execution.output_file("."),
    )
    return ret


def scale_to_map_execute(
    params: ScaleToMapParamsDict,
    runner: Runner | None = None,
) -> ScaleToMapOutputs:
    """
    ScaleToMap
    
    Tool to scale values to a color map.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `ScaleToMapOutputs`).
    """
    scale_to_map_validate(params)
    runner = runner or get_global_runner()
    execution = runner.start_execution(SCALE_TO_MAP_METADATA)
    params = execution.params(params)
    cargs = scale_to_map_cargs(params, execution)
    ret = scale_to_map_outputs(params, execution)
    execution.run(cargs)
    return ret


def scale_to_map(
    input_file: InputPathType,
    icol: float,
    vcol: float,
    cmap: str | None = None,
    cmapfile: InputPathType | None = None,
    cmapdb: InputPathType | None = None,
    frf: bool = False,
    clp: list[float] | None = None,
    perc_clp: list[float] | None = None,
    apr: float | None = None,
    anr: float | None = None,
    interp: bool = False,
    nointerp: bool = False,
    direct: bool = False,
    msk_zero: bool = False,
    msk: list[float] | None = None,
    msk_col: list[float] | None = None,
    nomsk_col: bool = False,
    br: float | None = None,
    help_: bool = False,
    verbose: bool = False,
    showmap: bool = False,
    showdb: bool = False,
    novolreg: bool = False,
    noxform: bool = False,
    setenv: str | None = None,
    trace_: ScaleToMapTraceParamsDict | None = None,
    nomall: bool = False,
    yesmall: bool = False,
    runner: Runner | None = None,
) -> ScaleToMapOutputs:
    """
    ScaleToMap
    
    Tool to scale values to a color map.
    
    Author: AFNI Developers
    
    URL: https://afni.nimh.nih.gov/
    
    Args:
        input_file: Input file in 1D formatted ascii containing node values.
        icol: Index of node index column (-1 if node index is implicit).
        vcol: Index of node value column.
        cmap: Choose one of the standard colormaps available with SUMA.
        cmapfile: Read color map from a Mapfile.
        cmapdb: Read color maps from an AFNI .pal file.
        frf: Indicate that the first row in the file is the first color.
        clp: Clip values in IntVect to specified range.
        perc_clp: Percentile clip values in IntVect to specified range.
        apr: Clip values in IntVect to [0 range].
        anr: Clip values in IntVect to [-range range].
        interp: Use color interpolation between colors in colormap (default).
        nointerp: Turn off color interpolation within the colormap.
        direct: Directly map values to index of color in colormap.
        msk_zero: Mask values that are 0.
        msk: Mask values in vcol between specified range.
        msk_col: Set color of masked voxels.
        nomsk_col: Do not output nodes that got masked.
        br: Apply a brightness factor to colormap and mask color.
        help_: Display help message.
        verbose: Verbose mode.
        showmap: Print colormap to screen and quit.
        showdb: Print colors and colormaps of AFNI along with any loaded from\
            Palfile.
        novolreg: Ignore any Rotate, Volreg, Tagalign, or WarpDrive\
            transformations present in the Surface Volume.
        noxform: Same as -novolreg.
        setenv: Set environment variable ENVname to ENVvalue. Quotes are\
            necessary.
        trace_: Turns on In/Out debug and Memory tracing. It's recommended to\
            redirect stdout to a file when using this option.
        nomall: Turn off memory tracing.
        yesmall: Turn on memory tracing (default).
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `ScaleToMapOutputs`).
    """
    params = scale_to_map_params(
        input_file=input_file,
        icol=icol,
        vcol=vcol,
        cmap=cmap,
        cmapfile=cmapfile,
        cmapdb=cmapdb,
        frf=frf,
        clp=clp,
        perc_clp=perc_clp,
        apr=apr,
        anr=anr,
        interp=interp,
        nointerp=nointerp,
        direct=direct,
        msk_zero=msk_zero,
        msk=msk,
        msk_col=msk_col,
        nomsk_col=nomsk_col,
        br=br,
        help_=help_,
        verbose=verbose,
        showmap=showmap,
        showdb=showdb,
        novolreg=novolreg,
        noxform=noxform,
        setenv=setenv,
        trace_=trace_,
        nomall=nomall,
        yesmall=yesmall,
    )
    return scale_to_map_execute(params, runner)


__all__ = [
    "SCALE_TO_MAP_METADATA",
    "ScaleToMapOutputs",
    "ScaleToMapParamsDict",
    "ScaleToMapParamsDictTagged",
    "ScaleToMapTraceParamsDict",
    "ScaleToMapTraceParamsDictTagged",
    "scale_to_map",
    "scale_to_map_execute",
    "scale_to_map_params",
    "scale_to_map_trace",
]
